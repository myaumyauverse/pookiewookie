JavaScript | MDNSkip to main contentSkip to searchSkip to select languageMDN Web DocsOpen main menuReferencesReferencesOverview / Web TechnologyWeb technology reference for developersHTMLStructure of content on the webCSSCode used to describe document styleJavaScriptGeneral-purpose scripting languageHTTPProtocol for transmitting web resourcesWeb APIsInterfaces for building web applicationsWeb ExtensionsDeveloping extensions for web browsersWeb TechnologyWeb technology reference for developersGuidesGuidesOverview / MDN Learning AreaLearn web developmentMDN Learning AreaLearn web developmentHTMLLearn to structure web content with HTMLCSSLearn to style content using CSSJavaScriptLearn to run scripts in the browserAccessibilityLearn to make the web accessible to allPlusPlusOverviewA customized MDN experienceAI Help (beta)Get real-time assistance and supportUpdatesAll browser compatibility updates at a glanceDocumentationLearn how to use MDN PlusFAQFrequently asked questions about MDN PlusBlogPlayAI Help BetaSearch MDNClear search inputSearchThemeLog inSign up for freeReferencesJavaScriptArticle ActionsEnglish (US)Filter sidebarClear filter inputIn this articleTutorialsReference

JavaScript
Tutorials


Complete beginners

JavaScript basics
JavaScript first steps
JavaScript building blocks
Introducing JavaScript objects





JavaScript Guide

Introduction
Grammar and types
Control flow and error handling
Loops and iteration
Functions
Expressions and operators
Numbers and dates
Text formatting
Regular expressions
Indexed collections
Keyed collections
Working with objects
Using classes
Using promises
JavaScript typed arrays
Iterators and generators
Meta programming
JavaScript modules





Intermediate

Client-side JavaScript frameworks
Client-side web APIs
Language overview
JavaScript data structures
Equality comparisons and sameness
Enumerability and ownership of properties
Closures





Advanced

Inheritance and the prototype chain
Memory Management
Concurrency model and Event Loop



References


Built-in objects
OverviewAggregateErrorArrayArrayBufferAsyncFunctionAsyncGeneratorAsyncGeneratorFunctionAsyncIteratorAtomicsBigIntBigInt64ArrayBigUint64ArrayBooleanDataViewDatedecodeURI()decodeURIComponent()encodeURI()encodeURIComponent()Errorescape()
Deprecated
eval()EvalErrorFinalizationRegistryFloat32ArrayFloat64ArrayFunctionGeneratorGeneratorFunctionglobalThisInfinityInt16ArrayInt32ArrayInt8ArrayInternalError
Non-standard
IntlisFinite()isNaN()IteratorJSONMapMathNaNNumberObjectparseFloat()parseInt()PromiseProxyRangeErrorReferenceErrorReflectRegExpSetSharedArrayBufferStringSymbolSyntaxErrorTypedArrayTypeErrorUint16ArrayUint32ArrayUint8ArrayUint8ClampedArrayundefinedunescape()
Deprecated
URIErrorWeakMapWeakRefWeakSet




Expressions & operators
OverviewAddition (+)Addition assignment (+=)Assignment (=)async function expressionasync function* expressionawaitBitwise AND (&)Bitwise AND assignment (&=)Bitwise NOT (~)Bitwise OR (|)Bitwise OR assignment (|=)Bitwise XOR (^)Bitwise XOR assignment (^=)class expressionComma operator (,)Conditional (ternary) operatorDecrement (--)deleteDestructuring assignmentDivision (/)Division assignment (/=)Equality (==)Exponentiation (**)Exponentiation assignment (**=)function expressionfunction* expressionGreater than (>)Greater than or equal (>=)Grouping operator ( )import.metaimport()inIncrement (++)Inequality (!=)instanceofLeft shift (<<)Left shift assignment (<<=)Less than (<)Less than or equal (<=)Logical AND (&&)Logical AND assignment (&&=)Logical NOT (!)Logical OR (||)Logical OR assignment (||=)Multiplication (*)Multiplication assignment (*=)newnew.targetnullNullish coalescing assignment (??=)Nullish coalescing operator (??)Object initializerOperator precedenceOptional chaining (?.)Property accessorsRemainder (%)Remainder assignment (%=)Right shift (>>)Right shift assignment (>>=)Spread syntax (...)Strict equality (===)Strict inequality (!==)Subtraction (-)Subtraction assignment (-=)superthistypeofUnary negation (-)Unary plus (+)Unsigned right shift (>>>)Unsigned right shift assignment (>>>=)void operatoryieldyield*




Statements & declarations
Overviewasync functionasync function*Block statementbreakclassconstcontinuedebuggerdo...whileEmpty statementexportExpression statementforfor await...offor...infor...offunctionfunction*if...elseimportLabeled statementletreturnswitchthrowtry...catchvarwhilewith
Deprecated





Functions
OverviewArrow function expressionsDefault parametersgetMethod definitionsRest parameterssetThe arguments object




Classes
OverviewconstructorextendsPrivate propertiesPublic class fieldsstaticStatic initialization blocks




Regular expressions
OverviewBackreference: \1, \2Capturing group: (...)Character class escape: \d, \D, \w, \W, \s, \SCharacter class: [...], [^...]Character escape: \n, \u{...}Disjunction: |Input boundary assertion: ^, $Literal character: a, bLookahead assertion: (?=...), (?!...)Lookbehind assertion: (?<=...), (?<!...)Named backreference: \k<name>Named capturing group: (?<name>...)Non-capturing group: (?:...)Quantifier: *, +, ?, {n}, {n,}, {n,m}Unicode character class escape: \p{...}, \P{...}Wildcard: .Word boundary assertion: \b, \B




Errors
OverviewError: Permission denied to access property "x"InternalError: too much recursionRangeError: argument is not a valid code pointRangeError: BigInt division by zeroRangeError: BigInt negative exponentRangeError: invalid array lengthRangeError: invalid dateRangeError: precision is out of rangeRangeError: radix must be an integerRangeError: repeat count must be less than infinityRangeError: repeat count must be non-negativeRangeError: x can't be converted to BigInt because it isn't an integerReferenceError: "x" is not definedReferenceError: assignment to undeclared variable "x"ReferenceError: can't access lexical declaration 'X' before initializationReferenceError: deprecated caller or arguments usageReferenceError: reference to undefined property "x"SyntaxError: "0"-prefixed octal literals and octal escape seq. are deprecatedSyntaxError: "use strict" not allowed in function with non-simple parametersSyntaxError: "x" is a reserved identifierSyntaxError: a declaration in the head of a for-of loop can't have an initializerSyntaxError: applying the 'delete' operator to an unqualified name is deprecatedSyntaxError: await is only valid in async functions, async generators and modulesSyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressionsSyntaxError: continue must be inside loopSyntaxError: for-in loop head declarations may not have initializersSyntaxError: function statement requires a nameSyntaxError: getter and setter for private name #x should either be both static or non-staticSyntaxError: identifier starts immediately after numeric literalSyntaxError: illegal characterSyntaxError: invalid assignment left-hand sideSyntaxError: invalid BigInt syntaxSyntaxError: invalid regular expression flag "x"SyntaxError: JSON.parse: bad parsingSyntaxError: label not foundSyntaxError: missing ; before statementSyntaxError: missing : after property idSyntaxError: missing ) after argument listSyntaxError: missing ) after conditionSyntaxError: missing ] after element listSyntaxError: missing } after function bodySyntaxError: missing } after property listSyntaxError: missing = in const declarationSyntaxError: missing formal parameterSyntaxError: missing name after . operatorSyntaxError: missing variable nameSyntaxError: redeclaration of formal parameter "x"SyntaxError: return not in functionSyntaxError: test for equality (==) mistyped as assignment (=)?SyntaxError: Unexpected '#' used outside of class bodySyntaxError: Unexpected tokenSyntaxError: unlabeled break must be inside loop or switchSyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**'SyntaxError: unterminated string literalSyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# insteadTypeError: 'x' is not iterableTypeError: "x" has no propertiesTypeError: "x" is (not) "y"TypeError: "x" is not a constructorTypeError: "x" is not a functionTypeError: "x" is not a non-null objectTypeError: "x" is read-onlyTypeError: can't assign to property "x" on "y": not an objectTypeError: can't convert BigInt to numberTypeError: can't convert x to BigIntTypeError: can't define property "x": "obj" is not extensibleTypeError: can't delete non-configurable array elementTypeError: can't redefine non-configurable property "x"TypeError: cannot use 'in' operator to search for 'x' in 'y'TypeError: cyclic object valueTypeError: invalid 'instanceof' operand 'x'TypeError: invalid Array.prototype.sort argumentTypeError: invalid assignment to const "x"TypeError: More arguments neededTypeError: property "x" is non-configurable and can't be deletedTypeError: Reduce of empty array with no initial valueTypeError: setting getter-only property "x"TypeError: X.prototype.y called on incompatible typeURIError: malformed URI sequenceWarning: -file- is being assigned a //# sourceMappingURL, but already has oneWarning: unreachable code after return statement




Misc

JavaScript technologies overview
Lexical grammar
Iteration protocols
Strict mode
Template literals
Trailing commas
Deprecated features




In this articleTutorialsReferenceJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.

Looking to become a front-end web developer?

    We have put together a course that includes all the essential information you need to
    work towards your goal.
  
Get started
TutorialsLearn how to program in JavaScript with guides and tutorials.For complete beginnersHead over to our Learning Area JavaScript topic if you want to learn JavaScript but have no previous experience with JavaScript or programming. The complete modules available there are as follows:

JavaScript first steps

Answers some fundamental questions such as "what is JavaScript?", "what does it look like?", and "what can it do?", along with discussing key JavaScript features such as variables, strings, numbers, and arrays.

JavaScript building blocks

Continues our coverage of JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events.

Introducing JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

Discusses asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript guide
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Understanding client-side JavaScript frameworks

JavaScript frameworks are an essential part of modern front-end web development, providing developers with proven tools for building scalable, interactive web applications. This module gives you some fundamental background knowledge about how client-side frameworks work and how they fit into your toolset, before moving on to a series of tutorials covering some of today's most popular ones.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

The event loop

JavaScript has a runtime model based on an "event loop".

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.MDN logoYour blueprint for a better internet.MDN on MastodonMDN on TwitterMDN on GitHubMDN Blog RSS FeedMDNAboutBlogCareersAdvertise with usSupportProduct helpReport an issueOur communitiesMDN CommunityMDN ForumMDN ChatDevelopersWeb TechnologiesLearn Web DevelopmentMDN PlusHacks BlogMozilla logoWebsite Privacy NoticeCookiesLegalCommunity Participation GuidelinesVisit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation.Portions of this content are ©1998–2024 by individual mozilla.org contributors. Content available under a Creative Commons license.
JavaScript basics
 Previous 
 Overview: Getting started with the web
 Next  


  JavaScript is a programming language that adds interactivity to your website. This happens in games, in the behavior of responses when buttons are pressed or with data entry on forms; with dynamic styling; with animation, etc.
  This article helps you get started with JavaScript and furthers your understanding of what is possible.
What is JavaScript?
JavaScript is a powerful programming language that can add interactivity to a website.
  It was invented by Brendan Eich.


  JavaScript is versatile and beginner-friendly.
  With more experience, you'll be able to create games, animated 2D and 3D graphics, comprehensive database-driven apps, and much more!

JavaScript itself is relatively compact, yet very flexible. Developers have written a variety of tools on top of the core JavaScript language, unlocking a vast amount of functionality with minimum effort. These include:

Browser Application Programming Interfaces (APIs) built into web browsers, providing functionality such as dynamically creating HTML and setting CSS styles; collecting and manipulating a video stream from a user's webcam, or generating 3D graphics and audio samples.
Third-party APIs that allow developers to incorporate functionality in sites from other content providers, such as Disqus or Facebook.
Third-party frameworks and libraries that you can apply to HTML to accelerate the work of building sites and applications.

It's outside the scope of this article—as a light introduction to JavaScript—to present the details of how the core JavaScript language is different from the tools listed above. You can learn more in MDN's JavaScript learning area, as well as in other parts of MDN.
The section below introduces some aspects of the core language and offers an opportunity to play with a few browser API features too. Have fun!A "Hello world!" exampleJavaScript is one of the most popular modern web technologies! As your JavaScript skills grow, your websites will enter a new dimension of power and creativity.
However, getting comfortable with JavaScript is more challenging than getting comfortable with HTML and CSS. You may have to start small, and progress gradually. To begin, let's examine how to add JavaScript to your page for creating a Hello world! example. (Hello world! is the standard for introductory programming examples.)

Warning: If you haven't been following along with the rest of our course, download this example code and use it as a starting point.


Go to your test site and create a new folder named scripts. Within the scripts folder, create a new text document called main.js, and save it.
In your index.html file, enter this code on a new line, just before the closing </body> tag:
    html<script src="scripts/main.js"></script>


This is doing the same job as the <link> element for CSS. It applies the JavaScript to the page, so it can have an effect on the HTML (along with the CSS, and anything else on the page).
Add this code to the main.js file:
    jsconst myHeading = document.querySelector("h1");
myHeading.textContent = "Hello world!";


Make sure the HTML and JavaScript files are saved. Then load index.html in your browser. You should see something like this:





Note: The reason the instructions (above) place the <script> element near the bottom of the HTML file is that the browser reads code in the order it appears in the file.
If the JavaScript loads first and it is supposed to affect the HTML that hasn't loaded yet, there could be problems. Placing JavaScript near the bottom of an HTML page is one way to accommodate this dependency. To learn more about alternative approaches, see Script loading strategies.
What happened?The heading text changed to Hello world! using JavaScript. You did this by using a function called querySelector() to grab a reference to your heading, and then store it in a variable called myHeading. This is similar to what we did using CSS selectors. When you want to do something to an element, you need to select it first.
Following that, the code set the value of the myHeading variable's textContent property (which represents the content of the heading) to Hello world!.

Note: Both of the features you used in this exercise are parts of the Document Object Model (DOM) API, which has the capability to manipulate documents.
Language basics crash courseTo give you a better understanding of how JavaScript works, let's explain some of the core features of the language. It's worth noting that these features are common to all programming languages. If you master these fundamentals, you have a head start on coding in other languages too!

Warning: In this article, try entering the example code lines into your JavaScript console to see what happens. For more details on JavaScript consoles, see Discover browser developer tools.
VariablesVariables are containers that store values. You start by declaring a variable with the let keyword, followed by the name you give to the variable:
jslet myVariable;

A semicolon at the end of a line indicates where a statement ends. It is only required when you need to separate statements on a single line. However, some people believe it's good practice to have semicolons at the end of each statement. There are other rules for when you should and shouldn't use semicolons. For more details, see Your Guide to Semicolons in JavaScript.
You can name a variable nearly anything, but there are some restrictions. (See this section about naming rules.) If you are unsure, you can check your variable name to see if it's valid.
JavaScript is case sensitive. This means myVariable is not the same as myvariable. If you have problems in your code, check the case!
After declaring a variable, you can give it a value:
jsmyVariable = "Bob";

Also, you can do both these operations on the same line:
jslet myVariable = "Bob";

You retrieve the value by calling the variable name:
jsmyVariable;

After assigning a value to a variable, you can change it later in the code:
jslet myVariable = "Bob";
myVariable = "Steve";

Note that variables may hold values that have different data types:



Variable
Explanation
Example




String

        This is a sequence of text known as a string. To signify that the value
        is a string, enclose it in single or double quote marks.
      
let myVariable = 'Bob'; orlet myVariable = "Bob";


Number
This is a number. Numbers don't have quotes around them.
let myVariable = 10;


Boolean

        This is a True/False value. The words true and
        false are special keywords that don't need quote marks.
      
let myVariable = true;


Array

        This is a structure that allows you to store multiple values in a single
        reference.
      

let myVariable = [1,'Bob','Steve',10];Refer to each
        member of the array like this:myVariable[0],
        myVariable[1], etc.
      


Object

        This can be anything. Everything in JavaScript is an object and can be
        stored in a variable. Keep this in mind as you learn.
      

let myVariable = document.querySelector('h1');All of
        the above examples too.
      



So why do we need variables? Variables are necessary to do anything interesting in programming. If values couldn't change, then you couldn't do anything dynamic, like personalize a greeting message or change an image displayed in an image gallery.CommentsComments are snippets of text that can be added along with code. The browser ignores text marked as comments. You can write comments in JavaScript just as you can in CSS:
js/*
Everything in between is a comment.
*/

If your comment contains no line breaks, it's an option to put it behind two slashes like this:
js// This is a comment
OperatorsAn operator is a mathematical symbol that produces a result based on two values (or variables). In the following table, you can see some of the simplest operators, along with some examples to try in the JavaScript console.



Operator
Explanation
Symbol(s)
Example




Addition
Add two numbers together or combine two strings.
+
6 + 9;'Hello ' + 'world!';


Subtraction, Multiplication, Division
These do what you'd expect them to do in basic math.
-, *, /
9 - 3;8 * 2; // multiply in JS is an asterisk9 / 3;


Assignment
As you've seen already: this assigns a value to a variable.
=
let myVariable = 'Bob';


Strict equality

        This performs a test to see if two values are equal and of the same data type. It returns a
        true/false (Boolean) result.
      
===
let myVariable = 3;myVariable === 4;


Not, Does-not-equal

        This returns the logically opposite value of what it precedes. It turns
        a true into a false, etc.. When it is used
        alongside the Equality operator, the negation operator tests whether two
        values are not equal.
      
!, !==


          For "Not", the basic expression is true, but the
          comparison returns false because we negate it:
        
let myVariable = 3;!(myVariable === 3);

          "Does-not-equal" gives basically the same result with different
          syntax. Here we are testing "is myVariable NOT equal to
          3". This returns false because myVariable IS
          equal to 3:
        
let myVariable = 3;myVariable !== 3;




There are a lot more operators to explore, but this is enough for now. See Expressions and operators for a complete list.

Note: Mixing data types can lead to some strange results when performing calculations. Be careful that you are referring to your variables correctly, and getting the results you expect. For example, enter '35' + '25' into your console. Why don't you get the result you expected? Because the quote marks turn the numbers into strings, so you've ended up concatenating strings rather than adding numbers. If you enter 35 + 25 you'll get the total of the two numbers.
ConditionalsConditionals are code structures used to test if an expression returns true or not. A very common form of conditionals is the if...else statement. For example:
jslet iceCream = "chocolate";
if (iceCream === "chocolate") {
  alert("Yay, I love chocolate ice cream!");
} else {
  alert("Awwww, but chocolate is my favorite…");
}

The expression inside the if () is the test. This uses the strict equality operator (as described above) to compare the variable iceCream with the string chocolate to see if the two are equal. If this comparison returns true, the first block of code runs. If the comparison is not true, the second block of code—after the else statement—runs instead.FunctionsFunctions are a way of packaging functionality that you wish to reuse. It's possible to define a body of code as a function that executes when you call the function name in your code. This is a good alternative to repeatedly writing the same code. You have already seen some uses of functions. For example:
jslet myVariable = document.querySelector("h1");

jsalert("hello!");

These functions, document.querySelector and alert, are built into the browser.
If you see something which looks like a variable name, but it's followed by parentheses— () —it is likely a function. Functions often take arguments: bits of data they need to do their job. Arguments go inside the parentheses, separated by commas if there is more than one argument.
For example, the alert() function makes a pop-up box appear inside the browser window, but we need to give it a string as an argument to tell the function what message to display.
You can also define your own functions. In the next example, we create a simple function which takes two numbers as arguments and multiplies them:
jsfunction multiply(num1, num2) {
  let result = num1 * num2;
  return result;
}

Try running this in the console; then test with several arguments. For example:
jsmultiply(4, 7);
multiply(20, 20);
multiply(0.5, 3);


Note: The return statement tells the browser to return the result variable out of the function so it is available to use. This is necessary because variables defined inside functions are only available inside those functions. This is called variable scoping. (Read more about variable scoping.)
EventsReal interactivity on a website requires event handlers. These are code structures that listen for activity in the browser, and run code in response. The most obvious example is handling the click event, which is fired by the browser when you click on something with your mouse. To demonstrate this, enter the following into your console, then click on the current webpage:
jsdocument.querySelector("html").addEventListener("click", function () {
  alert("Ouch! Stop poking me!");
});


  There are a number of ways to attach an event handler to an element.
  Here we select the <html> element. We then call its addEventListener() function, passing in the name of the event to listen to ('click') and a function to run when the event happens.


  The function we just passed to addEventListener() here is called an anonymous function, because it doesn't have a name. There's an alternative way of writing anonymous functions, which we call an arrow function.
  An arrow function uses () => instead of function ():

jsdocument.querySelector("html").addEventListener("click", () => {
  alert("Ouch! Stop poking me!");
});
Supercharging our example websiteWith this review of JavaScript basics completed (above), let's add some new features to our example site.
Before going any further, delete the current contents of your main.js file — the bit you added earlier during the "Hello world!" example — and save the empty file. If you don't, the existing code will clash with the new code you are about to add.Adding an image changerIn this section, you will learn how to use JavaScript and DOM API features to alternate the display of one of two images. This change will happen as a user clicks the displayed image.

Choose an image you want to feature on your example site. Ideally, the image will be the same size as the image you added previously, or as close as possible.
Save this image in your images folder.
Rename the image firefox2.png.
Add the following JavaScript code to your main.js file.
    jsconst myImage = document.querySelector("img");

myImage.onclick = () => {
  const mySrc = myImage.getAttribute("src");
  if (mySrc === "images/firefox-icon.png") {
    myImage.setAttribute("src", "images/firefox2.png");
  } else {
    myImage.setAttribute("src", "images/firefox-icon.png");
  }
};


Save all files and load index.html in the browser. Now when you click the image, it should change to the other one.

This is what happened. You stored a reference to your <img> element in myImage. Next, you made its onclick event handler property equal to a function with no name (an "anonymous" function). So every time this element is clicked:

The code retrieves the value of the image's src attribute.
The code uses a conditional to check if the src value is equal to the path of the original image:
    
If it is, the code changes the src value to the path of the second image, forcing the other image to be loaded inside the <img> element.
If it isn't (meaning it must already have changed), the src value swaps back to the original image path, to the original state.


Adding a personalized welcome messageNext, let's change the page title to a personalized welcome message when the user first visits the site. This welcome message will persist. Should the user leave the site and return later, we will save the message using the Web Storage API. We will also include an option to change the user, and therefore, the welcome message.

In index.html, add the following line just before the <script> element:
    html<button>Change user</button>


In main.js, place the following code at the bottom of the file, exactly as it is written. This takes references to the new button and the heading, storing each inside variables:
    jslet myButton = document.querySelector("button");
let myHeading = document.querySelector("h1");


Add the following function to set the personalized greeting. This won't do anything yet, but this will change soon.
    jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  localStorage.setItem("name", myName);
  myHeading.textContent = `Mozilla is cool, ${myName}`;
}
The setUserName() function contains a prompt() function, which displays a dialog box, similar to alert(). This prompt() function does more than alert(), asking the user to enter data, and storing it in a variable after the user clicks OK. In this case, we are asking the user to enter a name. Next, the code calls on an API localStorage, which allows us to store data in the browser and retrieve it later. We use localStorage's setItem() function to create and store a data item called 'name', setting its value to the myName variable which contains the user's entry for the name. Finally, we set the textContent of the heading to a string, plus the user's newly stored name.
  
Add the following condition block after the function declaration. We could call this initialization code, as it structures the app when it first loads.
    jsif (!localStorage.getItem("name")) {
  setUserName();
} else {
  const storedName = localStorage.getItem("name");
  myHeading.textContent = `Mozilla is cool, ${storedName}`;
}
This first line of this block uses the negation operator (logical NOT, represented by the !) to check whether the name data exists. If not, the setUserName() function runs to create it. If it exists (that is, the user set a user name during a previous visit), we retrieve the stored name using getItem() and set the textContent of the heading to a string, plus the user's name, as we did inside setUserName().
  
Put this onclick event handler (below) on the button. When clicked, setUserName() runs. This allows the user to enter a different name by pressing the button.
    jsmyButton.onclick = () => {
  setUserName();
};


A user name of null?When you run the example and get the dialog box that prompts you to enter your user name, try pressing the Cancel button. You should end up with a title that reads Mozilla is cool, null. This happens because—when you cancel the prompt—the value is set as null. Null is a special value in JavaScript that refers to the absence of a value.
Also, try clicking OK without entering a name. You should end up with a title that reads Mozilla is cool, for fairly obvious reasons.
To avoid these problems, you could check that the user hasn't entered a blank name. Update your setUserName() function to this:
jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  if (!myName) {
    setUserName();
  } else {
    localStorage.setItem("name", myName);
    myHeading.textContent = `Mozilla is cool, ${myName}`;
  }
}

In human language, this means: If myName has no value, run setUserName() again from the start. If it does have a value (if the above statement is not true), then store the value in localStorage and set it as the heading's text.ConclusionIf you have followed all the instructions in this article, you should end up with a page that looks something like the image below. You can also view our version.



If you get stuck, you can compare your work with our finished example code on GitHub.
We have just scratched the surface of JavaScript. If you enjoyed playing, and wish to go further, take advantage of the resources listed below.See also
Dynamic client-side scripting with JavaScript

Dive into JavaScript in much more detail.

Learn JavaScript

This is an excellent resource for aspiring web developers! Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by an automated assessment. The first 40 lessons are free. The complete course is available for a small one-time payment.


 Previous 
 Overview: Getting started with the web
 Next  
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 16, 2024 by MDN contributors.
JavaScript First StepsIn our first JavaScript module, we first answer some fundamental questions such as "what is JavaScript?", "what does it look like?", and "what can it do?", before moving on to taking you through your first practical experience of writing JavaScript. After that, we discuss some key building blocks in detail, such as variables, strings, numbers and arrays.

Looking to become a front-end web developer?

    We have put together a course that includes all the essential information you need to
    work towards your goal.
  
Get started
PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have some familiarity with HTML and CSS. You are advised to work through the following modules before starting on JavaScript:

Getting started with the Web (which includes a really basic JavaScript introduction).
Introduction to HTML.
Introduction to CSS.


Note: If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Guides
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In the final article of this module, we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

AssessmentsThe following assessment will test your understanding of the JavaScript basics covered in the guides above.

Silly story generator

In this assessment, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

See also
Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 3, 2023 by MDN contributors.
JavaScript building blocksIn this module, we continue our coverage of all JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events. You've seen this stuff already in the course, but only in passing — here we'll discuss it all explicitly.

Looking to become a front-end web developer?

    We have put together a course that includes all the essential information you need to
    work towards your goal.
  
Get started
PrerequisitesBefore starting this module, you should have some familiarity with the basics of HTML and CSS, and you should have also worked through our previous module, JavaScript first steps.

Note: If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Guides
Making decisions in your code — conditionals

In any programming language, code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is night. In this article we'll explore how conditional structures work in JavaScript.

Looping code

Sometimes you need a task done more than once in a row. For example, looking through a list of names. In programming, loops perform this job very well. Here we will look at loop structures in JavaScript.

Functions — reusable blocks of code

Another essential concept in coding is functions. Functions allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define functions, scope, and parameters.

Build your own function

With most of the essential theory dealt with previously, this article provides a practical experience. Here you'll get some practice with building up your own custom function. Along the way, we'll also explain some further useful details of dealing with functions.

Function return values

The last essential concept you must know about a function is return values. Some functions don't return a significant value after completion, but others do. It's important to understand what their values are, how to make use of them in your code, and how to make your own custom functions return useful values.

Introduction to events

Events are actions or occurrences that happen in the system you are programming, which the system tells you about so you can respond to them in some way if desired. For example if the user clicks a button on a webpage, you might want to respond to that action by displaying an information box. In this final article we will discuss some important concepts surrounding events, and look at how they work in browsers.

AssessmentsThe following assessment will test your understanding of the JavaScript basics covered in the guides above.

Image gallery

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by building a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

See also
Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 3, 2023 by MDN contributors.
Introducing JavaScript objectsIn JavaScript, most things are objects, from core JavaScript features like arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages and act as handy data containers. The object-based nature of JavaScript is important to understand if you want to go further with your knowledge of the language, therefore we've provided this module to help you. Here we teach object theory and syntax in detail, then look at how to create your own objects.

Looking to become a front-end web developer?

    We have put together a course that includes all the essential information you need to
    work towards your goal.
  
Get started
PrerequisitesBefore starting this module, you should have some familiarity with HTML and CSS. You are advised to work through the Introduction to HTML and Introduction to CSS modules before starting on JavaScript.
You should also have some familiarity with JavaScript basics before looking at JavaScript objects in detail. Before attempting this module, work through JavaScript first steps and JavaScript building blocks.

Note: If you are working on a computer/tablet/other devices where you are not able to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Guides
Object basics

In the first article looking at JavaScript objects, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features we've already looked at earlier on in the course, reiterating the fact that many of the features you've already dealt with are in fact objects.

Object prototypes

Prototypes are the mechanism by which JavaScript objects inherit features from one another, and they work differently from inheritance mechanisms in classical object-oriented programming languages. In this article, we explore how prototype chains work.

Object-oriented programming

In this article, we'll describe some of the basic principles of "classical" object-oriented programming, and look at the ways it is different from the prototype model in JavaScript.

Classes in JavaScript

JavaScript provides some features for people wanting to implement "classical" object-oriented programs, and in this article, we'll describe these features.

Working with JSON data

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax, which is commonly used for representing and transmitting data on the web (i.e., sending some data from the server to the client, so it can be displayed on a web page). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing the JSON so you can access data items within it, and writing your own JSON.

Object building practice

In previous articles we looked at all the essential JavaScript object theory and syntax details, giving you a solid base to start from. In this article we dive into a practical exercise, giving you some more practice in building custom JavaScript objects, which produce something fun and colorful — some colored bouncing balls.

Assessments
Adding features to our bouncing balls demo

In this assessment, you are expected to use the bouncing balls demo from the previous article as a starting point, and add some new and interesting features to it.

See also
Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 3, 2023 by MDN contributors.
Introduction
« Previous
Next  »

This chapter introduces JavaScript and discusses some of its fundamental concepts.What you should already knowThis guide assumes you have the following basic background:

A general understanding of the Internet and the World Wide Web (WWW).
Good working knowledge of HyperText Markup Language (HTML).
Some programming experience. If you are new to programming, try one of the tutorials linked on the main page about JavaScript.
Where to find JavaScript informationThe JavaScript documentation on MDN includes the following:

Learn Web Development provides information for beginners and introduces basic concepts of programming and the Internet.
JavaScript Guide (this guide) provides an overview about the JavaScript language and its objects.
JavaScript Reference provides detailed reference material for JavaScript.

If you are new to JavaScript, start with the articles in the learning area and the JavaScript Guide. Once you have a firm grasp of the fundamentals, you can use the JavaScript Reference to get more details on individual objects and statements.What is JavaScript?JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g., having complex animations, clickable buttons, popup menus, etc.). There are also more advanced server side versions of JavaScript such as Node.js, which allow you to add more functionality to a website than downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.
JavaScript contains a standard library of objects, such as Array, Date, and Math, and a core set of language elements such as operators, control structures, and statements. Core JavaScript can be extended for a variety of purposes by supplementing it with additional objects; for example:

Client-side JavaScript extends the core language by supplying objects to control a browser and its Document Object Model (DOM). For example, client-side extensions allow an application to place elements on an HTML form and respond to user events such as mouse clicks, form input, and page navigation.
Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a server. For example, server-side extensions allow an application to communicate with a database, provide continuity of information from one invocation to another of the application, or perform file manipulations on a server.

This means that in the browser, JavaScript can change the way the webpage (DOM) looks. And, likewise, Node.js JavaScript on the server can respond to custom requests sent by code executed in the browser.JavaScript and JavaJavaScript and Java are similar in some ways but fundamentally different in some others. The JavaScript language resembles Java but does not have Java's static typing and strong type checking. JavaScript follows most Java expression syntax, naming conventions and basic control-flow constructs which was the reason why it was renamed from LiveScript to JavaScript.
In contrast to Java's compile-time system of classes built by declarations, JavaScript supports a runtime system based on a small number of data types representing numeric, Boolean, and string values. JavaScript has a prototype-based object model instead of the more common class-based object model. The prototype-based model provides dynamic inheritance; that is, what is inherited can vary for individual objects. JavaScript also supports functions without any special declarative requirements. Functions can be properties of objects, executing as loosely typed methods.
JavaScript is a very free-form language compared to Java. You do not have to declare all variables, classes, and methods. You do not have to be concerned with whether methods are public, private, or protected, and you do not have to implement interfaces. Variables, parameters, and function return types are not explicitly typed.
Java is a class-based programming language designed for fast execution and type safety. Type safety means, for instance, that you can't cast a Java integer into an object reference or access private memory by corrupting the Java bytecode. Java's class-based model means that programs consist exclusively of classes and their methods. Java's class inheritance and strong typing generally require tightly coupled object hierarchies. These requirements make Java programming more complex than JavaScript programming.
In contrast, JavaScript descends in spirit from a line of smaller, dynamically typed languages such as HyperTalk and dBASE. These scripting languages offer programming tools to a much wider audience because of their easier syntax, specialized built-in functionality, and minimal requirements for object creation.



JavaScript
Java




Object-oriented. No distinction between types of objects. Inheritance is through the prototype mechanism, and properties and methods can be added to any object dynamically.
Class-based. Objects are divided into classes and instances with all inheritance through the class hierarchy. Classes and instances cannot have properties or methods added dynamically.


Variable data types are not declared (dynamic typing, loosely typed).
Variable data types must be declared (static typing, strongly typed).


Cannot automatically write to hard disk.
Can automatically write to hard disk.


JavaScript and the ECMAScript specificationJavaScript is standardized at Ecma International — the European association for standardizing information and communication systems (ECMA was formerly an acronym for the European Computer Manufacturers Association) to deliver a standardized, international programming language based on JavaScript. This standardized version of JavaScript, called ECMAScript, behaves the same way in all applications that support the standard. Companies can use the open standard language to develop their implementation of JavaScript. The ECMAScript standard is documented in the ECMA-262 specification.
The ECMA-262 standard is also approved by the ISO (International Organization for Standardization) as ISO-16262. You can also find the specification on the Ecma International website. The ECMAScript specification does not describe the Document Object Model (DOM), which is standardized by the World Wide Web Consortium (W3C) and/or WHATWG (Web Hypertext Application Technology Working Group). The DOM defines the way in which HTML document objects are exposed to your script. To get a better idea about the different technologies that are used when programming with JavaScript, consult the article JavaScript technologies overview.JavaScript documentation versus the ECMAScript specificationThe ECMAScript specification is a set of requirements for implementing ECMAScript. It is useful if you want to implement standards-compliant language features in your ECMAScript implementation or engine (such as SpiderMonkey in Firefox, or V8 in Chrome).
The ECMAScript document is not intended to help script programmers. Use the JavaScript documentation for information when writing scripts.
The ECMAScript specification uses terminology and syntax that may be unfamiliar to a JavaScript programmer. Although the description of the language may differ in ECMAScript, the language itself remains the same. JavaScript supports all functionality outlined in the ECMAScript specification.
The JavaScript documentation describes aspects of the language that are appropriate for a JavaScript programmer.Getting started with JavaScriptTo get started with JavaScript, all you need is a modern web browser. Recent versions of Firefox, Chrome, Microsoft Edge, and Safari all support the features discussed in this guide.
A very useful tool for exploring JavaScript is the JavaScript Console (sometimes called the Web Console, or just the console): this is a tool which enables you to enter JavaScript and run it in the current page.
The screenshots here show the Firefox Web Console, but all modern browsers ship with a console that works in a similar way.Opening the consoleThe exact instructions for opening the console vary from one browser to another:

Opening the console in Firefox
Opening the console in Chrome
Opening the console in Microsoft Edge
Entering and running JavaScriptThe console appears at the bottom of the browser window. Along the bottom of the console is an input line that you can use to enter JavaScript, and the output appears in the panel above:



The console works the exact same way as eval: the last expression entered is returned. For the sake of simplicity, it can be imagined that every time something is entered into the console, it is actually surrounded by console.log around eval, like so:
jsconsole.log(eval("3 + 5"));
Multi-line input in the consoleBy default, if you press Enter (or Return, depending on your keyboard) after entering a line of code, then the string you typed is executed. To enter multi-line input:

If the string you typed was incomplete (for example, you typed function foo() {) then the console will treat Enter as a line break, and let you type another line.
If you hold down Shift while pressing Enter, then the console will treat this as a line break, and let you type another line.
In Firefox only, you can activate multi-line input mode, in which you can enter multiple lines in a mini-editor, then run the whole thing when you are ready.

To get started with writing JavaScript, open the console, copy the following code, and paste it in at the prompt:
js(function () {
  "use strict";
  /* Start of your code */
  function greetMe(yourName) {
    alert(`Hello ${yourName}`);
  }

  greetMe("World");
  /* End of your code */
})();

Press Enter to watch it unfold in your browser!What's nextIn the following pages, this guide introduces you to the JavaScript syntax and language features, so that you will be able to write more complex applications.
But for now, remember to always include the (function(){"use strict"; before your code, and add })(); to the end of your code. The strict mode and IIFE articles explain what those do, but for now they can be thought of as doing the following:

Prevent semantics in JavaScript that trip up beginners.
Prevent code snippets executed in the console from interacting with one another (e.g., having something created in one console execution being used for a different console execution).

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jun 22, 2023 by MDN contributors.
Grammar and types
« Previous
Next  »

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.BasicsJavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.
JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.
jsconst Früh = "foobar";

But, the variable früh is not the same as Früh because JavaScript is case sensitive.
In JavaScript, instructions are called statements and are separated by semicolons (;).
A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

Note: ECMAScript also has rules for automatic insertion of semicolons (ASI) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar.)

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.
The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens, control characters, line terminators, comments, or whitespace. (Spaces, tabs, and newline characters are considered whitespace.)CommentsThe syntax of comments is the same as in C++ and in many other languages:
js// a one line comment

/* this is a longer,
 * multi-line comment
 */

You can't nest block comments. This often happens when you accidentally include a */ sequence in your comment, which will terminate the comment.
js/* You can't, however, /* nest comments */ SyntaxError */

In this case, you need to break up the */ pattern. For example, by inserting a backslash:
js/* You can /* nest comments *\/ by escaping slashes */

Comments behave like whitespace, and are discarded during script execution.

Note: You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: #!/usr/bin/env node.
This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.
DeclarationsJavaScript has three kinds of variable declarations.

var

Declares a variable, optionally initializing it to a value.

let

Declares a block-scoped, local variable, optionally initializing it to a value.

const

Declares a block-scoped, read-only named constant.

VariablesYou use variables as symbolic names for values in your application. The names of variables, called identifiers, conform to certain rules.
A JavaScript identifier usually starts with a letter, underscore (_), or dollar sign ($). Subsequent characters can also be digits (0 – 9). Because JavaScript is case sensitive, letters include the characters A through Z (uppercase) as well as a through z (lowercase).
You can use most Unicode letters such as å and ü in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.
Some examples of legal names are Number_hits, temp99, $credit, and _name.Declaring variablesYou can declare a variable in two ways:

With the keyword var. For example, var x = 42. This syntax can be used to declare both local and global variables, depending on the execution context.
With the keyword const or let. For example, let y = 13. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring assignment syntax. For example, const { bar } = foo. This will create a variable named bar and assign to it the value corresponding to the key of the same name from our object foo.
Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.Declaration and initializationIn a statement like let x = 42, the let x part is called a declaration, and the = 42 part is called an initializer. The declaration allows the variable to be accessed later in code without throwing a ReferenceError, while the initializer assigns a value to the variable. In var and let declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value undefined.
jslet x;
console.log(x); // logs "undefined"

In essence, let x = 42 is equivalent to let x; x = 42.
const declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with undefined is likely a programmer mistake.
jsconst x; // SyntaxError: Missing initializer in const declaration
Variable scopeA variable may belong to one of the following scopes:

Global scope: The default scope for all code running in script mode.
Module scope: The scope for code running in module mode.
Function scope: The scope created with a function.

In addition, variables declared with let or const can belong to an additional scope:

Block scope: The scope created with a pair of curly braces (a block).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.
let and const declarations can also be scoped to the block statement that they are declared in.
jsif (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined

However, variables created with var are not block-scoped, but only local to the function (or global scope) that the block resides within.
For example, the following code will log 5, because the scope of x is the global context (or the function context if the code is part of a function). The scope of x is not limited to the immediate if statement block.
jsif (true) {
  var x = 5;
}
console.log(x); // x is 5
Variable hoistingvar-declared variables are hoisted, meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see var declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always undefined, because only its declaration is hoisted, but not its initialization.
jsconsole.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();

The above examples will be interpreted the same as:
jsvar x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();

Because of hoisting, all var statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.
Whether let and const are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a ReferenceError, because the variable is in a "temporal dead zone" from the start of the block until the declaration is processed.
jsconsole.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;

Unlike var declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.Global variablesGlobal variables are in fact properties of the global object.
In web pages, the global object is window, so you can read and set global variables using the window.variable syntax. In all environments, the globalThis variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.
Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the window or frame name. For example, if a variable called phoneNumber is declared in a document, you can refer to this variable from an iframe as parent.phoneNumber.ConstantsYou can create a read-only, named constant with the const keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign ($), and can contain alphabetic, numeric, or underscore characters.
jsconst PI = 3.14;

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for let block-scope variables.
You cannot declare a constant with the same name as a function or variable in the same scope. For example:
js// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}

However, const only prevents re-assignments, but doesn't prevent mutations. The properties of objects assigned to constants are not protected, so the following statement is executed without problems.
jsconst MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";

Also, the contents of an array are not protected, so the following statement is executed without problems.
jsconst MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
Data structures and typesData typesThe latest ECMAScript standard defines eight data types:

Seven data types that are primitives:
    
Boolean. true and false.
null. A special keyword denoting a null value. (Because JavaScript is case-sensitive, null is not the same as Null, NULL, or any other variant.)
undefined. A top-level property whose value is not defined.
Number. An integer or floating point number. For example: 42 or 3.14159.
BigInt. An integer with arbitrary precision. For example: 9007199254740992n.
String. A sequence of characters that represent a text value. For example: "Howdy".
Symbol. A data type whose instances are unique and immutable.


and Object

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.Data type conversionJavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.
So, for example, you could define a variable as follows:
jslet answer = 42;

And later, you could assign the same variable a string value, for example:
jsanswer = "Thanks for all the fish!";

Because JavaScript is dynamically typed, this assignment does not cause an error message.Numbers and the '+' operatorIn expressions involving numeric and string values with the + operator, JavaScript converts numeric values to strings. For example, consider the following statements:
jsx = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"

With all other operators, JavaScript does not convert numeric values to strings. For example:
js"37" - 7; // 30
"37" * 7; // 259
Converting strings to numbersIn the case that a value representing a number is in memory as a string, there are methods for conversion.

parseInt()
parseFloat()

parseInt only returns whole numbers, so its use is diminished for decimals.

Note: Additionally, a best practice for parseInt is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

jsparseInt("101", 2); // 5

An alternative method of retrieving a number from a string is with the + (unary plus) operator:
js"1.1" + "1.1" // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
LiteralsLiterals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

Array literals
Boolean literals
Numeric literals
Object literals
RegExp literals
String literals
Array literalsAn array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets ([]). When you create an array using an array literal, it is initialized with the specified values as its elements, and its length is set to the number of arguments specified.
The following example creates the coffees array with three elements and a length of three:
jsconst coffees = ["French Roast", "Colombian", "Kona"];

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

Note: Array literals create Array objects. See Array and Indexed collections for details on Array objects.

Extra commas in array literals
If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the fish array:
jsconst fish = ["Lion", , "Angel"];

When you log this array, you will see:
jsconsole.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]

Note that the second item is "empty", which is not exactly the same as the actual undefined value. When using array-traversing methods like Array.prototype.map, empty slots are skipped. However, index-accessing fish[1] still returns undefined.
If you include a trailing comma at the end of the list of elements, the comma is ignored.
In the following example, the length of the array is three. There is no myList[3]. All other commas in the list indicate a new element.
jsconst myList = ["home", , "school"];

In the following example, the length of the array is four, and myList[0] and myList[2] are missing.
jsconst myList = [, "home", , "school"];

In the following example, the length of the array is four, and myList[1] and myList[3] are missing. Only the last comma is ignored.
jsconst myList = ["home", , "school", ,];


Note: Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.
diffconst myList = [
  "home",
  "school",
+ "hospital",
];


Understanding the behavior of extra commas is important to understanding JavaScript as a language.
However, when writing your own code, you should explicitly declare the missing elements as undefined, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.
jsconst myList = ["home", /* empty */, "school", /* empty */, ];
Boolean literalsThe Boolean type has two literal values: true and false.

Note: Do not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.
The Boolean object is a wrapper around the primitive Boolean data type. See Boolean for more information.
Numeric literalsJavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.
Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like -123.4 are fine, being interpreted as a unary - operator applied to the numeric literal 123.4.
Integer literals
Integer and BigInt literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

A decimal integer literal is a sequence of digits without a leading 0 (zero).
A leading 0 (zero) on an integer literal, or a leading 0o (or 0O) indicates it is in octal. Octal integer literals can include only the digits 0 – 7.
A leading 0x (or 0X) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (0 – 9) and the letters a – f and A – F. (The case of a character does not change its value. Therefore: 0xa = 0xA = 10 and 0xf = 0xF = 15.)
A leading 0b (or 0B) indicates a binary integer literal. Binary integer literals can only include the digits 0 and 1.
A trailing n suffix on an integer literal indicates a BigInt literal. The BigInt literal can use any of the above bases. Note that leading-zero octal syntax like 0123n is not allowed, but 0o123n is fine.

Some examples of integer literals are:
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)

For more information, see Numeric literals in the Lexical grammar reference.
Floating-point literals
A floating-point literal can have the following parts:

An unsigned decimal integer,
A decimal point (.),
A fraction (another decimal number),
An exponent.

The exponent part is an e or E followed by an integer, which can be signed (preceded by + or -). A floating-point literal must have at least one digit, and either a decimal point or e (or E).
More succinctly, the syntax is:
[digits].[digits][(E|e)[(+|-)]digits]

For example:
js3.1415926
.123456789
3.1E+12
.1e-23
Object literalsAn object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}).

Warning: Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the { will be interpreted as the beginning of a block.

The following is an example of an object literal. The first element of the car object defines a property, myCar, and assigns to it a new string, "Saturn"; the second element, the getCar property, is immediately assigned the result of invoking the function (carTypes("Honda")); the third element, the special property, uses an existing variable (sales).
jsconst sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.
jsconst car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.
Property names that are not valid identifiers cannot be accessed as a dot (.) property.
jsconst unusualPropertyNames = {
  '': 'An empty string',
  '!': 'Bang!'
}
console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !

Instead, they must be accessed with the bracket notation ([]).
jsconsole.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!

Enhanced Object literals
Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions.
Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.
jsconst obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "d " + super.toString();
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
RegExp literalsA regex literal (which is defined in detail later) is a pattern enclosed between slashes. The following is an example of a regex literal.
jsconst re = /ab+c/;
String literalsA string literal is zero or more characters enclosed in double (") or single (') quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).
The following are examples of string literals:
js'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"

You should use string literals unless you specifically need to use a String object. See String for details on String objects.
You can call any of the String object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the length property with a string literal:
js// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.

Template literals are also available. Template literals are enclosed by the back-tick (`) (grave accent) character instead of double or single quotes.
Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)
js// Basic literal string creation
`In JavaScript '\n' is a line-feed.`

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`

// String interpolation
const name = 'Lev', time = 'today';
`Hello ${name}, how are you ${time}?`

Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named print. The print function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky [object Object].
jsconst formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:
jsprint(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);

This may be reminiscent of the console.log-style interpolation:
jsconsole.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.
Using special characters in strings
In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.
js"one line \n another line";

The following table lists the special characters that you can use in JavaScript strings.



Character
Meaning




\0
Null Byte


\b
Backspace


\f
Form Feed


\n
New Line


\r
Carriage Return


\t
Tab


\v
Vertical tab


\'
Apostrophe or single quote


\"
Double quote


\\
Backslash character


\XXX
The character with the Latin-1 encoding specified by up to three octal digits XXX between 0 and 377. For example, \251 is the octal sequence for the copyright symbol.


\xXX
The character with the Latin-1 encoding specified by the two hexadecimal digits XX between 00 and FF. For example, \xA9 is the hexadecimal sequence for the copyright symbol.


\uXXXX
The Unicode character specified by the four hexadecimal digits XXXX. For example, \u00A9 is the Unicode sequence for the copyright symbol. See Unicode escape sequences.


\u{XXXXX}
Unicode code point escapes. For example, \u{2F804} is the same as the simple Unicode escapes \uD87E\uDC04.



Escaping characters
For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.
You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:
jsconst quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);

The result of this would be:
He read "The Cremation of Sam McGee" by R.W. Service.

To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path c:\temp to a string, use the following:
jsconst home = "c:\\temp";

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.
jsconst str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
More informationThis chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

Control flow and error handling guide
Loops and iteration
Functions
Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.
« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 11, 2024 by MDN contributors.
Control flow and error handling
« Previous
Next  »


  JavaScript supports a compact set of statements, specifically
  control flow statements, that you can use to incorporate a great deal of interactivity
  in your application. This chapter provides an overview of these statements.


  The JavaScript reference
  contains exhaustive details about the statements in this chapter. The semicolon
  (;) character is used to separate statements in JavaScript code.


  Any JavaScript expression is also a statement.
  See Expressions and operators
  for complete information about expressions.
Block statement
  The most basic statement is a block statement, which is used to group
  statements. The block is delimited by a pair of curly braces:

js{
  statement1;
  statement2;
  // …
  statementN;
}
Example
  Block statements are commonly used with control flow statements (if,
  for, while).

jswhile (x < 10) {
  x++;
}

Here, { x++; } is the block statement.

Note: var-declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:
jsvar x = 1;
{
  var x = 2;
}
console.log(x); // 2

This outputs 2 because the var x statement within the block is in the same scope as the var x statement before the block. (In C or Java, the equivalent code would have output 1.)
This scoping effect can be mitigated by using let or const.
Conditional statements
  A conditional statement is a set of commands that executes if a specified condition is
  true. JavaScript supports two conditional statements: if...else and
  switch.
if...else statement
  Use the if statement to execute a statement if a logical condition is
  true. Use the optional else clause to execute a statement if
  the condition is false.

An if statement looks like this:
jsif (condition) {
  statement1;
} else {
  statement2;
}


  Here, the condition can be any expression that evaluates to
  true or false. (See Boolean
  for an explanation of what evaluates to true and false.)


  If condition evaluates to true,
  statement_1 is executed. Otherwise,
  statement_2 is executed. statement_1 and
  statement_2 can be any statement, including further nested
  if statements.


  You can also compound the statements using else if to have multiple
  conditions tested in sequence, as follows:

jsif (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}


  In the case of multiple conditions, only the first logical condition which evaluates to
  true will be executed. To execute multiple statements, group them within a
  block statement ({ /* … */ }).

Best practice

  In general, it's good practice to always use block statements—especially when
  nesting if statements:

jsif (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}

In general it's good practice to not have an if...else with an assignment like x = y as a condition:
jsif (x = y) {
  // statements here
}

However, in the rare case you find yourself wanting to do something like that, the while documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.
Falsy values
The following values evaluate to false (also known as Falsy values):

false
undefined
null
0
NaN
the empty string ("")


  All other values—including all objects—evaluate to true when passed to a
  conditional statement.



Note: Do not confuse the primitive boolean values
    true and false with the true and false values of the
    Boolean object!
  
For example:
jsconst b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}


Example

  In the following example, the function checkData returns true
  if the number of characters in a Text object is three. Otherwise, it
  displays an alert and returns false.

jsfunction checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  } else {
    alert(
      `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
    );
    return false;
  }
}
switch statement
  A switch statement allows a program to evaluate an expression and attempt
  to match the expression's value to a case label. If a match is found, the
  program executes the associated statement.

A switch statement looks like this:
jsswitch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}

JavaScript evaluates the above switch statement as follows:


    The program first looks for a case clause with a label matching the
    value of expression and then transfers control to that clause, executing the
    associated statements.
  

    If no matching label is found, the program looks for the optional
    default clause:
    

        If a default clause is found, the program transfers control to that
        clause, executing the associated statements.
      

        If no default clause is found, the program resumes execution at the
        statement following the end of switch.
      

        (By convention, the default clause is written as the last clause,
        but it does not need to be so.)
      



break statements

  The optional break statement associated with each case clause
  ensures that the program breaks out of switch once the matched statement is
  executed, and then continues execution at the statement following switch.
  If break is omitted, the program continues execution inside the
  switch statement (and will execute statements under the next case, and so on).

Example

  In the following example, if fruitType evaluates to
  'Bananas', the program matches the value with case 'Bananas'
  and executes the associated statement. When break is encountered, the
  program exits the switch and continues execution from the statement
  following switch. If break were omitted, the statement for
  case 'Cherries' would also be executed.

jsswitch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Mangoes and papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
Exception handling statements
  You can throw exceptions using the throw statement and handle them using
  the try...catch statements.


throw statement
try...catch statement
Exception types
  Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
  are created equal. While it is common to throw numbers or strings as errors, it is
  frequently more effective to use one of the exception types specifically created for
  this purpose:


ECMAScript exceptions
DOMException
throw statement
  Use the throw statement to throw an exception. A throw
  statement specifies the value to be thrown:

jsthrow expression;


  You may throw any expression, not just expressions of a specific type. The following
  code throws several exceptions of varying types:

jsthrow "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
try...catch statement
  The try...catch statement marks a block of statements to try, and
  specifies one or more responses should an exception be thrown. If an exception is
  thrown, the try...catch statement catches it.


  The try...catch statement consists of a try block, which
  contains one or more statements, and a catch block, containing statements
  that specify what to do if an exception is thrown in the try block.


  In other words, you want the try block to succeed—but if it does not, you
  want control to pass to the catch block. If any statement within the
  try block (or in a function called from within the try block)
  throws an exception, control immediately shifts to the catch
  block. If no exception is thrown in the try block, the catch
  block is skipped. The finally block executes after the try and
  catch blocks execute but before the statements following the
  try...catch statement.


  The following example uses a try...catch statement. The example calls a
  function that retrieves a month name from an array based on the value passed to the
  function. If the value does not correspond to a month number
  (1 – 12), an exception is thrown with the value
  'InvalidMonthNo' and the statements in the catch block set the
  monthName variable to 'unknown'.

jsfunction getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (months[mo]) {
    return months[mo];
  } else {
    throw new Error("InvalidMonthNo"); // throw keyword is used here
  }
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}

The catch block

  You can use a catch block to handle all exceptions that may be generated
  in the try block.

jscatch (exception) {
  statements
}


  The catch block specifies an identifier (exception
  in the preceding syntax) that holds the value specified by the throw
  statement. You can use this identifier to get information about the exception that was
  thrown.


  JavaScript creates this identifier when the catch block is entered. The
  identifier lasts only for the duration of the catch block. Once the
  catch block finishes executing, the identifier no longer exists.


  For example, the following code throws an exception. When the exception occurs, control
  transfers to the catch block.

jstry {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}



Note: When logging errors to the console inside
    a catch block, using console.error() rather than
    console.log() is advised for debugging. It formats the message as an
    error, and adds it to the list of error messages generated by the page.
  

The finally block

  The finally block contains statements to be executed after the
  try and catch blocks execute. Additionally, the
  finally block executes before the code that follows the
  try…catch…finally statement.


  It is also important to note that the finally block will execute
  whether or not an exception is thrown. If an exception is thrown, however, the
  statements in the finally block execute even if no catch block
  handles the exception that was thrown.


  You can use the finally block to make your script fail gracefully when an
  exception occurs. For example, you may need to release a resource that your script has
  tied up.


  The following example opens a file and then executes statements that use the file.
  (Server-side JavaScript allows you to access files.) If an exception is thrown while the
  file is open, the finally block closes the file before the script fails.
  Using finally here ensures that the file is never left open, even
  if an error occurs.

jsopenMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}


  If the finally block returns a value, this value becomes the return value
  of the entire try…catch…finally production, regardless of any
  return statements in the try and catch blocks:

jsfunction f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false


  Overwriting of return values by the finally block also applies to
  exceptions thrown or re-thrown inside of the catch block:

jsfunction f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false

Nesting try...catch statements
You can nest one or more try...catch statements.

  If an inner try block does not have a corresponding
  catch block:


it must contain a finally block, and

    the enclosing try...catch statement's catch block is
    checked for a match.
  


  For more information, see nested try-blocks
  on the try...catch
  reference page.
Utilizing Error objects
  Depending on the type of error, you may be able to use the name and
  message properties to get a more refined message.


  The name property provides the general class of Error (such
  as DOMException or Error), while message
  generally provides a more succinct message than one would get by converting the error
  object to a string.


  If you are throwing your own exceptions, in order to take advantage of these properties
  (such as if your catch block doesn't discriminate between your own
  exceptions and system ones), you can use the Error constructor.

For example:
jsfunction doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  } else {
    doSomethingToGetAJavaScriptError();
  }
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 30, 2023 by MDN contributors.
Loops and iteration
« Previous
Next  »


  Loops offer a quick and easy way to do something repeatedly. This
  chapter of the JavaScript Guide
  introduces the different iteration statements available to JavaScript.


  You can think of a loop as a computerized version of the game where you tell someone to
  take X steps in one direction, then Y steps in another. For example,
  the idea "Go five steps to the east" could be expressed this way as a loop:

jsfor (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}


  There are many different kinds of loops, but they all essentially do the same thing:
  they repeat an action some number of times. (Note that it's possible that number could
  be zero!)


  The various loop mechanisms offer different ways to determine the start and end points
  of the loop. There are various situations that are more easily served by one type of
  loop over the others.

The statements for loops provided in JavaScript are:

for statement
do...while statement
while statement
labeled statement
break statement
continue statement
for...in statement
for...of statement
for statementA for loop repeats until a specified condition evaluates to false. The JavaScript for loop is similar to the Java and C for loop.
A for statement looks as follows:
jsfor (initialization; condition; afterthought)
  statement

When a for loop executes, the following occurs:

The initializing expression initialization, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.
The condition expression is evaluated. If the value of condition is true, the loop statements execute. Otherwise, the for loop terminates. (If the condition expression is omitted entirely, the condition is assumed to be true.)
The statement executes. To execute multiple statements, use a block statement ({ }) to group those statements.
If present, the update expression afterthought is executed.
Control returns to Step 2.
Example
  In the example below, the function contains a for statement that counts
  the number of selected options in a scrolling list (a <select>
  element that allows multiple selections).

HTML
html<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>

JavaScript
Here, the for statement declares the variable i and initializes it to 0. It checks that i is less than the number of options in the <select> element, performs the succeeding if statement, and increments i by 1 after each pass through the loop.
jsfunction countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
do...while statement
  The do...while statement repeats until a
  specified condition evaluates to false.

A do...while statement looks as follows:
jsdo
  statement
while (condition);


statement is always executed once before the condition is
  checked. (To execute multiple statements, use a block statement ({ })
  to group those statements.)


  If condition is true, the statement executes again. At the
  end of every execution, the condition is checked. When the condition is
  false, execution stops, and control passes to the statement following
  do...while.
Example
  In the following example, the do loop iterates at least once and
  reiterates until i is no longer less than 5.

jslet i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
while statement
  A while statement executes its statements as long as a
  specified condition evaluates to true. A while statement looks
  as follows:

jswhile (condition)
  statement


  If the condition becomes false,
  statement within the loop stops executing and control passes to the
  statement following the loop.


  The condition test occurs before statement in the loop is
  executed. If the condition returns true, statement is executed
  and the condition is tested again. If the condition returns
  false, execution stops, and control is passed to the statement following
  while.


  To execute multiple statements, use a block statement ({ }) to group
  those statements.
Example 1
  The following while loop iterates as long as n is
  less than 3:

jslet n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}


  With each iteration, the loop increments n and adds that value to
  x. Therefore, x and n take on the following
  values:



    After the first pass: n = 1 and x =
    1


    After the second pass: n = 2 and x =
    3


    After the third pass: n = 3 and x =
    6



  After completing the third pass, the condition n < 3 is no longer
  true, so the loop terminates.
Example 2
  Avoid infinite loops. Make sure the condition in a loop eventually becomes
  false—otherwise, the loop will never terminate! The statements in the
  following while loop execute forever because the condition never becomes
  false:

js// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
labeled statement
  A label provides a statement with an identifier that
  lets you refer to it elsewhere in your program. For example, you can use a label to
  identify a loop, and then use the break or continue statements
  to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:
jslabel:
  statement


  The value of label may be any JavaScript identifier that is not a
  reserved word. The statement that you identify with a label may be
  any statement. For examples of using labeled statements, see the examples of break and continue below.
break statement
  Use the break statement to terminate a loop,
  switch, or in conjunction with a labeled statement.



    When you use break without a label, it terminates the innermost
    enclosing while, do-while, for, or
    switch immediately and transfers control to the following statement.
  

    When you use break with a label, it terminates the specified labeled
    statement.
  

The syntax of the break statement looks like this:
jsbreak;
break label;


The first form of the syntax terminates the innermost enclosing loop or switch.
The second form of the syntax terminates the specified enclosing labeled statement.
Example 1
  The following example iterates through the elements in an array until it finds the
  index of an element whose value is theValue:

jsfor (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
Example 2: Breaking to a labeljslet x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
continue statement
  The continue statement can be used to restart a
  while, do-while, for, or label
  statement.



    When you use continue without a label, it terminates the current
    iteration of the innermost enclosing while, do-while, or
    for statement and continues execution of the loop with the next
    iteration. In contrast to the break statement, continue does
    not terminate the execution of the loop entirely. In a while loop, it
    jumps back to the condition. In a for loop, it jumps to the
    increment-expression.
  

    When you use continue with a label, it applies to the looping statement
    identified with that label.
  

The syntax of the continue statement looks like the following:
jscontinue;
continue label;
Example 1
  The following example shows a while loop with a continue
  statement that executes when the value of i is 3. Thus,
  n takes on the values 1, 3, 7, and
  12.

jslet i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12

If you comment out the continue;, the loop would run till the end and you would see 1,3,6,10,15.Example 2
  A statement labeled checkiandj contains a statement labeled
  checkj. If continue is encountered, the program
  terminates the current iteration of checkj and begins the next
  iteration. Each time continue is encountered, checkj
  reiterates until its condition returns false. When false is
  returned, the remainder of the checkiandj statement is completed,
  and checkiandj reiterates until its condition returns
  false. When false is returned, the program continues at the
  statement following checkiandj.


  If continue had a label of checkiandj, the program
  would continue at the top of the checkiandj statement.

jslet i = 0;
let j = 10;
checkiandj: while (i < 4) {
  console.log(i);
  i += 1;
  checkj: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue checkj;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
for...in statement
  The for...in statement iterates a specified
  variable over all the enumerable properties of an object. For each distinct property,
  JavaScript executes the specified statements. A for...in statement looks as
  follows:

jsfor (variable in object)
  statement
Example
  The following function takes as its argument an object and the object's name. It then
  iterates over all the object's properties and returns a string that lists the property
  names and their values.

jsfunction dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}

For an object car with properties make and model, result would be:
car.make = Ford
car.model = Mustang
Arrays
  Although it may be tempting to use this as a way to iterate over Array
  elements, the for...in statement will return the name of your user-defined
  properties in addition to the numeric indexes.


  Therefore, it is better to use a traditional for loop
  with a numeric index when iterating over arrays, because the for...in
  statement iterates over user-defined properties in addition to the array elements, if
  you modify the Array object (such as adding custom properties or methods).
for...of statement
  The for...of statement creates a loop Iterating
  over iterable objects (including
  Array, Map, Set,
  arguments object and so on), invoking a custom
  iteration hook with statements to be executed for the value of each distinct property.

jsfor (variable of object)
  statement


  The following example shows the difference between a for...of loop and a
  for...in loop. While for...in iterates
  over property names, for...of iterates over property values:

jsconst arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7

The for...of and for...in statements can also be used with destructuring. For example, you can simultaneously loop over the keys and values of an object using Object.entries().
jsconst obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Functions
« Previous
Next  »

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.
See also the exhaustive reference chapter about JavaScript functions to get to know the details.Defining functionsFunction declarationsA function definition (also called a function declaration, or function statement) consists of the function keyword, followed by:

The name of the function.
A list of parameters to the function, enclosed in parentheses and separated by commas.
The JavaScript statements that define the function, enclosed in curly braces, { /* … */ }.

For example, the following code defines a simple function named square:
jsfunction square(number) {
  return number * number;
}

The function square takes one parameter, called number. The function consists of one statement that says to return the parameter of the function (that is, number) multiplied by itself. The return statement specifies the value returned by the function, which is number * number.
Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function.
When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theObject) {
  theObject.make = "Toyota";
}

const mycar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(mycar.make); // "Honda"
myFunc(mycar);
console.log(mycar.make); // "Toyota"

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
Function expressionsWhile the function declaration above is syntactically a statement, functions can also be created by a function expression.
Such a function can be anonymous; it does not have to have a name. For example, the function square could have been defined as:
jsconst square = function (number) {
  return number * number;
};

console.log(square(4)); // 16

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:
jsconst factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6

Function expressions are convenient when passing a function as an argument to another function. The following example shows a map function that should receive a function as first argument and an array as second argument:
jsfunction map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

In the following code, the function receives a function defined by a function expression and executes it for every element of the array received as a second argument:
jsfunction map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const cube = function (x) {
  return x * x * x;
};

const numbers = [0, 1, 2, 5, 10];
console.log(map(cube, numbers)); // [0, 1, 8, 125, 1000]

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines myFunc only if num equals 0:
jslet myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}

In addition to defining functions as described here, you can also use the Function constructor to create functions from a string at runtime, much like eval().
A method is a function that is a property of an object. Read more about objects and methods in Working with objects.Calling functionsDefining a function does not execute it. Defining it names the function and specifies what to do when the function is called.
Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function square, you could call it as follows:
jssquare(5);

The preceding statement calls the function with an argument of 5. The function executes its statements and returns the value 25.
Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).
The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The showProps() function (defined in Working with objects) is an example of a function that takes an object as an argument.
A function can call itself. For example, here is a function that computes factorials recursively:
jsfunction factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

You could then compute the factorials of 1 through 5 as follows:
jsconsole.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.
It turns out that functions are themselves objects — and in turn, these objects have methods. (See the Function object.) The call() and apply() methods can be used to achieve this goal.Function hoistingConsider the example below:
jsconsole.log(square(5)); // 25

function square(n) {
  return n * n;
}

This code runs without any error, despite the square() function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:
js// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25

Function hoisting only works with function declarations — not with function expressions. The following code will not work:
jsconsole.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
Function scopeVariables defined inside a function cannot be accessed from anywhere outside the function, because the variable is defined only in the scope of the function. However, a function can access all variables and functions defined inside the scope in which it is defined.
In other words, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access.
js// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
Scope and the function stackRecursionA function can refer to and call itself. There are three ways for a function to refer to itself:

The function's name
arguments.callee
An in-scope variable that refers to the function

For example, consider the following function definition:
jsconst foo = function bar() {
  // statements go here
};

Within the function body, the following are all equivalent:

bar()
arguments.callee()
foo()

A function that calls itself is called a recursive function. In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).
For example, consider the following loop:
jslet x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}

It can be converted into a recursive function declaration, followed by a call to that function:
jsfunction loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM) is easier via recursion:
jsfunction walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (let i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}

Compared to the function loop, each recursive call itself makes many recursive calls here.
It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.
In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:
jsfunction foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
Nested functions and closuresYou may nest a function within another function. The nested (inner) function is private to its containing (outer) function.
It also forms a closure. A closure is an expression (most commonly, a function) that can have free variables together with an environment that binds those variables (that "closes" the expression).
Since a nested function is a closure, this means that a nested function can "inherit" the arguments and variables of its containing function. In other words, the inner function contains the scope of the outer function.
To summarize:

The inner function can be accessed only from statements in the outer function.
The inner function forms a closure: the inner function can use the arguments and variables of the outer function, while the outer function cannot use the arguments and variables of the inner function.

The following example shows nested functions:
jsfunction addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}

console.log(addSquares(2, 3)); // 13
console.log(addSquares(3, 4)); // 25
console.log(addSquares(4, 5)); // 41

Since the inner function forms a closure, you can call the outer function and specify arguments for both the outer and inner function:
jsfunction outside(x) {
  function inside(y) {
    return x + y;
  }
  return inside;
}

const fnInside = outside(3); // Think of it like: give me a function that adds 3 to whatever you give it
console.log(fnInside(5)); // 8
console.log(outside(3)(5)); // 8
Preservation of variablesNotice how x is preserved when inside is returned. A closure must preserve the arguments and variables in all scopes it references. Since each call provides potentially different arguments, a new closure is created for each call to outside. The memory can be freed only when the returned inside is no longer accessible.
This is not different from storing references in other objects, but is often less obvious because one does not set the references directly and cannot inspect them.Multiply-nested functionsFunctions can be multiply-nested. For example:

A function (A) contains a function (B), which itself contains a function (C).
Both functions B and C form closures here. So, B can access A, and C can access B.
In addition, since C can access B which can access A, C can also access A.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining. (The reason it is called "chaining" is explained later.)
Consider the following example:
jsfunction A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)

In this example, C accesses B's y and A's x.
This can be done because:

B forms a closure including A (i.e., B can access A's arguments and variables).
C forms a closure including B.
Because C's closure includes B and B's closure includes A, then C's closure also includes A. This means C can access both B and A's arguments and variables. In other words, C chains the scopes of B and A, in that order.

The reverse, however, is not true. A cannot access C, because A cannot access any argument or variable of B, which C is a variable of. Thus, C remains private to only B.Name conflictsWhen two arguments or variables in the scopes of a closure have the same name, there is a name conflict. More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:
jsfunction outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)

The name conflict happens at the statement return x * 2 and is between inside's parameter x and outside's variable x. The scope chain here is {inside, outside, global object}. Therefore, inside's x takes precedences over outside's x, and 20 (inside's x) is returned instead of 10 (outside's x).ClosuresClosures are one of the most powerful features of JavaScript. JavaScript allows for the nesting of functions and grants the inner function full access to all the variables and functions defined inside the outer function (and all other variables and functions that the outer function has access to).
However, the outer function does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables of the inner function.
Also, since the inner function has access to the scope of the outer function, the variables and functions defined in the outer function will live longer than the duration of the outer function execution, if the inner function manages to survive beyond the life of the outer function. A closure is created when the inner function is somehow made available to any scope outside the outer function.
js// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.
jsconst createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver

In the code above, the name variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.
jsconst getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"


Note: There are a number of pitfalls to watch out for when using closures!
If an enclosed function defines a variable with the same name as a variable in the outer scope, then there is no way to refer to the variable in the outer scope again. (The inner scope variable "overrides" the outer one, until the program exits the inner scope. It can be thought of as a name conflict.)
jsconst createPet = function (name) {
  // The outer function defines a variable called "name".
  return {
    setName(name) {
      // The enclosed function also defines a variable called "name".
      name = name; // How do we access the "name" defined by the outer function?
    },
  };
};

Using the arguments objectThe arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:
jsarguments[i];

where i is the ordinal number of the argument, starting at 0. So, the first argument passed to a function would be arguments[0]. The total number of arguments is indicated by arguments.length.
Using the arguments object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use arguments.length to determine the number of arguments actually passed to the function, and then access each argument using the arguments object.
For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:
jsfunction myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":
jsconsole.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "


Note: The arguments variable is "array-like", but not an array. It is array-like in that it has a numbered index and a length property. However, it does not possess all of the array-manipulation methods.

See the Function object in the JavaScript reference for more information.Function parametersThere are two special kinds of parameter syntax: default parameters and rest parameters.Default parametersIn JavaScript, parameters of functions default to undefined. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.
In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are undefined.
In the following example, if no value is provided for b, its value would be undefined when evaluating a*b, and a call to multiply would normally have returned NaN. However, this is prevented by the second line in this example:
jsfunction multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5

With default parameters, a manual check in the function body is no longer necessary. You can put 1 as the default value for b in the function head:
jsfunction multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5

For more details, see default parameters in the reference.Rest parametersThe rest parameter syntax allows us to represent an indefinite number of arguments as an array.
In the following example, the function multiply uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.
jsfunction multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
Arrow functionsAn arrow function expression (also called a fat arrow to distinguish from a hypothetical -> syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own this, arguments, super, or new.target. Arrow functions are always anonymous.
Two factors influenced the introduction of arrow functions: shorter functions and non-binding of this.Shorter functionsIn some functional patterns, shorter functions are welcome. Compare:
jsconst a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
No separate thisUntil arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.
jsfunction Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();

In ECMAScript 3/5, this issue was fixed by assigning the value in this to a variable that could be closed over.
jsfunction Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}

Alternatively, a bound function could be created so that the proper this value would be passed to the growUp() function.
An arrow function does not have its own this; the this value of the enclosing execution context is used. Thus, in the following code, the this within the function that is passed to setInterval has the same value as this in the enclosing function:
jsfunction Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
Expressions and operators
« Previous
Next  »

This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.
At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate.
The expression x = 7 is an example of the first type. This expression uses the = operator to assign the value seven to the variable x. The expression itself evaluates to 7.
The expression 3 + 4 is an example of the second type. This expression uses the + operator to add 3 and 4 together and produces a value, 7. However, if it's not eventually part of a bigger construct (for example, a variable declaration like const z = 3 + 4), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.
As the examples above also illustrate, all complex expressions are joined by operators, such as = and +. In this section, we will introduce the following operators:

Assignment operators
Comparison operators
Arithmetic operators
Bitwise operators
Logical operators
BigInt operators
String operators
Conditional (ternary) operator
Comma operator
Unary operators
Relational operators

These operators join operands either formed by higher-precedence operators or one of the basic expressions. A complete and detailed list of operators and expressions is also available in the reference.
The precedence of operators determines the order they are applied when evaluating an expression. For example:
jsconst x = 1 + 2 * 3;
const y = 2 * 3 + 1;

Despite * and + coming in different orders, both expressions would result in 7 because * has precedence over +, so the *-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.

  JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
  A binary operator requires two operands, one before the operator and one after the operator:

operand1 operator operand2

For example, 3 + 4 or x * y. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.
A unary operator requires a single operand, either before or after the operator:
operator operand
operand operator

For example, x++ or ++x. The operator operand form is called a prefix unary operator, and the operand operator form is called a postfix unary operator. ++ and -- are the only postfix operators in JavaScript — all other operators, like !, typeof, etc. are prefix.Assignment operators
  An assignment operator assigns a value to its left operand based on the value of its right operand.
  The simple assignment operator is equal (=), which assigns the value of its right operand to its left operand.
  That is, x = f() is an assignment expression that assigns the value of f() to x.

There are also compound assignment operators that are shorthand for the operations listed in the following table:



Name
Shorthand operator
Meaning




Assignment
x = f()
x = f()


Addition assignment
x += f()
x = x + f()


Subtraction assignment
x -= f()
x = x - f()


Multiplication assignment
x *= f()
x = x * f()


Division assignment
x /= f()
x = x / f()


Remainder assignment
x %= f()
x = x % f()


Exponentiation assignment
x **= f()
x = x ** f()


Left shift assignment
x <<= f()
x = x << f()


Right shift assignment
x >>= f()
x = x >> f()


Unsigned right shift assignment
x >>>= f()
x = x >>> f()


Bitwise AND assignment
x &= f()
x = x & f()


Bitwise XOR assignment
x ^= f()
x = x ^ f()


Bitwise OR assignment
x |= f()
x = x | f()


Logical AND assignment
x &&= f()
x && (x = f())


Logical OR assignment
x ||= f()
x || (x = f())


Nullish coalescing assignment
x ??= f()
x ?? (x = f())


Assigning to properties
  If an expression evaluates to an object, then the left-hand side of an assignment expression may make assignments to properties of that expression.
  For example:

jsconst obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.

For more information about objects, read Working with Objects.
If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:
jsconst val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.

In strict mode, the code above throws, because one cannot assign properties to primitives.
It is an error to assign values to unmodifiable properties or to properties of an expression without properties (null or undefined).Destructuring
  For more complex assignments, the destructuring assignment syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
  object literals.

Without destructuring, it takes multiple statements to extract values from arrays and objects:
jsconst foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];

With destructuring, you can extract multiple values into distinct variables using a single statement:
jsconst [one, two, three] = foo;
Evaluation and nestingIn general, assignments are used within a variable declaration (i.e., with const, let, or var) or as standalone statements).
js// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().


  However, like other expressions, assignment expressions like x = f() evaluate into a result value.
  Although this result value is usually not used, it can then be used by another expression.


  Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
  For this reason, some JavaScript style guides discourage chaining or nesting assignments.
  Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.


  By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
  It can be logged, it can be put inside an array literal or function call, and so on.

jslet x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));


  The evaluation result matches the expression to the right of the = sign in the
  "Meaning" column of the table above. That means that x = f() evaluates into
  whatever f()'s result is, x += f() evaluates into the resulting sum x + f(),
  x **= f() evaluates into the resulting power x ** f(), and so on.


  In the case of logical assignments, x &&= f(),
  x ||= f(), and x ??= f(), the return value is that of the
  logical operation without the assignment, so x && f(),
  x || f(), and x ?? f(), respectively.


  When chaining these expressions without parentheses or other grouping operators
  like array literals, the assignment expressions are grouped right to left
  (they are right-associative), but they are evaluated left to right.


  Note that, for all assignment operators other than = itself,
  the resulting values are always based on the operands' values before
  the operation.


  For example, assume that the following functions f and g
  and the variables x and y have been declared:

jsfunction f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;

Consider these three examples:
jsy = x = f();
y = [f(), x = g()];
x[f()] = g();

Evaluation example 1

y = x = f() is equivalent to y = (x = f()),
  because the assignment operator = is right-associative.
  However, it evaluates from left to right:


The assignment expression y = x = f() starts to evaluate.
    

        The y on this assignment's left-hand side evaluates
        into a reference to the variable named y.
      
The assignment expression x = f() starts to evaluate.
        

            The x on this assignment's left-hand side evaluates
            into a reference to the variable named x.
          

            The function call f() prints "F!" to the console and
            then evaluates to the number 2.
          
That 2 result from f() is assigned to x.



        The assignment expression x = f() has now finished evaluating;
        its result is the new value of x, which is 2.
      
That 2 result in turn is also assigned to y.



    The assignment expression y = x = f() has now finished evaluating;
    its result is the new value of y – which happens to be 2.
    x and y are assigned to 2,
    and the console has printed "F!".
  

Evaluation example 2
y = [ f(), x = g() ] also evaluates from left to right:

The assignment expression y = [ f(), x = g() ] starts to evaluate.
    

        The y on this assignment's left-hand evaluates
        into a reference to the variable named y.
      
The inner array literal [ f(), x = g() ] starts to evaluate.
        

            The function call f() prints "F!" to the console and
            then evaluates to the number 2.
          
The assignment expression x = g() starts to evaluate.
            

                The x on this assignment's left-hand side evaluates
                into a reference to the variable named x.
              

                The function call g() prints "G!" to the console and
                then evaluates to the number 3.
              
That 3 result from g() is assigned to x.



            The assignment expression x = g() has now finished evaluating;
            its result is the new value of x, which is 3.
            That 3 result becomes the next element
            in the inner array literal (after the 2 from the f()).
          



        The inner array literal [ f(), x = g() ]
        has now finished evaluating;
        its result is an array with two values: [ 2, 3 ].
      
That [ 2, 3 ] array is now assigned to y.



    The assignment expression y = [ f(), x = g() ] has
    now finished evaluating;
    its result is the new value of y – which happens to be [ 2, 3 ].
    x is now assigned to 3,
    y is now assigned to [ 2, 3 ],
    and the console has printed "F!" then "G!".
  

Evaluation example 3

x[f()] = g() also evaluates from left to right.
  (This example assumes that x is already assigned to some object.
  For more information about objects, read Working with Objects.)


The assignment expression x[f()] = g() starts to evaluate.
    

        The x[f()] property access on this assignment's left-hand
        starts to evaluate.
        

            The x in this property access evaluates
            into a reference to the variable named x.
          

            Then the function call f() prints "F!" to the console and
            then evaluates to the number 2.
          



        The x[f()] property access on this assignment
        has now finished evaluating;
        its result is a variable property reference: x[2].
      

        Then the function call g() prints "G!" to the console and
        then evaluates to the number 3.
      

        That 3 is now assigned to x[2].
        (This step will succeed only if x is assigned to an object.)
      



    The assignment expression x[f()] = g() has now finished evaluating;
    its result is the new value of x[2] – which happens to be 3.
    x[2] is now assigned to 3,
    and the console has printed "F!" then "G!".
  
Avoid assignment chains
  Chaining assignments or nesting assignments in other expressions can
  result in surprising behavior. For this reason,
  chaining assignments in the same statement is discouraged.


  In particular, putting a variable chain in a const, let, or var statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the const/let/var statement.
  For example:

jsconst z = y = x = f();


  This statement seemingly declares the variables x, y, and z.
  However, it only actually declares the variable z.
  y and x are either invalid references to nonexistent variables (in strict mode) or, worse, would implicitly create global variables for x and y in sloppy mode.
Comparison operators
  A comparison operator compares its operands and returns a logical value based on whether the comparison is true.
  The operands can be numerical, string, logical, or object values.
  Strings are compared based on standard lexicographical ordering, using Unicode values.
  In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
  This behavior generally results in comparing the operands numerically.
  The sole exceptions to type conversion within comparisons involve the === and !== operators, which perform strict equality and inequality comparisons.
  These operators do not attempt to convert the operands to compatible types before checking equality.
  The following table describes the comparison operators in terms of this sample code:

jsconst var1 = 3;
const var2 = 4;


Comparison operators


Operator
Description
Examples returning true




Equal (==)
Returns true if the operands are equal.
3 == var1
"3" == var13 == '3'



Not equal (!=)
Returns true if the operands are not equal.
var1 != 4var2 != "3"


Strict equal (===)

        Returns true if the operands are equal and of the same
        type. See also Object.is and
        sameness in JS.
      
3 === var1


Strict not equal (!==)
Returns true if the operands are of the same type but not equal, or are of different type.
var1 !== "3"3 !== '3'


Greater than (>)
Returns true if the left operand is greater than the right operand.
var2 > var1"12" > 2



Greater than or equal
        (>=)
      
Returns true if the left operand is greater than or equal to the right operand.
var2 >= var1var1 >= 3



Less than
        (<)
      
Returns true if the left operand is less than the right operand.
var1 < var2"2" < 12



Less than or equal
        (<=)
      
Returns true if the left operand is less than or equal to the right operand.
var1 <= var2var2 <= 5





Note: => is not a comparison operator but rather is the notation
    for Arrow functions.
  
Arithmetic operators
  An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
  The standard arithmetic operators are addition (+), subtraction (-), multiplication (*), and division (/).
  These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces Infinity). For example:

js1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true

In addition to the standard arithmetic operations (+, -, *, /), JavaScript provides the arithmetic operators listed in the following table:

Arithmetic operators


Operator
Description
Example




Remainder (%)
Binary operator. Returns the integer remainder of dividing the two operands.
12 % 5 returns 2.


Increment (++)

        Unary operator. Adds one to its operand. If used as a prefix operator
        (++x), returns the value of its operand after adding one;
        if used as a postfix operator (x++), returns the value of
        its operand before adding one.
      

        If x is 3, then ++x sets x to 4
        and returns 4, whereas x++ returns 3 and, only then, sets x to 4.
      


Decrement (--)

        Unary operator. Subtracts one from its operand.
        The return value is analogous to that for the increment operator.
      

        If x is 3, then --x sets x to 2
        and returns 2, whereas x-- returns 3 and, only then, sets x to 2.
      


Unary negation (-)
Unary operator. Returns the negation of its operand.
If x is 3, then -x returns -3.


Unary plus (+)
Unary operator. Attempts to convert the operand to a number, if it is not already.

+"3" returns 3.
+true returns 1.



Exponentiation operator (**)

        Calculates the base to the exponent power,
        that is, base^exponent


2 ** 3 returns 8.10 ** -1
        returns 0.1.
      


Bitwise operators
  A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
  than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
  a binary representation of 1001. Bitwise operators perform their operations on such
  binary representations, but they return standard JavaScript numerical values.

The following table summarizes JavaScript's bitwise operators.



Operator
Usage
Description




Bitwise AND
a & b
Returns a one in each bit position for which the corresponding bits of both operands are ones.


Bitwise OR
a | b
Returns a zero in each bit position for which the corresponding bits of both operands are zeros.


Bitwise XOR
a ^ b
Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.]


Bitwise NOT
~ a
Inverts the bits of its operand.


Left shift
a << b
Shifts a in binary representation b bits to the left, shifting in zeros from the right.


Sign-propagating right shift
a >> b
Shifts a in binary representation b bits to the right, discarding bits shifted off.


Zero-fill right shift
a >>> b
Shifts a in binary representation b bits to the right, discarding bits shifted off, and shifting in zeros from the left.


Bitwise logical operatorsConceptually, the bitwise logical operators work as follows:


    The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
    Numbers with more than 32 bits get their most significant bits discarded.
    For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
    Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001


Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.
The operator is applied to each pair of bits, and the result is constructed bitwise.


  For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
  So, when the bitwise operators are applied to these values, the results are as follows:




Expression
Result
Binary Description




15 & 9
9
1111 & 1001 = 1001


15 | 9
15
1111 | 1001 = 1111


15 ^ 9
6
1111 ^ 1001 = 0110


~15
-16
~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000


~9
-10
~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110




  Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
  the most significant (left-most) bit set to 1 represent negative numbers
  (two's-complement representation). ~x evaluates to the same value that
  -x - 1 evaluates to.
Bitwise shift operators
  The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
  shifted.
  The direction of the shift operation is controlled by the operator used.


  Shift operators convert their operands to thirty-two-bit integers and return a result of either type Number or BigInt: specifically, if the type
  of the left operand is BigInt, they return BigInt;
  otherwise, they return Number.

The shift operators are listed in the following table.

Bitwise shift operators


Operator
Description
Example




Left shift(<<)

        This operator shifts the first operand the specified number of bits to
        the left. Excess bits shifted off to the left are discarded. Zero bits
        are shifted in from the right.
      

9<<2 yields 36, because 1001 shifted 2 bits to
        the left becomes 100100, which is 36.
      


Sign-propagating right shift (>>)

        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Copies of
        the leftmost bit are shifted in from the left.
      

9>>2 yields 2, because 1001 shifted 2 bits to the right
        becomes 10, which is 2. Likewise, -9>>2 yields -3, because the sign is preserved.
      


Zero-fill right shift (>>>)

        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Zero bits
        are shifted in from the left.
      

19>>>2 yields 4, because 10011 shifted 2 bits to the right
        becomes 100, which is 4. For non-negative numbers, zero-fill right shift
        and sign-propagating right shift yield the same result.
      


Logical operators
  Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
  However, the && and || operators actually return the value of one of the specified operands, so if these
  operators are used with non-Boolean values, they may return a non-Boolean value.
  The logical operators are described in the following table.


Logical operators


Operator
Usage
Description




Logical AND (&&)
expr1 && expr2

        Returns expr1 if it can be converted to false;
        otherwise, returns expr2. Thus, when used with Boolean
        values, && returns true if both
        operands are true; otherwise, returns false.
      


Logical OR (||)
expr1 || expr2

        Returns expr1 if it can be converted to true;
        otherwise, returns expr2. Thus, when used with Boolean
        values, || returns true if either operand is
        true; if both are false, returns false.
      


Logical NOT (!)
!expr

        Returns false if its single operand that can be converted
        to true; otherwise, returns true.
      




  Examples of expressions that can be converted to false are those that
  evaluate to null, 0, NaN, the empty string (""), or undefined.


  The following code shows examples of the && (logical AND)
  operator.

jsconst a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false

The following code shows examples of the || (logical OR) operator.
jsconst o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat

The following code shows examples of the ! (logical NOT) operator.
jsconst n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
Short-circuit evaluation
  As logical expressions are evaluated left to right, they are tested for possible
  "short-circuit" evaluation using the following rules:


false && anything is short-circuit evaluated to false.
true || anything is short-circuit evaluated to true.


  The rules of logic guarantee that these evaluations are always correct. Note that the
  anything part of the above expressions is not evaluated, so any side effects of
  doing so do not take effect.


  Note that for the second case, in modern code you can use the Nullish coalescing operator (??) that works like ||, but it only returns the second expression, when the first one is "nullish", i.e. null
  or undefined.
  It is thus the better alternative to provide defaults, when values like '' or 0 are valid values for the first expression, too.
BigInt operatorsMost operators that can be used between numbers can be used between BigInt values as well.
js// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n

One exception is unsigned right shift (>>>), which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".
jsconst d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.
jsconst a = 1n + 2; // TypeError: Cannot mix BigInt and other types

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.
jsconst a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n

You can compare BigInts with numbers.
jsconst a = 1n > 2; // false
const b = 3 > 2n; // true
String operatorsIn addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.
For example,
jsconsole.log("my " + "string"); // console logs the string "my string".

The shorthand assignment operator += can also be used to concatenate strings.
For example,
jslet mystring = "alpha";
mystring += "bet"; // evaluates to "alphabet" and assigns this value to mystring.
Conditional (ternary) operator
  The conditional operator
  is the only JavaScript operator that takes three operands.
  The operator can have one of two values based on a condition.
  The syntax is:

jscondition ? val1 : val2


  If condition is true, the operator has the value of val1.
  Otherwise it has the value of val2. You can use the conditional operator anywhere you would use a standard operator.

For example,
jsconst status = age >= 18 ? "adult" : "minor";


  This statement assigns the value "adult" to the variable status if
  age is eighteen or more. Otherwise, it assigns the value "minor" to
  status.
Comma operator
  The comma operator (,)
  evaluates both of its operands and returns the value of the last operand.
  This operator is primarily used inside a for loop, to allow multiple variables to be updated each time through the loop.
  It is regarded bad style to use it elsewhere, when it is not necessary.
  Often two separate statements can and should be used instead.


  For example, if a is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
  The code prints the values of the diagonal elements in the array:

jsconst x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
Unary operatorsA unary operation is an operation with only one operand.delete
  The delete operator deletes an object's property.
  The syntax is:

jsdelete object.property;
delete object[propertyKey];
delete objectName[index];

where object is the name of an object, property is an existing property, and propertyKey is a string or symbol referring to an existing property.

  If the delete operator succeeds, it removes the property from the object.
  Trying to access it afterwards will yield undefined.
  The delete operator returns true if the operation is possible; it returns false if the operation is not possible.

jsdelete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)

Deleting array elements

  Since arrays are just objects, it's technically possible to delete elements from them.
  This is, however, regarded as a bad practice — try to avoid it.
  When you delete an array property, the array length is not affected and other elements are not re-indexed.
  To achieve that behavior, it is much better to just overwrite the element with the value undefined.
  To actually manipulate the array, use the various array methods such as splice.
typeof
  The typeof operator returns a string indicating the type of the unevaluated operand.
  operand is the string, variable, keyword, or object for which the type is to be returned.
  The parentheses are optional.

Suppose you define the following variables:
jsconst myFun = new Function("5 + 2");
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();

The typeof operator returns the following results for these variables:
jstypeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"


  For the keywords true and null, the typeof
  operator returns the following results:

jstypeof true; // returns "boolean"
typeof null; // returns "object"

For a number or string, the typeof operator returns the following results:
jstypeof 62; // returns "number"
typeof "Hello world"; // returns "string"


  For property values, the typeof operator returns the type of value the
  property contains:

jstypeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"

For methods and functions, the typeof operator returns results as follows:
jstypeof blur; // returns "function"
typeof eval; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"

For predefined objects, the typeof operator returns results as follows:
jstypeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
void
  The void operator specifies an expression to be evaluated without returning a value. expression is a JavaScript expression to evaluate.
  The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.
Relational operatorsA relational operator compares its operands and returns a Boolean value based on whether the comparison is true.in
  The in operator returns true if the specified property is in the specified object.
  The syntax is:

jspropNameOrNumber in objectName

where propNameOrNumber is a string, numeric, or symbol expression representing a property name or array index, and objectName is the name of an object.
The following examples show some uses of the in operator.
js// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const mycar = { make: "Honda", model: "Accord", year: 1998 };
"make" in mycar; // returns true
"model" in mycar; // returns true
instanceof
  The instanceof operator returns true
  if the specified object is of the specified object type. The syntax is:

jsobjectName instanceof objectType

where objectName is the name of the object to compare to objectType, and objectType is an object type, such as Date or Array.

  Use instanceof when you need to confirm the type of an object at runtime.
  For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.

For example, the following code uses instanceof to determine whether theDay is a Date object. Because theDay is a Date object, the statements in the if statement execute.
jsconst theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // statements to execute
}
Basic expressionsAll operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals, but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.this
  Use the this keyword to refer to the current object.
  In general, this refers to the calling object in a method.
  Use this either with the dot or the bracket notation:

jsthis["propertyName"];
this.propertyName;

Suppose a function called validate validates an object's value property, given the object and the high and low values:
jsfunction validate(obj, lowval, hival) {
  if (obj.value < lowval || obj.value > hival) {
    console.log("Invalid Value!");
  }
}

You could call validate in each form element's onChange event handler, using this to pass it to the form element, as in the following example:
html<p>Enter a number between 18 and 99:</p>
<input type="text" name="age" size="3" onChange="validate(this, 18, 99);" />
Grouping operator
  The grouping operator ( ) controls the precedence of evaluation in
  expressions. For example, you can override multiplication and division first, then
  addition and subtraction to evaluate addition first.

jsconst a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c     // 7
// evaluated by default like this
a + (b * c)   // 7

// now overriding precedence
// addition before multiplication
(a + b) * c   // 9

// which is equivalent to
a * c + b * c // 9
newYou can use the new operator to create an instance of a user-defined object type or of one of the built-in object types. Use new as follows:
jsconst objectName = new ObjectType(param1, param2, /* …, */ paramN);
super
  The super keyword is used to call functions on an object's parent.
  It is useful with classes to call the parent constructor, for example.

jssuper(args); // calls the parent constructor.
super.functionOnParent(args);

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 27, 2024 by MDN contributors.
Numbers and dates
« Previous
Next  »

This chapter introduces the concepts, objects and functions used to work with and perform calculations using numbers and dates in JavaScript. This includes using numbers written in various bases including decimal, binary, and hexadecimal, as well as the use of the global Math object to perform a wide variety of mathematical operations on numbers.NumbersIn JavaScript, numbers are implemented in double-precision 64-bit binary format IEEE 754 (i.e., a number between ±2^−1022 and ±2^+1023, or about ±10^−308 to ±10^+308, with a numeric precision of 53 bits). Integer values up to ±2^53 − 1 can be represented exactly.
In addition to being able to represent floating-point numbers, the number type has three symbolic values: +Infinity, -Infinity, and NaN (not-a-number).
See also JavaScript data types and structures for context with other primitive types in JavaScript.
You can use four types of number literals: decimal, binary, octal, and hexadecimal.Decimal numbersjs1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal
Binary numbersBinary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). If the digits after the 0b are not 0 or 1, the following SyntaxError is thrown: "Missing binary digits after 0b".
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607
Octal numbersThe standard syntax for octal numbers is to prefix them with 0o. For example:
js0O755 // 493
0o644 // 420

There's also a legacy syntax for octal numbers — by prefixing the octal number with a zero: 0644 === 420 and "\045" === "%". If the digits after the 0 are outside the range 0 through 7, the number will be interpreted as a decimal number.
jsconst n = 0755; // 493
const m = 0644; // 420

Strict mode forbids this octal syntax.Hexadecimal numbersHexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). If the digits after 0x are outside the range (0123456789ABCDEF), the following SyntaxError is thrown: "Identifier starts immediately after numeric literal".
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
Exponentiationjs0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000
Number objectThe built-in Number object has properties for numerical constants, such as maximum value, not-a-number, and infinity. You cannot change the values of these properties and you use them as follows:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;

You always refer to a property of the predefined Number object as shown above, and not as a property of a Number object you create yourself.
The following table summarizes the Number object's properties.



Property
Description




Number.MAX_VALUE
The largest positive representable number (1.7976931348623157e+308)


Number.MIN_VALUE
The smallest positive representable number (5e-324)


Number.NaN
Special "not a number" value


Number.NEGATIVE_INFINITY
Special negative infinite value; returned on overflow


Number.POSITIVE_INFINITY
Special positive infinite value; returned on overflow


Number.EPSILON
Difference between 1 and the smallest value greater than 1 that can be represented as a Number (2.220446049250313e-16)


Number.MIN_SAFE_INTEGER
Minimum safe integer in JavaScript (−2^53 + 1, or −9007199254740991)


Number.MAX_SAFE_INTEGER
Maximum safe integer in JavaScript (+2^53 − 1, or +9007199254740991)






Method
Description




Number.parseFloat()
Parses a string argument and returns a floating point number. Same as the global parseFloat() function.


Number.parseInt()
Parses a string argument and returns an integer of the specified radix or base. Same as the global parseInt() function.


Number.isFinite()
Determines whether the passed value is a finite number.


Number.isInteger()
Determines whether the passed value is an integer.


Number.isNaN()
Determines whether the passed value is NaN. More robust version of the original global isNaN().


Number.isSafeInteger()
Determines whether the provided value is a number that is a safe integer.



The Number prototype provides methods for retrieving information from Number objects in various formats. The following table summarizes the methods of Number.prototype.



Method
Description




toExponential()
Returns a string representing the number in exponential notation.


toFixed()
Returns a string representing the number in fixed-point notation.


toPrecision()
Returns a string representing the number to a specified precision in fixed-point notation.


Math objectThe built-in Math object has properties and methods for mathematical constants and functions. For example, the Math object's PI property has the value of pi (3.141…), which you would use in an application as
jsMath.PI;

Similarly, standard mathematical functions are methods of Math. These include trigonometric, logarithmic, exponential, and other functions. For example, if you want to use the trigonometric function sine, you would write
jsMath.sin(1.56);

Note that all trigonometric methods of Math take arguments in radians.
The following table summarizes the Math object's methods.


    Methods of
    Math



Method
Description




abs()
Absolute value



sin(),
        cos(),
        tan()

Standard trigonometric functions; with the argument in radians.



asin(),
        acos(),
        atan(),
        atan2()

Inverse trigonometric functions; return values in radians.



sinh(),
        cosh(),
        tanh()

Hyperbolic functions; argument in hyperbolic angle.



asinh(),
        acosh(),
        atanh()

Inverse hyperbolic functions; return values in hyperbolic angle.




pow(),
          exp(),
          expm1(),
          log(),
          log10(),
          log1p(),
          log2()


Exponential and logarithmic functions.



floor(),
        ceil()


        Returns the largest/smallest integer less/greater than or equal to an
        argument.
      



min(),
        max()


        Returns the minimum or maximum (respectively) value of a comma separated
        list of numbers as arguments.
      


random()
Returns a random number between 0 and 1.



round(),
        fround(),
        trunc(),
      
Rounding and truncation functions.



sqrt(),
        cbrt(),
        hypot()

Square root, cube root, Square root of the sum of square arguments.


sign()

        The sign of a number, indicating whether the number is positive,
        negative or zero.
      


clz32(),imul()

        Number of leading zero bits in the 32-bit binary representation.The
        result of the C-like 32-bit multiplication of the two arguments.
      



Unlike many other objects, you never create a Math object of your own. You always use the built-in Math object.BigIntsOne shortcoming of number values is they only have 64 bits. In practice, due to using IEEE 754 encoding, they cannot represent any integer larger than Number.MAX_SAFE_INTEGER (which is 253 - 1) accurately. To solve the need of encoding binary data and to interoperate with other languages that offer wide integers like i64 (64-bit integers) and i128 (128-bit integers), JavaScript also offers another data type to represent arbitrarily large integers: BigInt.
A BigInt can be defined as an integer literal suffixed by n:
jsconst b1 = 123n;
// Can be arbitrarily large.
const b2 = -1234567890987654321n;

BigInts can also be constructed from number values or string values using the BigInt constructor.
jsconst b1 = BigInt(123);
// Using a string prevents loss of precision, since long number
// literals don't represent what they seem like.
const b2 = BigInt("-1234567890987654321");

Conceptually, a BigInt is just an arbitrarily long sequence of bits which encodes an integer. You can safely do any arithmetic operations without losing precision or over-/underflowing.
jsconst integer = 12 ** 34; // 4.9222352429520264e+36; only has limited precision
const bigint = 12n ** 34n; // 4922235242952026704037113243122008064n

Compared to numbers, BigInt values yield higher precision when representing large integers; however, they cannot represent floating-point numbers. For example, division would round to zero:
jsconst bigintDiv = 5n / 2n; // 2n, because there's no 2.5 in BigInt

Math functions cannot be used on BigInt values. There is an open proposal to overload certain Math functions like Math.max() to allow BigInt values.
Choosing between BigInt and number depends on your use-case and your input's range. The precision of numbers should be able to accommodate most day-to-day tasks already, and BigInts are most suitable for handling binary data.
Read more about what you can do with BigInt values in the Expressions and Operators section, or the BigInt reference.Date objectJavaScript does not have a date data type. However, you can use the Date object and its methods to work with dates and times in your applications. The Date object has a large number of methods for setting, getting, and manipulating dates. It does not have any properties.
JavaScript handles dates similarly to Java. The two languages have many of the same date methods, and both languages store dates as the number of milliseconds since midnight at the beginning of January 1, 1970, UTC, with a Unix Timestamp being the number of seconds since the same instant. The instant at the midnight at the beginning of January 1, 1970, UTC is called the epoch.
The Date object range is -100,000,000 days to 100,000,000 days relative to the epoch.
To create a Date object:
jsconst dateObjectName = new Date([parameters]);

where dateObjectName is the name of the Date object being created; it can be a new object or a property of an existing object.
Calling Date without the new keyword returns a string representing the current date and time.
The parameters in the preceding syntax can be any of the following:

Nothing: creates today's date and time. For example, today = new Date();.
A string representing a date, in many different forms. The exact forms supported differ among engines, but the following form is always supported: YYYY-MM-DDTHH:mm:ss.sssZ. For example, xmas95 = new Date("1995-12-25"). If you omit hours, minutes, or seconds, the value will be set to zero.
A set of integer values for year, month, and day. For example, xmas95 = new Date(1995, 11, 25).
A set of integer values for year, month, day, hour, minute, and seconds. For example, xmas95 = new Date(1995, 11, 25, 9, 30, 0);.
Methods of the Date objectThe Date object methods for handling dates and times fall into these broad categories:

"set" methods, for setting date and time values in Date objects.
"get" methods, for getting date and time values from Date objects.
"to" methods, for returning string values from Date objects.
parse and UTC methods, for parsing Date strings.

With the "get" and "set" methods you can get and set seconds, minutes, hours, day of the month, day of the week, months, and years separately. There is a getDay method that returns the day of the week, but no corresponding setDay method, because the day of the week is set automatically. These methods use integers to represent these values as follows:

Seconds and minutes: 0 to 59
Hours: 0 to 23
Day: 0 (Sunday) to 6 (Saturday)
Date: 1 to 31 (day of the month)
Months: 0 (January) to 11 (December)
Year: years since 1900

For example, suppose you define the following date:
jsconst xmas95 = new Date("1995-12-25");

Then xmas95.getMonth() returns 11, and xmas95.getFullYear() returns 1995.
The getTime and setTime methods are useful for comparing dates. The getTime method returns the number of milliseconds since the epoch for a Date object.
For example, the following code displays the number of days left in the current year:
jsconst today = new Date();
const endYear = new Date(1995, 11, 31, 23, 59, 59, 999); // Set day and month
endYear.setFullYear(today.getFullYear()); // Set year to this year
const msPerDay = 24 * 60 * 60 * 1000; // Number of milliseconds per day
let daysLeft = (endYear.getTime() - today.getTime()) / msPerDay;
daysLeft = Math.round(daysLeft); // Returns days left in the year

This example creates a Date object named today that contains today's date. It then creates a Date object named endYear and sets the year to the current year. Then, using the number of milliseconds per day, it computes the number of days between today and endYear, using getTime and rounding to a whole number of days.
The parse method is useful for assigning values from date strings to existing Date objects. For example, the following code uses parse and setTime to assign a date value to the ipoDate object:
jsconst ipoDate = new Date();
ipoDate.setTime(Date.parse("Aug 9, 1995"));
ExampleIn the following example, the function JSClock() returns the time in the format of a digital clock.
jsfunction JSClock() {
  const time = new Date();
  const hour = time.getHours();
  const minute = time.getMinutes();
  const second = time.getSeconds();
  let temp = String(hour % 12);
  if (temp === "0") {
    temp = "12";
  }
  temp += (minute < 10 ? ":0" : ":") + minute;
  temp += (second < 10 ? ":0" : ":") + second;
  temp += hour >= 12 ? " P.M." : " A.M.";
  return temp;
}

The JSClock function first creates a new Date object called time; since no arguments are given, time is created with the current date and time. Then calls to the getHours, getMinutes, and getSeconds methods assign the value of the current hour, minute, and second to hour, minute, and second.
The following statements build a string value based on the time. The first statement creates a variable temp. Its value is hour % 12, which is hour in the 12-hour system. Then, if the hour is 0, it gets re-assigned to 12, so that midnights and noons are displayed as 12:00 instead of 0:00.
The next statement appends a minute value to temp. If the value of minute is less than 10, the conditional expression adds a string with a preceding zero; otherwise it adds a string with a demarcating colon. Then a statement appends a seconds value to temp in the same way.
Finally, a conditional expression appends "P.M." to temp if hour is 12 or greater; otherwise, it appends "A.M." to temp.
« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Text formatting
« Previous
Next  »

This chapter introduces how to work with strings and text in JavaScript.StringsJavaScript's String type is used to represent textual data. It is a set of "elements" of 16-bit unsigned integer values (UTF-16 code units). Each element in the String occupies a position in the String. The first element is at index 0, the next at index 1, and so on. The length of a String is the number of elements in it. You can create strings using string literals or string objects.String literalsYou can create simple strings using either single or double quotes:
js'foo'
"bar"

More advanced strings can be created using escape sequences:
Hexadecimal escape sequences
The number after \x is interpreted as a hexadecimal number.
js"\xA9" // "©"

Unicode escape sequences
The Unicode escape sequences require at least four hexadecimal digits following \u.
js"\u00A9" // "©"

Unicode code point escapes
With Unicode code point escapes, any character can be escaped using hexadecimal numbers so that it is possible to use Unicode code points up to 0x10FFFF. With simple Unicode escapes it is often necessary to write the surrogate halves separately to achieve the same result.
See also String.fromCodePoint() or String.prototype.codePointAt().
js"\u{2F804}"

// the same with simple Unicode escapes
"\uD87E\uDC04"
String objectsThe String object is a wrapper around the string primitive data type.
jsconst foo = new String("foo"); // Creates a String object
console.log(foo); // [String: 'foo']
typeof foo; // 'object'

You can call any of the methods of the String object on a string literal value—JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the length property with a string literal.
You should use string literals unless you specifically need to use a String object, because String objects can have counterintuitive behavior. For example:
jsconst firstString = "2 + 2"; // Creates a string literal value
const secondString = new String("2 + 2"); // Creates a String object
eval(firstString); // Returns the number 4
eval(secondString); // Returns a String object containing "2 + 2"

A String object has one property, length, that indicates the number of UTF-16 code units in the string. For example, the following code assigns helloLength the value 13, because "Hello, World!" has 13 characters, each represented by one UTF-16 code unit. You can access each code unit using an array bracket style. You can't change individual characters because strings are immutable array-like objects:
jsconst hello = "Hello, World!";
const helloLength = hello.length;
hello[0] = "L"; // This has no effect, because strings are immutable
hello[0]; // This returns "H"

Characters whose Unicode scalar values are greater than U+FFFF (such as some rare Chinese/Japanese/Korean/Vietnamese characters and some emoji) are stored in UTF-16 with two surrogate code units each. For example, a string containing the single character U+1F600 "Emoji grinning face" will have length 2. Accessing the individual code units in such a string using square brackets may have undesirable consequences such as the formation of strings with unmatched surrogate code units, in violation of the Unicode standard. (Examples should be added to this page after MDN bug 857438 is fixed.) See also String.fromCodePoint() or String.prototype.codePointAt().
A String object has a variety of methods: for example those that return a variation on the string itself, such as substring and toUpperCase.
The following table summarizes the methods of String objects.


Methods of String



Method
Description





charAt(), charCodeAt(),
        codePointAt()


        Return the character or character code at the specified position in
        string.
      



indexOf(),
        lastIndexOf()


        Return the position of specified substring in the string or last
        position of specified substring, respectively.
      



startsWith(),
        endsWith(),
        includes()


        Returns whether or not the string starts, ends or contains a specified
        string.
      


concat()
Combines the text of two strings and returns a new string.


split()

        Splits a String object into an array of strings by
        separating the string into substrings.
      


slice()
Extracts a section of a string and returns a new string.



substring(),
        substr()


        Return the specified subset of the string, either by specifying the
        start and end indexes or the start index and a length.
      



match(), matchAll(),
        replace(), replaceAll(),
        search()

Work with regular expressions.



toLowerCase(),
        toUpperCase()


Return the string in all lowercase or all uppercase, respectively.



normalize()
Returns the Unicode Normalization Form of the calling string value.


repeat()

        Returns a string consisting of the elements of the object repeated the
        given times.
      


trim()
Trims whitespace from the beginning and end of the string.


Multi-line template literalsTemplate literals are string literals allowing embedded expressions. You can use multi-line strings and string interpolation features with them.
Template literals are enclosed by backtick (grave accent) characters (`) instead of double or single quotes. Template literals can contain placeholders. These are indicated by the dollar sign and curly braces (${expression}).
Multi-lines
Any new line characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log(
  "string text line 1\n\
string text line 2",
);
// "string text line 1
// string text line 2"

To get the same effect with multi-line strings, you can now write:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Embedded expressions
In order to embed expressions within normal strings, you would use the following syntax:
jsconst five = 5;
const ten = 10;
console.log(
  "Fifteen is " + (five + ten) + " and not " + (2 * five + ten) + ".",
);
// "Fifteen is 15 and not 20."

Now, with template literals, you are able to make use of the syntactic sugar making substitutions like this more readable:
jsconst five = 5;
const ten = 10;
console.log(`Fifteen is ${five + ten} and not ${2 * five + ten}.`);
// "Fifteen is 15 and not 20."

For more information, read about Template literals in the JavaScript reference.InternationalizationThe Intl object is the namespace for the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, and date and time formatting. The constructors for Intl.Collator, Intl.NumberFormat, and Intl.DateTimeFormat objects are properties of the Intl object.Date and time formattingThe Intl.DateTimeFormat object is useful for formatting date and time. The following formats a date for English as used in the United States. (The result is different in another time zone.)
js// July 17, 2014 00:00:00 UTC:
const july172014 = new Date("2014-07-17");

const options = {
  year: "2-digit",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  timeZoneName: "short",
};
const americanDateTime = new Intl.DateTimeFormat("en-US", options).format;

// Local timezone vary depending on your settings
// In CEST, logs: 07/17/14, 02:00 AM GMT+2
// In PDT, logs: 07/16/14, 05:00 PM GMT-7
console.log(americanDateTime(july172014));
Number formattingThe Intl.NumberFormat object is useful for formatting numbers, for example currencies.
jsconst gasPrice = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  minimumFractionDigits: 3,
});

console.log(gasPrice.format(5.259)); // $5.259

const hanDecimalRMBInChina = new Intl.NumberFormat("zh-CN-u-nu-hanidec", {
  style: "currency",
  currency: "CNY",
});

console.log(hanDecimalRMBInChina.format(1314.25)); // ￥ 一,三一四.二五
CollationThe Intl.Collator object is useful for comparing and sorting strings.
For example, there are actually two different sort orders in German, phonebook and dictionary. Phonebook sort emphasizes sound, and it's as if "ä", "ö", and so on were expanded to "ae", "oe", and so on prior to sorting.
jsconst names = ["Hochberg", "Hönigswald", "Holzman"];

const germanPhonebook = new Intl.Collator("de-DE-u-co-phonebk");

// as if sorting ["Hochberg", "Hoenigswald", "Holzman"]:
console.log(names.sort(germanPhonebook.compare).join(", "));
// "Hochberg, Hönigswald, Holzman"

Some German words conjugate with extra umlauts, so in dictionaries it's sensible to order ignoring umlauts (except when ordering words differing only by umlauts: schon before schön).
jsconst germanDictionary = new Intl.Collator("de-DE-u-co-dict");

// as if sorting ["Hochberg", "Honigswald", "Holzman"]:
console.log(names.sort(germanDictionary.compare).join(", "));
// "Hochberg, Holzman, Hönigswald"

For more information about the Intl API, see also Introducing the JavaScript Internationalization API.
« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
Regular expressions
« Previous
Next  »


  Regular expressions are patterns used to match character combinations in strings.
  In JavaScript, regular expressions are also objects. These patterns are used with the exec() and test() methods of RegExp, and with the match(), matchAll(), replace(), replaceAll(), search(), and split() methods of String.
  This chapter describes JavaScript regular expressions.
Creating a regular expressionYou construct a regular expression in one of two ways:


    Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows:
    jsconst re = /ab+c/;
Regular expression literals provide compilation of the regular expression when the script is loaded.
    If the regular expression remains constant, using this can improve performance.
  

    Or calling the constructor function of the RegExp object, as follows:
    jsconst re = new RegExp("ab+c");
Using the constructor function provides runtime compilation of the regular expression.
    Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.
  
Writing a regular expression pattern
  A regular expression pattern is composed of simple characters, such as /abc/, or a combination of simple and special characters, such as /ab*c/ or /Chapter (\d+)\.\d*/.
  The last example includes parentheses, which are used as a memory device.
  The match made with this part of the pattern is remembered for later use, as described in Using groups.


Note: If you are already familiar with the forms of a regular expression, you may also read the cheat sheet for a quick lookup for a specific pattern/construct.
Using simple patterns
  Simple patterns are constructed of characters for which you want to find a direct match. For example, the pattern /abc/ matches character combinations in strings only when the exact sequence "abc" occurs (all characters together and in that order).
  Such a match would succeed in the strings "Hi, do you know your abc's?" and "The latest airplane designs evolved from slabcraft.".
  In both cases the match is with the substring "abc".
  There is no match in the string "Grab crab" because while it contains the substring "ab c", it does not contain the exact substring "abc".
Using special characters
  When the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern.
  For example, to match a single "a" followed by zero or more "b"s followed by "c", you'd use the pattern /ab*c/: the * after "b" means "0 or more occurrences of the preceding item."
  In the string "cbbabbbbcdebc", this pattern will match the substring "abbbbc".

The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples.

Assertions guide

Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions).

Character classes guide

Distinguish different types of characters. For example, distinguishing between letters and digits.

Groups and backreferences guide

Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression.

Quantifiers guide

Indicate numbers of characters or expressions to match.


If you want to look at all the special characters that can be used in regular expressions in a single table, see the following:

Special characters in regular expressions.


Characters / constructs
Corresponding article





[xyz], [^xyz], .,
        \d, \D, \w, \W,
        \s, \S, \t, \r,
        \n, \v, \f, [\b],
        \0, \cX, \xhh,
        \uhhhh, \u{hhhh},
        x|y


Character classes




^, $, \b, \B,
        x(?=y), x(?!y), (?<=y)x,
        (?<!y)x


Assertions




(x), (?<Name>x), (?:x),
        \n, \k<Name>


Groups and backreferences




x*, x+, x?,
        x{n}, x{n,},
        x{n,m}


Quantifiers





Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).
Escaping
  If you need to use any of the special characters literally (actually searching for a "*", for instance), you must escape it by putting a backslash in front of it.
  For instance, to search for "a" followed by "*" followed by "b", you'd use /a\*b/ — the backslash "escapes" the "*", making it literal instead of special.


  Similarly, if you're writing a regular expression literal and need to match a slash ("/"), you need to escape that (otherwise, it terminates the pattern).
  For instance, to search for the string "/example/" followed by one or more alphabetic characters, you'd use /\/example\/[a-z]+/i—the backslashes before each slash make them literal.


  To match a literal backslash, you need to escape the backslash.
  For instance, to match the string "C:\" where "C" can be any letter, you'd use /[A-Z]:\\/ — the first backslash escapes the one after it, so the expression searches for a single literal backslash.


  If using the RegExp constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level.
  /a\*b/ and new RegExp("a\\*b") create the same expression, which searches for "a" followed by a literal "*" followed by "b".

If escape strings are not already part of your pattern you can add them using String.prototype.replace():
jsfunction escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}


  The "g" after the regular expression is an option or flag that performs a global search, looking in the whole string and returning all matches.
  It is explained in detail below in Advanced Searching With Flags.

Why isn't this built into JavaScript? There is a proposal to add such a function to RegExp.Using parentheses
  Parentheses around any part of the regular expression pattern causes that part of the matched substring to be remembered.
  Once remembered, the substring can be recalled for other use. See Groups and backreferences for more details.
Using regular expressions in JavaScriptRegular expressions are used with the RegExp methods test() and exec() and with the String methods match(), matchAll(), replace(), replaceAll(), search(), and split().



Method
Description




exec()
Executes a search for a match in a string. It returns an array of information or null on a mismatch.


test()
Tests for a match in a string. It returns true or false.


match()
Returns an array containing all of the matches, including capturing groups, or null if no match is found.


matchAll()
Returns an iterator containing all of the matches, including capturing groups.


search()
Tests for a match in a string. It returns the index of the match, or -1 if the search fails.


replace()
Executes a search for a match in a string, and replaces the matched substring with a replacement substring.


replaceAll()
Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring.


split()
Uses a regular expression or a fixed string to break a string into an array of substrings.




  When you want to know whether a pattern is found in a string, use the test() or search() methods; for more information (but slower execution) use the exec() or match() methods.
  If you use exec() or match() and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, RegExp.
  If the match fails, the exec() method returns null (which coerces to false).

In the following example, the script uses the exec() method to find a match in a string.
jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");

If you do not need to access the properties of the regular expression, an alternative way of creating myArray is with this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
// similar to 'cdbbdbsbz'.match(/d(b+)d/g); however,
// 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ "dbbd" ]
// while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ]

(See Using the global search flag with exec() for further info about the different behaviors.)
If you want to construct the regular expression from a string, yet another alternative is this script:
jsconst myRe = new RegExp("d(b+)d", "g");
const myArray = myRe.exec("cdbbdbsbz");

With these scripts, the match succeeds and returns the array and updates the properties shown in the following table.

Results of regular expression execution.


Object
Property or index
Description
In this example




myArray

The matched string and all remembered substrings.
['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']


index
The 0-based index of the match in the input string.
1


input
The original string.
'cdbbdbsbz'


[0]
The last matched characters.
'dbbd'


myRe
lastIndex

        The index at which to start the next match.
        (This property is set only if the regular expression uses the g option, described in
        Advanced Searching With Flags.)
      
5


source
The text of the pattern. Updated at the time that the regular expression is created, not executed.
'd(b+)d'




  As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable.
  If you do, however, every occurrence is a new regular expression.
  For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression.
  For example, assume you have this script:

jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${myRe.lastIndex}`);

// "The value of lastIndex is 5"

However, if you have this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`);

// "The value of lastIndex is 0"


  The occurrences of /d(b+)d/g in the two statements are different regular expression objects and hence have different values for their lastIndex property.
  If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.
Advanced searching with flags
  Regular expressions have optional flags that allow for functionality like global searching and case-insensitive searching.
  These flags can be used separately or together in any order, and are included as part of the regular expression.




Flag
Description
Corresponding property




d
Generate indices for substring matches.
hasIndices


g
Global search.
global


i
Case-insensitive search.
ignoreCase


m
Allows ^ and $ to match next to newline characters.
multiline


s
Allows . to match newline characters.
dotAll


u
"Unicode"; treat a pattern as a sequence of Unicode code points.
unicode


v
An upgrade to the u mode with more Unicode features.
unicodeSets


y
Perform a "sticky" search that matches starting at the current position in the target string.
sticky



To include a flag with the regular expression, use this syntax:
jsconst re = /pattern/flags;

or
jsconst re = new RegExp("pattern", "flags");

Note that the flags are an integral part of a regular expression. They cannot be added or removed later.
For example, re = /\w+\s/g creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string.
jsconst re = /\w+\s/g;
const str = "fee fi fo fum";
const myArray = str.match(re);
console.log(myArray);

// ["fee ", "fi ", "fo "]

You could replace the line:
jsconst re = /\w+\s/g;

with:
jsconst re = new RegExp("\\w+\\s", "g");

and get the same result.

  The m flag is used to specify that a multiline input string should be treated as multiple lines.
  If the m flag is used, ^ and $ match at the start or end of any line within the input string instead of the start or end of the entire string.

Using the global search flag with exec()
RegExp.prototype.exec() method with the g flag returns each match and its position iteratively.
jsconst str = "fee fi fo fum";
const re = /\w+\s/g;

console.log(re.exec(str)); // ["fee ", index: 0, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fi ", index: 4, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fo ", index: 7, input: "fee fi fo fum"]
console.log(re.exec(str)); // null

In contrast, String.prototype.match() method returns all matches at once, but without their position.
jsconsole.log(str.match(re)); // ["fee ", "fi ", "fo "]

Using unicode regular expressions
The u flag is used to create "unicode" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode "word":
js/\p{L}*/u;

Unicode regular expressions have different execution behavior as well. RegExp.prototype.unicode contains more explanation about this.Examples
Note: Several examples are also available in:

The reference pages for exec(), test(), match(), matchAll(), search(), replace(), split()
The guide articles: character classes, assertions, groups and backreferences, quantifiers

Using special characters to verify input
  In the following example, the user is expected to enter a phone number.
  When the user presses the "Check" button, the script checks the validity of the number.
  If the number is valid (matches the character sequence specified by the regular expression), the script shows a message thanking the user and confirming the number.
  If the number is invalid, the script informs the user that the phone number is not valid.

The regular expression looks for:

the beginning of the line of data: ^
followed by three numeric characters \d{3} OR | a left parenthesis \(, followed by three digits \d{3}, followed by a close parenthesis \), in a non-capturing group (?:)
followed by one dash, forward slash, or decimal point in a capturing group ()
followed by three digits \d{3}
followed by the match remembered in the (first) captured group \1
followed by four digits \d{4}
followed by the end of the line of data: $

HTML
html<p>
  Enter your phone number (with area code) and then click "Check".
  <br />
  The expected format is like ###-###-####.
</p>
<form id="form">
  <input id="phone" />
  <button type="submit">Check</button>
</form>
<p id="output"></p>

JavaScript
jsconst form = document.querySelector("#form");
const input = document.querySelector("#phone");
const output = document.querySelector("#output");

const re = /^(?:\d{3}|\(\d{3}\))([-/.])\d{3}\1\d{4}$/;

function testInfo(phoneInput) {
  const ok = re.exec(phoneInput.value);

  output.textContent = ok
    ? `Thanks, your phone number is ${ok[0]}`
    : `${phoneInput.value} isn't a phone number with area code!`;
}

form.addEventListener("submit", (event) => {
  event.preventDefault();
  testInfo(input);
});

ResultTools
RegExr

An online tool to learn, build, & test Regular Expressions.

Regex tester

An online regex builder/debugger

Regex interactive tutorial

An online interactive tutorials, Cheat sheet, & Playground.

Regex visualizer

An online visual regex tester.


« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 2, 2024 by MDN contributors.
Indexed collections
« Previous
Next  »

This chapter introduces collections of data which are ordered by an index value. This includes arrays and array-like constructs such as Array objects and TypedArray objects.
An array is an ordered list of values that you refer to with a name and an index.
For example, consider an array called emp, which contains employees' names indexed by their numerical employee number. So emp[0] would be employee number zero, emp[1] employee number one, and so on.
JavaScript does not have an explicit array data type. However, you can use the predefined Array object and its methods to work with arrays in your applications. The Array object has methods for manipulating arrays in various ways, such as joining, reversing, and sorting them. It has a property for determining the array length and other properties for use with regular expressions.
We will be focusing on arrays in this article, but many of the same concepts apply to typed arrays as well, since arrays and typed arrays share many similar methods. For more information on typed arrays, see the typed array guide.Creating an arrayThe following statements create equivalent arrays:
jsconst arr1 = new Array(element0, element1, /* …, */ elementN);
const arr2 = Array(element0, element1, /* …, */ elementN);
const arr3 = [element0, element1, /* …, */ elementN];

element0, element1, …, elementN is a list of values for the array's elements. When these values are specified, the array is initialized with them as the array's elements. The array's length property is set to the number of arguments.
The bracket syntax is called an "array literal" or "array initializer." It's shorter than other forms of array creation, and so is generally preferred. See Array literals for details.
To create an array with non-zero length, but without any items, either of the following can be used:
js// This...
const arr1 = new Array(arrayLength);

// ...results in the same array as this
const arr2 = Array(arrayLength);

// This has exactly the same effect
const arr3 = [];
arr3.length = arrayLength;


Note: In the above code, arrayLength must be a Number. Otherwise, an array with a single element (the provided value) will be created. Calling arr.length will return arrayLength, but the array doesn't contain any elements. A for...in loop will not find any property on the array.

In addition to a newly defined variable as shown above, arrays can also be assigned as a property of a new or an existing object:
jsconst obj = {};
// …
obj.prop = [element0, element1, /* …, */ elementN];

// OR
const obj = { prop: [element0, element1, /* …, */ elementN] };

If you wish to initialize an array with a single element, and the element happens to be a Number, you must use the bracket syntax. When a single Number value is passed to the Array() constructor or function, it is interpreted as an arrayLength, not as a single element.
This creates an array with only one element: the number 42.
jsconst arr = [42];

This creates an array with no elements and arr.length set to 42.
jsconst arr = Array(42);

This is equivalent to:
jsconst arr = [];
arr.length = 42;

Calling Array(N) results in a RangeError, if N is a non-whole number whose fractional portion is non-zero. The following example illustrates this behavior.
jsconst arr = Array(9.3); // RangeError: Invalid array length

If your code needs to create arrays with single elements of an arbitrary data type, it is safer to use array literals. Alternatively, create an empty array first before adding the single element to it.
You can also use the Array.of static method to create arrays with single element.
jsconst wisenArray = Array.of(9.3); // wisenArray contains only one element 9.3
Referring to array elementsBecause elements are also properties, you can access them using property accessors. Suppose you define the following array:
jsconst myArray = ["Wind", "Rain", "Fire"];

You can refer to the first element of the array as myArray[0], the second element of the array as myArray[1], etc… The index of the elements begins with zero.

Note: You can also use property accessors to access other properties of the array, like with an object.
jsconst arr = ["one", "two", "three"];
arr[2]; // three
arr["length"]; // 3

Populating an arrayYou can populate an array by assigning values to its elements. For example:
jsconst emp = [];
emp[0] = "Casey Jones";
emp[1] = "Phil Lesh";
emp[2] = "August West";


Note: If you supply a non-integer value to the array operator in the code above, a property will be created in the object representing the array, instead of an array element.
jsconst arr = [];
arr[3.4] = "Oranges";
console.log(arr.length); // 0
console.log(Object.hasOwn(arr, 3.4)); // true


You can also populate an array when you create it:
jsconst myArray = new Array("Hello", myVar, 3.14159);
// OR
const myArray = ["Mango", "Apple", "Orange"];
Understanding lengthAt the implementation level, JavaScript's arrays actually store their elements as standard object properties, using the array index as the property name.
The length property is special. Its value is always a positive integer greater than the index of the last element if one exists. (In the example below, 'Dusty' is indexed at 30, so cats.length returns 30 + 1).
Remember, JavaScript Array indexes are 0-based: they start at 0, not 1. This means that the length property will be one more than the highest index stored in the array:
jsconst cats = [];
cats[30] = ["Dusty"];
console.log(cats.length); // 31

You can also assign to the length property.
Writing a value that is shorter than the number of stored items truncates the array. Writing 0 empties it entirely:
jsconst cats = ["Dusty", "Misty", "Twiggy"];
console.log(cats.length); // 3

cats.length = 2;
console.log(cats); // [ 'Dusty', 'Misty' ] - Twiggy has been removed

cats.length = 0;
console.log(cats); // []; the cats array is empty

cats.length = 3;
console.log(cats); // [ <3 empty items> ]
Iterating over arraysA common operation is to iterate over the values of an array, processing each one in some way. The simplest way to do this is as follows:
jsconst colors = ["red", "green", "blue"];
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]);
}

If you know that none of the elements in your array evaluate to false in a boolean context—if your array consists only of DOM nodes, for example—you can use a more efficient idiom:
jsconst divs = document.getElementsByTagName("div");
for (let i = 0, div; (div = divs[i]); i++) {
  /* Process div in some way */
}

This avoids the overhead of checking the length of the array, and ensures that the div variable is reassigned to the current item each time around the loop for added convenience.
The forEach() method provides another way of iterating over an array:
jsconst colors = ["red", "green", "blue"];
colors.forEach((color) => console.log(color));
// red
// green
// blue

The function passed to forEach is executed once for every item in the array, with the array item passed as the argument to the function. Unassigned values are not iterated in a forEach loop.
Note that the elements of an array that are omitted when the array is defined are not listed when iterating by forEach, but are listed when undefined has been manually assigned to the element:
jsconst sparseArray = ["first", "second", , "fourth"];

sparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// fourth

if (sparseArray[2] === undefined) {
  console.log("sparseArray[2] is undefined"); // true
}

const nonsparseArray = ["first", "second", undefined, "fourth"];

nonsparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// undefined
// fourth

Since JavaScript array elements are saved as standard object properties, it is not advisable to iterate through JavaScript arrays using for...in loops, because normal elements and all enumerable properties will be listed.Array methodsThe Array object has the following methods:
The concat() method joins two or more arrays and returns a new array.
jslet myArray = ["1", "2", "3"];
myArray = myArray.concat("a", "b", "c");
// myArray is now ["1", "2", "3", "a", "b", "c"]

The join() method joins all elements of an array into a string.
jsconst myArray = ["Wind", "Rain", "Fire"];
const list = myArray.join(" - "); // list is "Wind - Rain - Fire"

The push() method adds one or more elements to the end of an array and returns the resulting length of the array.
jsconst myArray = ["1", "2"];
myArray.push("3"); // myArray is now ["1", "2", "3"]

The pop() method removes the last element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const last = myArray.pop();
// myArray is now ["1", "2"], last = "3"

The shift() method removes the first element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const first = myArray.shift();
// myArray is now ["2", "3"], first is "1"

The unshift() method adds one or more elements to the front of an array and returns the new length of the array.
jsconst myArray = ["1", "2", "3"];
myArray.unshift("4", "5");
// myArray becomes ["4", "5", "1", "2", "3"]

The slice() method extracts a section of an array and returns a new array.
jslet myArray = ["a", "b", "c", "d", "e"];
myArray = myArray.slice(1, 4); // [ "b", "c", "d"]
// starts at index 1 and extracts all elements
// until index 3

The at() method returns the element at the specified index in the array, or undefined if the index is out of range. It's notably used for negative indices that access elements from the end of the array.
jsconst myArray = ["a", "b", "c", "d", "e"];
myArray.at(-2); // "d", the second-last element of myArray

The splice() method removes elements from an array and (optionally) replaces them. It returns the items which were removed from the array.
jsconst myArray = ["1", "2", "3", "4", "5"];
myArray.splice(1, 3, "a", "b", "c", "d");
// myArray is now ["1", "a", "b", "c", "d", "5"]
// This code started at index one (or where the "2" was),
// removed 3 elements there, and then inserted all consecutive
// elements in its place.

The reverse() method transposes the elements of an array, in place: the first array element becomes the last and the last becomes the first. It returns a reference to the array.
jsconst myArray = ["1", "2", "3"];
myArray.reverse();
// transposes the array so that myArray = ["3", "2", "1"]

The flat() method returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.
jslet myArray = [1, 2, [3, 4]];
myArray = myArray.flat();
// myArray is now [1, 2, 3, 4], since the [3, 4] subarray is flattened

The sort() method sorts the elements of an array in place, and returns a reference to the array.
jsconst myArray = ["Wind", "Rain", "Fire"];
myArray.sort();
// sorts the array so that myArray = ["Fire", "Rain", "Wind"]

sort() can also take a callback function to determine how array elements are compared. The callback function is called with two arguments, which are two values from the array. The function compares these two values and returns a positive number, negative number, or zero, indicating the order of the two values. For instance, the following will sort the array by the last letter of a string:
jsconst sortFn = (a, b) => {
  if (a[a.length - 1] < b[b.length - 1]) {
    return -1; // Negative number => a < b, a comes before b
  } else if (a[a.length - 1] > b[b.length - 1]) {
    return 1; // Positive number => a > b, a comes after b
  }
  return 0; // Zero => a = b, a and b keep their original order
};
myArray.sort(sortFn);
// sorts the array so that myArray = ["Wind","Fire","Rain"]


if a is less than b by the sorting system, return -1 (or any negative number)
if a is greater than b by the sorting system, return 1 (or any positive number)
if a and b are considered equivalent, return 0.

The indexOf() method searches the array for searchElement and returns the index of the first match.
jsconst a = ["a", "b", "a", "b", "a"];
console.log(a.indexOf("b")); // 1

// Now try again, starting from after the last match
console.log(a.indexOf("b", 2)); // 3
console.log(a.indexOf("z")); // -1, because 'z' was not found

The lastIndexOf() method works like indexOf, but starts at the end and searches backwards.
jsconst a = ["a", "b", "c", "d", "a", "b"];
console.log(a.lastIndexOf("b")); // 5

// Now try again, starting from before the last match
console.log(a.lastIndexOf("b", 4)); // 1
console.log(a.lastIndexOf("z")); // -1

The forEach() method executes callback on every array item and returns undefined.
jsconst a = ["a", "b", "c"];
a.forEach((element) => {
  console.log(element);
});
// Logs:
// a
// b
// c

The forEach method (and others below) that take a callback are known as iterative methods, because they iterate over the entire array in some fashion. Each one takes an optional second argument called thisArg. If provided, thisArg becomes the value of the this keyword inside the body of the callback function. If not provided, as with other cases where a function is invoked outside of an explicit object context, this will refer to the global object (window, globalThis, etc.) when the function is not strict, or undefined when the function is strict.

Note: The sort() method introduced above is not an iterative method, because its callback function is only used for comparison and may not be called in any particular order based on element order. sort() does not accept the thisArg parameter either.

The map() method returns a new array of the return value from executing callback on every array item.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.map((item) => item.toUpperCase());
console.log(a2); // ['A', 'B', 'C']

The flatMap() method runs map() followed by a flat() of depth 1.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.flatMap((item) => [item.toUpperCase(), item.toLowerCase()]);
console.log(a2); // ['A', 'a', 'B', 'b', 'C', 'c']

The filter() method returns a new array containing the items for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const a2 = a1.filter((item) => typeof item === "number");
console.log(a2); // [10, 20, 30]

The find() method returns the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.find((item) => typeof item === "number");
console.log(i); // 10

The findLast() method returns the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLast((item) => typeof item === "number");
console.log(i); // 30

The findIndex() method returns the index of the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findIndex((item) => typeof item === "number");
console.log(i); // 1

The findLastIndex() method returns the index of the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLastIndex((item) => typeof item === "number");
console.log(i); // 5

The every() method returns true if callback returns true for every item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.every(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.every(isNumber)); // false

The some() method returns true if callback returns true for at least one item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.some(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.some(isNumber)); // true
const a3 = ["1", "2", "3"];
console.log(a3.some(isNumber)); // false

The reduce() method applies callback(accumulator, currentValue, currentIndex, array) for each value in the array for the purpose of reducing the list of items down to a single value. The reduce function returns the final value returned by callback function.
If initialValue is specified, then callback is called with initialValue as the first parameter value and the value of the first item in the array as the second parameter value.
If initialValue is not specified, then callback's first two parameter values will be the first and second elements of the array. On every subsequent call, the first parameter's value will be whatever callback returned on the previous call, and the second parameter's value will be the next value in the array.
If callback needs access to the index of the item being processed, or access to the entire array, they are available as optional parameters.
jsconst a = [10, 20, 30];
const total = a.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0,
);
console.log(total); // 60

The reduceRight() method works like reduce(), but starts with the last element.
reduce and reduceRight are the least obvious of the iterative array methods. They should be used for algorithms that combine two values recursively in order to reduce a sequence down to a single value.Array transformationsYou can transform back and forth between arrays and other data structures.Grouping the elements of an arrayThe Object.groupBy() method can be used to group the elements of an array, using a test function that returns a string indicating the group of the current element.
Here we have a simple inventory array that contains "food" objects that have a name and a type.
jsconst inventory = [
  { name: "asparagus", type: "vegetables" },
  { name: "bananas", type: "fruit" },
  { name: "goat", type: "meat" },
  { name: "cherries", type: "fruit" },
  { name: "fish", type: "meat" },
];

To use Object.groupBy(), you supply a callback function that is called with the current element, and optionally the current index and array, and returns a string indicating the group of the element.
The code below uses an arrow function to return the type of each array element (this uses object destructuring syntax for function arguments to unpack the type element from the passed object). The result is an object that has properties named after the unique strings returned by the callback. Each property is assigned an array containing the elements in the group.
jsconst result = Object.groupBy(inventory, ({ type }) => type);
console.log(result.vegetables);
// [{ name: "asparagus", type: "vegetables" }]

Note that the returned object references the same elements as the original array (not deep copies). Changing the internal structure of these elements will be reflected in both the original array and the returned object.
If you can't use a string as the key, for example, if the information to group is associated with an object that might change, then you can instead use Map.groupBy(). This is very similar to Object.groupBy() except that it groups the elements of the array into a Map that can use an arbitrary value (object or primitive) as a key.Sparse arraysArrays can contain "empty slots", which are not the same as slots filled with the value undefined. Empty slots can be created in one of the following ways:
js// Array constructor:
const a = Array(5); // [ <5 empty items> ]

// Consecutive commas in array literal:
const b = [1, 2, , , 5]; // [ 1, 2, <2 empty items>, 5 ]

// Directly setting a slot with index greater than array.length:
const c = [1, 2];
c[4] = 5; // [ 1, 2, <2 empty items>, 5 ]

// Elongating an array by directly setting .length:
const d = [1, 2];
d.length = 5; // [ 1, 2, <3 empty items> ]

// Deleting an element:
const e = [1, 2, 3, 4, 5];
delete e[2]; // [ 1, 2, <1 empty item>, 4, 5 ]

In some operations, empty slots behave as if they are filled with undefined.
jsconst arr = [1, 2, , , 5]; // Create a sparse array

// Indexed access
console.log(arr[2]); // undefined

// For...of
for (const i of arr) {
  console.log(i);
}
// Logs: 1 2 undefined undefined 5

// Spreading
const another = [...arr]; // "another" is [ 1, 2, undefined, undefined, 5 ]

But in others (most notably array iteration methods), empty slots are skipped.
jsconst mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
arr.forEach((i) => console.log(i)); // 1 2 5
const filtered = arr.filter(() => true); // [ 1, 2, 5 ]
const hasFalsy = arr.some((k) => !k); // false

// Property enumeration
const keys = Object.keys(arr); // [ '0', '1', '4' ]
for (const key in arr) {
  console.log(key);
}
// Logs: '0' '1' '4'
// Spreading into an object uses property enumeration, not the array's iterator
const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }

For a complete list of how array methods behave with sparse arrays, see the Array reference page.Multi-dimensional arraysArrays can be nested, meaning that an array can contain another array as an element. Using this characteristic of JavaScript arrays, multi-dimensional arrays can be created.
The following code creates a two-dimensional array.
jsconst a = new Array(4);
for (let i = 0; i < 4; i++) {
  a[i] = new Array(4);
  for (let j = 0; j < 4; j++) {
    a[i][j] = `[${i}, ${j}]`;
  }
}

This example creates an array with the following rows:
Row 0: [0, 0] [0, 1] [0, 2] [0, 3]
Row 1: [1, 0] [1, 1] [1, 2] [1, 3]
Row 2: [2, 0] [2, 1] [2, 2] [2, 3]
Row 3: [3, 0] [3, 1] [3, 2] [3, 3]
Using arrays to store other propertiesArrays can also be used like objects, to store related information.
jsconst arr = [1, 2, 3];
arr.property = "value";
console.log(arr.property); // "value"

For example, when an array is the result of a match between a regular expression and a string, the array returns properties and elements that provide information about the match. An array is the return value of RegExp.prototype.exec(), String.prototype.match(), and String.prototype.split(). For information on using arrays with regular expressions, see Regular Expressions.Working with array-like objectsSome JavaScript objects, such as the NodeList returned by document.getElementsByTagName() or the arguments object made available within the body of a function, look and behave like arrays on the surface but do not share all of their methods. The arguments object provides a length attribute but does not implement array methods like forEach().
Array methods cannot be called directly on array-like objects.
jsfunction printArguments() {
  arguments.forEach((item) => {
    console.log(item);
  }); // TypeError: arguments.forEach is not a function
}

But you can call them indirectly using Function.prototype.call().
jsfunction printArguments() {
  Array.prototype.forEach.call(arguments, (item) => {
    console.log(item);
  });
}

Array prototype methods can be used on strings as well, since they provide sequential access to their characters in a similar way to arrays:
jsArray.prototype.forEach.call("a string", (chr) => {
  console.log(chr);
});

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Keyed collections
« Previous
Next  »

This chapter introduces collections of data which are indexed by a key; Map and Set objects contain elements which are iterable in the order of insertion.MapsMap objectA Map object is a simple key/value map and can iterate its elements in insertion order.
The following code shows some basic operations with a Map. See also the Map reference page for more examples and the complete API. You can use a for...of loop to return an array of [key, value] for each iteration.
jsconst sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
Object and Map comparedTraditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. Map objects, however, have a few more advantages that make them better maps.

The keys of an Object are strings or symbols, whereas they can be of any value for a Map.
You can get the size of a Map easily, while you have to manually keep track of size for an Object.
The iteration of maps is in insertion order of the elements.
An Object has a prototype, so there are default keys in the map. (This can be bypassed using map = Object.create(null).)

These three tips can help you to decide whether to use a Map or an Object:

Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.
Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.
Use objects when there is logic that operates on individual elements.
WeakMap objectA WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.
The WeakMap API is essentially the same as the Map API. However, a WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a WeakMap. If there were, the list would depend on the state of garbage collection, introducing non-determinism.
For more information and example code, see also "Why WeakMap?" on the WeakMap reference page.
One use case of WeakMap objects is to store private data for an object, or to hide implementation details. The following example is from Nick Fitzgerald's blog post "Hiding Implementation Details with ECMAScript 6 WeakMaps". The private data and methods belong inside the object and are stored in the privates object, which is a WeakMap. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because privates is not exported from the module.
jsconst privates = new WeakMap();

function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};

module.exports = Public;
SetsSet objectSet objects are collections of unique values. You can iterate its elements in insertion order. A value in a Set may only occur once; it is unique in the Set's collection.
The following code shows some basic operations with a Set. See also the Set reference page for more examples and the complete API.
jsconst mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
Converting between Array and SetYou can create an Array from a Set using Array.from or the spread syntax. Also, the Set constructor accepts an Array to convert in the other direction.

Note: Set objects store unique values—so any duplicate elements from an Array are deleted when converting!

jsArray.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
Array and Set comparedTraditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The Set object, however, has some advantages:

Deleting Array elements by value (arr.splice(arr.indexOf(val), 1)) is very slow.
Set objects let you delete elements by their value. With an array, you would have to splice based on an element's index.
The value NaN cannot be found with indexOf in an array.
Set objects store unique values. You don't have to manually keep track of duplicates.
WeakSet objectWeakSet objects are collections of garbage-collectable values, including objects and non-registered symbols. A value in the WeakSet may only occur once. It is unique in the WeakSet's collection.
The main differences to the Set object are:

In contrast to Sets, WeakSets are collections of objects or symbols only, and not of arbitrary values of any type.
The WeakSet is weak: References to objects in the collection are held weakly. If there is no other reference to an object stored in the WeakSet, they can be garbage collected. That also means that there is no list of current objects stored in the collection.
WeakSets are not enumerable.

The use cases of WeakSet objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.Key and value equality of Map and SetBoth the key equality of Map objects and the value equality of Set objects are based on the SameValueZero algorithm:

Equality works like the identity comparison operator ===.
-0 and +0 are considered equal.
NaN is considered equal to itself (contrary to ===).

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 1, 2024 by MDN contributors.
Working with objects
« Previous
Next  »

JavaScript is designed on a simple object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method.
Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.
In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.Creating new objectsYou can create an object using an object initializer. Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the new operator.Using object initializersObject initializers are also called object literals. "Object initializer" is consistent with the terminology used by C++.
The syntax for an object using an object initializer is:
jsconst obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};

Each property name before colons is an identifier (either a name, a number, or a string literal), and each valueN is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.
In this example, the newly created object is assigned to a variable obj — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)
Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.
The following statement creates an object and assigns it to the variable x if and only if the expression cond is true:
jslet x;
if (cond) {
  x = { greeting: "hi there" };
}

The following example creates myHonda with three properties. Note that the engine property is also an object with its own properties.
jsconst myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};

Objects created with initializers are called plain objects, because they are instances of Object, but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals.Using a constructor functionAlternatively, you can create an object with these two steps:

Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.
Create an instance of the object with new.

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called Car, and you want it to have properties for make, model, and year. To do this, you would write the following function:
jsfunction Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

Notice the use of this to assign values to the object's properties based on the values passed to the function.
Now you can create an object called myCar as follows:
jsconst myCar = new Car("Eagle", "Talon TSi", 1993);

This statement creates myCar and assigns it the specified values for its properties. Then the value of myCar.make is the string "Eagle", myCar.model is the string "Talon TSi", myCar.year is the integer 1993, and so on. The order of arguments and parameters should be the same.
You can create any number of Car objects by calls to new. For example,
jsconst kenscar = new Car("Nissan", "300ZX", 1992);
const vpgscar = new Car("Mazda", "Miata", 1990);

An object can have a property that is itself another object. For example, suppose you define an object called Person as follows:
jsfunction Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}

and then instantiate two new Person objects as follows:
jsconst rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");

Then, you can rewrite the definition of Car to include an owner property that takes a Person object, as follows:
jsfunction Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}

To instantiate the new objects, you then use the following:
jsconst car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects rand and ken as the arguments for the owners. Then if you want to find out the name of the owner of car2, you can access the following property:
jscar2.owner.name;

You can always add a property to a previously defined object. For example, the statement
jscar1.color = "black";

adds a property color to car1, and assigns it a value of "black". However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the Car object type.
You can also use the class syntax instead of the function syntax to define a constructor function. For more information, see the class guide.Using the Object.create() methodObjects can also be created using the Object.create() method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.
js// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called animal1
const animal1 = Object.create(Animal);
animal1.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
Objects and propertiesA JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes. The properties of an object define the characteristics of the object.
For example, this example creates an object named myCar, with properties named make, model, and year, with their values set to "Ford", "Mustang", and 1969:
jsconst myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.Accessing propertiesYou can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation. For example, you could access the properties of the myCar object as follows:
js// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;

An object property name can be any JavaScript string or symbol, including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e. not determinable until runtime. Examples are as follows:
jsconst myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'

In the above code, the key anotherObj is an object, which is neither a string nor a symbol. When it is added to the myObj, JavaScript calls the toString() method of anotherObj, and use the resulting string as the new key.
You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable str held "myString" and it is "myString" that is the property name. Therefore, myObj.str will return as undefined.
jsstr = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'

This allows accessing any property as determined at runtime:
jslet propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks.
Nonexistent properties of an object have value undefined (and not null).
jsmyCar.nonexistentProperty; // undefined
Enumerating propertiesThere are three native ways to list/traverse object properties:

for...in loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.
Object.keys(). This method returns an array with only the enumerable own string property names ("keys") in the object myObj, but not those in the prototype chain.
Object.getOwnPropertyNames(). This method returns an array containing all the own string property names in the object myObj, regardless of if they are enumerable or not.

You can use the bracket notation with for...in to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:
jsfunction showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call showProps(myCar, 'myCar') would print the following:
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969

The above is equivalent to:
jsfunction showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}

There is no native way to list inherited non-enumerable properties. However, this can be achieved with the following function:
jsfunction listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}

For more information, see Enumerability and ownership of properties.Deleting propertiesYou can remove a non-inherited property using the delete operator. The following code shows how to remove a property.
js// Creates a new object, myobj, with two properties, a and b.
const myobj = new Object();
myobj.a = 5;
myobj.b = 12;

// Removes the a property, leaving myobj with only the b property.
delete myobj.a;
console.log("a" in myobj); // false
InheritanceAll objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the prototype object of the constructor. See Inheritance and the prototype chain for more information.Defining properties for all objects of one typeYou can add a property to all objects created through a certain constructor using the prototype property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a color property to all objects of type Car, and then reads the property's value from an instance car1.
jsCar.prototype.color = "red";
console.log(car1.color); // "red"
Defining methodsA method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:
jsobjectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};

where objectName is an existing object, methodName is the name you are assigning to the method, and functionName is the name of the function.
You can then call the method in the context of the object as follows:
jsobjectName.methodName(params);

Methods are typically defined on the prototype object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined Car objects.
jsCar.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};

Notice the use of this to refer to the object to which the method belongs. Then you can call the displayCar method for each of the objects as follows:
jscar1.displayCar();
car2.displayCar();
Using this for object referencesJavaScript has a special keyword, this, that you can use within a method to refer to the current object. For example, suppose you have 2 objects, Manager and Intern. Each object has its own name, age and job. In the function sayHi(), notice the use of this.name. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.
jsconst Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone

this is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in Manager.sayHi(), this is the Manager object, because Manager comes before the function sayHi(). If you access the same function from another object, this will change as well. If you use other methods to call the function, like Function.prototype.call() or Reflect.apply(), you can explicitly pass the value of this as an argument.Defining getters and settersA getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.
Getters and setters can be either

defined within object initializers, or
added later to any existing object.

Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords get or set. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:
jsconst myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25

The myObj object's properties are:

myObj.a — a number
myObj.b — a getter that returns myObj.a plus 1
myObj.c — a setter that sets the value of myObj.a to half of the value myObj.c is being set to

Getters and setters can also be added to an object at any time after creation using the Object.defineProperties() method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:
jsconst myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.Comparing objectsIn JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.
js// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const fruitbear = { name: "apple" };

fruit == fruitbear; // return false
fruit === fruitbear; // return false

js// Two variables, a single object
const fruit = { name: "apple" };
const fruitbear = fruit; // Assign fruit object reference to fruitbear

// Here fruit and fruitbear are pointing to same object
fruit == fruitbear; // return true
fruit === fruitbear; // return true

fruit.name = "grape";
console.log(fruitbear); // { name: "grape" }; not { name: "apple" }

For more information about comparison operators, see equality operators.See also
Inheritance and the prototype chain
Classes

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Using classes
« Previous
Next  »

JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.
In many other languages, classes, or constructors, are clearly distinguished from objects, or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the new operator with a constructor function to create a new object.
We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.
This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.Overview of classesIf you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you:
jsconst bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}

On the first line, we created an instance of the class Date, and called it bigDay. On the second line, we called a method toLocaleDateString() on the bigDay instance, which returns a string. Then, we compared two numbers: one returned from the getTime() method, the other directly called from the Date class itself, as Date.now().
Date is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

Classes create objects through the new operator.
Each object has some properties (data or method) added by the class.
The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

Constructor;
Instance methods and instance fields;
Static methods and static fields.
Declaring a classClasses are usually created with class declarations.
jsclass MyClass {
  // class body...
}

Within a class body, there are a range of features available.
jsclass MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:
jsfunction MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();


Note: Private fields and methods are new features in classes with no trivial equivalent in function constructors.
Constructing a classAfter a class has been declared, you can create instances of it using the new operator.
jsconst myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();

Typical function constructors can both be constructed with new and called without new. However, attempting to "call" a class without new will result in an error.
jsconst myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
Class declaration hoistingUnlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.
jsnew MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}

This behavior is similar to variables declared with let and const.Class expressionsSimilar to functions, class declarations also have their expression counterparts.
jsconst MyClass = class {
  // Class body...
};

Class expressions can have names as well. The expression's name is only visible to the class's body.
jsconst MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
ConstructorPerhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the Date constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor.
As an example, we would create a class called Color, which represents a specific color. Users create colors through passing in an RGB triplet.
jsclass Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}

Open your browser's devtools, paste the above code into the console, and then create an instance:
jsconst red = new Color(255, 0, 0);
console.log(red);

You should see some output like this:
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]

You have successfully created a Color instance, and the instance has a values property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:
jsfunction createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters:
jsclass Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.

Each time you call new, a different instance is created.
jsconst red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false

Within a class constructor, the value of this points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).
The this value will be automatically returned as the result of new. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the new expression, and the value of this is dropped. (You can read more about what new does in its description.)
jsclass MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
Instance methodsIf a class only has a constructor, it is not much different from a createX factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.
For example, for Date instances, you can use a range of methods to get different information from a single date value, such as the year, month, day of the week, etc. You can also set those values through the setX counterparts like setFullYear.
For our own Color class, we can add a method called getRed which returns the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Without methods, you may be tempted to define the function within the constructor:
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}

This also works. However, a problem is that this creates a new function every time a Color instance is created, even when they all do the same thing!
jsconsole.log(new Color().getRed === new Color().getRed); // false

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of this is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or Color.prototype, which is explained in more detail in Inheritance and the prototype chain.
Similarly, we can create a new method called setRed, which sets the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
Private fieldsYou might be wondering: why do we want to go to the trouble of using getRed and setRed methods, when we can directly access the values array on the instance?
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:
jsclass Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0

The user assumption that values means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields.
A private field is an identifier prefixed with # (the hash symbol). The hash is an integral part of the field's name, which means a private property can never have name clash with a public property. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private property on the fly). Apart from this, a private field is pretty much equivalent to a normal property.
jsclass Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Accessing private fields outside the class is an early syntax error. The language can guard against this because #privateField is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.
jsconsole.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class


Note: Code run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

Private fields in JavaScript are hard private: if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.
After we've made the values field private, we can add some more logic in the getRed and setRed methods, instead of making them simple pass-through methods. For example, we can add a check in setRed to see if it's a valid R value:
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value

If we leave the values property exposed, our users can easily circumvent that check by assigning to values[0] directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.
A class method can read the private fields of other instances, as long as they belong to the same class.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35

However, if anotherColor is not a Color instance, #values won't exist. (Even if another class has an identically named #values private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private property throws an error instead of returning undefined like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using try/catch to handle the error, you can use the in operator.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}


Note: Keep in mind that the # is a special identifier syntax, and you can't use the field name as if it's a string. "#values" in anotherColor would look for a property name literally called "#values", instead of a private field.

There are some limitations in using private properties: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.
jsclass BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.
For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.
jsclass Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of Counter.Accessor fieldscolor.getRed() and color.setRed() allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if its an "actual property".
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0

It looks as if the object has a property called red — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with get and set, which allows them to be manipulated as if they were properties.
If a field only has a getter but no setter, it will be effectively read-only.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255

In strict mode, the red.red = 0 line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.Public fieldsPrivate fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.
jsclass MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3

Public fields are almost equivalent to assigning a property to this. For example, the above example can also be converted to:
jsclass MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
Static propertiesWith the Date example, we have also encountered the Date.now() method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the Date class instead of being exposed as a global DateNow() function, because it's mostly useful when dealing with date instances.

Note: Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed parseInt() method, JavaScript also later added the prefixed Number.parseInt() method to indicate that it's for dealing with numbers.

Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

Static methods
Static fields
Static getters and setters

Everything also has private counterparts. For example, for our Color class, we can create a static method that checks whether a given triplet is a valid RGB value:
jsclass Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false

Static properties are very similar to their instance counterparts, except that:

They are all prefixed with static, and
They are not accessible from instances.

jsconsole.log(new Color(0, 0, 0).isValid); // undefined

There is also a special construct called a static initialization block, which is a block of code that runs when the class is first loaded.
jsclass MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private properties.Extends and inheritanceA key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance, which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.
For example, suppose our Color class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:
jsclass Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our Color class will become very bloated and hard to maintain.
Instead, in object-oriented programming, we would create a derived class. The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an extends clause, which indicates the class it extends from.
jsclass ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}

There are a few things that have immediately come to attention. First is that in the constructor, we are calling super(r, g, b). It is a language requirement to call super() before accessing this. The super() call calls the parent class's constructor to initialize this — here it's roughly equivalent to this = new Color(r, g, b). You can have code before super(), but you cannot access this before super() — the language prevents you from accessing the uninitialized this.
After the parent class is done with modifying this, the derived class can do its own logic. Here we added a private field called #alpha, and also provided a pair of getter/setters to interact with them.
A derived class inherits all methods from its parent. For example, although ColorWithAlpha doesn't declare a get red() accessor itself, you can still access red because this behavior is specified by the parent class:
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the Object class, which defines some basic methods like toString(). However, the base toString() method is notoriously useless, because it prints [object Object] in most cases:
jsconsole.log(red.toString()); // [object Object]

Instead, our class can override it to print the color's RGB values:
jsclass Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'

Within derived classes, you can access the parent class's methods by using super. This allows you to build enhancement methods and avoid code duplication.
jsclass ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'

When you use extends, the static methods inherit from each other as well, so you can also override or enhance them.
jsclass ColorWithAlpha extends Color {
  // ...
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.
jsclass ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem. However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins.
Instances of derived classes are also instances of the base class.
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
Why classes?The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.
Classes introduce a paradigm, or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism). However, many people are philosophically against certain OOP practices and don't use classes as a result.
For example, one thing that makes Date objects infamous is that they're mutable.
jsfunction incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.
In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.



However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.
On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the Color class, we may need to create a dozen of utility functions:
jsfunction isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// ...

But with classes, we can congregate them all under the Color namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.
In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

The Map and Set classes store a collection of elements and allow you to access them by key using get(), set(), has(), etc.
The Date class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.
The Error class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like TypeError and ReferenceError that extend Error. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with instanceof.

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.
« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Using promises
« Previous
Next  »

A Promise is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them.
Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, createAudioFileAsync(), which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs.
Here's some code that uses createAudioFileAsync():
jsfunction successCallback(result) {
  console.log(`Audio file ready at URL: ${result}`);
}

function failureCallback(error) {
  console.error(`Error generating audio file: ${error}`);
}

createAudioFileAsync(audioSettings, successCallback, failureCallback);

If createAudioFileAsync() were rewritten to return a promise, you would attach your callbacks to it instead:
jscreateAudioFileAsync(audioSettings).then(successCallback, failureCallback);

This convention has several advantages. We will explore each one.ChainingA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback pyramid of doom:
jsdoSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doThirdThing(newResult, function (finalResult) {
      console.log(`Got the final result: ${finalResult}`);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);

With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function.
Here's the magic: the then() function returns a new promise, different from the original:
jsconst promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);

This second promise (promise2) represents the completion not just of doSomething(), but also of the successCallback or failureCallback you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to promise2 get queued behind the promise returned by either successCallback or failureCallback.

Note: If you want a working example to play with, you can use the following template to create any function returning a promise:
jsfunction doSomething() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Other things to do before completion of the promise
      console.log("Did something");
      // The fulfillment value of the promise
      resolve("https://example.com/");
    }, 200);
  });
}

The implementation is discussed in the Creating a Promise around an old callback API section below.

With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to then are optional, and catch(failureCallback) is short for then(null, failureCallback) — so if your error handling code is the same for all steps, you can attach it to the end of the chain:
jsdoSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);

You might see this expressed with arrow functions instead:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);


Note: Arrow function expressions can have an implicit return; so, () => x is short for () => { return x; }.

doSomethingElse and doThirdThing can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from then callbacks, even if the promise always resolves to undefined. If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be "floating".
jsdoSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url);
  })
  .then((result) => {
    // result is undefined, because nothing is returned from the previous
    // handler. There's no way to know the return value of the fetch()
    // call anymore, or whether it succeeded at all.
  });

By returning the result of the fetch call (which is a promise), we can both track its completion and receive its value when it completes.
jsdoSomething()
  .then((url) => {
    // `return` keyword added
    return fetch(url);
  })
  .then((result) => {
    // result is a Response object
  });

Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next then handler will be called early, and any value it reads may be incomplete.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will always be [], because the fetch request hasn't completed yet.
  });

Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next then handler.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // `return` keyword now included in front of fetch call.
    return fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will now contain data from fetch call.
  });

Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below.
jsdoSomething()
  .then((url) => fetch(url))
  .then((res) => res.json())
  .then((data) => {
    listOfIngredients.push(data);
  })
  .then(() => {
    console.log(listOfIngredients);
  });

Using async/await can help you write code that's more intuitive and resembles synchronous code. Below is the same example using async/await:
jsasync function logIngredients() {
  const url = await doSomething();
  const res = await fetch(url);
  const data = await res.json();
  listOfIngredients.push(data);
  console.log(listOfIngredients);
}

Note how the code looks exactly like synchronous code, except for the await keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the await keyword, which can only be fixed when there's a type mismatch (e.g. trying to use a promise as a value).
async/await builds on promises — for example, doSomething() is the same function as before, so there's minimal refactoring needed to change from promises to async/await. You can read more about the async/await syntax in the async functions and await references.

Note: async/await has the same concurrency semantics as normal promise chains. await within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the await is pending.
Error handlingYou might recall seeing failureCallback three times in the pyramid of doom earlier, compared to only once at the end of the promise chain:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => console.log(`Got the final result: ${finalResult}`))
  .catch(failureCallback);

If there's an exception, the browser will look down the chain for .catch() handlers or onRejected. This is very much modeled after how synchronous code works:
jstry {
  const result = syncDoSomething();
  const newResult = syncDoSomethingElse(result);
  const finalResult = syncDoThirdThing(newResult);
  console.log(`Got the final result: ${finalResult}`);
} catch (error) {
  failureCallback(error);
}

This symmetry with asynchronous code culminates in the async/await syntax:
jsasync function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch (error) {
    failureCallback(error);
  }
}

Promises solve a fundamental flaw with the callback pyramid of doom, by catching all errors, even thrown exceptions and programming errors. This is essential for functional composition of asynchronous operations. All errors are now handled by the catch() method at the end of the chain, and you should almost never need to use try/catch without using async/await.NestingIn the examples above involving listOfIngredients, the first one has one promise chain nested in the return value of another then() handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition.
Nesting is a control structure to limit the scope of catch statements. Specifically, a nested catch only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery:
jsdoSomethingCritical()
  .then((result) =>
    doSomethingOptional(result)
      .then((optionalResult) => doSomethingExtraNice(optionalResult))
      .catch((e) => {}),
  ) // Ignore if optional stuff fails; proceed.
  .then(() => moreCriticalStuff())
  .catch((e) => console.error(`Critical failure: ${e.message}`));

Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer ( and ) parentheses around the steps.
The inner error-silencing catch handler only catches failures from doSomethingOptional() and doSomethingExtraNice(), after which the code resumes with moreCriticalStuff(). Importantly, if doSomethingCritical() fails, its error is caught by the final (outer) catch only, and does not get swallowed by the inner catch handler.
In async/await, this code looks like:
jsasync function main() {
  try {
    const result = await doSomethingCritical();
    try {
      const optionalResult = await doSomethingOptional(result);
      await doSomethingExtraNice(optionalResult);
    } catch (e) {
      // Ignore failures in optional steps and proceed.
    }
    await moreCriticalStuff();
  } catch (e) {
    console.error(`Critical failure: ${e.message}`);
  }
}


Note: If you don't have sophisticated error handling, you very likely don't need nested then handlers. Instead, use a flat chain and put the error handling logic at the end.
Chaining after a catchIt's possible to chain after a failure, i.e. a catch, which is useful to accomplish new actions even after an action failed in the chain. Read the following example:
jsdoSomething()
  .then(() => {
    throw new Error("Something failed");

    console.log("Do this");
  })
  .catch(() => {
    console.error("Do that");
  })
  .then(() => {
    console.log("Do this, no matter what happened before");
  });

This will output the following text:
Initial
Do that
Do this, no matter what happened before


Note: The text "Do this" is not displayed because the "Something failed" error caused a rejection.

In async/await, this code looks like:
jsasync function main() {
  try {
    await doSomething();
    throw new Error("Something failed");
    console.log("Do this");
  } catch (e) {
    console.error("Do that");
  }
  console.log("Do this, no matter what happened before");
}
Promise rejection eventsIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the window or, if being used in a web worker, it's the Worker or other worker-based interface). The two events are:

unhandledrejection

Sent when a promise is rejected but there is no rejection handler available.

rejectionhandled

Sent when a handler is attached to a rejected promise that has already caused an unhandledrejection event.


In both cases, the event (of type PromiseRejectionEvent) has as members a promise property indicating the promise that was rejected, and a reason property that provides the reason given for the promise to be rejected.
These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source.
In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js unhandledRejection event (notice the difference in capitalization of the name), like this:
jsprocess.on("unhandledRejection", (reason, promise) => {
  // Add code here to examine the "promise" and "reason" values
});

For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that process.on() listener is all that's necessary; there's no need for an equivalent of the browser runtime's preventDefault() method.
However, if you add that process.on listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.CompositionThere are four composition tools for running asynchronous operations concurrently: Promise.all(), Promise.allSettled(), Promise.any(), and Promise.race().
We can start operations at the same time and wait for them all to finish like this:
jsPromise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {
  // use result1, result2 and result3
});

If one of the promises in the array rejects, Promise.all() immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. Promise.allSettled() is another composition tool that ensures all operations are complete before resolving.
These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript:
js[func1, func2, func3]
  .reduce((p, f) => p.then(f), Promise.resolve())
  .then((result3) => {
    /* use result3 */
  });

In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to:
jsPromise.resolve()
  .then(func1)
  .then(func2)
  .then(func3)
  .then((result3) => {
    /* use result3 */
  });

This can be made into a reusable compose function, which is common in functional programming:
jsconst applyAsync = (acc, val) => acc.then(val);
const composeAsync =
  (...funcs) =>
  (x) =>
    funcs.reduce(applyAsync, Promise.resolve(x));

The composeAsync() function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline:
jsconst transformData = composeAsync(func1, func2, func3);
const result3 = transformData(data);

Sequential composition can also be done more succinctly with async/await:
jslet result;
for (const f of [func1, func2, func3]) {
  result = await f(result);
}
/* use last result (i.e. result3) */

However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.Creating a Promise around an old callback APIA Promise can be created from scratch using its constructor. This should be needed only to wrap old APIs.
In an ideal world, all asynchronous functions would already return promises. Unfortunately, some APIs still expect success and/or failure callbacks to be passed in the old way. The most obvious example is the setTimeout() function:
jssetTimeout(() => saySomething("10 seconds passed"), 10 * 1000);

Mixing old-style callbacks and promises is problematic. If saySomething() fails or contains a programming error, nothing catches it. This is intrinsic to the design of setTimeout.
Luckily we can wrap setTimeout in a promise. The best practice is to wrap the callback-accepting functions at the lowest possible level, and then never call them directly again:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(10 * 1000)
  .then(() => saySomething("10 seconds"))
  .catch(failureCallback);

The promise constructor takes an executor function that lets us resolve or reject a promise manually. Since setTimeout() doesn't really fail, we left out reject in this case. For more information on how the executor function works, see the Promise() reference.TimingLastly, we will look into the more technical details, about when the registered callbacks get called.GuaranteesIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously:
jsfunction doSomething(callback) {
  if (Math.random() > 0.5) {
    callback();
  } else {
    setTimeout(() => callback(), 1000);
  }
}

The above design is strongly discouraged because it leads to the so-called "state of Zalgo". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze:
jslet value = 1;
doSomething(() => {
  value = 2;
});
console.log(value); // 1 or 2?

On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:

Callbacks added with then() will never be invoked before the completion of the current run of the JavaScript event loop.
These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.
Multiple callbacks may be added by calling then() several times. They will be invoked one after another, in the order in which they were inserted.

To avoid surprises, functions passed to then() will never be called synchronously, even with an already-resolved promise:
jsPromise.resolve().then(() => console.log(2));
console.log(1);
// Logs: 1, 2

Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e. pretty soon:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(0).then(() => console.log(4));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
console.log(1); // 1, 2, 3, 4
Task queues vs. microtasksPromise callbacks are handled as a microtask whereas setTimeout() callbacks are handled as task queues.
jsconst promise = new Promise((resolve, reject) => {
  console.log("Promise callback");
  resolve();
}).then((result) => {
  console.log("Promise callback (.then)");
});

setTimeout(() => {
  console.log("event-loop cycle: Promise (fulfilled)", promise);
}, 0);

console.log("Promise (pending)", promise);

The code above will output:
Promise callback
Promise (pending) Promise {<pending>}
Promise callback (.then)
event-loop cycle: Promise (fulfilled) Promise {<fulfilled>}

For more details, refer to Tasks vs. microtasks.When promises and tasks collideIf you run into situations in which you have promises and tasks (such as events or callbacks) which are firing in unpredictable orders, it's possible you may benefit from using a microtask to check status or balance out your promises when promises are created conditionally.
If you think microtasks may help solve this problem, see the microtask guide to learn more about how to use queueMicrotask() to enqueue a function as a microtask.See also
Promise
async function
await
Promises/A+ specification
We have a problem with promises on pouchdb.com (2015)

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 25, 2023 by MDN contributors.
JavaScript typed arrays
« Previous
Next  »

JavaScript typed arrays are array-like objects that provide a mechanism for reading and writing raw binary data in memory buffers.
Typed arrays are not intended to replace arrays for any kind of functionality. Instead, they provide developers with a familiar interface for manipulating binary data. This is useful when interacting with platform features, such as audio and video manipulation, access to raw data using WebSockets, and so forth. Each entry in a JavaScript typed array is a raw binary value in one of a number of supported formats, from 8-bit integers to 64-bit floating-point numbers.
Typed array objects share many of the same methods as arrays with similar semantics. However, typed arrays are not to be confused with normal arrays, as calling Array.isArray() on a typed array returns false. Moreover, not all methods available for normal arrays are supported by typed arrays (e.g. push and pop).
To achieve maximum flexibility and efficiency, JavaScript typed arrays split the implementation into buffers and views. A buffer is an object representing a chunk of data; it has no format to speak of, and offers no mechanism for accessing its contents. In order to access the memory contained in a buffer, you need to use a view. A view provides a context — that is, a data type, starting offset, and number of elements.


BuffersThere are two types of buffers: ArrayBuffer and SharedArrayBuffer. Both are low-level representations of a memory span. They have "array" in their names, but they don't have much to do with arrays — you cannot read or write to them directly. Instead, buffers are generic objects that just contain raw data. In order to access the memory represented by a buffer, you need to use a view.
Buffers support the following actions:

Allocate: As soon as a new buffer is created, a new memory span is allocated and initialized to 0.
Copy: Using the slice() method, you can efficiently copy a portion of the memory without creating views to manually copy each byte.
Transfer: Using the transfer() and transferToFixedLength() methods, you can transfer ownership of the memory span to a new buffer object. This is useful when transferring data between different execution contexts without copying. After the transfer, the original buffer is no longer usable. A SharedArrayBuffer cannot be transferred (as the buffer is already shared by all execution contexts).
Resize: Using the resize() method, you can resize the memory span (either claim more memory space, as long as it doesn't pass the pre-set maxByteLength limit, or release some memory space). SharedArrayBuffer can only be grown but not shrunk.

The difference between ArrayBuffer and SharedArrayBuffer is that the former is always owned by a single execution context at a time. If you pass an ArrayBuffer to a different execution context, it is transferred and the original ArrayBuffer becomes unusable. This ensures that only one execution context can access the memory at a time. A SharedArrayBuffer is not transferred when passed to a different execution context, so it can be accessed by multiple execution contexts at the same time. This may introduce race conditions when multiple threads access the same memory span, so operations such as Atomics methods become useful.ViewsThere are currently two main kinds of views: typed array views and DataView. Typed arrays provide utility methods that allow you to conveniently transform binary data. DataView is more low-level and allows granular control of how data is accessed. The ways to read and write data using the two views are very different.
Both kinds of views cause ArrayBuffer.isView() to return true. They both have the following properties:

buffer

The underlying buffer that the view references.

byteOffset

The offset, in bytes, of the view from the start of its buffer.

byteLength

The length, in bytes, of the view.


Both constructors accept the above three as separate arguments, although typed array constructors accept length as the number of elements rather than the number of bytes.Typed array viewsTyped array views have self-descriptive names and provide views for all the usual numeric types like Int8, Uint32, Float64 and so forth. There is one special typed array view, Uint8ClampedArray, which clamps the values between 0 and 255. This is useful for Canvas data processing, for example.



Type
Value Range
Size in bytes
Web IDL type




Int8Array
-128 to 127
1
byte


Uint8Array
0 to 255
1
octet


Uint8ClampedArray
0 to 255
1
octet


Int16Array
-32768 to 32767
2
short


Uint16Array
0 to 65535
2
unsigned short


Int32Array
-2147483648 to 2147483647
4
long


Uint32Array
0 to 4294967295
4
unsigned long


Float32Array
-3.4e38 to 3.4e38
4
unrestricted float


Float64Array
-1.8e308 to 1.8e308
8
unrestricted double


BigInt64Array
-263 to 263 - 1
8
bigint


BigUint64Array
0 to 264 - 1
8
bigint



All typed array views have the same methods and properties, as defined by the TypedArray class. They only differ in the underlying data type and the size in bytes. This is discussed in more detail in Value encoding and normalization.
Typed arrays are, in principle, fixed-length, so array methods that may change the length of an array are not available. This includes pop, push, shift, splice, and unshift. In addition, flat is unavailable because there are no nested typed arrays, and related methods including concat and flatMap do not have great use cases so are unavailable. As splice is unavailable, so too is toSpliced. All other array methods are shared between Array and TypedArray.
On the other hand, TypedArray has the extra set and subarray methods that optimize working with multiple typed arrays that view the same buffer. The set() method allows setting multiple typed array indices at once, using data from another array or typed array. If the two typed arrays share the same underlying buffer, the operation may be more efficient as it's a fast memory move. The subarray() method creates a new typed array view that references the same buffer as the original typed array, but with a narrower span.
There's no way to directly change the length of a typed array without changing the underlying buffer. However, when the typed array views a resizable buffer and does not have a fixed byteLength, it is length-tracking, and will automatically resize to fit the underlying buffer as the resizable buffer is resized. See Behavior when viewing a resizable buffer for details.
Similar to regular arrays, you can access typed array elements using bracket notation. The corresponding bytes in the underlying buffer are retrieved and interpreted as a number. Any property access using a number (or the string representation of a number, since numbers are always converted to strings when accessing properties) will be proxied by the typed array — they never interact with the object itself. This means, for example:

Out-of-bounds index access always returns undefined, without actually accessing the property on the object.
Any attempt to write to such an out-of-bounds property has no effect: it does not throw an error but doesn't change the buffer or typed array either.
Typed array indices appear to be configurable and writable, but any attempt to change their attributes will fail.

jsconst uint8 = new Uint8Array([1, 2, 3]);
console.log(uint8[0]); // 1

// For illustrative purposes only. Not for production code.
uint8[-1] = 0;
uint8[2.5] = 0;
uint8[NaN] = 0;
console.log(Object.keys(uint8)); // ["0", "1", "2"]
console.log(uint8[NaN]); // undefined

// Non-numeric access still works
uint8[true] = 0;
console.log(uint8[true]); // 0

Object.freeze(uint8); // TypeError: Cannot freeze array buffer views with elements
DataViewThe DataView is a low-level interface that provides a getter/setter API to read and write arbitrary data to the buffer. This is useful when dealing with different types of data, for example. Typed array views are in the native byte-order (see Endianness) of your platform. With a DataView, the byte-order can be controlled. By default, it's big-endian—the bytes are ordered from most significant to least significant. This can be reversed, with the bytes ordered from least significant to most significant (little-endian), using getter/setter methods.
DataView does not require alignment; multi-byte read and write can be started at any specified offset. The setter methods work the same way.
The following example uses a DataView to get the binary representation of any number:
jsfunction toBinary(
  x,
  { type = "Float64", littleEndian = false, separator = " ", radix = 16 } = {},
) {
  const bytesNeeded = globalThis[`${type}Array`].BYTES_PER_ELEMENT;
  const dv = new DataView(new ArrayBuffer(bytesNeeded));
  dv[`set${type}`](0, x, littleEndian);
  const bytes = Array.from({ length: bytesNeeded }, (_, i) =>
    dv
      .getUint8(i)
      .toString(radix)
      .padStart(8 / Math.log2(radix), "0"),
  );
  return bytes.join(separator);
}

console.log(toBinary(1.1)); // 3f f1 99 99 99 99 99 9a
console.log(toBinary(1.1, { littleEndian: true })); // 9a 99 99 99 99 99 f1 3f
console.log(toBinary(20, { type: "Int8", radix: 2 })); // 00010100
Web APIs using typed arraysThese are some examples of APIs that make use of typed arrays; there are others, and more are being added all the time.

FileReader.prototype.readAsArrayBuffer()

The FileReader.prototype.readAsArrayBuffer() method starts reading the contents of the specified Blob or File.

fetch()

The body option to fetch() can be a typed array or ArrayBuffer, enabling you to send these objects as the payload of a POST request.

ImageData.data

Is a Uint8ClampedArray representing a one-dimensional array containing the data in the RGBA order, with integer values between 0 and 255 inclusive.

ExamplesUsing views with buffersFirst of all, we will need to create a buffer, here with a fixed length of 16-bytes:
jsconst buffer = new ArrayBuffer(16);

At this point, we have a chunk of memory whose bytes are all pre-initialized to 0. There's not a lot we can do with it, though. For example, we can confirm that the buffer is the right size:
jsif (buffer.byteLength === 16) {
  console.log("Yes, it's 16 bytes.");
} else {
  console.log("Oh no, it's the wrong size!");
}

Before we can really work with this buffer, we need to create a view. Let's create a view that treats the data in the buffer as an array of 32-bit signed integers:
jsconst int32View = new Int32Array(buffer);

Now we can access the fields in the array just like a normal array:
jsfor (let i = 0; i < int32View.length; i++) {
  int32View[i] = i * 2;
}

This fills out the 4 entries in the array (4 entries at 4 bytes each makes 16 total bytes) with the values 0, 2, 4, and 6.Multiple views on the same dataThings start to get really interesting when you consider that you can create multiple views onto the same data. For example, given the code above, we can continue like this:
jsconst int16View = new Int16Array(buffer);

for (let i = 0; i < int16View.length; i++) {
  console.log(`Entry ${i}: ${int16View[i]}`);
}

Here we create a 16-bit integer view that shares the same buffer as the existing 32-bit view and we output all the values in the buffer as 16-bit integers. Now we get the output 0, 0, 2, 0, 4, 0, 6, 0 (assuming little-endian encoding):
Int16Array  |   0  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |      0      |      2      |      4      |      6      |
ArrayBuffer | 00 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can go a step farther, though. Consider this:
jsint16View[0] = 32;
console.log(`Entry 0 in the 32-bit array is now ${int32View[0]}`);

The output from this is "Entry 0 in the 32-bit array is now 32".
In other words, the two arrays are indeed viewed on the same data buffer, treating it as different formats.
Int16Array  |  32  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |     32      |      2      |      4      |      6      |
ArrayBuffer | 00 02 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can do this with any view type, although if you set an integer and then read it as a floating-point number, you will probably get a strange result because the bits are interpreted differently.
jsconst float32View = new Float32Array(buffer);
console.log(float32View[0]); // 4.484155085839415e-44
Reading text from a bufferBuffers don't always represent numbers. For example, reading a file can give you a text data buffer. You can read this data out of the buffer using a typed array.
The following reads UTF-8 text using the TextDecoder web API:
jsconst buffer = new ArrayBuffer(8);
const uint8 = new Uint8Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint8.set([228, 189, 160, 229, 165, 189]);
const text = new TextDecoder().decode(uint8);
console.log(text); // "你好"

The following reads UTF-16 text using the String.fromCharCode() method:
jsconst buffer = new ArrayBuffer(8);
const uint16 = new Uint16Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint16.set([0x4f60, 0x597d]);
const text = String.fromCharCode(...uint16);
console.log(text); // "你好"
Working with complex data structuresBy combining a single buffer with multiple views of different types, starting at different offsets into the buffer, you can interact with data objects containing multiple data types. This lets you, for example, interact with complex data structures from WebGL or data files.
Consider this C structure:
cppstruct someStruct {
  unsigned long id;
  char username[16];
  float amountDue;
};

You can access a buffer containing data in this format like this:
jsconst buffer = new ArrayBuffer(24);

// ... read the data into the buffer ...

const idView = new Uint32Array(buffer, 0, 1);
const usernameView = new Uint8Array(buffer, 4, 16);
const amountDueView = new Float32Array(buffer, 20, 1);

Then you can access, for example, the amount due with amountDueView[0].

Note: The data structure alignment in a C structure is platform-dependent. Take precautions and considerations for these padding differences.
Conversion to normal arraysAfter processing a typed array, it is sometimes useful to convert it back to a normal array in order to benefit from the Array prototype. This can be done using Array.from():
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = Array.from(typedArray);

as well as the spread syntax:
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = [...typedArray];
See also
Faster Canvas Pixel Manipulation with Typed Arrays on hacks.mozilla.org (2011)
Typed arrays - Binary data in the browser on web.dev (2012)
Endianness
ArrayBuffer
DataView
TypedArray
SharedArrayBuffer

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 20, 2023 by MDN contributors.
Iterators and generators
« Previous
Next  »

Iterators and Generators bring the concept of iteration directly into the core language and provide a mechanism for customizing the behavior of for...of loops.
For details, see also:

Iteration protocols
for...of
function* and Generator
yield and yield*
IteratorsIn JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination.
Specifically, an iterator is any object which implements the Iterator protocol by having a next() method that returns an object with two properties:

value

The next value in the iteration sequence.

done

This is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.


Once created, an iterator object can be iterated explicitly by repeatedly calling next(). Iterating over an iterator is said to consume the iterator, because it is generally only possible to do once. After a terminating value has been yielded additional calls to next() should continue to return {done: true}.
The most common iterator in JavaScript is the Array iterator, which returns each value in the associated array in sequence.
While it is easy to imagine that all iterators could be expressed as arrays, this is not true. Arrays must be allocated in their entirety, but iterators are consumed only as necessary. Because of this, iterators can express sequences of unlimited size, such as the range of integers between 0 and Infinity.
Here is an example which can do just that. It allows creation of a simple range iterator which defines a sequence of integers from start (inclusive) to end (exclusive) spaced step apart. Its final return value is the size of the sequence it created, tracked by the variable iterationCount.
jsfunction makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let nextIndex = start;
  let iterationCount = 0;

  const rangeIterator = {
    next() {
      let result;
      if (nextIndex < end) {
        result = { value: nextIndex, done: false };
        nextIndex += step;
        iterationCount++;
        return result;
      }
      return { value: iterationCount, done: true };
    },
  };
  return rangeIterator;
}

Using the iterator then looks like this:
jsconst iter = makeRangeIterator(1, 10, 2);

let result = iter.next();
while (!result.done) {
  console.log(result.value); // 1 3 5 7 9
  result = iter.next();
}

console.log("Iterated over sequence of size:", result.value); // [5 numbers returned, that took interval in between: 0 to 10]


Note: It is not possible to know reflectively whether a particular object is an iterator. If you need to do this, use Iterables.
Generator functionsWhile custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous. Generator functions are written using the function* syntax.
When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.
The function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.
We can now adapt the example from above. The behavior of this code is identical, but the implementation is much easier to write and read.
jsfunction* makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let iterationCount = 0;
  for (let i = start; i < end; i += step) {
    iterationCount++;
    yield i;
  }
  return iterationCount;
}
IterablesAn object is iterable if it defines its iteration behavior, such as what values are looped over in a for...of construct. Some built-in types, such as Array or Map, have a default iteration behavior, while other types (such as Object) do not.
In order to be iterable, an object must implement the @@iterator method. This means that the object (or one of the objects up its prototype chain) must have a property with a Symbol.iterator key.
It may be possible to iterate over an iterable more than once, or only once. It is up to the programmer to know which is the case.
Iterables which can iterate only once (such as Generators) customarily return this from their @@iterator method, whereas iterables which can be iterated many times must return a new iterator on each invocation of @@iterator.
jsfunction* makeIterator() {
  yield 1;
  yield 2;
}

const iter = makeIterator();

for (const itItem of iter) {
  console.log(itItem);
}

console.log(iter[Symbol.iterator]() === iter); // true

// This example show us generator(iterator) is iterable object,
// which has the @@iterator method return the `iter` (itself),
// and consequently, the it object can iterate only _once_.

// If we change the @@iterator method of `iter` to a function/generator
// which returns a new iterator/generator object, `iter`
// can iterate many times

iter[Symbol.iterator] = function* () {
  yield 2;
  yield 1;
};
User-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

User-defined iterables can be used in for...of loops or the spread syntax as usual.
jsfor (const value of myIterable) {
  console.log(value);
}
// 1
// 2
// 3

[...myIterable]; // [1, 2, 3]
Built-in iterablesString, Array, TypedArray, Map and Set are all built-in iterables, because their prototype objects all have a Symbol.iterator method.Syntaxes expecting iterablesSome statements and expressions expect iterables. For example: the for...of loops, spread syntax, yield*, and destructuring syntax.
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

[..."abc"];
// ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

gen().next();
// { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
a;
// "a"
Advanced generatorsGenerators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute (or even infinite sequences, as demonstrated above).
The next() method also accepts a value, which can be used to modify the internal state of the generator. A value passed to next() will be received by yield .

Note: A value passed to the first invocation of next() is always ignored.

Here is the fibonacci generator using next(x) to restart the sequence:
jsfunction* fibonacci() {
  let current = 0;
  let next = 1;
  while (true) {
    const reset = yield current;
    [current, next] = [next, next + current];
    if (reset) {
      current = 0;
      next = 1;
    }
  }
}

const sequence = fibonacci();
console.log(sequence.next().value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
console.log(sequence.next().value); // 3
console.log(sequence.next().value); // 5
console.log(sequence.next().value); // 8
console.log(sequence.next(true).value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2

You can force a generator to throw an exception by calling its throw() method and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the yield that is currently suspended were instead a throw value statement.
If the exception is not caught from within the generator, it will propagate up through the call to throw(), and subsequent calls to next() will result in the done property being true.
Generators have a return() method that returns the given value and finishes the generator itself.
« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 28, 2023 by MDN contributors.
Meta programming
« Previous
Next  »

The Proxy and Reflect objects allow you to intercept and define custom behavior for fundamental language operations (e.g. property lookup, assignment, enumeration, function invocation, etc.). With the help of these two objects you are able to program at the meta level of JavaScript.ProxiesProxy objects allow you to intercept certain operations and to implement custom behaviors.
For example, getting a property on an object:
jsconst handler = {
  get(target, name) {
    return name in target ? target[name] : 42;
  },
};

const p = new Proxy({}, handler);
p.a = 1;
console.log(p.a, p.b); // 1, 42

The Proxy object defines a target (an empty object here) and a handler object, in which a get trap is implemented. Here, an object that is proxied will not return undefined when getting undefined properties, but will instead return the number 42.
Additional examples are available on the Proxy reference page.TerminologyThe following terms are used when talking about the functionality of proxies.

handler

Placeholder object which contains traps.

traps

The methods that provide property access. (This is analogous to the concept of traps in operating systems.)

target

Object which the proxy virtualizes. It is often used as storage backend for the proxy. Invariants (semantics that remain unchanged) regarding object non-extensibility or non-configurable properties are verified against the target.

invariants

Semantics that remain unchanged when implementing custom operations are called invariants. If you violate the invariants of a handler, a TypeError will be thrown.

Handlers and trapsThe following table summarizes the available traps available to Proxy objects. See the reference pages for detailed explanations and examples.



Handler / trap
Interceptions
Invariants




handler.getPrototypeOf()
Object.getPrototypeOf()Reflect.getPrototypeOf()__proto__Object.prototype.isPrototypeOf()instanceof



getPrototypeOf method must return an object or
            null.
          

            If target is not extensible,
            Object.getPrototypeOf(proxy) method must
            return the same value as
            Object.getPrototypeOf(target).
          




handler.setPrototypeOf()
Object.setPrototypeOf()Reflect.setPrototypeOf()

        If target is not extensible, the
        prototype parameter must be the same value as
        Object.getPrototypeOf(target).
      


handler.isExtensible()
Object.isExtensible()Reflect.isExtensible()

Object.isExtensible(proxy) must return the same
        value as Object.isExtensible(target).
      


handler.preventExtensions()
Object.preventExtensions()Reflect.preventExtensions()

Object.preventExtensions(proxy) only returns
        true if
        Object.isExtensible(proxy) is
        false.
      


handler.getOwnPropertyDescriptor()
Object.getOwnPropertyDescriptor()Reflect.getOwnPropertyDescriptor()



getOwnPropertyDescriptor must return an object or
            undefined.
          

            A property cannot be reported as non-existent if it exists as a
            non-configurable own property of target.
          

            A property cannot be reported as non-existent if it exists as an own
            property of target and
            target is not extensible.
          

            A property cannot be reported as existent if it does not exists as
            an own property of target and
            target is not extensible.
          

            A property cannot be reported as non-configurable if it does not
            exist as an own property of target or if it
            exists as a configurable own property of
            target.
          

            The result of
            Object.getOwnPropertyDescriptor(target) can
            be applied to target using
            Object.defineProperty and will not throw an exception.
          




handler.defineProperty()
Object.defineProperty()Reflect.defineProperty()


A property cannot be added if target is not extensible.

            A property cannot be added as (or modified to be)
            non-configurable if it does not exist as a non-configurable own
            property of target.
          

            A property may not be non-configurable if a corresponding
            configurable property of target exists.
          

            If a property has a corresponding target object property, then
            Object.defineProperty(target, prop,
descriptor)
            will not throw an exception.
          

            In strict mode, a false value returned from the
            defineProperty handler will throw a
            TypeError exception.
          




handler.has()


Property query
foo in proxy
Inherited property query
foo in Object.create(proxy)Reflect.has()





            A property cannot be reported as non-existent, if it exists as a
            non-configurable own property of target.
          

            A property cannot be reported as non-existent if it exists as an own
            property of target and
            target is not extensible.
          




handler.get()


Property access
proxy[foo]proxy.bar
Inherited property access
Object.create(proxy)[foo]Reflect.get()





            The value reported for a property must be the same as the value of
            the corresponding target property if
            target's property is a non-writable, non-configurable data property.
          

            The value reported for a property must be undefined if
            the corresponding target property is
            non-configurable accessor property that has undefined as its
            [[Get]] attribute.
          




handler.set()


Property assignment
proxy[foo] = barproxy.foo = bar
Inherited property assignment
Object.create(proxy)[foo] = barReflect.set()





            Cannot change the value of a property to be different from the value
            of the corresponding target property if the
            corresponding target property is a
            non-writable, non-configurable data property.
          

            Cannot set the value of a property if the corresponding
            target property is a non-configurable
            accessor property that has undefined as its
            [[Set]] attribute.
          

            In strict mode, a false return value from the
            set handler will throw a
            TypeError exception.
          




handler.deleteProperty()


Property deletion
delete proxy[foo]delete proxy.fooReflect.deleteProperty()



        A property cannot be deleted if it exists as a non-configurable own
        property of target.
      


handler.ownKeys()
Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.keys()Reflect.ownKeys()


The result of ownKeys is a List.

            The Type of each result List element is either
            String or Symbol.
          

            The result List must contain the keys of all non-configurable own
            properties of target.
          

            If the target object is not extensible, then
            the result List must contain all the keys of the own properties of
            target and no other values.
          




handler.apply()

proxy(..args)Function.prototype.apply() and
        Function.prototype.call()Reflect.apply()


        There are no invariants for the
        handler.apply method.
      


handler.construct()
new proxy(...args)Reflect.construct()
The result must be an Object.


Revocable ProxyThe Proxy.revocable() method is used to create a revocable Proxy object. This means that the proxy can be revoked via the function revoke and switches the proxy off.
Afterwards, any operation on the proxy leads to a TypeError.
jsconst revocable = Proxy.revocable(
  {},
  {
    get(target, name) {
      return `[[${name}]]`;
    },
  },
);
const proxy = revocable.proxy;
console.log(proxy.foo); // "[[foo]]"

revocable.revoke();

console.log(proxy.foo); // TypeError: Cannot perform 'get' on a proxy that has been revoked
proxy.foo = 1; // TypeError: Cannot perform 'set' on a proxy that has been revoked
delete proxy.foo; // TypeError: Cannot perform 'deleteProperty' on a proxy that has been revoked
console.log(typeof proxy); // "object", typeof doesn't trigger any trap
ReflectionReflect is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of the proxy handler's.
Reflect is not a function object.
Reflect helps with forwarding default operations from the handler to the target.
With Reflect.has() for example, you get the in operator as a function:
jsReflect.has(Object, "assign"); // true
A better apply() functionBefore Reflect, you typically use the Function.prototype.apply() method to call a function with a given this value and arguments provided as an array (or an array-like object).
jsFunction.prototype.apply.call(Math.floor, undefined, [1.75]);

With Reflect.apply this becomes less verbose and easier to understand:
jsReflect.apply(Math.floor, undefined, [1.75]);
// 1

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]);
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ["confabulation"]).index;
// 4

Reflect.apply("".charAt, "ponies", [3]);
// "i"
Checking if property definition has been successfulWith Object.defineProperty, which returns an object if successful, or throws a TypeError otherwise, you would use a try...catch block to catch any error that occurred while defining a property. Because Reflect.defineProperty() returns a Boolean success status, you can just use an if...else block here:
jsif (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}

« Previous
Next  »
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
JavaScript modules
« Previous

This guide gives you all you need to get started with JavaScript module syntax.A background on modulesJavaScript programs started off pretty small — most of its usage in the early days was to do isolated scripting tasks, providing a bit of interactivity to your web pages where needed, so large scripts were generally not needed. Fast forward a few years and we now have complete applications being run in browsers with a lot of JavaScript, as well as JavaScript being used in other contexts (Node.js, for example).
It has therefore made sense in recent years to start thinking about providing mechanisms for splitting JavaScript programs up into separate modules that can be imported when needed. Node.js has had this ability for a long time, and there are a number of JavaScript libraries and frameworks that enable module usage (for example, other CommonJS and AMD-based module systems like RequireJS, and more recently Webpack and Babel).
The good news is that modern browsers have started to support module functionality natively, and this is what this article is all about. This can only be a good thing — browsers can optimize loading of modules, making it more efficient than having to use a library and do all of that extra client-side processing and extra round trips.
Use of native JavaScript modules is dependent on the import and export statements; these are supported in browsers as shown in the compatibility table below.Browser compatibilityjavascript.statements.importBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.javascript.statements.exportBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.Introducing an exampleTo demonstrate usage of modules, we've created a simple set of examples that you can find on GitHub. These examples demonstrate a simple set of modules that create a <canvas> element on a webpage, and then draw (and report information about) different shapes on the canvas.
These are fairly trivial, but have been kept deliberately simple to demonstrate modules clearly.

Note: If you want to download the examples and run them locally, you'll need to run them through a local web server.
Basic example structureIn our first example (see basic-modules) we have a file structure as follows:
index.html
main.js
modules/
    canvas.js
    square.js


Note: All of the examples in this guide have basically the same structure; the above should start getting pretty familiar.

The modules directory's two modules are described below:

canvas.js — contains functions related to setting up the canvas:
    
create() — creates a canvas with a specified width and height inside a wrapper <div> with a specified ID, which is itself appended inside a specified parent element. Returns an object containing the canvas's 2D context and the wrapper's ID.
createReportList() — creates an unordered list appended inside a specified wrapper element, which can be used to output report data into. Returns the list's ID.


square.js — contains:
    
name — a constant containing the string 'square'.
draw() — draws a square on a specified canvas, with a specified size, position, and color. Returns an object containing the square's size, position, and color.
reportArea() — writes a square's area to a specific report list, given its length.
reportPerimeter() — writes a square's perimeter to a specific report list, given its length.


Aside — .mjs versus .jsThroughout this article, we've used .js extensions for our module files, but in other resources you may see the .mjs extension used instead. V8's documentation recommends this, for example. The reasons given are:

It is good for clarity, i.e. it makes it clear which files are modules, and which are regular JavaScript.
It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel.

However, we decided to keep using .js, at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a Content-Type header that contains a JavaScript MIME type such as text/javascript. If you don't, you'll get a strict MIME type checking error along the lines of "The server responded with a non-JavaScript MIME type" and the browser won't run your JavaScript. Most servers already set the correct type for .js files, but not yet for .mjs files. Servers that already serve .mjs files correctly include GitHub Pages and http-server for Node.js.
This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e. you can configure your server to set the correct Content-Type for .mjs files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here.
For learning and portability purposes, we decided to keep to .js.
If you really value the clarity of using .mjs for modules versus using .js for "normal" JavaScript files, but don't want to run into the problem described above, you could always use .mjs during development and convert them to .js during your build step.
It is also worth noting that:

Some tools may never support .mjs.
The <script type="module"> attribute is used to denote when a module is being pointed to, as you'll see below.
Exporting module featuresThe first thing you do to get access to module features is export them. This is done using the export statement.
The easiest way to use it is to place it in front of any items you want exported out of the module, for example:
jsexport const name = "square";

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);

  return { length, x, y, color };
}

You can export functions, var, let, const, and — as we'll see later — classes. They need to be top-level items; you can't use export inside a function, for example.
A more convenient way of exporting all the items you want to export is to use a single export statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. For example:
jsexport { name, draw, reportArea, reportPerimeter };
Importing features into your scriptOnce you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows:
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";

You use the import statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword from, followed by the module specifier.

  The module specifier provides a string that the JavaScript environment can resolve to a path to the module file.
  In a browser, this could be a path relative to the site root, which for our basic-modules example would be /js-examples/module-examples/basic-modules.
  However, here we are instead using the dot (.) syntax to mean "the current location", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable — the example will still work if you move it to a different location in the site hierarchy.

So for example:
bash/js-examples/module-examples/basic-modules/modules/square.js

becomes
bash./modules/square.js

You can see such lines in action in main.js.


Note: In some module systems, you can use a module specifier like modules/square that isn't a relative or absolute path, and that doesn't have a file extension.
    This kind of specifier can be used in a browser environment if you first define an import map.
  

Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in main.js, below the import lines:
jsconst myCanvas = create("myCanvas", document.body, 480, 320);
const reportList = createReportList(myCanvas.id);

const square1 = draw(myCanvas.ctx, 50, 50, 100, "blue");
reportArea(square1.length, reportList);
reportPerimeter(square1.length, reportList);


Note: The imported values are read-only views of the features that were exported. Similar to const variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the import reference for an example.
Importing modules using import mapsAbove we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document:
jsimport { name as squareName, draw } from "./shapes/square.js";
import { name as circleName } from "https://example.com/shapes/circle.js";

Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved.

  For example, the imports key in the import map below defines a "module specifier map" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL.
  The values must be absolute or relative URLs.
  Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map.

html<script type="importmap">
  {
    "imports": {
      "shapes": "./shapes/square.js",
      "shapes/square": "./modules/shapes/square.js",
      "https://example.com/shapes/square.js": "./shapes/square.js",
      "https://example.com/shapes/": "/shapes/square/",
      "../shapes/square": "./shapes/square.js"
    }
  }
</script>


  The import map is defined using a JSON object inside a <script> element with the type attribute set to importmap.
  There can only be one import map in the document, and because it is used to resolve which modules are loaded in both static and dynamic imports, it must be declared before any <script> elements that import modules.
  Note that the import map only applies to the document — the specification does not cover how to apply an import map in a worker or worklet context.


  With this map you can now use the property names above as module specifiers.
  If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted.
  For example, below we match bare module names, and remap a URL to another path.

js// Bare module names as module specifiers
import { name as squareNameOne } from "shapes";
import { name as squareNameTwo } from "shapes/square";

// Remap a URL to another URL
import { name as squareNameThree } from "https://example.com/shapes/square.js";


  If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a "path prefix".
  This allows remapping of whole classes of URLs.

js// Remap a URL as a prefix ( https://example.com/shapes/)
import { name as squareNameFour } from "https://example.com/shapes/moduleshapes/square.js";


  It is possible for multiple keys in an import map to be valid matches for a module specifier.
  For example, a module specifier of shapes/circle/ could match the module specifier keys shapes/ and shapes/circle/.
  In this case the browser will select the most specific (longest) matching module specifier key.


  Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions.
  While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module.
  Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site.
  This can reduce the effort required to use the same JavaScript libraries in both browser and server.

The following sections expand on the various features outlined above.Feature detectionYou can check support for import maps using the HTMLScriptElement.supports() static method (which is itself broadly supported):
jsif (HTMLScriptElement.supports?.("importmap")) {
  console.log("Browser supports import maps.");
}
Importing modules as bare names
  In some JavaScript environments, such as Node.js, you can use bare names for the module specifier.
  This works because the environment can resolve module names to a standard location in the file system.
  For example, you might use the following syntax to import the "square" module.

jsimport { name, draw, reportArea, reportPerimeter } from "square";

To use bare names on a browser you need an import map, which provides the information needed by the browser to resolve module specifiers to URLs (JavaScript will throw a TypeError if it attempts to import a module specifier that can't be resolved to a module location).
Below you can see a map that defines a square module specifier key, which in this case maps to a relative address value.
html<script type="importmap">
  {
    "imports": {
      "square": "./shapes/square.js"
    }
  }
</script>

With this map we can now use a bare name when we import the module:
jsimport { name as squareName, draw } from "square";
Remapping module paths
  Module specifier map entries, where both the specifier key and its associated value have a trailing forward slash (/), can be used as a path-prefix.
  This allows the remapping of a whole set of import URLs from one location to another.
  It can also be used to emulate working with "packages and modules", such as you might see in the Node ecosystem.



Note: The trailing / indicates that the module specifier key can be substituted as part of a module specifier.
    If this is not present, the browser will only match (and substitute) the whole module specifier key.
  

Packages of modules
The following JSON import map definition maps lodash as a bare name, and the module specifier prefix lodash/ to the path /node_modules/lodash-es/ (resolved to the document base URL):
json{
  "imports": {
    "lodash": "/node_modules/lodash-es/lodash.js",
    "lodash/": "/node_modules/lodash-es/"
  }
}

With this mapping you can import both the whole "package", using the bare name, and modules within it (using the path mapping):
jsimport _ from "lodash";
import fp from "lodash/fp.js";


  It is possible to import fp above without the .js file extension, but you would need to create a bare module specifier key for that file, such as lodash/fp, rather than using the path.
  This may be reasonable for just one module, but scales poorly if you wish to import many modules.

General URL remapping

  A module specifier key doesn't have to be path — it can also be an absolute URL (or a URL-like relative path like ./, ../, /).
  This may be useful if you want to remap a module that has absolute paths to a resource with your own local resources.

json{
  "imports": {
    "https://www.unpkg.com/moment/": "/node_modules/moment/"
  }
}
Scoped modules for version management
  Ecosystems like Node use package managers such as npm to manage modules and their dependencies.
  The package manager ensures that each module is separated from other modules and their dependencies.
  As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity.


Note: You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names.


  Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier.
  You implement this with the scopes key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import.
  The example below demonstrates this.

json{
  "imports": {
    "coolmodule": "/node_modules/coolmodule/index.js"
  },
  "scopes": {
    "/node_modules/dependency/": {
      "coolmodule": "/node_modules/some/other/location/coolmodule/index.js"
    }
  }
}


  With this mapping, if a script with an URL that contains /node_modules/dependency/ imports coolmodule, the version in /node_modules/some/other/location/coolmodule/index.js will be used.
  The map in imports is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if coolmodule is imported from a script with a non-matching scope path, then the module specifier map in imports will be used instead, mapping to the version in /node_modules/coolmodule/index.js.


  Note that the path used to select a scope does not affect how the address is resolved.
  The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map.


  Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths.
  If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier.
  The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on.
  If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the imports key.
Improve caching by mapping away hashed filenames
  Script files used by websites often have hashed filenames to simplify caching.
  The downside of this approach is that if a module changes, any modules that import it using its hashed filename will also need to be updated/regenerated.
  This potentially results in a cascade of updates, which is wasteful of network resources.


  Import maps provide a convenient solution to this problem.
  Rather than depending on specific hashed filenames, applications and scripts instead depend on an un-hashed version of the module name (address).
  An import map like the one below then provides a mapping to the actual script file.

json{
  "imports": {
    "main_script": "/node/srcs/application-fg7744e1b.js",
    "dependency_script": "/node/srcs/dependency-3qn7e4b1q.js"
  }
}


  If dependency_script changes, then its hash contained in the file name changes as well. In this case, we only need to update the import map to reflect the changed name of the module.
  We don't have to update the source of any JavaScript code that depends on it, because the specifier in the import statement does not change.
Applying the module to your HTMLNow we just need to apply the main.js module to our HTML page. This is very similar to how we apply a regular script to a page, with a few notable differences.
First of all, you need to include type="module" in the <script> element, to declare this script as a module. To import the main.js script, we use this:
html<script type="module" src="main.js"></script>

You can also embed the module's script directly into the HTML file by placing the JavaScript code within the body of the <script> element:
html<script type="module">
  /* JavaScript module code here */
</script>

The script into which you import the module features basically acts as the top-level module. If you omit it, Firefox for example gives you an error of "SyntaxError: import declarations may only appear at top level of a module".
You can only use import and export statements inside modules, not regular scripts.


Note: Modules and their dependencies can be preloaded by specifying them in <link> elements with rel="modulepreloaded".
    This can significantly reduce load time when the modules are used.
  
Other differences between modules and standard scripts
You need to pay attention to local testing — if you try to load the HTML file locally (i.e. with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server.
Also, note that you might get different behavior from sections of script defined inside modules as opposed to in standard scripts. This is because modules use strict mode automatically.
There is no need to use the defer attribute (see <script> attributes) when loading a module script; modules are deferred automatically.
Modules are only executed once, even if they have been referenced in multiple <script> tags.
Last but not least, let's make this clear — module features are imported into the scope of a single script — they aren't available in the global scope. Therefore, you will only be able to access imported features in the script they are imported into, and you won't be able to access them from the JavaScript console, for example. You'll still get syntax errors shown in the DevTools, but you'll not be able to use some of the debugging techniques you might have expected to use.

Module-defined variables are scoped to the module unless explicitly attached to the global object. On the other hand, globally-defined variables are available within the module. For example, given the following code:
html<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title></title>
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <div id="main"></div>
    <script>
      // A var statement creates a global variable.
      var text = "Hello";
    </script>
    <script type="module" src="./render.js"></script>
  </body>
</html>

js/* render.js */
document.getElementById("main").innerText = text;

The page would still render Hello, because the global variables text and document are available in the module. (Also note from this example that a module doesn't necessarily need an import/export statement — the only thing needed is for the entry point to have type="module".)Default exports versus named exportsThe functionality we've exported so far has been comprised of named exports — each item (be it a function, const, etc.) has been referred to by its name upon export, and that name has been used to refer to it on import as well.
There is also a type of export called the default export — this is designed to make it easy to have a default function provided by a module, and also helps JavaScript modules to interoperate with existing CommonJS and AMD module systems (as explained nicely in ES6 In Depth: Modules by Jason Orendorff; search for "Default exports").
Let's look at an example as we explain how it works. In our basic-modules square.js you can find a function called randomSquare() that creates a square with a random color, size, and position. We want to export this as our default, so at the bottom of the file we write this:
jsexport default randomSquare;

Note the lack of curly braces.
We could instead prepend export default onto the function and define it as an anonymous function, like this:
jsexport default function (ctx) {
  // …
}

Over in our main.js file, we import the default function using this line:
jsimport randomSquare from "./modules/square.js";

Again, note the lack of curly braces. This is because there is only one default export allowed per module, and we know that randomSquare is it. The above line is basically shorthand for:
jsimport { default as randomSquare } from "./modules/square.js";


Note: The as syntax for renaming exported items is explained below in the Renaming imports and exports section.
Avoiding naming conflictsSo far, our canvas shape drawing modules seem to be working OK. But what happens if we try to add a module that deals with drawing another shape, like a circle or triangle? These shapes would probably have associated functions like draw(), reportArea(), etc. too; if we tried to import different functions of the same name into the same top-level module file, we'd end up with conflicts and errors.
Fortunately there are a number of ways to get around this. We'll look at these in the following sections.Renaming imports and exportsInside your import and export statement's curly braces, you can use the keyword as along with a new feature name, to change the identifying name you will use for a feature inside the top-level module.
So for example, both of the following would do the same job, albeit in a slightly different way:
js// inside module.js
export { function1 as newFunctionName, function2 as anotherNewFunctionName };

// inside main.js
import { newFunctionName, anotherNewFunctionName } from "./modules/module.js";

js// inside module.js
export { function1, function2 };

// inside main.js
import {
  function1 as newFunctionName,
  function2 as anotherNewFunctionName,
} from "./modules/module.js";

Let's look at a real example. In our renaming directory you'll see the same module system as in the previous example, except that we've added circle.js and triangle.js modules to draw and report on circles and triangles.
Inside each of these modules, we've got features with the same names being exported, and therefore each has the same export statement at the bottom:
jsexport { name, draw, reportArea, reportPerimeter };

When importing these into main.js, if we tried to use
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/circle.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/triangle.js";

The browser would throw an error such as "SyntaxError: redeclaration of import name" (Firefox).
Instead we need to rename the imports so that they are unique:
jsimport {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
} from "./modules/square.js";

import {
  name as circleName,
  draw as drawCircle,
  reportArea as reportCircleArea,
  reportPerimeter as reportCirclePerimeter,
} from "./modules/circle.js";

import {
  name as triangleName,
  draw as drawTriangle,
  reportArea as reportTriangleArea,
  reportPerimeter as reportTrianglePerimeter,
} from "./modules/triangle.js";

Note that you could solve the problem in the module files instead, e.g.
js// in square.js
export {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
};

js// in main.js
import {
  squareName,
  drawSquare,
  reportSquareArea,
  reportSquarePerimeter,
} from "./modules/square.js";

And it would work just the same. What style you use is up to you, however it arguably makes more sense to leave your module code alone, and make the changes in the imports. This especially makes sense when you are importing from third party modules that you don't have any control over.Creating a module objectThe above method works OK, but it's a little messy and long-winded. An even better solution is to import each module's features inside a module object. The following syntax form does that:
jsimport * as Module from "./modules/module.js";

This grabs all the exports available inside module.js, and makes them available as members of an object Module, effectively giving it its own namespace. So for example:
jsModule.function1();
Module.function2();

Again, let's look at a real example. If you go to our module-objects directory, you'll see the same example again, but rewritten to take advantage of this new syntax. In the modules, the exports are all in the following simple form:
jsexport { name, draw, reportArea, reportPerimeter };

The imports on the other hand look like this:
jsimport * as Canvas from "./modules/canvas.js";

import * as Square from "./modules/square.js";
import * as Circle from "./modules/circle.js";
import * as Triangle from "./modules/triangle.js";

In each case, you can now access the module's imports underneath the specified object name, for example:
jsconst square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
Square.reportArea(square1.length, reportList);
Square.reportPerimeter(square1.length, reportList);

So you can now write the code just the same as before (as long as you include the object names where needed), and the imports are much neater.Modules and classesAs we hinted at earlier, you can also export and import classes; this is another option for avoiding conflicts in your code, and is especially useful if you've already got your module code written in an object-oriented style.
You can see an example of our shape drawing module rewritten with ES classes in our classes directory. As an example, the square.js file now contains all its functionality in a single class:
jsclass Square {
  constructor(ctx, listId, length, x, y, color) {
    // …
  }

  draw() {
    // …
  }

  // …
}

which we then export:
jsexport { Square };

Over in main.js, we import it like this:
jsimport { Square } from "./modules/square.js";

And then use the class to draw our square:
jsconst square1 = new Square(myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue");
square1.draw();
square1.reportArea();
square1.reportPerimeter();
Aggregating modulesThere will be times where you'll want to aggregate modules together. You might have multiple levels of dependencies, where you want to simplify things, combining several submodules into one parent module. This is possible using export syntax of the following forms in the parent module:
jsexport * from "x.js";
export { name } from "x.js";

For an example, see our module-aggregation directory. In this example (based on our earlier classes example) we've got an extra module called shapes.js, which aggregates all the functionality from circle.js, square.js, and triangle.js together. We've also moved our submodules inside a subdirectory inside the modules directory called shapes. So the module structure in this example is:
modules/
  canvas.js
  shapes.js
  shapes/
    circle.js
    square.js
    triangle.js

In each of the submodules, the export is of the same form, e.g.
jsexport { Square };

Next up comes the aggregation part. Inside shapes.js, we include the following lines:
jsexport { Square } from "./shapes/square.js";
export { Triangle } from "./shapes/triangle.js";
export { Circle } from "./shapes/circle.js";

These grab the exports from the individual submodules and effectively make them available from the shapes.js module.

Note: The exports referenced in shapes.js basically get redirected through the file and don't really exist there, so you won't be able to write any useful related code inside the same file.

So now in the main.js file, we can get access to all three module classes by replacing
jsimport { Square } from "./modules/square.js";
import { Circle } from "./modules/circle.js";
import { Triangle } from "./modules/triangle.js";

with the following single line:
jsimport { Square, Circle, Triangle } from "./modules/shapes.js";
Dynamic module loadingA recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works.
This new functionality allows you to call import() as a function, passing it the path to the module as a parameter. It returns a Promise, which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example:
jsimport("./modules/myModule.js").then((module) => {
  // Do something with the module.
});



Note: Dynamic import is permitted in the browser main thread, and in shared and dedicated workers.
    However import() will throw if called in a service worker or worklet.
  

Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons — "Circle", "Square", and "Triangle" — that, when pressed, dynamically load the required module and then use it to draw the associated shape.
In this example we've only made changes to our index.html and main.js files — the module exports remain the same as before.
Over in main.js we've grabbed a reference to each button using a document.querySelector() call, for example:
jsconst squareBtn = document.querySelector(".square");

We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape:
jssquareBtn.addEventListener("click", () => {
  import("./modules/square.js").then((Module) => {
    const square1 = new Module.Square(
      myCanvas.ctx,
      myCanvas.listId,
      50,
      50,
      100,
      "blue",
    );
    square1.draw();
    square1.reportArea();
    square1.reportPerimeter();
  });
});

Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with Module. prepended to it, e.g. Module.Square( /* … */ ).
Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing <script> tag in your HTML that doesn't have type="module", you can still reuse code distributed as modules by dynamically importing it.
html<script>
  import("./modules/square.js").then((module) => {
    // Do something with the module.
  });
  // Other code that operates on the global scope and is not
  // ready to be refactored into modules yet.
  var btn = document.querySelector(".square");
</script>
Top level awaitTop level await is a feature available within modules. This means the await keyword can be used. It allows modules to act as big asynchronous functions meaning code can be evaluated before use in parent modules, but without blocking sibling modules from loading.
Let's take a look at an example. You can find all the files and code described in this section within the top-level-await directory, which extends from the previous examples.
Firstly we'll declare our color palette in a separate colors.json file:
json{
  "yellow": "#F4D03F",
  "green": "#52BE80",
  "blue": "#5499C7",
  "red": "#CD6155",
  "orange": "#F39C12"
}

Then we'll create a module called getColors.js which uses a fetch request to load the colors.json file and return the data as an object.
js// fetch request
const colors = fetch("../data/colors.json").then((response) => response.json());

export default await colors;

Notice the last export line here.
We're using the keyword await before specifying the constant colors to export. This means any other modules which include this one will wait until colors has been downloaded and parsed before using it.
Let's include this module in our main.js file:
jsimport colors from "./modules/getColors.js";
import { Canvas } from "./modules/canvas.js";

const circleBtn = document.querySelector(".circle");

// …

We'll use colors instead of the previously used strings when calling our shape functions:
jsconst square1 = new Module.Square(
  myCanvas.ctx,
  myCanvas.listId,
  50,
  50,
  100,
  colors.blue,
);

const circle1 = new Module.Circle(
  myCanvas.ctx,
  myCanvas.listId,
  75,
  200,
  100,
  colors.green,
);

const triangle1 = new Module.Triangle(
  myCanvas.ctx,
  myCanvas.listId,
  100,
  75,
  190,
  colors.yellow,
);

This is useful because the code within main.js won't execute until the code in getColors.js has run. However it won't block other modules being loaded. For instance our canvas.js module will continue to load while colors is being fetched.Import declarations are hoistedImport declarations are hoisted. In this case, it means that the imported values are available in the module's code even before the place that declares them, and that the imported module's side effects are produced before the rest of the module's code starts running.
So for example, in main.js, importing Canvas in the middle of the code would still work:
js// …
const myCanvas = new Canvas("myCanvas", document.body, 480, 320);
myCanvas.create();
import { Canvas } from "./modules/canvas.js";
myCanvas.createReportList();
// …

Still, it is considered good practice to put all your imports at the top of the code, which makes it easier to analyze dependencies.Cyclic importsModules can import other modules, and those modules can import other modules, and so on. This forms a directed graph called the "dependency graph". In an ideal world, this graph is acyclic. In this case, the graph can be evaluated using a depth-first traversal.
However, cycles are often inevitable. Cyclic import arises if module a imports module b, but b directly or indirectly depends on a. For example:
js// -- a.js --
import { b } from "./b.js";

// -- b.js --
import { a } from "./a.js";

// Cycle:
// a.js ───> b.js
//  ^         │
//  └─────────┘

Cyclic imports don't always fail. The imported variable's value is only retrieved when the variable is actually used (hence allowing live bindings), and only if the variable remains uninitialized at that time will a ReferenceError be thrown.
js// -- a.js --
import { b } from "./b.js";

setTimeout(() => {
  console.log(b); // 1
}, 10);

export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);

export const b = 1;

In this example, both a and b are used asynchronously. Therefore, at the time the module is evaluated, neither b nor a is actually read, so the rest of the code is executed as normal, and the two export declarations produce the values of a and b. Then, after the timeout, both a and b are available, so the two console.log statements also execute as normal.
If you change the code to use a synchronously, the module evaluation fails:
js// -- a.js (entry module) --
import { b } from "./b.js";

export const a = 2;

// -- b.js --
import { a } from "./a.js";

console.log(a); // ReferenceError: Cannot access 'a' before initialization
export const b = 1;

This is because when JavaScript evaluates a.js, it needs to first evaluate b.js, the dependency of a.js. However, b.js uses a, which is not yet available.
On the other hand, if you change the code to use b synchronously but a asynchronously, the module evaluation succeeds:
js// -- a.js (entry module) --
import { b } from "./b.js";

console.log(b); // 1
export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);
export const b = 1;

This is because the evaluation of b.js completes normally, so the value of b is available when a.js is evaluated.
You should usually avoid cyclic imports in your project, because they make your code more error-prone. Some common cycle-elimination techniques are:

Merge the two modules into one.
Move the shared code into a third module.
Move some code from one module to the other.

However, cyclic imports can also occur if the libraries depend on each other, which is harder to fix.Authoring "isomorphic" modulesThe introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends.
Modules still have access to global variables, as demonstrated previously. If the module references globals like window, it can run in the browser, but will throw an error in your Node.js server, because window is not available there. Similarly, if the code requires access to process to be functional, it can only be used in Node.js.
In order to maximize the reusability of a module, it is often advised to make the code "isomorphic" — that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways:

Separate your modules into "core" and "binding". For the "core", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the "binding" part, you can read from and write to the global context. For example, the "browser binding" may choose to read the value from an input box, while the "Node binding" may read it from process.env, but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific.
Detect whether a particular global exists before using it. For example, if you test that typeof window === "undefined", you know that you are probably in a Node.js environment, and should not read DOM.
    js// myModule.js
let password;
if (typeof process !== "undefined") {
  // We are running in Node.js; read it from `process.env`
  password = process.env.PASSWORD;
} else if (typeof window !== "undefined") {
  // We are running in the browser; read it from the input box
  password = document.getElementById("password").value;
}
This is preferable if the two branches actually end up with the same behavior ("isomorphic"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different "bindings" instead.
  
Use a polyfill to provide a fallback for missing features. For example, if you want to use the fetch function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by node-fetch. You can do so conditionally through dynamic imports:
    js// myModule.js
if (typeof fetch === "undefined") {
  // We are running in Node.js; use node-fetch
  globalThis.fetch = (await import("node-fetch")).default;
}
// …
The globalThis variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules.
  

These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web.TroubleshootingHere are a few tips that may help you if you are having trouble getting your modules to work. Feel free to add to the list if you discover more!

We mentioned this before, but to reiterate: .mjs files need to be loaded with a MIME-type of text/javascript (or another JavaScript-compatible MIME-type, but text/javascript is recommended), otherwise you'll get a strict MIME type checking error like "The server responded with a non-JavaScript MIME type".
If you try to load the HTML file locally (i.e. with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. GitHub pages is ideal as it also serves .mjs files with the correct MIME type.
Because .mjs is a non-standard file extension, some operating systems might not recognize it, or try to replace it with something else. For example, we found that macOS was silently adding on .js to the end of .mjs files and then automatically hiding the file extension. So all of our files were actually coming out as x.mjs.js. Once we turned off automatically hiding file extensions, and trained it to accept .mjs, it was OK.
See also
JavaScript modules on v8.dev (2018)
ES modules: A cartoon deep-dive on hacks.mozilla.org (2018)
ES6 in Depth: Modules on hacks.mozilla.org (2015)
Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer

« Previous
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 28, 2023 by MDN contributors.
Understanding client-side JavaScript frameworksJavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we are aiming to give you a comfortable starting point to help you begin learning frameworks.
As an aspiring front-end developer, it can be hard to work out where to begin when learning frameworks — there are so many frameworks to choose from, new ones appear all the time, they mostly work in a similar way but do some things differently, and there are some specific things to be careful about when using frameworks.
We are not aiming to exhaustively teach you everything you need to know about React/ReactDOM, or Vue, or some other specific framework; the framework teams' own docs (and other resources) do that job already. Instead, we want to back up and first answer more fundamental questions such as:

Why should I use a framework? What problems do they solve for me?
What questions should I ask when trying to choose a framework? Do I even need to use a framework?
What features do frameworks have? How do they work in general, and how do frameworks' implementations of these features differ?
How do they relate to "vanilla" JavaScript or HTML?

After that, we'll provide some tutorials covering the essentials of some of the different framework choices, to provide you with enough context and familiarity to start going into greater depth yourself. We want you to go forward and learn about frameworks in a pragmatic way that doesn't forget about web platform fundamental best practices such as accessibility.
Get started now, with "Introduction to client-side frameworks"PrerequisitesYou should really learn the basics of the core web languages first before attempting to move on to learning client-side frameworks — HTML, CSS, and especially JavaScript.
Your code will be richer and more professional as a result, and you'll be able to troubleshoot problems with more confidence if you understand the fundamental web platform features that the frameworks are building on top of.

Looking to become a front-end web developer?

    We have put together a course that includes all the essential information you need to
    work towards your goal.
  
Get started
Introductory guides
1. Introduction to client-side frameworks

We begin our look at frameworks with a general overview of the area, looking at a brief history of JavaScript and frameworks, why frameworks exist and what they give us, how to start thinking about choosing a framework to learn, and what alternatives there are to client-side frameworks.

2. Framework main features

Each major JavaScript framework has a different approach to updating the DOM, handling browser events, and providing an enjoyable developer experience. This article will explore the main features of "the big 4" frameworks, looking at how frameworks tend to work from a high level and the differences between them.

React tutorials
Note: React tutorials last tested in January 2023, with React/ReactDOM 18.2.0 and create-react-app 5.0.1.
If you need to check your code against our version, you can find a finished version of the sample React app code in our todo-react repository. For a running live version, see https://mdn.github.io/todo-react/.


1. Getting started with React

In this article we will say hello to React. We'll discover a little bit of detail about its background and use cases, set up a basic React toolchain on our local computer, and create and play with a simple starter app, learning a bit about how React works in the process.

2. Beginning our React todo list

Let's say that we've been tasked with creating a proof-of-concept in React – an app that allows users to add, edit, and delete tasks they want to work on, and also mark tasks as complete without deleting them. This article will walk you through putting the basic App component structure and styling in place, ready for individual component definition and interactivity, which we'll add later.

3. Componentizing our React app

At this point, our app is a monolith. Before we can make it do things, we need to break it apart into manageable, descriptive components. React doesn't have any hard rules for what is and isn't a component – that's up to you! In this article, we will show you a sensible way to break our app up into components.

4. React interactivity: Events and state

With our component plan worked out, it's now time to start updating our app from a completely static UI to one that actually allows us to interact and change things. In this article we'll do this, digging into events and state along the way.

5. React interactivity: Editing, filtering, conditional rendering

As we near the end of our React journey (for now at least), we'll add the finishing touches to the main areas of functionality in our Todo list app. This includes allowing you to edit existing tasks and filtering the list of tasks between all, completed, and incomplete tasks. We'll look at conditional UI rendering along the way.

6. Accessibility in React

In our final tutorial article, we'll focus on (pun intended) accessibility, including focus management in React, which can improve usability and reduce confusion for both keyboard-only and screen reader users.

7. React resources

Our final article provides you with a list of React resources that you can use to go further in your learning.

Ember tutorials
Note: Ember tutorials last tested in May 2020, with Ember/Ember CLI version 3.18.0.
If you need to check your code against our version, you can find a finished version of the sample Ember app code in the ember-todomvc-tutorial repository. For a running live version, see https://nullvoxpopuli.github.io/ember-todomvc-tutorial/ (this also includes a few additional features not covered in the tutorial).


1. Getting started with Ember

In our first Ember article we will look at how Ember works and what it's useful for, install the Ember toolchain locally, create a sample app, and then do some initial setup to get it ready for development.

2. Ember app structure and componentization

In this article we'll get right on with planning out the structure of our TodoMVC Ember app, adding in the HTML for it, and then breaking that HTML structure into components.

3. Ember interactivity: Events, classes and state

At this point we'll start adding some interactivity to our app, providing the ability to add and display new todo items. Along the way, we'll look at using events in Ember, creating component classes to contain JavaScript code to control interactive features, and setting up a service to keep track of the data state of our app.

4. Ember Interactivity: Footer functionality, conditional rendering

Now it's time to start tackling the footer functionality in our app. Here we'll get the todo counter to update to show the correct number of todos still to complete, and correctly apply styling to completed todos (i.e. where the checkbox has been checked). We'll also wire up our "Clear completed" button. Along the way, we'll learn about using conditional rendering in our templates.

5. Routing in Ember

In this article we learn about routing or URL-based filtering as it is sometimes referred to. We'll use it to provide a unique URL for each of the three todo views — "All", "Active", and "Completed".

6. Ember resources and troubleshooting

Our final Ember article provides you with a list of resources that you can use to go further in your learning, plus some useful troubleshooting and other information.

Vue tutorials
Note: Vue tutorial last tested in January 2023, with Vue 3.2.45.
If you need to check your code against our version, you can find a finished version of the sample Vue app code in our todo-vue repository. For a running live version, see https://mdn.github.io/todo-vue/.


1. Getting started with Vue

Now let's introduce Vue, the third of our frameworks. In this article, we'll look at a little bit of Vue background, learn how to install it and create a new project, study the high-level structure of the whole project and an individual component, see how to run the project locally, and get it prepared to start building our example.

2. Creating our first Vue component

Now it's time to dive deeper into Vue, and create our own custom component — we'll start by creating a component to represent each item in the todo list. Along the way, we'll learn about a few important concepts such as calling components inside other components, passing data to them via props and saving data state.

3. Rendering a list of Vue components

At this point we've got a fully working component; we're now ready to add multiple ToDoItem components to our app. In this article we'll look at adding a set of todo item data to our App.vue component, which we'll then loop through and display inside ToDoItem components using the v-for directive.

4. Adding a new todo form: Vue events, methods, and models

We now have sample data in place and a loop that takes each bit of data and renders it inside a ToDoItem in our app. What we really need next is the ability to allow our users to enter their own todo items into the app, and for that, we'll need a text <input>, an event to fire when the data is submitted, a method to fire upon submission to add the data and rerender the list, and a model to control the data. This is what we'll cover in this article.

5. Styling Vue components with CSS

The time has finally come to make our app look a bit nicer. In this article, we'll explore the different ways of styling Vue components with CSS.

6. Using Vue computed properties

In this article we'll add a counter that displays the number of completed todo items, using a feature of Vue called computed properties. These work similarly to methods but only re-run when one of their dependencies changes.

7. Vue conditional rendering: editing existing todos

Now it is time to add one of the major parts of functionality that we're still missing — the ability to edit existing todo items. To do this, we will take advantage of Vue's conditional rendering capabilities — namely v-if and v-else — to allow us to toggle between the existing todo item view and an edit view where you can update todo item labels. We'll also look at adding functionality to delete todo items.

8. Vue refs and lifecycle methods for focus management

We are nearly done with Vue. The last bit of functionality to look at is focus management, or put another way, how we can improve our app's keyboard accessibility. We'll look at using Vue refs to handle this — an advanced feature that allows you to have direct access to the underlying DOM nodes below the virtual DOM, or direct access from one component to the internal DOM structure of a child component.

9. Vue resources

Now we'll round off our study of Vue by giving you a list of resources that you can use to go further in your learning, plus some other useful tips.

Svelte tutorials
Note: Svelte tutorials last tested in August 2020, with Svelte 3.24.1.
If you need to check your code against our version, you can find a finished version of the sample Svelte app code as it should be after each article, in our mdn-svelte-tutorial repo. For a running live version, see our Svelte REPL at https://svelte.dev/repl/378dd79e0dfe4486a8f10823f3813190?version=3.23.2.


1. Getting started with Svelte

In this article we'll provide a quick introduction to the Svelte framework. We will see how Svelte works and what sets it apart from the rest of the frameworks and tools we've seen so far. Then we will learn how to set up our development environment, create a sample app, understand the structure of the project, and see how to run it locally and build it for production.

2. Starting our Svelte Todo list app

Now that we have a basic understanding of how things work in Svelte, we can start building our example app: a todo list. In this article we will first have a look at the desired functionality of our app, then we'll create a Todos.svelte component and put static markup and styles in place, leaving everything ready to start developing our To-Do list app features, which we'll go on to in subsequent articles.

3. Dynamic behavior in Svelte: working with variables and props

Now that we have our markup and styles ready we can start developing the required features for our Svelte To-Do list app. In this article we'll be using variables and props to make our app dynamic, allowing us to add and delete todos, mark them as complete, and filter them by status.

4. Componentizing our Svelte app

The central objective of this article is to look at how to break our app into manageable components and share information between them. We'll componentize our app, then add more functionality to allow users to update existing components.

5. Advanced Svelte: Reactivity, lifecycle, accessibility

In this article we will add the app's final features and further componentize our app. We will learn how to deal with reactivity issues related to updating objects and arrays. To avoid common pitfalls, we'll have to dig a little deeper into Svelte's reactivity system. We'll also look at solving some accessibility focus issues, and more besides.

6. Working with Svelte stores

In this article we will show another way to handle state management in Svelte — Stores. Stores are global data repositories that hold values. Components can subscribe to stores and receive notifications when their values change.

7. TypeScript support in Svelte

We will now learn how to use TypeScript in Svelte applications. First we'll learn what TypeScript is and what benefits it can bring us. Then we'll see how to configure our project to work with TypeScript files. Finally we will go over our app and see what modifications we have to make to fully take advantage of TypeScript features.

8. Deployment and next steps

In this final article we will look at how to deploy your application and get it online, and also share some of the resources that you should go on to, to continue your Svelte learning journey.

Angular tutorials
Note: Angular tutorials last tested in April 2021, with Angular CLI (NG) 11.2.5.


1. Getting started with Angular

In this article we look at what Angular has to offer, install the prerequisites and set up a sample app, and look at Angular's basic architecture.

2. Beginning our Angular todo list app

At this point, we are ready to start creating our to-do list application using Angular. The finished application will display a list of to-do items and includes editing, deleting, and adding features. In this article you will get to know your application structure, and work up to displaying a basic list of to-do items.

3. Styling our Angular app

Now that we've got our basic application structure set up and started displaying something useful, let's switch gears and spend an article looking at how Angular handles styling of applications.

4. Creating an item component

Components provide a way for you to organize your application. This article walks you through creating a component to handle the individual items in the list, and adding check, edit, and delete functionality. The Angular event model is covered here.

5. Filtering our to-do items

Now let's move on to adding functionality to allow users to filter their to-do items, so they can view active, completed, or all items.

6. Building Angular applications and further resources

This final Angular article covers how to build an app ready for production, and provides further resources for you to continue your learning journey.

Which frameworks did we choose?We are publishing our initial set of articles with guides focusing on five frameworks. Four of them are very popular and well-established — React/ReactDOM, Ember, Vue, and Angular — whereas Svelte is a comparative newcomer that shows a lot of promise and has gained a lot of recent popularity.
There is a variety of reasons for this:

They are popular choices that will be around for a while — like with any software tool, it is good to stick with actively-developed choices that are likely to not be discontinued next week, and which will be desirable additions to your skill set when looking for a job.
They have strong communities and good documentation. It is very important to be able to get help with learning a complex subject, especially when you are just starting out.
We don't have the resources to cover all modern frameworks. That list would be very difficult to keep up-to-date anyway, as new ones appear all the time.
As a beginner, trying to choose what to focus on out of the huge number of choices available is a very real problem. Keeping the list short is therefore helpful.

We want to say this upfront — we've not chosen the frameworks we are focusing on because we think they are the best, or because we endorse them in any way. We just think they score highly on the above criteria.
Note that we were hoping to have more frameworks included upon initial publication, but we decided to release the content and then add more framework guides later, rather than delay it longer. If your favorite framework is not represented in this content and you'd like to help change that, feel free to discuss it with us!Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 16, 2024 by MDN contributors.
Client-side web APIsWhen writing client-side JavaScript for websites or applications, you will quickly encounter Application Programming Interfaces (APIs). APIs are programming features for manipulating different aspects of the browser and operating system the site is running on, or manipulating data from other websites or services. In this module, we will explore what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

Looking to become a front-end web developer?

    We have put together a course that includes all the essential information you need to
    work towards your goal.
  
Get started
PrerequisitesTo get the most out of this module, you should have worked your way through the previous JavaScript modules in the series (First steps, Building blocks, and JavaScript objects). Those modules typically involve simple API usage, as it is often difficult to write client-side JavaScript examples without them. For this tutorial, we will assume that you are knowledgeable about the core JavaScript language, and we will explore common Web APIs in a bit more detail.
Basic knowledge of HTML and CSS would also be useful.

Note: If you are working on a device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Guides
Introduction to web APIs

First up, we'll start by looking at APIs from a high level — what are they, how do they work, how do you use them in your code, and how are they structured? We'll also take a look at what the different main classes of APIs are, and what kind of uses they have.

Manipulating documents

When writing web pages and apps, one of the most common things you'll want to do is manipulate web documents in some way. This is usually done by using the Document Object Model (DOM), a set of APIs for controlling HTML and styling information that makes heavy use of the Document object. In this article, we'll look at how to use the DOM in detail, along with some other interesting APIs that can alter your environment in interesting ways.

Fetching data from the server

Another very common task in modern websites and applications is retrieving individual data items from the server to update sections of a webpage without having to load an entirely new page. This seemingly small detail has had a huge impact on the performance and behavior of sites. In this article, we'll explain the concept, and look at technologies that make it possible, such as XMLHttpRequest and the Fetch API.

Third party APIs

The APIs we've covered so far are built into the browser, but not all APIs are. Many large websites and services such as Google Maps, Facebook, PayPal, etc. provide APIs allowing developers to make use of their data or services (e.g. displaying custom Google Maps on your site, or using Facebook login to log in your users). This article looks at the difference between browser APIs and 3rd party APIs and shows some typical uses of the latter.

Drawing graphics

The browser contains some very powerful graphics programming tools, from the Scalable Vector Graphics (SVG) language, to APIs for drawing on HTML <canvas> elements, (see The Canvas API and WebGL). This article provides an introduction to the Canvas API, and further resources to allow you to learn more.

Video and audio APIs

HTML comes with elements for embedding rich media in documents — <video> and <audio> — which in turn come with their own APIs for controlling playback, seeking, etc. This article shows you how to do common tasks such as creating custom playback controls.

Client-side storage

Modern web browsers feature a number of different technologies that allow you to store data related to websites and retrieve it when necessary allowing you to persist data long term, save sites offline, and more. This article explains the very basics of how these work.

Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 4, 2024 by MDN contributors.
JavaScript language overviewJavaScript is a multi-paradigm, dynamic language with types and operators, standard built-in objects, and methods. Its syntax is based on the Java and C languages — many structures from those languages apply to JavaScript as well. JavaScript supports object-oriented programming with object prototypes and classes. It also supports functional programming since functions are first-class objects that can be easily created via expressions and passed around like any other object.
This page serves as a quick overview of various JavaScript language features, written for readers with background in other languages, such as C or Java.Data typesLet's start off by looking at the building blocks of any language: the types. JavaScript programs manipulate values, and those values all belong to a type. JavaScript offers seven primitive types:

Number: used for all number values (integer and floating point) except for very big integers.
BigInt: used for arbitrarily large integers.
String: used to store text.
Boolean: true and false — usually used for conditional logic.
Symbol: used for creating unique identifiers that won't collide.
Undefined: indicating that a variable has not been assigned a value.
Null: indicating a deliberate non-value.

Everything else is known as an Object. Common object types include:

Function
Array
Date
RegExp
Error

Functions aren't special data structures in JavaScript — they are just a special type of object that can be called.NumbersJavaScript has two built-in numeric types: Number and BigInt.
The Number type is a IEEE 754 64-bit double-precision floating point value, which means integers can be safely represented between -(253 − 1) and 253 − 1 without loss of precision, and floating point numbers can be stored all the way up to 1.79 × 10308. Within numbers, JavaScript does not distinguish between floating point numbers and integers.
jsconsole.log(3 / 2); // 1.5, not 1

So an apparent integer is in fact implicitly a float. Because of IEEE 754 encoding, sometimes floating point arithmetic can be imprecise.
jsconsole.log(0.1 + 0.2); // 0.30000000000000004

For operations that expect integers, such as bitwise operations, the number will be converted to a 32-bit integer.
Number literals can also have prefixes to indicate the base (binary, octal, decimal, or hexadecimal), or an exponent suffix.
jsconsole.log(0b111110111); // 503
console.log(0o767); // 503
console.log(0x1f7); // 503
console.log(5.03e2); // 503

The BigInt type is an arbitrary length integer. Its behavior is similar to C's integer types (e.g. division truncates to zero), except it can grow indefinitely. BigInts are specified with a number literal and an n suffix.
jsconsole.log(-3n / 2n); // -1n

The standard arithmetic operators are supported, including addition, subtraction, remainder arithmetic, etc. BigInts and numbers cannot be mixed in arithmetic operations.
The Math object provides standard mathematical functions and constants.
jsMath.sin(3.5);
const circumference = 2 * Math.PI * r;

There are three ways to convert a string to a number:

parseInt(), which parses the string for an integer.
parseFloat(), which parses the string for a floating-point number.
The Number() function, which parses a string as if it's a number literal and supports many different number representations.

You can also use the unary plus + as a shorthand for Number().
Number values also include NaN (short for "Not a Number") and Infinity. Many "invalid math" operations will return NaN — for example, if attempting to parse a non-numeric string, or using Math.log() on a negative value. Division by zero produces Infinity (positive or negative).
NaN is contagious: if you provide it as an operand to any mathematical operation, the result will also be NaN. NaN is the only value in JavaScript that's not equal to itself (per IEEE 754 specification).StringsStrings in JavaScript are sequences of Unicode characters. This should be welcome news to anyone who has had to deal with internationalization. More accurately, they are UTF-16 encoded.
jsconsole.log("Hello, world");
console.log("你好，世界！"); // Nearly all Unicode characters can be written literally in string literals

Strings can be written with either single or double quotes — JavaScript does not have the distinction between characters and strings. If you want to represent a single character, you just use a string consisting of that single character.
jsconsole.log("Hello"[1] === "e"); // true

To find the length of a string (in code units), access its length property.
Strings have utility methods to manipulate the string and access information about the string. Because all primitives are immutable by design, these methods return new strings.
The + operator is overloaded for strings: when one of the operands is a string, it performs string concatenation instead of number addition. A special template literal syntax allows you to write strings with embedded expressions more succinctly. Unlike Python's f-strings or C#'s interpolated strings, template literals use backticks (not single or double quotes).
jsconst age = 25;
console.log("I am " + age + " years old."); // String concatenation
console.log(`I am ${age} years old.`); // Template literal
Other typesJavaScript distinguishes between null, which indicates a deliberate non-value (and is only accessible through the null keyword), and undefined, which indicates absence of value. There are many ways to obtain undefined:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) will implicitly initialize the variable to undefined.

JavaScript has a Boolean type, with possible values true and false — both of which are keywords. Any value can be converted to a boolean according to the following rules:

false, 0, empty strings (""), NaN, null, and undefined all become false.
All other values become true.

You can perform this conversion explicitly using the Boolean() function:
jsBoolean(""); // false
Boolean(234); // true

However, this is rarely necessary, as JavaScript will silently perform this conversion when it expects a boolean, such as in an if statement (see Control structures). For this reason, we sometimes speak of "truthy" and "falsy", meaning values that become true and false, respectively, when used in boolean contexts.
Boolean operations such as && (logical and), || (logical or), and ! (logical not) are supported; see Operators.
The Symbol type is often used to create unique identifiers. Every symbol created with the Symbol() function is guaranteed to be unique. In addition, there are registered symbols, which are shared constants, and well-known symbols, which are utilized by the language as "protocols" for certain operations. You can read more about them in the symbol reference.VariablesVariables in JavaScript are declared using one of three keywords: let, const, or var.
let allows you to declare block-level variables. The declared variable is available from the block it is enclosed in.
jslet a;
let name = "Simon";

// myLetVariable is *not* visible out here

for (let myLetVariable = 0; myLetVariable < 5; myLetVariable++) {
  // myLetVariable is only visible in here
}

// myLetVariable is *not* visible out here

const allows you to declare variables whose values are never intended to change. The variable is available from the block it is declared in.
jsconst Pi = 3.14; // Declare variable Pi
console.log(Pi); // 3.14

A variable declared with const cannot be reassigned.
jsconst Pi = 3.14;
Pi = 1; // will throw an error because you cannot change a constant variable.

const declarations only prevent reassignments — they don't prevent mutations of the variable's value, if it's an object.
jsconst obj = {};
obj.a = 1; // no error
console.log(obj); // { a: 1 }

var declarations can have surprising behaviors (for example, they are not block-scoped), and they are discouraged in modern JavaScript code.
If you declare a variable without assigning any value to it, its value is undefined. You can't declare a const variable without an initializer, because you can't change it later anyway.
let and const declared variables still occupy the entire scope they are defined in, and are in a region known as the temporal dead zone before the actual line of declaration. This has some interesting interactions with variable shadowing, which don't occur in other languages.
jsfunction foo(x, condition) {
  if (condition) {
    console.log(x);
    const x = 2;
    console.log(x);
  }
}

foo(1, true);

In most other languages, this would log "1" and "2", because before the const x = 2 line, x should still refer to the parameter x in the upper scope. In JavaScript, because each declaration occupies the entire scope, this would throw an error on the first console.log: "Cannot access 'x' before initialization". For more information, see the reference page of let.
JavaScript is dynamically typed. Types (as described in the previous section) are only associated with values, but not with variables. For let-declared variables, you can always change its type through reassignment.
jslet a = 1;
a = "foo";
OperatorsJavaScript's numeric operators include +, -, *, /, % (remainder), and ** (exponentiation). Values are assigned using =. Each binary operator also has a compound assignment counterpart such as += and -=, which extend out to x = x operator y.
jsx += 5;
x = x + 5;

You can use ++ and -- to increment and decrement respectively. These can be used as a prefix or postfix operators.
The + operator also does string concatenation:
js"hello" + " world"; // "hello world"

If you add a string to a number (or other value) everything is converted into a string first. This might trip you up:
js"3" + 4 + 5; // "345"
3 + 4 + "5"; // "75"

Adding an empty string to something is a useful way of converting it to a string itself.
Comparisons in JavaScript can be made using <, >, <= and >=, which work for both strings and numbers. For equality, the double-equals operator performs type coercion if you give it different types, with sometimes interesting results. On the other hand, the triple-equals operator does not attempt type coercion, and is usually preferred.
js123 == "123"; // true
1 == true; // true

123 === "123"; // false
1 === true; // false

The double-equals and triple-equals also have their inequality counterparts: != and !==.
JavaScript also has bitwise operators and logical operators. Notably, logical operators don't work with boolean values only — they work by the "truthiness" of the value.
jsconst a = 0 && "Hello"; // 0 because 0 is "falsy"
const b = "Hello" || "world"; // "Hello" because both "Hello" and "world" are "truthy"

The && and || operators use short-circuit logic, which means whether they will execute their second operand is dependent on the first. This is useful for checking for null objects before accessing their attributes:
jsconst name = o && o.getName();

Or for caching values (when falsy values are invalid):
jsconst name = cachedName || (cachedName = getName());

For a comprehensive list of operators, see the guide page or reference section. You may be especially interested in the operator precedence.GrammarJavaScript grammar is very similar to the C family. There are a few points worth mentioning:

Identifiers can have Unicode characters, but they cannot be one of the reserved words.
Comments are commonly // or /* */, while many other scripting languages like Perl, Python, and Bash use #.
Semicolons are optional in JavaScript — the language automatically inserts them when needed. However, there are certain caveats to watch out for, since unlike Python, semicolons are still part of the syntax.

For an in-depth look at the JavaScript grammar, see the reference page for lexical grammar.Control structuresJavaScript has a similar set of control structures to other languages in the C family. Conditional statements are supported by if and else; you can chain them together:
jslet name = "kittens";
if (name === "puppies") {
  name += " woof";
} else if (name === "kittens") {
  name += " meow";
} else {
  name += "!";
}
name === "kittens meow";

JavaScript doesn't have elif, and else if is really just an else branch comprised of a single if statement.
JavaScript has while loops and do...while loops. The first is good for basic looping; the second is for loops where you wish to ensure that the body of the loop is executed at least once:
jswhile (true) {
  // an infinite loop!
}

let input;
do {
  input = get_input();
} while (inputIsNotValid(input));

JavaScript's for loop is the same as that in C and Java: it lets you provide the control information for your loop on a single line.
jsfor (let i = 0; i < 5; i++) {
  // Will execute 5 times
}

JavaScript also contains two other prominent for loops: for...of, which iterates over iterables, most notably arrays, and for...in, which visits all enumerable properties of an object.
jsfor (const value of array) {
  // do something with value
}

for (const property in object) {
  // do something with object property
}

The switch statement can be used for multiple branches based on equality checking.
jsswitch (action) {
  case "draw":
    drawIt();
    break;
  case "eat":
    eatIt();
    break;
  default:
    doNothing();
}

Similar to C, case clauses are conceptually the same as labels, so if you don't add a break statement, execution will "fall through" to the next level. However, they are not actually jump tables — any expression can be part of the case clause, not just string or number literals, and they would be evaluated one-by-one until one equals the value being matched. Comparison takes place between the two using the === operator.
Unlike some languages like Rust, control-flow structures are statements in JavaScript, meaning you can't assign them to a variable, like const a = if (x) { 1 } else { 2 }.
JavaScript errors are handled using the try...catch statement.
jstry {
  buildMySite("./website");
} catch (e) {
  console.error("Building site failed:", e);
}

Errors can be thrown using the throw statement. Many built-in operations may throw as well.
jsfunction buildMySite(siteDirectory) {
  if (!pathExists(siteDirectory)) {
    throw new Error("Site directory does not exist");
  }
}

In general, you can't tell the type of the error you just caught, because anything can be thrown from a throw statement. However, you can usually assume it's an Error instance, as is the example above. There are some subclasses of Error built-in, like TypeError and RangeError, that you can use to provide extra semantics about the error. There's no conditional catch in JavaScript — if you only want to handle one type of error, you need to catch everything, identify the type of error using instanceof, and then rethrow the other cases.
jstry {
  buildMySite("./website");
} catch (e) {
  if (e instanceof RangeError) {
    console.error("Seems like a parameter is out of range:", e);
    console.log("Retrying...");
    buildMySite("./website");
  } else {
    // Don't know how to handle other error types; throw them so
    // something else up in the call stack may catch and handle it
    throw e;
  }
}

If an error is uncaught by any try...catch in the call stack, the program will exit.
For a comprehensive list of control flow statements, see the reference section.ObjectsJavaScript objects can be thought of as collections of key-value pairs. As such, they are similar to:

Dictionaries in Python.
Hashes in Perl and Ruby.
Hash tables in C and C++.
HashMaps in Java.
Associative arrays in PHP.

JavaScript objects are hashes. Unlike objects in statically typed languages, objects in JavaScript do not have fixed shapes — properties can be added, deleted, re-ordered, mutated, or dynamically queried at any time. Object keys are always strings or symbols — even array indices, which are canonically integers, are actually strings under the hood.
Objects are usually created using the literal syntax:
jsconst obj = {
  name: "Carrot",
  for: "Max",
  details: {
    color: "orange",
    size: 12,
  },
};

Object properties can be accessed using dot (.) or square brackets ([]). When using the dot notation, the key must be a valid identifier. Square brackets, on the other hand, allow indexing the object with a dynamic key value.
js// Dot notation
obj.name = "Simon";
const name = obj.name;

// Bracket notation
obj["name"] = "Simon";
const name = obj["name"];

// Can use a variable to define a key
const userName = prompt("what is your key?");
obj[userName] = prompt("what is its value?");

Property access can be chained together:
jsobj.details.color; // orange
obj["details"]["size"]; // 12

Objects are always references, so unless something is explicitly copying the object, mutations to an object would be visible to the outside.
jsconst obj = {};
function doSomething(o) {
  o.x = 1;
}
doSomething(obj);
console.log(obj.x); // 1

This also means two separately created objects will never be equal (!==), because they are different references. If you hold two references of the same object, mutating one would be observable through the other.
jsconst me = {};
const stillMe = me;
me.x = 1;
console.log(stillMe.x); // 1

For more on objects and prototypes, see the Object reference page. For more information on the object initializer syntax, see its reference page.
This page has omitted all details about object prototypes and inheritance because you can usually achieve inheritance with classes without touching the underlying mechanism (which you may have heard to be abstruse). To learn about them, see Inheritance and the prototype chain.ArraysArrays in JavaScript are actually a special type of object. They work very much like regular objects (numerical properties can naturally be accessed only using [] syntax) but they have one magic property called length. This is always one more than the highest index in the array.
Arrays are usually created with array literals:
jsconst a = ["dog", "cat", "hen"];
a.length; // 3

JavaScript arrays are still objects — you can assign any properties to them, including arbitrary number indices. The only "magic" is that length will be automatically updated when you set a particular index.
jsconst a = ["dog", "cat", "hen"];
a[100] = "fox";
console.log(a.length); // 101
console.log(a); // ['dog', 'cat', 'hen', empty × 97, 'fox']

The array we got above is called a sparse array because there are uninhabited slots in the middle, and will cause the engine to deoptimize it from an array to a hash table. Make sure your array is densely populated!
Out-of-bounds indexing doesn't throw. If you query a non-existent array index, you'll get a value of undefined in return:
jsconst a = ["dog", "cat", "hen"];
console.log(typeof a[90]); // undefined

Arrays can have any elements and can grow or shrink arbitrarily.
jsconst arr = [1, "foo", true];
arr.push({});
// arr = [1, "foo", true, {}]

Arrays can be iterated with the for loop, as you can in other C-like languages:
jsfor (let i = 0; i < a.length; i++) {
  // Do something with a[i]
}

Or, since arrays are iterable, you can use the for...of loop, which is synonymous to C++/Java's for (int x : arr) syntax:
jsfor (const currentValue of a) {
  // Do something with currentValue
}

Arrays come with a plethora of array methods. Many of them would iterate the array — for example, map() would apply a callback to every array element, and return a new array:
jsconst babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);
// babies = ['baby dog', 'baby cat', 'baby hen']
FunctionsAlong with objects, functions are the core component in understanding JavaScript. The most basic function declaration looks like this:
jsfunction add(x, y) {
  const total = x + y;
  return total;
}

A JavaScript function can take 0 or more parameters. The function body can contain as many statements as you like and can declare its own variables which are local to that function. The return statement can be used to return a value at any time, terminating the function. If no return statement is used (or an empty return with no value), JavaScript returns undefined.
Functions can be called with more or fewer parameters than it specifies. If you call a function without passing the parameters it expects, they will be set to undefined. If you pass more parameters than it expects, the function will ignore the extra parameters.
jsadd(); // NaN
// Equivalent to add(undefined, undefined)

add(2, 3, 4); // 5
// added the first two; 4 was ignored

There are a number of other parameter syntaxes available. For example, the rest parameter syntax allows collecting all the extra parameters passed by the caller into an array, similar to Python's *args. (Since JS doesn't have named parameters on the language level, there's no **kwargs.)
jsfunction avg(...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5

In the above code, the variable args holds all the values that were passed into the function.
The rest parameter will store all arguments after where it's declared, but not before. In other words, function avg(firstValue, ...args) will store the first value passed into the function in the firstValue variable and the remaining arguments in args.
If a function accepts a list of arguments and you already hold them in an array, you can use the spread syntax in the function call to spread the array as a list of elements. For instance: avg(...numbers).
We mentioned that JavaScript doesn't have named parameters. It's possible, though, to implement them using object destructuring, which allows objects to be conveniently packed and unpacked.
js// Note the { } braces: this is destructuring an object
function area({ width, height }) {
  return width * height;
}

// The { } braces here create a new object
console.log(area({ width: 2, height: 3 }));

There's also the default parameter syntax, which allows omitted parameters (or those passed as undefined) to have a default value.
jsfunction avg(firstValue, secondValue, thirdValue = 0) {
  return (firstValue + secondValue + thirdValue) / 3;
}

avg(1, 2); // 1, instead of NaN
Anonymous functionsJavaScript lets you create anonymous functions — that is, functions without names. In practice, anonymous functions are typically used as arguments to other functions, immediately assigned to a variable that can be used to invoke the function, or returned from another function.
js// Note that there's no function name before the parentheses
const avg = function (...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

That makes the anonymous function invocable by calling avg() with some arguments — that is, it's semantically equivalent to declaring the function using the function avg() {} declaration syntax.
There's another way to define anonymous functions — using an arrow function expression.
js// Note that there's no function name before the parentheses
const avg = (...args) => {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

// You can omit the `return` when simply returning an expression
const sum = (a, b, c) => a + b + c;

Arrow functions are not semantically equivalent to function expressions — for more information, see its reference page.
There's another way that anonymous functions can be useful: it can be simultaneously declared and invoked in a single expression, called an Immediately invoked function expression (IIFE):
js(function () {
  // …
})();

For use-cases of IIFEs, you can read emulating private methods with closures.Recursive functionsJavaScript allows you to call functions recursively. This is particularly useful for dealing with tree structures, such as those found in the browser DOM.
jsfunction countChars(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += countChars(child);
  }
  return count;
}

Function expressions can be named as well, which allows them to be recursive.
jsconst charsInBody = (function counter(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += counter(child);
  }
  return count;
})(document.body);

The name provided to a function expression as above is only available to the function's own scope. This allows more optimizations to be done by the engine and results in more readable code. The name also shows up in the debugger and some stack traces, which can save you time when debugging.
If you are used to functional programming, beware of the performance implications of recursion in JavaScript. Although the language specification specifies tail-call optimization, only JavaScriptCore (used by Safari) has implemented it, due to the difficulty of recovering stack traces and debuggability. For deep recursion, consider using iteration instead to avoid stack overflow.Functions are first-class objectsJavaScript functions are first-class objects. This means that they can be assigned to variables, passed as arguments to other functions, and returned from other functions. In addition, JavaScript supports closures out-of-the-box without explicit capturing, allowing you to conveniently apply functional programming styles.
js// Function returning function
const add = (x) => (y) => x + y;
// Function accepting function
const babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);

Note that JavaScript functions are themselves objects — like everything else in JavaScript — and you can add or change properties on them just like we've seen earlier in the Objects section.Inner functionsJavaScript function declarations are allowed inside other functions. An important detail of nested functions in JavaScript is that they can access variables in their parent function's scope:
jsfunction parentFunc() {
  const a = 1;

  function nestedFunc() {
    const b = 4; // parentFunc can't use this
    return a + b;
  }
  return nestedFunc(); // 5
}

This provides a great deal of utility in writing more maintainable code. If a called function relies on one or two other functions that are not useful to any other part of your code, you can nest those utility functions inside it. This keeps the number of functions that are in the global scope down.
This is also a great counter to the lure of global variables. When writing complex code, it is often tempting to use global variables to share values between multiple functions, which leads to code that is hard to maintain. Nested functions can share variables in their parent, so you can use that mechanism to couple functions together without polluting your global namespace.ClassesJavaScript offers the class syntax that's very similar to languages like Java.
jsclass Person {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    return `Hello, I'm ${this.name}!`;
  }
}

const p = new Person("Maria");
console.log(p.sayHello());

JavaScript classes are just functions that must be instantiated with the new operator. Every time a class is instantiated, it returns an object containing the methods and properties that the class specified. Classes don't enforce any code organization — for example, you can have functions returning classes, or you can have multiple classes per file. Here's an example of how ad hoc the creation of a class can be: it's just an expression returned from an arrow function. This pattern is called a mixin.
jsconst withAuthentication = (cls) =>
  class extends cls {
    authenticate() {
      // …
    }
  };

class Admin extends withAuthentication(Person) {
  // …
}

Static properties are created by prepending static. Private properties are created by prepending a hash # (not private). The hash is an integral part of the property name. (Think about # as _ in Python.) Unlike most other languages, there's absolutely no way to read a private property outside the class body — not even in derived classes.
For a detailed guide on various class features, you can read the guide page.Asynchronous programmingJavaScript is single-threaded by nature. There's no paralleling; only concurrency. Asynchronous programming is powered by an event loop, which allows a set of tasks to be queued and polled for completion.
There are three idiomatic ways to write asynchronous code in JavaScript:

Callback-based (such as setTimeout())
Promise-based
async/await, which is a syntactic sugar for Promises

For example, here's what a file-read operation might look like in JavaScript:
js// Callback-based
fs.readFile(filename, (err, content) => {
  // This callback is invoked when the file is read, which could be after a while
  if (err) {
    throw err;
  }
  console.log(content);
});
// Code here will be executed while the file is waiting to be read

// Promise-based
fs.readFile(filename)
  .then((content) => {
    // What to do when the file is read
    console.log(content);
  })
  .catch((err) => {
    throw err;
  });
// Code here will be executed while the file is waiting to be read

// Async/await
async function readFile(filename) {
  const content = await fs.readFile(filename);
  console.log(content);
}

The core language doesn't specify any asynchronous programming features, but it's crucial when interacting with the external environment — from asking user permissions, to fetching data, to reading files. Keeping the potentially long-running operations async ensures that other processes can still run while this one waits — for example, the browser will not freeze while waiting for the user to click a button to grant permission.
If you have an async value, it's not possible to get its value synchronously. For example, if you have a promise, you can only access the eventual result via the then() method. Similarly, await can only be used in an async context, which is usually an async function or a module. Promises are never blocking — only the logic depending on the promise's result will be deferred; everything else continues to execute in the meantime. If you are a functional programmer, you may recognize promises as monads which can be mapped with then() (however, they are not proper monads because they auto-flatten; i.e. you can't have a Promise<Promise<T>>).
In fact, the single-threaded model has made Node.js a popular choice for server-side programming due to its non-blocking IO, making handling a large number of database or file-system requests very performant. However, CPU-bound (computationally intensive) tasks that are pure JavaScript will still block the main thread. To achieve real paralleling, you may need to use workers.
To learn more about asynchronous programming, you can read about using promises or follow the asynchronous JavaScript tutorial.ModulesJavaScript also specifies a module system supported by most runtimes. A module is usually a file, identified by its file path or URL. You can use the import and export statements to exchange data between modules:
jsimport { foo } from "./foo.js";

// Unexported variables are local to the module
const b = 2;

export const a = 1;

Unlike Haskell, Python, Java, etc., JavaScript module resolution is entirely host-defined — it's usually based on URLs or file paths, so relative file paths "just work" and are relative to the current module's path instead of some project root path.
However, the JavaScript language doesn't offer standard library modules — all core functionalities are powered by global variables like Math and Intl instead. This is due to the long history of JavaScript lacking a module system, and the fact that opting into the module system involves some changes to the runtime setup.
Different runtimes may use different module systems. For example, Node.js uses the package manager npm and is mostly file-system based, while Deno and browsers are fully URL-based and modules can be resolved from HTTP URLs.
For more information, see the modules guide page.Language and runtimeThroughout this page, we've constantly mentioned that certain features are language-level while others are runtime-level.
JavaScript is a general-purpose scripting language. The core language specification focuses on pure computational logic. It doesn't deal with any input/output — in fact, without extra runtime-level APIs (most notably console.log()), a JavaScript program's behavior is entirely unobservable.
A runtime, or a host, is something that feeds data to the JavaScript engine (the interpreter), provides extra global properties, and provides hooks for the engine to interact with the outside world. Module resolution, reading data, printing messages, sending network requests, etc. are all runtime-level operations. Since its inception, JavaScript has been adopted in various environments, such as browsers (which provide APIs like DOM), Node.js (which provides APIs like file system access), etc. JavaScript has been successfully integrated in web (which was its primary purpose), mobile apps, desktop apps, server-side apps, serverless, embedded systems, and more. While you learn about JavaScript core features, it's also important to understand host-provided features in order to put the knowledge to use. For example, you can read about all web platform APIs, which are implemented by browsers, and sometimes non-browsers.Further explorationThis page offers a very basic insight into how various JavaScript features compare with other languages. If you want to learn more about the language itself and the nuances of each feature, you can read the JavaScript guide and the JavaScript reference.
There are some essential parts of the language that we have omitted due to space and complexity, but you can explore on your own:

Inheritance and the prototype chain
Closures
Regular expressions
Iteration
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 15, 2023 by MDN contributors.
JavaScript data types and data structuresProgramming languages all have built-in data structures, but these often differ from one language to another. This article attempts to list the built-in data structures available in JavaScript and what properties they have. These can be used to build other data structures.
The language overview offers a similar summary of the common data types, but with more comparisons to other languages.Dynamic and weak typingJavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:
jslet foo = 42; // foo is now a number
foo = "bar"; // foo is now a string
foo = true; // foo is now a boolean

JavaScript is also a weakly typed language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.
jsconst foo = 42; // foo is a number
const result = foo + "1"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand
console.log(result); // 421

Implicit coercions are very convenient, but can create subtle bugs when conversions happen where they are not expected, or where they are expected to happen in the other direction (for example, string to number instead of number to string). For symbols and BigInts, JavaScript has intentionally disallowed certain implicit type conversions.Primitive valuesAll types except Object define immutable values represented directly at the lowest level of the language. We refer to values of these types as primitive values.
All primitive types, except null, can be tested by the typeof operator. typeof null returns "object", so one has to use === null to test for null.
All primitive types, except null and undefined, have their corresponding object wrapper types, which provide useful methods for working with the primitive values. For example, the Number object provides methods like toExponential(). When a property is accessed on a primitive value, JavaScript automatically wraps the value into the corresponding wrapper object and accesses the property on the object instead. However, accessing a property on null or undefined throws a TypeError exception, which necessitates the introduction of the optional chaining operator.



Type
typeof return value
Object wrapper




Null
"object"
N/A


Undefined
"undefined"
N/A


Boolean
"boolean"
Boolean


Number
"number"
Number


BigInt
"bigint"
BigInt


String
"string"
String


Symbol
"symbol"
Symbol



The object wrapper classes' reference pages contain more information about the methods and properties available for each type, as well as detailed descriptions for the semantics of the primitive types themselves.Null typeThe Null type is inhabited by exactly one value: null.Undefined typeThe Undefined type is inhabited by exactly one value: undefined.
Conceptually, undefined indicates the absence of a value, while null indicates the absence of an object (which could also make up an excuse for typeof null === "object"). The language usually defaults to undefined when something is devoid of a value:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) implicitly initializes the variable to undefined.
Many methods, such as Array.prototype.find() and Map.prototype.get(), return undefined when no element is found.

null is used much less often in the core language. The most important place is the end of the prototype chain — subsequently, methods that interact with prototypes, such as Object.getPrototypeOf(), Object.create(), etc., accept or return null instead of undefined.
null is a keyword, but undefined is a normal identifier that happens to be a global property. In practice, the difference is minor, since undefined should not be redefined or shadowed.Boolean typeThe Boolean type represents a logical entity and is inhabited by two values: true and false.
Boolean values are usually used for conditional operations, including ternary operators, if...else, while, etc.Number typeThe Number type is a double-precision 64-bit binary format IEEE 754 value. It is capable of storing positive floating-point numbers between 2-1074 (Number.MIN_VALUE) and 21024 (Number.MAX_VALUE) as well as negative floating-point numbers between -2-1074 and -21024, but it can only safely store integers in the range -(253 − 1) (Number.MIN_SAFE_INTEGER) to 253 − 1 (Number.MAX_SAFE_INTEGER). Outside this range, JavaScript can no longer safely represent integers; they will instead be represented by a double-precision floating point approximation. You can check if a number is within the range of safe integers using Number.isSafeInteger().
Values outside the range ±(2-1074 to 21024) are automatically converted:

Positive values greater than Number.MAX_VALUE are converted to +Infinity.
Positive values smaller than Number.MIN_VALUE are converted to +0.
Negative values smaller than -Number.MAX_VALUE are converted to -Infinity.
Negative values greater than -Number.MIN_VALUE are converted to -0.

+Infinity and -Infinity behave similarly to mathematical infinity, but with some slight differences; see Number.POSITIVE_INFINITY and Number.NEGATIVE_INFINITY for details.
The Number type has only one value with multiple representations: 0 is represented as both -0 and +0 (where 0 is an alias for +0). In practice, there is almost no difference between the different representations; for example, +0 === -0 is true. However, you are able to notice this when you divide by zero:
jsconsole.log(42 / +0); // Infinity
console.log(42 / -0); // -Infinity

NaN ("Not a Number") is a special kind of number value that's typically encountered when the result of an arithmetic operation cannot be expressed as a number. It is also the only value in JavaScript that is not equal to itself.
Although a number is conceptually a "mathematical value" and is always implicitly floating-point-encoded, JavaScript provides bitwise operators. When applying bitwise operators, the number is first converted to a 32-bit integer.

Note: Although bitwise operators can be used to represent several Boolean values within a single number using bit masking, this is usually considered a bad practice. JavaScript offers other means to represent a set of Booleans (like an array of Booleans, or an object with Boolean values assigned to named properties). Bit masking also tends to make the code more difficult to read, understand, and maintain.

It may be necessary to use such techniques in very constrained environments, like when trying to cope with the limitations of local storage, or in extreme cases (such as when each bit over the network counts). This technique should only be considered when it is the last measure that can be taken to optimize size.BigInt typeThe BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary magnitude. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit (Number.MAX_SAFE_INTEGER) for Numbers.
A BigInt is created by appending n to the end of an integer or by calling the BigInt() function.
This example demonstrates where incrementing the Number.MAX_SAFE_INTEGER returns the expected result:
js// BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
x + 1n === x + 2n; // false because 9007199254740992n and 9007199254740993n are unequal

// Number
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true because both are 9007199254740992

You can use most operators to work with BigInts, including +, *, -, **, and % — the only forbidden one is >>>. A BigInt is not strictly equal to a Number with the same mathematical value, but it is loosely so.
BigInt values are neither always more precise nor always less precise than numbers, since BigInts cannot represent fractional numbers, but can represent big integers more accurately. Neither type entails the other, and they are not mutually substitutable. A TypeError is thrown if BigInt values are mixed with regular numbers in arithmetic expressions, or if they are implicitly converted to each other.String typeThe String type represents textual data and is encoded as a sequence of 16-bit unsigned integer values representing UTF-16 code units. Each element in the string occupies a position in the string. The first element is at index 0, the next at index 1, and so on. The length of a string is the number of UTF-16 code units in it, which may not correspond to the actual number of Unicode characters; see the String reference page for more details.
JavaScript strings are immutable. This means that once a string is created, it is not possible to modify it. String methods create new strings based on the content of the current string — for example:

A substring of the original using substring().
A concatenation of two strings using the concatenation operator (+) or concat().

Beware of "stringly-typing" your code!
It can be tempting to use strings to represent complex data. Doing this comes with short-term benefits:

It is easy to build complex strings with concatenation.
Strings are easy to debug (what you see printed is always what is in the string).
Strings are the common denominator of a lot of APIs (input fields, local storage values, fetch() responses when using Response.text(), etc.) and it can be tempting to only work with strings.

With conventions, it is possible to represent any data structure in a string. This does not make it a good idea. For instance, with a separator, one could emulate a list (while a JavaScript array would be more suitable). Unfortunately, when the separator is used in one of the "list" elements, then, the list is broken. An escape character can be chosen, etc. All of this requires conventions and creates an unnecessary maintenance burden.
Use strings for textual data. When representing complex data, parse strings, and use the appropriate abstraction.Symbol typeA Symbol is a unique and immutable primitive value and may be used as the key of an Object property (see below). In some programming languages, Symbols are called "atoms". The purpose of symbols is to create unique property keys that are guaranteed not to clash with keys from other code.ObjectsIn computer science, an object is a value in memory which is possibly referenced by an identifier. In JavaScript, objects are the only mutable values. Functions are, in fact, also objects with the additional capability of being callable.PropertiesIn JavaScript, objects can be seen as a collection of properties. With the object literal syntax, a limited set of properties are initialized; then properties can be added and removed. Object properties are equivalent to key-value pairs. Property keys are either strings or symbols. Property values can be values of any type, including other objects, which enables building complex data structures.
There are two types of object properties: The data property and the accessor property. Each property has corresponding attributes. Each attribute is accessed internally by the JavaScript engine, but you can set them through Object.defineProperty(), or read them through Object.getOwnPropertyDescriptor(). You can read more about the various nuances on the Object.defineProperty() page.
Data property
Data properties associate a key with a value. It can be described by the following attributes:

value

The value retrieved by a get access of the property. Can be any JavaScript value.

writable

A boolean value indicating if the property can be changed with an assignment.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to an accessor property, and can have its attributes changed.


Accessor property
Associates a key with one of two accessor functions (get and set) to retrieve or store a value.

Note: It's important to recognize it's accessor property — not accessor method. We can give a JavaScript object class-like accessors by using a function as a value — but that doesn't make the object a class.

An accessor property has the following attributes:

get

A function called with an empty argument list to retrieve the property value whenever a get access to the value is performed. See also getters. May be undefined.

set

A function called with an argument that contains the assigned value. Executed whenever a specified property is attempted to be changed. See also setters. May be undefined.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to a data property, and can have its attributes changed.


The prototype of an object points to another object or to null — it's conceptually a hidden property of the object, commonly represented as [[Prototype]]. Properties of the object's [[Prototype]] can also be accessed on the object itself.
Objects are ad-hoc key-value pairs, so they are often used as maps. However, there can be ergonomics, security, and performance issues. Use a Map for storing arbitrary data instead. The Map reference contains a more detailed discussion of the pros & cons between plain objects and maps for storing key-value associations.DatesWhen representing dates, the best choice is to use the built-in Date utility in JavaScript.Indexed collections: Arrays and typed ArraysArrays are regular objects for which there is a particular relationship between integer-keyed properties and the length property.
Additionally, arrays inherit from Array.prototype, which provides a handful of convenient methods to manipulate arrays. For example, indexOf() searches a value in the array and push() appends an element to the array. This makes Arrays a perfect candidate to represent ordered lists.
Typed Arrays present an array-like view of an underlying binary data buffer, and offer many methods that have similar semantics to the array counterparts. "Typed array" is an umbrella term for a range of data structures, including Int8Array, Float32Array, etc. Check the typed array page for more information. Typed arrays are often used in conjunction with ArrayBuffer and DataView.Keyed collections: Maps, Sets, WeakMaps, WeakSetsThese data structures take object references as keys. Set and WeakSet represent a collection of unique values, while Map and WeakMap represent a collection of key-value associations.
You could implement Maps and Sets yourself. However, since objects cannot be compared (in the sense of < "less than", for instance), neither does the engine expose its hash function for objects, look-up performance would necessarily be linear. Native implementations of them (including WeakMaps) can have look-up performance that is approximately logarithmic to constant time.
Usually, to bind data to a DOM node, one could set properties directly on the object, or use data-* attributes. This has the downside that the data is available to any script running in the same context. Maps and WeakMaps make it easy to privately bind data to an object.
WeakMap and WeakSet only allow garbage-collectable values as keys, which are either objects or non-registered symbols, and the keys may be collected even when they remain in the collection. They are specifically used for memory usage optimization.Structured data: JSONJSON (JavaScript Object Notation) is a lightweight data-interchange format, derived from JavaScript, but used by many programming languages. JSON builds universal data structures that can be transferred between different environments and even across languages. See JSON for more details.More objects in the standard libraryJavaScript has a standard library of built-in objects. Read the reference to find out more about the built-in objects.Type coercionAs mentioned above, JavaScript is a weakly typed language. This means that you can often use a value of one type where another type is expected, and the language will convert it to the right type for you. To do so, JavaScript defines a handful of coercion rules.Primitive coercionThe primitive coercion process is used where a primitive value is expected, but there's no strong preference for what the actual type should be. This is usually when a string, a number, or a BigInt are equally acceptable. For example:

The Date() constructor, when it receives one argument that's not a Date instance — strings represent date strings, while numbers represent timestamps.
The + operator — if one operand is a string, string concatenation is performed; otherwise, numeric addition is performed.
The == operator — if one operand is a primitive while the other is an object, the object is converted to a primitive value with no preferred type.

This operation does not do any conversion if the value is already a primitive. Objects are converted to primitives by calling its [@@toPrimitive]() (with "default" as hint), valueOf(), and toString() methods, in that order. Note that primitive conversion calls valueOf() before toString(), which is similar to the behavior of number coercion but different from string coercion.
The [@@toPrimitive]() method, if present, must return a primitive — returning an object results in a TypeError. For valueOf() and toString(), if one returns an object, the return value is ignored and the other's return value is used instead; if neither is present, or neither returns a primitive, a TypeError is thrown. For example, in the following code:
jsconsole.log({} + []); // "[object Object]"

Neither {} nor [] have a [@@toPrimitive]() method. Both {} and [] inherit valueOf() from Object.prototype.valueOf, which returns the object itself. Since the return value is an object, it is ignored. Therefore, toString() is called instead. {}.toString() returns "[object Object]", while [].toString() returns "", so the result is their concatenation: "[object Object]".
The [@@toPrimitive]() method always takes precedence when doing conversion to any primitive type. Primitive conversion generally behaves like number conversion, because valueOf() is called in priority; however, objects with custom [@@toPrimitive]() methods can choose to return any primitive. Date and Symbol objects are the only built-in objects that override the [@@toPrimitive]() method. Date.prototype[@@toPrimitive]() treats the "default" hint as if it's "string", while Symbol.prototype[@@toPrimitive]() ignores the hint and always returns a symbol.Numeric coercionThere are two numeric types: Number and BigInt. Sometimes the language specifically expects a number or a BigInt (such as Array.prototype.slice(), where the index must be a number); other times, it may tolerate either and perform different operations depending on the operand's type. For strict coercion processes that do not allow implicit conversion from the other type, see number coercion and BigInt coercion.
Numeric coercion is nearly the same as number coercion, except that BigInts are returned as-is instead of causing a TypeError. Numeric coercion is used by all arithmetic operators, since they are overloaded for both numbers and BigInts. The only exception is unary plus, which always does number coercion.Other coercionsAll data types, except Null, Undefined, and Symbol, have their respective coercion process. See string coercion, boolean coercion, and object coercion for more details.
As you may have noticed, there are three distinct paths through which objects may be converted to primitives:

Primitive coercion: [@@toPrimitive]("default") → valueOf() → toString()
Numeric coercion, number coercion, BigInt coercion: [@@toPrimitive]("number") → valueOf() → toString()
String coercion: [@@toPrimitive]("string") → toString() → valueOf()

In all cases, [@@toPrimitive](), if present, must be callable and return a primitive, while valueOf or toString will be ignored if they are not callable or return an object. At the end of the process, if successful, the result is guaranteed to be a primitive. The resulting primitive is then subject to further coercions depending on the context.See also
JavaScript Data Structures and Algorithms by Oleksii Trekhleb
Computer Science in JavaScript by Nicholas C. Zakas
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 20, 2023 by MDN contributors.
Equality comparisons and samenessJavaScript provides three different value-comparison operations:

=== — strict equality (triple equals)
== — loose equality (double equals)
Object.is()

Which operation you choose depends on what sort of comparison you are looking to perform. Briefly:

Double equals (==) will perform a type conversion when comparing two things, and will handle NaN, -0, and +0 specially to conform to IEEE 754 (so NaN != NaN, and -0 == +0);
Triple equals (===) will do the same comparison as double equals (including the special handling for NaN, -0, and +0) but without type conversion; if the types differ, false is returned.
Object.is() does no type conversion and no special handling for NaN, -0, and +0 (giving it the same behavior as === except on those special numeric values).

They correspond to three of four equality algorithms in JavaScript:

IsLooselyEqual: ==
IsStrictlyEqual: ===
SameValue: Object.is()
SameValueZero: used by many built-in operations

Note that the distinction between these all have to do with their handling of primitives; none of them compares whether the parameters are conceptually similar in structure. For any non-primitive objects x and y which have the same structure but are distinct objects themselves, all of the above forms will evaluate to false.Strict equality using ===Strict equality compares two values for equality. Neither value is implicitly converted to some other value before being compared. If the values have different types, the values are considered unequal. If the values have the same type, are not numbers, and have the same value, they're considered equal. Finally, if both values are numbers, they're considered equal if they're both not NaN and are the same value, or if one is +0 and one is -0.
jsconst num = 0;
const obj = new String("0");
const str = "0";

console.log(num === num); // true
console.log(obj === obj); // true
console.log(str === str); // true

console.log(num === obj); // false
console.log(num === str); // false
console.log(obj === str); // false
console.log(null === undefined); // false
console.log(obj === null); // false
console.log(obj === undefined); // false

Strict equality is almost always the correct comparison operation to use. For all values except numbers, it uses the obvious semantics: a value is only equal to itself. For numbers it uses slightly different semantics to gloss over two different edge cases. The first is that floating point zero is either positively or negatively signed. This is useful in representing certain mathematical solutions, but as most situations don't care about the difference between +0 and -0, strict equality treats them as the same value. The second is that floating point includes the concept of a not-a-number value, NaN, to represent the solution to certain ill-defined mathematical problems: negative infinity added to positive infinity, for example. Strict equality treats NaN as unequal to every other value — including itself. (The only case in which (x !== x) is true is when x is NaN.)
Besides ===, strict equality is also used by array index-finding methods including Array.prototype.indexOf(), Array.prototype.lastIndexOf(), TypedArray.prototype.indexOf(), TypedArray.prototype.lastIndexOf(), and case-matching. This means you cannot use indexOf(NaN) to find the index of a NaN value in an array, or use NaN as a case value in a switch statement and make it match anything.
jsconsole.log([NaN].indexOf(NaN)); // -1
switch (NaN) {
  case NaN:
    console.log("Surprise"); // Nothing is logged
}
Loose equality using ==Loose equality is symmetric: A == B always has identical semantics to B == A for any values of A and B (except for the order of applied conversions). The behavior for performing loose equality using == is as follows:

If the operands have the same type, they are compared as follows:
    
Object: return true only if both operands reference the same object.
String: return true only if both operands have the same characters in the same order.
Number: return true only if both operands have the same value. +0 and -0 are treated as the same value. If either operand is NaN, return false; so NaN is never equal to NaN.
Boolean: return true only if operands are both true or both false.
BigInt: return true only if both operands have the same value.
Symbol: return true only if both operands reference the same symbol.


If one of the operands is null or undefined, the other must also be null or undefined to return true. Otherwise return false.
If one of the operands is an object and the other is a primitive, convert the object to a primitive.
At this step, both operands are converted to primitives (one of String, Number, Boolean, Symbol, and BigInt). The rest of the conversion is done case-by-case.
    
If they are of the same type, compare them using step 1.
If one of the operands is a Symbol but the other is not, return false.
If one of the operands is a Boolean but the other is not, convert the boolean to a number: true is converted to 1, and false is converted to 0. Then compare the two operands loosely again.
Number to String: convert the string to a number. Conversion failure results in NaN, which will guarantee the equality to be false.
Number to BigInt: compare by their numeric value. If the number is ±Infinity or NaN, return false.
String to BigInt: convert the string to a BigInt using the same algorithm as the BigInt() constructor. If conversion fails, return false.



Traditionally, and according to ECMAScript, all primitives and objects are loosely unequal to undefined and null. But most browsers permit a very narrow class of objects (specifically, the document.all object for any page), in some contexts, to act as if they emulate the value undefined. Loose equality is one such context: null == A and undefined == A evaluate to true if, and only if, A is an object that emulates undefined. In all other cases an object is never loosely equal to undefined or null.
In most cases, using loose equality is discouraged. The result of a comparison using strict equality is easier to predict, and may evaluate more quickly due to the lack of type coercion.
The following example demonstrates loose equality comparisons involving the number primitive 0, the bigint primitive 0n, the string primitive '0', and an object whose toString() value is '0'.
jsconst num = 0;
const big = 0n;
const str = "0";
const obj = new String("0");

console.log(num == str); // true
console.log(big == num); // true
console.log(str == big); // true

console.log(num == obj); // true
console.log(big == obj); // true
console.log(str == obj); // true

Loose equality is only used by the == operator.Same-value equality using Object.is()Same-value equality determines whether two values are functionally identical in all contexts. (This use case demonstrates an instance of the Liskov substitution principle.) One instance occurs when an attempt is made to mutate an immutable property:
js// Add an immutable NEGATIVE_ZERO property to the Number constructor.
Object.defineProperty(Number, "NEGATIVE_ZERO", {
  value: -0,
  writable: false,
  configurable: false,
  enumerable: false,
});

function attemptMutation(v) {
  Object.defineProperty(Number, "NEGATIVE_ZERO", { value: v });
}

Object.defineProperty will throw an exception when attempting to change an immutable property, but it does nothing if no actual change is requested. If v is -0, no change has been requested, and no error will be thrown. Internally, when an immutable property is redefined, the newly-specified value is compared against the current value using same-value equality.
Same-value equality is provided by the Object.is method. It's used almost everywhere in the language where a value of equivalent identity is expected.Same-value-zero equalitySimilar to same-value equality, but +0 and -0 are considered equal.
Same-value-zero equality is not exposed as a JavaScript API, but can be implemented with custom code:
jsfunction sameValueZero(x, y) {
  if (typeof x === "number" && typeof y === "number") {
    // x and y are equal (may be -0 and 0) or they are both NaN
    return x === y || (x !== x && y !== y);
  }
  return x === y;
}

Same-value-zero only differs from strict equality by treating NaN as equivalent, and only differs from same-value equality by treating -0 as equivalent to 0. This makes it usually have the most sensible behavior during searching, especially when working with NaN. It's used by Array.prototype.includes(), TypedArray.prototype.includes(), as well as Map and Set methods for comparing key equality.Comparing equality methodsPeople often compare double equals and triple equals by saying one is an "enhanced" version of the other. For example, double equals could be said as an extended version of triple equals, because the former does everything that the latter does, but with type conversion on its operands — for example, 6 == "6". Alternatively, it can be claimed that double equals is the baseline, and triple equals is an enhanced version, because it requires the two operands to be the same type, so it adds an extra constraint.
However, this way of thinking implies that the equality comparisons form a one-dimensional "spectrum" where "totally strict" lies on one end and "totally loose" lies on the other. This model falls short with Object.is, because it isn't "looser" than double equals or "stricter" than triple equals, nor does it fit somewhere in between (i.e., being both stricter than double equals, but looser than triple equals). We can see from the sameness comparisons table below that this is due to the way that Object.is handles NaN. Notice that if Object.is(NaN, NaN) evaluated to false, we could say that it fits on the loose/strict spectrum as an even stricter form of triple equals, one that distinguishes between -0 and +0. The NaN handling means this is untrue, however. Unfortunately, Object.is has to be thought of in terms of its specific characteristics, rather than its looseness or strictness with regard to the equality operators.



x
y
==
===
Object.is
SameValueZero




undefined
undefined
✅ true
✅ true
✅ true
✅ true


null
null
✅ true
✅ true
✅ true
✅ true


true
true
✅ true
✅ true
✅ true
✅ true


false
false
✅ true
✅ true
✅ true
✅ true


'foo'
'foo'
✅ true
✅ true
✅ true
✅ true


0
0
✅ true
✅ true
✅ true
✅ true


+0
-0
✅ true
✅ true
❌ false
✅ true


+0
0
✅ true
✅ true
✅ true
✅ true


-0
0
✅ true
✅ true
❌ false
✅ true


0n
-0n
✅ true
✅ true
✅ true
✅ true


0
false
✅ true
❌ false
❌ false
❌ false


""
false
✅ true
❌ false
❌ false
❌ false


""
0
✅ true
❌ false
❌ false
❌ false


'0'
0
✅ true
❌ false
❌ false
❌ false


'17'
17
✅ true
❌ false
❌ false
❌ false


[1, 2]
'1,2'
✅ true
❌ false
❌ false
❌ false


new String('foo')
'foo'
✅ true
❌ false
❌ false
❌ false


null
undefined
✅ true
❌ false
❌ false
❌ false


null
false
❌ false
❌ false
❌ false
❌ false


undefined
false
❌ false
❌ false
❌ false
❌ false


{ foo: 'bar' }
{ foo: 'bar' }
❌ false
❌ false
❌ false
❌ false


new String('foo')
new String('foo')
❌ false
❌ false
❌ false
❌ false


0
null
❌ false
❌ false
❌ false
❌ false


0
NaN
❌ false
❌ false
❌ false
❌ false


'foo'
NaN
❌ false
❌ false
❌ false
❌ false


NaN
NaN
❌ false
❌ false
✅ true
✅ true


When to use Object.is() versus triple equalsIn general, the only time Object.is's special behavior towards zeros is likely to be of interest is in the pursuit of certain meta-programming schemes, especially regarding property descriptors, when it is desirable for your work to mirror some of the characteristics of Object.defineProperty. If your use case does not require this, it is suggested to avoid Object.is and use === instead. Even if your requirements involve having comparisons between two NaN values evaluate to true, generally it is easier to special-case the NaN checks (using the isNaN method available from previous versions of ECMAScript) than it is to work out how surrounding computations might affect the sign of any zeros you encounter in your comparison.
Here's a non-exhaustive list of built-in methods and operators that might cause a distinction between -0 and +0 to manifest itself in your code:

- (unary negation)

Consider the following example:
jsconst stoppingForce = obj.mass * -obj.velocity;

If obj.velocity is 0 (or computes to 0), a -0 is introduced at that place and propagates out into stoppingForce.

Math.atan2, Math.ceil, Math.pow, Math.round

In some cases, it's possible for a -0 to be introduced into an expression as a return value of these methods even when no -0 exists as one of the parameters. For example, using Math.pow to raise -Infinity to the power of any negative, odd exponent evaluates to -0. Refer to the documentation for the individual methods.

Math.floor, Math.max, Math.min, Math.sin, Math.sqrt, Math.tan

It's possible to get a -0 return value out of these methods in some cases where a -0 exists as one of the parameters. E.g., Math.min(-0, +0) evaluates to -0. Refer to the documentation for the individual methods.

~, <<, >>

Each of these operators uses the ToInt32 algorithm internally. Since there is only one representation for 0 in the internal 32-bit integer type, -0 will not survive a round trip after an inverse operation. E.g., both Object.is(~~(-0), -0) and Object.is(-0 << 2 >> 2, -0) evaluate to false.


Relying on Object.is when the signedness of zeros is not taken into account can be hazardous. Of course, when the intent is to distinguish between -0 and +0, it does exactly what's desired.Caveat: Object.is() and NaNThe Object.is specification treats all instances of NaN as the same object. However, since typed arrays are available, we can have distinct floating point representations of NaN which don't behave identically in all contexts. For example:
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
// Change the first bit, which is the sign bit and doesn't matter for NaN
n[0] = 1;
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
See also
JS Comparison Table by dorey
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 7, 2023 by MDN contributors.
Enumerability and ownership of propertiesEvery property in JavaScript objects can be classified by three factors:

Enumerable or non-enumerable;
String or symbol;
Own property or inherited property from the prototype chain.

Enumerable properties are those properties whose internal enumerable flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Properties defined via Object.defineProperty and such are not enumerable by default. Most iteration means (such as for...in loops and Object.keys) only visit enumerable keys.
Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain.
All properties, enumerable or not, string or symbol, own or inherited, can be accessed with dot notation or bracket notation. In this section, we will focus on JavaScript means that visit a group of object properties one-by-one.Querying object propertiesThere are four built-in ways to query a property of an object. They all support both string and symbol keys. The following table summarizes when each method returns true.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




propertyIsEnumerable()
true ✅
false ❌
false ❌
false ❌


hasOwnProperty()
true ✅
false ❌
true ✅
false ❌


Object.hasOwn()
true ✅
false ❌
true ✅
false ❌


in
true ✅
true ✅
true ✅
true ✅


Traversing object propertiesThere are many methods in JavaScript that traverse a group of properties of an object. Sometimes, these properties are returned as an array; sometimes, they are iterated one-by-one in a loop; sometimes, they are used for constructing or mutating another object. The following table summarizes when a property may be visited.
Methods that only visit string properties or only symbol properties will have an extra note. ✅ means a property of this type will be visited; ❌ means it will not.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




Object.keysObject.valuesObject.entries
✅(strings)
❌
❌
❌


Object.getOwnPropertyNames
✅(strings)
❌
✅(strings)
❌


Object.getOwnPropertySymbols
✅(symbols)
❌
✅(symbols)
❌


Object.getOwnPropertyDescriptors
✅
❌
✅
❌


Reflect.ownKeys
✅
❌
✅
❌


for...in
✅(strings)
✅(strings)
❌
❌


Object.assign(After the first parameter)
✅
❌
❌
❌


Object spread
✅
❌
❌
❌


Obtaining properties by enumerability/ownershipNote that this is not the most efficient algorithm for all cases, but useful for a quick demonstration.

Detection can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).includes(prop)
Iteration can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).forEach((value, prop) => {}); (or use filter(), map(), etc.)

jsconst SimplePropertyRetriever = {
  getOwnEnumerables(obj) {
    return this._getPropertyNames(obj, true, false, this._enumerable);
    // Or could use for...in filtered with Object.hasOwn or just this: return Object.keys(obj);
  },
  getOwnNonenumerables(obj) {
    return this._getPropertyNames(obj, true, false, this._notEnumerable);
  },
  getOwnEnumerablesAndNonenumerables(obj) {
    return this._getPropertyNames(
      obj,
      true,
      false,
      this._enumerableAndNotEnumerable,
    );
    // Or just use: return Object.getOwnPropertyNames(obj);
  },
  getPrototypeEnumerables(obj) {
    return this._getPropertyNames(obj, false, true, this._enumerable);
  },
  getPrototypeNonenumerables(obj) {
    return this._getPropertyNames(obj, false, true, this._notEnumerable);
  },
  getPrototypeEnumerablesAndNonenumerables(obj) {
    return this._getPropertyNames(
      obj,
      false,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  getOwnAndPrototypeEnumerables(obj) {
    return this._getPropertyNames(obj, true, true, this._enumerable);
    // Or could use unfiltered for...in
  },
  getOwnAndPrototypeNonenumerables(obj) {
    return this._getPropertyNames(obj, true, true, this._notEnumerable);
  },
  getOwnAndPrototypeEnumerablesAndNonenumerables(obj) {
    return this._getPropertyNames(
      obj,
      true,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  // Private static property checker callbacks
  _enumerable(obj, prop) {
    return Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _notEnumerable(obj, prop) {
    return !Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _enumerableAndNotEnumerable(obj, prop) {
    return true;
  },
  // Inspired by http://stackoverflow.com/a/8024294/271577
  _getPropertyNames(obj, iterateSelf, iteratePrototype, shouldInclude) {
    const props = [];
    do {
      if (iterateSelf) {
        Object.getOwnPropertyNames(obj).forEach((prop) => {
          if (props.indexOf(prop) === -1 && shouldInclude(obj, prop)) {
            props.push(prop);
          }
        });
      }
      if (!iteratePrototype) {
        break;
      }
      iterateSelf = true;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return props;
  },
};
See also
in
for...in
Object.prototype.hasOwnProperty()
Object.prototype.propertyIsEnumerable()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
Object.getOwnPropertyDescriptors()
Object.hasOwn()
Reflect.ownKeys()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
ClosuresA closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.Lexical scopingConsider the following example code:
jsfunction init() {
  var name = "Mozilla"; // name is a local variable created by init
  function displayName() {
    // displayName() is the inner function, that forms the closure
    console.log(name); // use variable declared in the parent function
  }
  displayName();
}
init();

init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer functions, displayName() can access the variable name declared in the parent function, init().
Run the code using this JSFiddle link and notice that the console.log() statement within the displayName() function successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.
In this particular example, the scope is called a function scope, because the variable is accessible and only accessible within the function body where it's declared.Scoping with let and constTraditionally (before ES6), JavaScript only had two kinds of scopes: function scope and global scope. Variables declared with var are either function-scoped or global-scoped, depending on whether they are declared within a function or outside a function. This can be tricky, because blocks with curly braces do not create scopes:
jsif (Math.random() > 0.5) {
  var x = 1;
} else {
  var x = 2;
}
console.log(x);

For people from other languages (e.g. C, Java) where blocks create scopes, the above code should throw an error on the console.log line, because we are outside the scope of x in either block. However, because blocks don't create scopes for var, the var statements here actually create a global variable. There is also a practical example introduced below that illustrates how this can cause actual bugs when combined with closures.
In ES6, JavaScript introduced the let and const declarations, which, among other things like temporal dead zones, allow you to create block-scoped variables.
jsif (Math.random() > 0.5) {
  const x = 1;
} else {
  const x = 2;
}
console.log(x); // ReferenceError: x is not defined

In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. In addition, ES6 introduced modules, which introduced another kind of scope. Closures are able to capture variables in all these scopes, which we will introduce later.ClosureConsider the following code example:
jsfunction makeFunc() {
  const name = "Mozilla";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();

Running this code has exactly the same effect as the previous example of the init() function above. What's different (and interesting) is that the displayName() inner function is returned from the outer function before being executed.
At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function's execution. Once makeFunc() finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript.
The reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created. In this case, myFunc is a reference to the instance of the function displayName that is created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use, and "Mozilla" is passed to console.log.
Here's a slightly more interesting example—a makeAdder function:
jsfunction makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12

In this example, we have defined a function makeAdder(x), that takes a single argument x, and returns a new function. The function it returns takes a single argument y, and returns the sum of x and y.
In essence, makeAdder is a function factory. It creates functions that can add a specific value to their argument. In the above example, the function factory creates two new functions—one that adds five to its argument, and one that adds 10.
add5 and add10 both form closures. They share the same function body definition, but store different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10.Practical closuresClosures are useful because they let you associate data (the lexical environment) with a function that operates on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate data (the object's properties) with one or more methods.
Consequently, you can use a closure anywhere that you might normally use an object with only a single method.
Situations where you might want to do this are particularly common on the web. Much of the code written in front-end JavaScript is event-based. You define some behavior, and then attach it to an event that is triggered by the user (such as a click or a keypress). The code is attached as a callback (a single function that is executed in response to the event).
For instance, suppose we want to add buttons to a page to adjust the text size. One way of doing this is to specify the font-size of the body element (in pixels), and then set the size of the other elements on the page (such as headers) using the relative em unit:
cssbody {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
}

h1 {
  font-size: 1.5em;
}

h2 {
  font-size: 1.2em;
}

Such interactive text size buttons can change the font-size property of the body element, and the adjustments are picked up by other elements on the page thanks to the relative units.
Here's the JavaScript:
jsfunction makeSizer(size) {
  return function () {
    document.body.style.fontSize = `${size}px`;
  };
}

const size12 = makeSizer(12);
const size14 = makeSizer(14);
const size16 = makeSizer(16);

size12, size14, and size16 are now functions that resize the body text to 12, 14, and 16 pixels, respectively. You can attach them to buttons as demonstrated in the following code example.
jsdocument.getElementById("size-12").onclick = size12;
document.getElementById("size-14").onclick = size14;
document.getElementById("size-16").onclick = size16;

html<button id="size-12">12</button>
<button id="size-14">14</button>
<button id="size-16">16</button>

Run the code using JSFiddle.Emulating private methods with closuresLanguages such as Java allow you to declare methods as private, meaning that they can be called only by other methods in the same class.
JavaScript, prior to classes, didn't have a native way of declaring private methods, but it was possible to emulate private methods using closures. Private methods aren't just useful for restricting access to code. They also provide a powerful way of managing your global namespace.
The following code illustrates how to use closures to define public functions that can access private functions and variables. Note that these closures follow the Module Design Pattern.
jsconst counter = (function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }

  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
})();

console.log(counter.value()); // 0.

counter.increment();
counter.increment();
console.log(counter.value()); // 2.

counter.decrement();
console.log(counter.value()); // 1.

In previous examples, each closure had its own lexical environment. Here though, there is a single lexical environment that is shared by the three functions: counter.increment, counter.decrement, and counter.value.
The shared lexical environment is created in the body of an anonymous function, which is executed as soon as it has been defined (also known as an IIFE). The lexical environment contains two private items: a variable called privateCounter, and a function called changeBy. You can't access either of these private members from outside the anonymous function. Instead, you can access them using the three public functions that are returned from the anonymous wrapper.
Those three public functions form closures that share the same lexical environment. Thanks to JavaScript's lexical scoping, they each have access to the privateCounter variable and the changeBy function.
jsconst makeCounter = function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
};

const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1.value()); // 0.

counter1.increment();
counter1.increment();
console.log(counter1.value()); // 2.

counter1.decrement();
console.log(counter1.value()); // 1.
console.log(counter2.value()); // 0.

Notice how the two counters maintain their independence from one another. Each closure references a different version of the privateCounter variable through its own closure. Each time one of the counters is called, its lexical environment changes by changing the value of this variable. Changes to the variable value in one closure don't affect the value in the other closure.

Note: Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation.
Closure scope chainEvery closure has three scopes:

Local scope (Own scope)
Enclosing scope (can be block, function, or module scope)
Global scope

A common mistake is not realizing that in the case where the outer function is itself a nested function, access to the outer function's scope includes the enclosing scope of the outer function—effectively creating a chain of function scopes. To demonstrate, consider the following example code.
js// global scope
const e = 10;
function sum(a) {
  return function (b) {
    return function (c) {
      // outer functions scope
      return function (d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

console.log(sum(1)(2)(3)(4)); // 20

You can also write without anonymous functions:
js// global scope
const e = 10;
function sum(a) {
  return function sum2(b) {
    return function sum3(c) {
      // outer functions scope
      return function sum4(d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

const sum2 = sum(1);
const sum3 = sum2(2);
const sum4 = sum3(3);
const result = sum4(4);
console.log(result); // 20

In the example above, there's a series of nested functions, all of which have access to the outer functions' scope. In this context, we can say that closures have access to all outer function scopes.
Closures can capture variables in block scopes and module scopes as well. For example, the following creates a closure over the block-scoped variable y:
jsfunction outer() {
  let getY;
  {
    const y = 6;
    getY = () => y;
  }
  console.log(typeof y); // undefined
  console.log(getY()); // 6
}

outer();

Closures over modules can be more interesting.
js// myModule.js
let x = 5;
export const getX = () => x;
export const setX = (val) => {
  x = val;
};

Here, the module exports a pair of getter-setter functions, which close over the module-scoped variable x. Even when x is not directly accessible from other modules, it can be read and written with the functions.
jsimport { getX, setX } from "./myModule.js";

console.log(getX()); // 5
setX(6);
console.log(getX()); // 6

Closures can close over imported values as well, which are regarded as live bindings, because when the original value changes, the imported one changes accordingly.
js// myModule.js
export let x = 1;
export const setX = (val) => {
  x = val;
};

js// closureCreator.js
import { x } from "./myModule.js";

export const getX = () => x; // Close over an imported live binding

jsimport { getX } from "./closureCreator.js";
import { setX } from "./myModule.js";

console.log(getX()); // 1
setX(2);
console.log(getX()); // 2
Creating closures in loops: A common mistakePrior to the introduction of the let keyword, a common problem with closures occurred when you created them inside a loop. To demonstrate, consider the following example code.
html<p id="help">Helpful notes will appear here</p>
<p>Email: <input type="text" id="email" name="email" /></p>
<p>Name: <input type="text" id="name" name="name" /></p>
<p>Age: <input type="text" id="age" name="age" /></p>

jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    // Culprit is the use of `var` on this line
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function () {
      showHelp(item.help);
    };
  }
}

setupHelp();

Try running the code in JSFiddle.
The helpText array defines three helpful hints, each associated with the ID of an input field in the document. The loop cycles through these definitions, hooking up an onfocus event to each one that shows the associated help method.
If you try this code out, you'll see that it doesn't work as expected. No matter what field you focus on, the message about your age will be displayed.
The reason for this is that the functions assigned to onfocus form closures; they consist of the function definition and the captured environment from the setupHelp function's scope. Three closures have been created by the loop, but each one shares the same single lexical environment, which has a variable with changing values (item). This is because the variable item is declared with var and thus has function scope due to hoisting. The value of item.help is determined when the onfocus callbacks are executed. Because the loop has already run its course by that time, the item variable object (shared by all three closures) has been left pointing to the last entry in the helpText list.
One solution in this case is to use more closures: in particular, to use a function factory as described earlier:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function makeHelpCallback(help) {
  return function () {
    showHelp(help);
  };
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}

setupHelp();

Run the code using this JSFiddle link.
This works as expected. Rather than the callbacks all sharing a single lexical environment, the makeHelpCallback function creates a new lexical environment for each callback, in which help refers to the corresponding string from the helpText array.
One other way to write the above using anonymous closures is:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    (function () {
      var item = helpText[i];
      document.getElementById(item.id).onfocus = function () {
        showHelp(item.help);
      };
    })(); // Immediate event listener attachment with the current value of item (preserved until iteration).
  }
}

setupHelp();

If you don't want to use more closures, you can use the let or const keyword:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  const helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (let i = 0; i < helpText.length; i++) {
    const item = helpText[i];
    document.getElementById(item.id).onfocus = () => {
      showHelp(item.help);
    };
  }
}

setupHelp();

This example uses const instead of var, so every closure binds the block-scoped variable, meaning that no additional closures are required.
Another alternative could be to use forEach() to iterate over the helpText array and attach a listener to each <input>, as shown:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  helpText.forEach(function (text) {
    document.getElementById(text.id).onfocus = function () {
      showHelp(text.help);
    };
  });
}

setupHelp();
Performance considerationsAs mentioned previously, each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption.
For instance, when creating a new object/class, methods should normally be associated to the object's prototype rather than defined into the object constructor. The reason is that whenever the constructor is called, the methods would get reassigned (that is, for every object creation).
Consider the following case:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
  this.getName = function () {
    return this.name;
  };

  this.getMessage = function () {
    return this.message;
  };
}

Because the previous code does not take advantage of the benefits of using closures in this particular instance, we could instead rewrite it to avoid using closures as follows:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype = {
  getName() {
    return this.name;
  },
  getMessage() {
    return this.message;
  },
};

However, redefining the prototype is not recommended. The following example instead appends to the existing prototype:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype.getName = function () {
  return this.name;
};
MyObject.prototype.getMessage = function () {
  return this.message;
};

In the two previous examples, the inherited prototype can be shared by all objects and the method definitions need not occur at every object creation. See Inheritance and the prototype chain for more.Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Inheritance and the prototype chainIn programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript.
JavaScript is a bit confusing for developers experienced in class-based languages (like Java or C++), as it is dynamic and does not have static types. While this confusion is often considered to be one of JavaScript's weaknesses, the prototypal inheritance model itself is, in fact, more powerful than the classic model. It is, for example, fairly trivial to build a classic model on top of a prototypal model — which is how classes are implemented.
Although classes are now widely adopted and have become a new paradigm in JavaScript, classes do not bring a new inheritance pattern. While classes abstract most of the prototypal mechanism away, understanding how prototypes work under the hood is still useful.Inheritance with the prototype chainInheriting propertiesJavaScript objects are dynamic "bags" of properties (referred to as own properties). JavaScript objects have a link to a prototype object. When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached.

Note: Following the ECMAScript standard, the notation someObject.[[Prototype]] is used to designate the prototype of someObject. The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines. To prevent confusion while keeping it succinct, in our notation we will avoid using obj.__proto__ but use obj.[[Prototype]] instead. This corresponds to Object.getPrototypeOf(obj).
It should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor. We will discuss the prototype property of constructor functions in a later section.

There are several ways to specify the [[Prototype]] of an object, which are listed in a later section. For now, we will use the __proto__ syntax for illustration. It's worth noting that the { __proto__: ... } syntax is different from the obj.__proto__ accessor: the former is standard and not deprecated.
In an object literal like { a: 1, b: 2, __proto__: c }, the value c (which has to be either null or another object) will become the [[Prototype]] of the object represented by the literal, while the other keys like a and b will become the own properties of the object. This syntax reads very naturally, since [[Prototype]] is just an "internal property" of the object.
Here is what happens when trying to access a property:
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
  },
};

// o.[[Prototype]] has properties b and c.
// o.[[Prototype]].[[Prototype]] is Object.prototype (we will explain
// what that means later).
// Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
// This is the end of the prototype chain, as null,
// by definition, has no [[Prototype]].
// Thus, the full prototype chain looks like:
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null

console.log(o.a); // 1
// Is there an 'a' own property on o? Yes, and its value is 1.

console.log(o.b); // 2
// Is there a 'b' own property on o? Yes, and its value is 2.
// The prototype also has a 'b' property, but it's not visited.
// This is called Property Shadowing

console.log(o.c); // 4
// Is there a 'c' own property on o? No, check its prototype.
// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

console.log(o.d); // undefined
// Is there a 'd' own property on o? No, check its prototype.
// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
// o.[[Prototype]].[[Prototype]] is Object.prototype and
// there is no 'd' property by default, check its prototype.
// o.[[Prototype]].[[Prototype]].[[Prototype]] is null, stop searching,
// no property found, return undefined.

Setting a property to an object creates an own property. The only exception to the getting and setting behavior rules is when it's intercepted by a getter or setter.
Similarly, you can create longer prototype chains, and a property will be sought on all of them.
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
    __proto__: {
      d: 5,
    },
  },
};

// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> { d: 5 } ---> Object.prototype ---> null

console.log(o.d); // 5
Inheriting "methods"JavaScript does not have "methods" in the form that class-based languages define them. In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding).
When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property.
jsconst parent = {
  value: 2,
  method() {
    return this.value + 1;
  },
};

console.log(parent.method()); // 3
// When calling parent.method in this case, 'this' refers to parent

// child is an object that inherits from parent
const child = {
  __proto__: parent,
};
console.log(child.method()); // 3
// When child.method is called, 'this' refers to child.
// So when child inherits the method of parent,
// The property 'value' is sought on child. However, since child
// doesn't have an own property called 'value', the property is
// found on the [[Prototype]], which is parent.value.

child.value = 4; // assign the value 4 to the property 'value' on child.
// This shadows the 'value' property on parent.
// The child object now looks like:
// { value: 4, __proto__: { value: 2, method: [Function] } }
console.log(child.method()); // 5
// Since child now has the 'value' property, 'this.value' means
// child.value instead
ConstructorsThe power of prototypes is that we can reuse a set of properties if they should be present on every instance — especially for methods. Suppose we are to create a series of boxes, where each box is an object that contains a value which can be accessed through a getValue function. A naive implementation would be:
jsconst boxes = [
  { value: 1, getValue() { return this.value; } },
  { value: 2, getValue() { return this.value; } },
  { value: 3, getValue() { return this.value; } },
];

This is subpar, because each instance has its own function property that does the same thing, which is redundant and unnecessary. Instead, we can move getValue to the [[Prototype]] of all boxes:
jsconst boxPrototype = {
  getValue() {
    return this.value;
  },
};

const boxes = [
  { value: 1, __proto__: boxPrototype },
  { value: 2, __proto__: boxPrototype },
  { value: 3, __proto__: boxPrototype },
];

This way, all boxes' getValue method will refer to the same function, lowering memory usage. However, manually binding the __proto__ for every object creation is still very inconvenient. This is when we would use a constructor function, which automatically sets the [[Prototype]] for every object manufactured. Constructors are functions called with new.
js// A constructor function
function Box(value) {
  this.value = value;
}

// Properties all boxes created from the Box() constructor
// will have
Box.prototype.getValue = function () {
  return this.value;
};

const boxes = [new Box(1), new Box(2), new Box(3)];

We say that new Box(1) is an instance created from the Box constructor function. Box.prototype is not much different from the boxPrototype object we created previously — it's just a plain object. Every instance created from a constructor function will automatically have the constructor's prototype property as its [[Prototype]] — that is, Object.getPrototypeOf(new Box()) === Box.prototype. Constructor.prototype by default has one own property: constructor, which references the constructor function itself — that is, Box.prototype.constructor === Box. This allows one to access the original constructor from any instance.

Note: If a non-primitive is returned from the constructor function, that value will become the result of the new expression. In this case the [[Prototype]] may not be correctly bound — but this should not happen much in practice.

The above constructor function can be rewritten in classes as:
jsclass Box {
  constructor(value) {
    this.value = value;
  }

  // Methods are created on Box.prototype
  getValue() {
    return this.value;
  }
}

Classes are syntax sugar over constructor functions, which means you can still manipulate Box.prototype to change the behavior of all instances. However, because classes are designed to be an abstraction over the underlying prototype mechanism, we will use the more-lightweight constructor function syntax for this tutorial to fully demonstrate how prototypes work.
Because Box.prototype references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype.
jsfunction Box(value) {
  this.value = value;
}
Box.prototype.getValue = function () {
  return this.value;
};
const box = new Box(1);

// Mutate Box.prototype after an instance has already been created
Box.prototype.getValue = function () {
  return this.value + 1;
};
box.getValue(); // 2

A corollary is, re-assigning Constructor.prototype (Constructor.prototype = ...) is a bad idea for two reasons:

The [[Prototype]] of instances created before the reassignment is now referencing a different object from the [[Prototype]] of instances created after the reassignment — mutating one's [[Prototype]] no longer mutates the other.
Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation. Some built-in operations will read the constructor property as well, and if it is not set, they may not work as expected.

Constructor.prototype is only useful when constructing instances. It has nothing to do with Constructor.[[Prototype]], which is the constructor function's own prototype, which is Function.prototype — that is, Object.getPrototypeOf(Constructor) === Function.prototype.Implicit constructors of literalsSome literal syntaxes in JavaScript create instances that implicitly set the [[Prototype]]. For example:
js// Object literals (without the `__proto__` key) automatically
// have `Object.prototype` as their `[[Prototype]]`
const object = { a: 1 };
Object.getPrototypeOf(object) === Object.prototype; // true

// Array literals automatically have `Array.prototype` as their `[[Prototype]]`
const array = [1, 2, 3];
Object.getPrototypeOf(array) === Array.prototype; // true

// RegExp literals automatically have `RegExp.prototype` as their `[[Prototype]]`
const regexp = /abc/;
Object.getPrototypeOf(regexp) === RegExp.prototype; // true

We can "de-sugar" them into their constructor form.
jsconst array = new Array(1, 2, 3);
const regexp = new RegExp("abc");

For example, "array methods" like map() are simply methods defined on Array.prototype, which is why they are automatically available on all array instances.

Warning: There is one misfeature that used to be prevalent — extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances.
This misfeature is called monkey patching. Doing monkey patching risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break. It has led to incidents like the SmooshGate, and can be a great nuisance for the language to advance since JavaScript tries to "not break the web".
The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like Array.prototype.forEach.

It may be interesting to note that due to historical reasons, some built-in constructors' prototype property are instances themselves. For example, Number.prototype is a number 0, Array.prototype is an empty array, and RegExp.prototype is /(?:)/.
jsNumber.prototype + 1; // 1
Array.prototype.map((x) => x + 1); // []
String.prototype + "a"; // "a"
RegExp.prototype.source; // "(?:)"
Function.prototype(); // Function.prototype is a no-op function by itself

However, this is not the case for user-defined constructors, nor for modern constructors like Map.
jsMap.prototype.get(1);
// Uncaught TypeError: get method called on incompatible Map.prototype
Building longer inheritance chainsThe Constructor.prototype property will become the [[Prototype]] of the constructor's instances, as-is — including Constructor.prototype's own [[Prototype]]. By default, Constructor.prototype is a plain object — that is, Object.getPrototypeOf(Constructor.prototype) === Object.prototype. The only exception is Object.prototype itself, whose [[Prototype]] is null — that is, Object.getPrototypeOf(Object.prototype) === null. Therefore, a typical constructor will build the following prototype chain:
jsfunction Constructor() {}

const obj = new Constructor();
// obj ---> Constructor.prototype ---> Object.prototype ---> null

To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function.
jsfunction Base() {}
function Derived() {}
// Set the `[[Prototype]]` of `Derived.prototype`
// to `Base.prototype`
Object.setPrototypeOf(Derived.prototype, Base.prototype);

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

In class terms, this is equivalent to using the extends syntax.
jsclass Base {}
class Derived extends Base {}

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

You may also see some legacy code using Object.create() to build the inheritance chain. However, because this reassigns the prototype property and removes the constructor property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet.
jsfunction Base() {}
function Derived() {}
// Re-assigns `Derived.prototype` to a new object
// with `Base.prototype` as its `[[Prototype]]`
// DON'T DO THIS — use Object.setPrototypeOf to mutate it instead
Derived.prototype = Object.create(Base.prototype);
Inspecting prototypes: a deeper diveLet's look at what happens behind the scenes in a bit more detail.
In JavaScript, as mentioned above, functions are able to have properties. All functions have a special property named prototype. Please note that the code below is free-standing (it is safe to assume there is no other JavaScript on the webpage other than the below code). For the best learning experience, it is highly recommended that you open a console, navigate to the "console" tab, copy-and-paste in the below JavaScript code, and run it by pressing the Enter/Return key. (The console is included in most web browser's Developer Tools. More information is available for Firefox Developer Tools, Chrome DevTools, and Edge DevTools.)
jsfunction doSomething() {}
console.log(doSomething.prototype);
// It does not matter how you declare the function; a
// function in JavaScript will always have a default
// prototype property — with one exception: an arrow
// function doesn't have a default prototype property:
const doSomethingFromArrowFunction = () => {};
console.log(doSomethingFromArrowFunction.prototype);

As seen above, doSomething() has a default prototype property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this.
{
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}


Note: The Chrome console uses [[Prototype]] to denote the object's prototype, following the spec's terms; Firefox uses <prototype>. For consistency we will use [[Prototype]].

We can add properties to the prototype of doSomething(), as shown below.
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
console.log(doSomething.prototype);

This results in:
{
  foo: "bar",
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}

We can now use the new operator to create an instance of doSomething() based on this prototype. To use the new operator, call the function normally except prefix it with new. Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object.
Try the following code:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar"; // add a property onto the prototype
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // add a property onto the object
console.log(doSomeInstancing);

This results in an output similar to the following:
{
  prop: "some value",
  [[Prototype]]: {
    foo: "bar",
    constructor: ƒ doSomething(),
    [[Prototype]]: {
      constructor: ƒ Object(),
      hasOwnProperty: ƒ hasOwnProperty(),
      isPrototypeOf: ƒ isPrototypeOf(),
      propertyIsEnumerable: ƒ propertyIsEnumerable(),
      toLocaleString: ƒ toLocaleString(),
      toString: ƒ toString(),
      valueOf: ƒ valueOf()
    }
  }
}

As seen above, the [[Prototype]] of doSomeInstancing is doSomething.prototype. But, what does this do? When you access a property of doSomeInstancing, the runtime first looks to see if doSomeInstancing has that property.
If doSomeInstancing does not have the property, then the runtime looks for the property in doSomeInstancing.[[Prototype]] (a.k.a. doSomething.prototype). If doSomeInstancing.[[Prototype]] has the property being looked for, then that property on doSomeInstancing.[[Prototype]] is used.
Otherwise, if doSomeInstancing.[[Prototype]] does not have the property, then doSomeInstancing.[[Prototype]].[[Prototype]] is checked for the property. By default, the [[Prototype]] of any function's prototype property is Object.prototype. So, doSomeInstancing.[[Prototype]].[[Prototype]] (a.k.a. doSomething.prototype.[[Prototype]] (a.k.a. Object.prototype)) is then looked through for the property being searched for.
If the property is not found in doSomeInstancing.[[Prototype]].[[Prototype]], then doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] is looked through. However, there is a problem: doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] does not exist, because Object.prototype.[[Prototype]] is null. Then, and only then, after the entire prototype chain of [[Prototype]]'s is looked through, the runtime asserts that the property does not exist and conclude that the value at the property is undefined.
Let's try entering some more code into the console:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value";
console.log("doSomeInstancing.prop:     ", doSomeInstancing.prop);
console.log("doSomeInstancing.foo:      ", doSomeInstancing.foo);
console.log("doSomething.prop:          ", doSomething.prop);
console.log("doSomething.foo:           ", doSomething.foo);
console.log("doSomething.prototype.prop:", doSomething.prototype.prop);
console.log("doSomething.prototype.foo: ", doSomething.prototype.foo);

This results in the following:
doSomeInstancing.prop:      some value
doSomeInstancing.foo:       bar
doSomething.prop:           undefined
doSomething.foo:            undefined
doSomething.prototype.prop: undefined
doSomething.prototype.foo:  bar
Different ways of creating and mutating prototype chainsWe have encountered many ways to create objects and change their prototype chains. We will systematically summarize the different ways, comparing each approach's pros and cons.Objects created with syntax constructsjsconst o = { a: 1 };
// The newly created object o has Object.prototype as its [[Prototype]]
// Object.prototype has null as its prototype.
// o ---> Object.prototype ---> null

const b = ["yo", "whadup", "?"];
// Arrays inherit from Array.prototype
// (which has methods indexOf, forEach, etc.)
// The prototype chain looks like:
// b ---> Array.prototype ---> Object.prototype ---> null

function f() {
  return 2;
}
// Functions inherit from Function.prototype
// (which has methods call, bind, etc.)
// f ---> Function.prototype ---> Object.prototype ---> null

const p = { b: 2, __proto__: o };
// It is possible to point the newly created object's [[Prototype]] to
// another object via the __proto__ literal property. (Not to be confused
// with Object.prototype.__proto__ accessors)
// p ---> o ---> Object.prototype ---> null


Pros and cons of using the __proto__ key in object initializers


Pro(s)

        Supported in all modern engines. Pointing the __proto__
        key to something that is not an object only fails silently without
        throwing an exception. Contrary to the
        Object.prototype.__proto__ setter,
        __proto__ in object literal initializers is standardized
        and optimized, and can even be more performant than
        Object.create. Declaring extra own properties on the
        object at creation is more ergonomic than
        Object.create.
      


Con(s)

        Not supported in IE10 and below. Likely to be confused with
        Object.prototype.__proto__ accessors for
        people unaware of the difference.
      


With constructor functionsjsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g is an object with own properties 'vertices' and 'edges'.
// g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.


Pros and cons of using constructor functions


Pro(s)

        Supported in all engines — going all the way back to IE 5.5. Also, it
        is very fast, very standard, and very JIT-optimizable.
      


Con(s)



            In order to use this method, the function in question must be
            initialized. During this initialization, the constructor may store
            unique information that must be generated per-object. This unique
            information would only be generated once, potentially leading to
            problems.
          

            The initialization of the constructor may put unwanted methods onto
            the object.
          

Both of those are generally not problems in practice.



With Object.create()Calling Object.create() creates a new object. The [[Prototype]] of this object is the first argument of the function:
jsconst a = { a: 1 };
// a ---> Object.prototype ---> null

const b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (inherited)

const c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

const d = Object.create(null);
// d ---> null (d is an object that has null directly as its prototype)
console.log(d.hasOwnProperty);
// undefined, because d doesn't inherit from Object.prototype


Pros and cons of Object.create


Pro(s)

        Supported in all modern engines. Allows directly setting
        [[Prototype]] of an object at creation time, which permits
        the runtime to further optimize the object. Also allows the creation of
        objects without a prototype, using Object.create(null).
      


Con(s)

        Not supported in IE8 and below. However, as Microsoft has discontinued
        extended support for systems running IE8 and below, that should not be a
        concern for most applications. Additionally, the slow object
        initialization can be a performance black hole if using the second
        argument, because each object-descriptor property has its own separate
        descriptor object. When dealing with hundreds of thousands of object
        descriptors in the form of objects, that lag time might become a serious
        issue.
      


With classesjsclass Rectangle {
  constructor(height, width) {
    this.name = "Rectangle";
    this.height = height;
    this.width = width;
  }
}

class FilledRectangle extends Rectangle {
  constructor(height, width, color) {
    super(height, width);
    this.name = "Filled rectangle";
    this.color = color;
  }
}

const filledRectangle = new FilledRectangle(5, 10, "blue");
// filledRectangle ---> FilledRectangle.prototype ---> Rectangle.prototype ---> Object.prototype ---> null


Pros and cons of classes


Pro(s)

        Supported in all modern engines. Very high readability and maintainability.
        Private properties
        are a feature with no trivial replacement in prototypal inheritance.
      


Con(s)

        Classes, especially with private properties, are less optimized than
        traditional ones (although engine implementors are working to improve
        this). Not supported in older environments and transpilers are usually
        needed to use classes in production.
      


With Object.setPrototypeOf()While all methods above will set the prototype chain at object creation time, Object.setPrototypeOf() allows mutating the [[Prototype]] internal property of an existing object.
jsconst obj = { a: 1 };
const anotherObj = { b: 2 };
Object.setPrototypeOf(obj, anotherObj);
// obj ---> anotherObj ---> Object.prototype ---> null


Pros and cons of Object.setPrototypeOf


Pro(s)

        Supported in all modern engines. Allows the dynamic manipulation of an
        object's prototype and can even force a prototype on a prototype-less
        object created with Object.create(null).
      


Con(s)

        Ill-performing. Should be avoided if it's possible to set the prototype
        at object creation time. Many engines optimize the prototype and try to
        guess the location of the method in memory when calling an instance in
        advance; but setting the prototype dynamically disrupts all those
        optimizations. It might cause some engines to recompile your code for
        de-optimization, to make it work according to the specs. Not supported
        in IE8 and below.
      


With the __proto__ accessorAll objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (if the __proto__ key is not overridden on the object).

Warning: Object.prototype.__proto__ accessors are non-standard and deprecated. You should almost always use Object.setPrototypeOf instead.

jsconst obj = {};
// DON'T USE THIS: for example only.
obj.__proto__ = { barProp: "bar val" };
obj.__proto__.__proto__ = { fooProp: "foo val" };
console.log(obj.fooProp);
console.log(obj.barProp);



    Pros and cons of setting the
    __proto__ property
  


Pro(s)

        Supported in all modern engines. Setting
        __proto__ to something that
        is not an object only fails silently. It does not throw an exception.
      


Con(s)

        Non-performant and deprecated. Many engines optimize the prototype and
        try to guess the location of the method in the memory when calling an
        instance in advance; but setting the prototype dynamically disrupts all
        those optimizations and can even force some engines to recompile for
        de-optimization of your code, to make it work according to the specs.
        Not supported in IE10 and below. The __proto__
        setter is normative optional, so it may not work across all platforms.
        You should almost always use Object.setPrototypeOf
        instead.
      


PerformanceThe lookup time for properties that are high up on the prototype chain can have a negative impact on the performance, and this may be significant in the code where performance is critical. Additionally, trying to access nonexistent properties will always traverse the full prototype chain.
Also, when iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, it is necessary to use the hasOwnProperty or Object.hasOwn methods. All objects, except those with null as [[Prototype]], inherit hasOwnProperty from Object.prototype — unless it has been overridden further down the prototype chain. To give you a concrete example, let's take the above graph example code to illustrate it:
jsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g ---> Graph.prototype ---> Object.prototype ---> null

g.hasOwnProperty("vertices"); // true
Object.hasOwn(g, "vertices"); // true

g.hasOwnProperty("nope"); // false
Object.hasOwn(g, "nope"); // false

g.hasOwnProperty("addVertex"); // false
Object.hasOwn(g, "addVertex"); // false

Object.getPrototypeOf(g).hasOwnProperty("addVertex"); // true

Note: It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.ConclusionJavaScript may be a bit confusing for developers coming from Java or C++, as it's all dynamic, all runtime, and it has no static types at all. Everything is either an object (instance) or a function (constructor), and even functions themselves are instances of the Function constructor. Even the "classes" as syntax constructs are just constructor functions at runtime.
All constructor functions in JavaScript have a special property called prototype, which works with the new operator. The reference to the prototype object is copied to the internal [[Prototype]] property of the new instance. For example, when you do const a1 = new A(), JavaScript (after creating the object in memory and before running function A() with this defined to it) sets a1.[[Prototype]] = A.prototype. When you then access properties of the instance, JavaScript first checks whether they exist on that object directly, and if not, it looks in [[Prototype]]. [[Prototype]] is looked at recursively, i.e. a1.doSomething, Object.getPrototypeOf(a1).doSomething, Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething etc., until it's found or Object.getPrototypeOf returns null. This means that all properties defined on prototype are effectively shared by all instances, and you can even later change parts of prototype and have the changes appear in all existing instances.
If, in the example above, you do const a1 = new A(); const a2 = new A();, then a1.doSomething would actually refer to Object.getPrototypeOf(a1).doSomething — which is the same as the A.prototype.doSomething you defined, i.e. Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething.
It is essential to understand the prototypal inheritance model before writing complex code that makes use of it. Also, be aware of the length of the prototype chains in your code and break them up if necessary to avoid possible performance problems. Further, the native prototypes should never be extended unless it is for the sake of compatibility with newer JavaScript features.Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 23, 2023 by MDN contributors.
Memory managementLow-level languages like C, have manual memory management primitives such as malloc() and free(). In contrast, JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (garbage collection). This automaticity is a potential source of confusion: it can give developers the false impression that they don't need to worry about memory management.Memory life cycleRegardless of the programming language, the memory life cycle is pretty much always the same:

Allocate the memory you need
Use the allocated memory (read, write)
Release the allocated memory when it is not needed anymore

The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.Allocation in JavaScriptValue initialization
In order to not bother the programmer with allocations, JavaScript will automatically allocate memory when values are initially declared.
jsconst n = 123; // allocates memory for a number
const s = "azerty"; // allocates memory for a string

const o = {
  a: 1,
  b: null,
}; // allocates memory for an object and contained values

// (like object) allocates memory for the array and
// contained values
const a = [1, null, "abra"];

function f(a) {
  return a + 2;
} // allocates a function (which is a callable object)

// function expressions also allocate an object
someElement.addEventListener(
  "click",
  () => {
    someElement.style.backgroundColor = "blue";
  },
  false,
);

Allocation via function calls
Some function calls result in object allocation.
jsconst d = new Date(); // allocates a Date object

const e = document.createElement("div"); // allocates a DOM element

Some methods allocate new values or objects:
jsconst s = "azerty";
const s2 = s.substr(0, 3); // s2 is a new string
// Since strings are immutable values,
// JavaScript may decide to not allocate memory,
// but just store the [0, 3] range.

const a = ["ouais ouais", "nan nan"];
const a2 = ["generation", "nan nan"];
const a3 = a.concat(a2);
// new array with 4 elements being
// the concatenation of a and a2 elements.
Using valuesUsing values basically means reading and writing in allocated memory. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function.Release when the memory is not needed anymoreThe majority of memory management issues occur at this phase. The most difficult aspect of this stage is determining when the allocated memory is no longer needed.
Low-level languages require the developer to manually determine at which point in the program the allocated memory is no longer needed and to release it.
Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it. This automatic process is an approximation since the general problem of determining whether or not a specific piece of memory is still needed is undecidable.Garbage collectionAs stated above, the general problem of automatically finding whether some memory "is not needed anymore" is undecidable. As a consequence, garbage collectors implement a restriction of a solution to the general problem. This section will explain the concepts that are necessary for understanding the main garbage collection algorithms and their respective limitations.ReferencesThe main concept that garbage collection algorithms rely on is the concept of reference. Within the context of memory management, an object is said to reference another object if the former has access to the latter (either implicitly or explicitly). For instance, a JavaScript object has a reference to its prototype (implicit reference) and to its properties values (explicit reference).
In this context, the notion of an "object" is extended to something broader than regular JavaScript objects and also contain function scopes (or the global lexical scope).Reference-counting garbage collection
Note: no modern JavaScript engine uses reference-counting for garbage collection anymore.

This is the most naïve garbage collection algorithm. This algorithm reduces the problem from determining whether or not an object is still needed to determining if an object still has any other objects referencing it. An object is said to be "garbage", or collectible if there are zero references pointing to it.
For example:
jslet x = {
  a: {
    b: 2,
  },
};
// 2 objects are created. One is referenced by the other as one of its properties.
// The other is referenced by virtue of being assigned to the 'x' variable.
// Obviously, none can be garbage-collected.

let y = x;
// The 'y' variable is the second thing that has a reference to the object.

x = 1;
// Now, the object that was originally in 'x' has a unique reference
// embodied by the 'y' variable.

let z = y.a;
// Reference to 'a' property of the object.
// This object now has 2 references: one as a property,
// the other as the 'z' variable.

y = "mozilla";
// The object that was originally in 'x' has now zero
// references to it. It can be garbage-collected.
// However its 'a' property is still referenced by
// the 'z' variable, so it cannot be freed.

z = null;
// The 'a' property of the object originally in x
// has zero references to it. It can be garbage collected.

There is a limitation when it comes to circular references. In the following example, two objects are created with properties that reference one another, thus creating a cycle. They will go out of scope after the function call has completed. At that point they become unneeded and their allocated memory should be reclaimed. However, the reference-counting algorithm will not consider them reclaimable since each of the two objects has at least one reference pointing to them, resulting in neither of them being marked for garbage collection. Circular references are a common cause of memory leaks.
jsfunction f() {
  const x = {};
  const y = {};
  x.a = y; // x references y
  y.a = x; // y references x

  return "azerty";
}

f();
Mark-and-sweep algorithmThis algorithm reduces the definition of "an object is no longer needed" to "an object is unreachable".
This algorithm assumes the knowledge of a set of objects called roots. In JavaScript, the root is the global object. Periodically, the garbage collector will start from these roots, find all objects that are referenced from these roots, then all objects referenced from these, etc. Starting from the roots, the garbage collector will thus find all reachable objects and collect all non-reachable objects.
This algorithm is an improvement over the previous one since an object having zero references is effectively unreachable. The opposite does not hold true as we have seen with circular references.
Currently, all modern engines ship a mark-and-sweep garbage collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last few years are implementation improvements of this algorithm, but not improvements over the garbage collection algorithm itself nor its reduction of the definition of when "an object is no longer needed".
The immediate benefit of this approach is that cycles are no longer a problem. In the first example above, after the function call returns, the two objects are no longer referenced by any resource that is reachable from the global object. Consequently, they will be found unreachable by the garbage collector and have their allocated memory reclaimed.
However, the inability to manually control garbage collection remains. There are times when it would be convenient to manually decide when and what memory is released. In order to release the memory of an object, it needs to be made explicitly unreachable. It is also not possible to programmatically trigger garbage collection in JavaScript — and will likely never be within the core language, although engines may expose APIs behind opt-in flags.Configuring an engine's memory modelJavaScript engines typically offer flags that expose the memory model. For example, Node.js offers additional options and tools that expose the underlying V8 mechanisms for configuring and debugging memory issues. This configuration may not be available in browsers, and even less so for web pages (via HTTP headers, etc.).
The max amount of available heap memory can be increased with a flag:
bashnode --max-old-space-size=6000 index.js

We can also expose the garbage collector for debugging memory issues using a flag and the Chrome Debugger:
bashnode --expose-gc --inspect index.js
Data structures aiding memory managementAlthough JavaScript does not directly expose the garbage collector API, the language offers several data structures that indirectly observe garbage collection and can be used to manage memory usage.WeakMaps and WeakSetsWeakMap and WeakSet are data structures whose APIs closely mirror their non-weak counterparts: Map and Set. WeakMap allows you to maintain a collection of key-value pairs, while WeakSet allows you to maintain a collection of unique values, both with performant addition, deletion, and querying.
WeakMap and WeakSet got the name from the concept of weakly held values. If x is weakly held by y, it means that although you can access the value of x via y, the mark-and-sweep algorithm won't consider x as reachable if nothing else strongly holds to it. Most data structures, except the ones discussed here, strongly holds to the objects passed in so that you can retrieve them at any time. The keys of WeakMap and WeakSet can be garbage-collected (for WeakMap objects, the values would then be eligible for garbage collection as well) as long as nothing else in the program is referencing the key. This is ensured by two characteristics:

WeakMap and WeakSet can only store objects or symbols. This is because only objects are garbage collected — primitive values can always be forged (that is, 1 === 1 but {} !== {}), making them stay in the collection forever. Registered symbols (like Symbol.for("key")) can also be forged and thus not garbage collectable, but symbols created with Symbol("key") are garbage collectable. Well-known symbols like Symbol.iterator come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed as keys.
WeakMap and WeakSet are not iterable. This prevents you from using Array.from(map.keys()).length to observe the liveliness of objects, or get hold of an arbitrary key which should otherwise be eligible for garbage collection. (Garbage collection should be as invisible as possible.)

In typical explanations of WeakMap and WeakSet (such as the one above), it's often implied that the key is garbage-collected first, freeing the value for garbage collection as well. However, consider the case of the value referencing the key:
jsconst wm = new WeakMap();
const key = {};
wm.set(key, { key });
// Now `key` cannot be garbage collected,
// because the value holds a reference to the key,
// and the value is strongly held in the map!

If key is stored as an actual reference, it would create a cyclic reference and make both the key and value ineligible for garbage collection, even when nothing else references key — because if key is garbage collected, it means that at some particular instant, value.key would point to a non-existent address, which is not legal. To fix this, the entries of WeakMap and WeakSet aren't actual references, but ephemerons, an enhancement to the mark-and-sweep mechanism. Barros et al. offers a good summary of the algorithm (page 4). To quote a paragraph:

Ephemerons are a refinement of weak pairs where neither the key nor the value can be classified as weak or strong. The connectivity of the key determines the connectivity of the value, but the connectivity of the value does not affect the connectivity of the key. […] when the garbage collection offers support to ephemerons, it occurs in three phases instead of two (mark and sweep).

As a rough mental model, think of a WeakMap as the following implementation:

Warning: This is not a polyfill nor is anywhere close to how it's implemented in the engine (which hooks into the garbage collection mechanism).

jsclass MyWeakMap {
  #marker = Symbol("MyWeakMapData");
  get(key) {
    return key[this.#marker];
  }
  set(key, value) {
    key[this.#marker] = value;
  }
  has(key) {
    return this.#marker in key;
  }
  delete(key) {
    delete key[this.#marker];
  }
}

As you can see, the MyWeakMap never actually holds a collection of keys. It simply adds metadata to each object being passed in. The object is then garbage-collectable via mark-and-sweep. Therefore, it's not possible to iterate over the keys in a WeakMap, nor clear the WeakMap (as that also relies on the knowledge of the entire key collection).
For more information on their APIs, see the keyed collections guide.WeakRefs and FinalizationRegistry
Note: WeakRef and FinalizationRegistry offer direct introspection into the garbage collection machinery. Avoid using them where possible because the runtime semantics are almost completely unguaranteed.

All variables with an object as value are references to that object. However, such references are strong — their existence would prevent the garbage collector from marking the object as eligible for collection. A WeakRef is a weak reference to an object that allows the object to be garbage collected, while still retaining the ability to read the object's content during its lifetime.
One use case for WeakRef is a cache system which maps string URLs to large objects. We cannot use a WeakMap for this purpose, because WeakMap objects have their keys weakly held, but not their values — if you access a key, you would always deterministically get the value (since having access to the key means it's still alive). Here, we are okay to get undefined for a key (if the corresponding value is no longer alive) since we can just re-compute it, but we don't want unreachable objects to stay in the cache. In this case, we can use a normal Map, but with each value being a WeakRef of the object instead of the actual object value.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  return async (key) => {
    if (cache.has(key)) {
      return cache.get(key).deref();
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

FinalizationRegistry provides an even stronger mechanism to observe garbage collection. It allows you to register objects and be notified when they are garbage collected. For example, for the cache system exemplified above, even when the blobs themselves are free for collection, the WeakRef objects that hold them are not — and over time, the Map may accumulate a lot of useless entries. Using a FinalizationRegistry allows one to perform cleanup in this case.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  // Every time after a value is garbage collected, the callback is
  // called with the key in the cache as argument, allowing us to remove
  // the cache entry
  const registry = new FinalizationRegistry((key) => {
    // Note: it's important to test that the WeakRef is indeed empty.
    // Otherwise, the callback may be called after a new object has been
    // added with this key, and that new, alive object gets deleted
    if (!cache.get(key)?.deref()) {
      cache.delete(key);
    }
  });
  return async (key) => {
    if (cache.has(key)) {
      return cache.get(key).deref();
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    registry.register(value, key);
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

Due to performance and security concerns, there is no guarantee of when the callback will be called, or if it will be called at all. It should only be used for cleanup — and non-critical cleanup. There are other ways for more deterministic resource management, such as try...finally, which will always execute the finally block. WeakRef and FinalizationRegistry exist solely for optimization of memory usage in long-running programs.
For more information on the API of WeakRef and FinalizationRegistry, see their reference pages.Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
The event loopJavaScript has a runtime model based on an event loop, which is responsible for executing the code, collecting and processing events, and executing queued sub-tasks. This model is quite different from models in other languages like C and Java.Runtime conceptsThe following sections explain a theoretical model. Modern JavaScript engines implement and heavily optimize the described semantics.Visual representation

StackFunction calls form a stack of frames.
jsfunction foo(b) {
  const a = 10;
  return a + b + 11;
}

function bar(x) {
  const y = 3;
  return foo(x * y);
}

const baz = bar(7); // assigns 42 to baz

Order of operations:

When calling bar, a first frame is created containing references to bar's arguments and local variables.
When bar calls foo, a second frame is created and pushed on top of the first one, containing references to foo's arguments and local variables.
When foo returns, the top frame element is popped out of the stack (leaving only bar's call frame).
When bar returns, the stack is empty.

Note that the arguments and local variables may continue to exist, as they are stored outside the stack — so they can be accessed by any nested functions long after their outer function has returned.HeapObjects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.QueueA JavaScript runtime uses a message queue, which is a list of messages to be processed. Each message has an associated function that gets called to handle the message.
At some point during the event loop, the runtime starts handling the messages on the queue, starting with the oldest one. To do so, the message is removed from the queue and its corresponding function is called with the message as an input parameter. As always, calling a function creates a new stack frame for that function's use.
The processing of functions continues until the stack is once again empty. Then, the event loop will process the next message in the queue (if there is one).Event loopThe event loop got its name because of how it's usually implemented, which usually resembles:
jswhile (queue.waitForMessage()) {
  queue.processNextMessage();
}

queue.waitForMessage() waits synchronously for a message to arrive (if one is not already available and waiting to be handled)."Run-to-completion"Each message is processed completely before any other message is processed.
This offers some nice properties when reasoning about your program, including the fact that whenever a function runs, it cannot be preempted and will run entirely before any other code runs (and can modify data the function manipulates). This differs from C, for instance, where if a function runs in a thread, it may be stopped at any point by the runtime system to run some other code in another thread.
A downside of this model is that if a message takes too long to complete, the web application is unable to process user interactions like click or scroll. The browser mitigates this with the "a script is taking too long to run" dialog. A good practice to follow is to make message processing short and if possible cut down one message into several messages.Adding messagesIn web browsers, messages are added anytime an event occurs and there is an event listener attached to it. If there is no listener, the event is lost. So a click on an element with a click event handler will add a message — likewise with any other event.
The first two arguments to the function setTimeout are a message to add to the queue and a time value (optional; defaults to 0). The time value represents the (minimum) delay after which the message will be pushed into the queue. If there is no other message in the queue, and the stack is empty, the message is processed right after the delay. However, if there are messages, the setTimeout message will have to wait for other messages to be processed. For this reason, the second argument indicates a minimum time — not a guaranteed time.
Here is an example that demonstrates this concept (setTimeout does not run immediately after its timer expires):
jsconst seconds = new Date().getTime() / 1000;

setTimeout(() => {
  // prints out "2", meaning that the callback is not called immediately after 500 milliseconds.
  console.log(`Ran after ${new Date().getTime() / 1000 - seconds} seconds`);
}, 500);

while (true) {
  if (new Date().getTime() / 1000 - seconds >= 2) {
    console.log("Good, looped for 2 seconds");
    break;
  }
}
Zero delaysZero delay doesn't mean the call back will fire-off after zero milliseconds. Calling setTimeout with a delay of 0 (zero) milliseconds doesn't execute the callback function after the given interval.
The execution depends on the number of waiting tasks in the queue. In the example below, the message "this is just a message" will be written to the console before the message in the callback gets processed, because the delay is the minimum time required for the runtime to process the request (not a guaranteed time).
The setTimeout needs to wait for all the code for queued messages to complete even though you specified a particular time limit for your setTimeout.
js(() => {
  console.log("this is the start");

  setTimeout(() => {
    console.log("Callback 1: this is a msg from call back");
  }); // has a default time value of 0

  console.log("this is just a message");

  setTimeout(() => {
    console.log("Callback 2: this is a msg from call back");
  }, 0);

  console.log("this is the end");
})();

// "this is the start"
// "this is just a message"
// "this is the end"
// "Callback 1: this is a msg from call back"
// "Callback 2: this is a msg from call back"
Several runtimes communicating togetherA web worker or a cross-origin iframe has its own stack, heap, and message queue. Two distinct runtimes can only communicate through sending messages via the postMessage method. This method adds a message to the other runtime if the latter listens to message events.Never blockingA very interesting property of the event loop model is that JavaScript, unlike a lot of other languages, never blocks. Handling I/O is typically performed via events and callbacks, so when the application is waiting for an IndexedDB query to return or a fetch() request to return, it can still process other things like user input.
Legacy exceptions exist like alert or synchronous XHR, but it is considered good practice to avoid them. Beware: exceptions to the exception do exist (but are usually implementation bugs, rather than anything else).See also
Event loops in the HTML standard
The Node.js Event Loop, Timers, and process.nextTick() in the Node.js docs
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 20, 2023 by MDN contributors.
Standard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
AggregateErrorThe AggregateError object represents an error when several errors need to be wrapped in a single error. It is thrown when multiple errors need to be reported by an operation, for example by Promise.any(), when all promises passed to it reject.
AggregateError is a subclass of Error.Constructor
AggregateError()

Creates a new AggregateError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on AggregateError.prototype and shared by all AggregateError instances.

AggregateError.prototype.constructor

The constructor function that created the instance object. For AggregateError instances, the initial value is the AggregateError constructor.

AggregateError.prototype.name

Represents the name for the type of error. For AggregateError.prototype.name, the initial value is "AggregateError".


These properties are own properties of each AggregateError instance.

errors

An array representing the errors that were aggregated.

Instance methodsInherits instance methods from its parent Error.ExamplesCatching an AggregateErrorjsPromise.any([Promise.reject(new Error("some error"))]).catch((e) => {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "All Promises rejected"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
});
Creating an AggregateErrorjstry {
  throw new AggregateError([new Error("some error")], "Hello");
} catch (e) {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
}
SpecificationsSpecificationECMAScript Language Specification # sec-aggregate-error-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of AggregateError in core-js
Error
Promise.any
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
ArrayThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.DescriptionIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:

JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)
JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.
JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).
Array indicesArray objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
Array elements are object properties in the same way that toString is a property (to be specific, however, toString() is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:
jsarr.0; // a syntax error

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., years['2'] instead of years[2]), although usually not necessary.
The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. As a result, '2' and '02' would refer to two different slots on the years object, and the following example could be true:
jsconsole.log(years["2"] !== years["02"]);

Only years['2'] is an actual array index. years['02'] is an arbitrary string property that will not be visited in array iteration.Relationship between length and numerical propertiesA JavaScript array's length property and numerical properties are connected.
Several of the built-in array methods (e.g., join(), slice(), indexOf(), etc.) take into account the value of an array's length property when they're called.
Other methods (e.g., push(), splice(), etc.) also result in updates to an array's length property.
jsconst fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's length property accordingly:
jsfruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6

Increasing the length extends the array by adding empty slots without creating any new elements — not even undefined.
jsfruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined

Decreasing the length property does, however, delete elements.
jsfruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2

This is explained further on the length page.Array methods and empty slotsArray methods have different behaviors when encountering empty slots in sparse arrays. In general, older methods (e.g. forEach) treat empty slots differently from indices that contain undefined.
Methods that have special treatment for empty slots include the following: concat(), copyWithin(), every(), filter(), flat(), flatMap(), forEach(), indexOf(), lastIndexOf(), map(), reduce(), reduceRight(), reverse(), slice(), some(), sort(), and splice(). Iteration methods such as forEach don't visit empty slots at all. Other methods, such as concat, copyWithin, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

Newer methods (e.g. keys) do not treat empty slots specially and treat them as if they contain undefined. Methods that conflate empty slots with undefined elements include the following: entries(), fill(), find(), findIndex(), findLast(), findLastIndex(), includes(), join(), keys(), toLocaleString(), toReversed(), toSorted(), toSpliced(), values(), and with().
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
Copying methods and mutating methodsSome methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.
Primitive types such as strings, numbers and booleans (not String, Number, and Boolean objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.
The following methods create new arrays by accessing this.constructor[Symbol.species] to determine the constructor to use: concat(), filter(), flat(), flatMap(), map(), slice(), and splice() (to construct the array of removed elements that's returned).
The following methods always create new arrays with the Array base constructor: toReversed(), toSorted(), toSpliced(), and with().
The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:



Mutating method
Non-mutating alternative




copyWithin()
No one-method alternative


fill()
No one-method alternative


pop()
slice(0, -1)


push(v1, v2)
concat([v1, v2])


reverse()
toReversed()


shift()
slice(1)


sort()
toSorted()


splice()
toSpliced()


unshift(v1, v2)
toSpliced(0, 0, v1, v2)



An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or slice() to create a copy first:
jsarr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
Iterative methodsMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:
jsmethod(callbackFn, thisArg)

Where callbackFn takes three arguments:

element

The current element being processed in the array.

index

The index of the current element being processed in the array.

array

The array that the method was called upon.


What callbackFn is expected to return depends on the array method that was called.
The thisArg argument (defaults to undefined) will be used as the this value when calling callbackFn. The this value ultimately observable by callbackFn is determined according to the usual rules: if callbackFn is non-strict, primitive this values are wrapped into objects, and undefined/null is substituted with globalThis. The thisArg argument is irrelevant for any callbackFn defined with an arrow function, as arrow functions don't have their own this binding.
The array argument passed to callbackFn is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The array argument is not the array that is being built, in the case of methods like map(), filter(), and flatMap() — there is no way to access the array being built from the callback function.
All iterative methods are copying and generic, although they behave differently with empty slots.
The following methods are iterative:every(), filter(), find(), findIndex(), findLast(), findLastIndex(), flatMap(), forEach(), map(), and some().
In particular, every(), find(), findIndex(), findLast(), findLastIndex(), and some() do not always invoke callbackFn on every element — they stop iteration as soon as the return value is determined.
The reduce() and reduceRight() methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept thisArg).
The sort() method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept thisArg, and may invoke the callback multiple times on an index.
Iterative methods iterate the array like the following (with a lot of technical details omitted):
jsfunction method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}

Note the following:

Not all methods do the i in this test. The find, findIndex, findLast, and findLastIndex methods do not, but other methods do.
The length is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).
The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.
The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (for (let i = length - 1; i >= 0; i--)): reduceRight(), findLast(), and findLastIndex().
reduce and reduceRight have slightly different signatures and do not always start at the first/last element.
Generic array methodsArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
jsconst arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'

Normalization of the length property
The length property is converted to an integer and then clamped to the range between 0 and 253 - 1. NaN becomes 0, so even when length is not present or is undefined, it behaves as if it has value 0.
The language avoids setting length to an unsafe integer. All built-in methods will throw a TypeError if length will be set to a number greater than 253 - 1. However, because the length property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.
jsArray.prototype.flat.call({}); // []

Some array methods set the length property of the array object. They always set the value after normalization, so length always ends as an integer.
jsconst a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0

Array-like objects
The term array-like object refers to any object that doesn't throw during the length conversion process described above. In practice, such object is expected to actually have a length property and to have indexed elements in the range 0 to length - 1. (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than length - 1 is ignored when an array method operates on an array-like object.
Many DOM objects are array-like — for example, NodeList and HTMLCollection. The arguments object is also array-like. You can call array methods on them even if they don't have these methods themselves.
jsfunction f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
Constructor
Array()

Creates a new Array object.

Static properties
Array[@@species]

Returns the Array constructor.

Static methods
Array.from()

Creates a new Array instance from an iterable or array-like object.

Array.fromAsync()

Creates a new Array instance from an async iterable, iterable, or array-like object.

Array.isArray()

Returns true if the argument is an array, or false otherwise.

Array.of()

Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

Instance propertiesThese properties are defined on Array.prototype and shared by all Array instances.

Array.prototype.constructor

The constructor function that created the instance object. For Array instances, the initial value is the Array constructor.

Array.prototype[@@unscopables]

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for with statement-binding purposes.


These properties are own properties of each Array instance.

length

Reflects the number of elements in an array.

Instance methods
Array.prototype.at()

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

Array.prototype.concat()

Returns a new array that is the calling array joined with other array(s) and/or value(s).

Array.prototype.copyWithin()

Copies a sequence of array elements within an array.

Array.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in an array.

Array.prototype.every()

Returns true if every element in the calling array satisfies the testing function.

Array.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value.

Array.prototype.filter()

Returns a new array containing all elements of the calling array for which the provided filtering function returns true.

Array.prototype.find()

Returns the value of the first element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findIndex()

Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.findLast()

Returns the value of the last element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.flat()

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Array.prototype.flatMap()

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

Array.prototype.forEach()

Calls a function for each element in the calling array.

Array.prototype.includes()

Determines whether the calling array contains a value, returning true or false as appropriate.

Array.prototype.indexOf()

Returns the first (least) index at which a given element can be found in the calling array.

Array.prototype.join()

Joins all elements of an array into a string.

Array.prototype.keys()

Returns a new array iterator that contains the keys for each index in the calling array.

Array.prototype.lastIndexOf()

Returns the last (greatest) index at which a given element can be found in the calling array, or -1 if none is found.

Array.prototype.map()

Returns a new array containing the results of invoking a function on every element in the calling array.

Array.prototype.pop()

Removes the last element from an array and returns that element.

Array.prototype.push()

Adds one or more elements to the end of an array, and returns the new length of the array.

Array.prototype.reduce()

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

Array.prototype.reduceRight()

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

Array.prototype.reverse()

Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)

Array.prototype.shift()

Removes the first element from an array and returns that element.

Array.prototype.slice()

Extracts a section of the calling array and returns a new array.

Array.prototype.some()

Returns true if at least one element in the calling array satisfies the provided testing function.

Array.prototype.sort()

Sorts the elements of an array in place and returns the array.

Array.prototype.splice()

Adds and/or removes elements from an array.

Array.prototype.toLocaleString()

Returns a localized string representing the calling array and its elements. Overrides the Object.prototype.toLocaleString() method.

Array.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

Array.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

Array.prototype.toSpliced()

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

Array.prototype.toString()

Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

Array.prototype.unshift()

Adds one or more elements to the front of an array, and returns the new length of the array.

Array.prototype.values()

Returns a new array iterator object that contains the values for each index in the array.

Array.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

Array.prototype[@@iterator]()

An alias for the values() method by default.

ExamplesThis section provides some examples of common array operations in JavaScript.

Note: If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays, which explains what arrays are, and includes other examples of common array operations.
Create an arrayThis example shows three ways to create new array: first using array literal notation, then using the Array() constructor, and finally using String.prototype.split() to build the array from a string.
js// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
Create a string from an arrayThis example uses the join() method to create a string from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
Access an array item by its indexThis example shows how to access items in the fruits array by specifying the index number of their position in the array.
jsconst fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
Find the index of an item in an arrayThis example uses the indexOf() method to find the position (index) of the string "Banana" in the fruits array.
jsconst fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
Check if an array contains a certain itemThis example shows two ways to check if the fruits array contains "Banana" and "Cherry": first with the includes() method, and then with the indexOf() method to test for an index value that's not -1.
jsconst fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
Append an item to an arrayThis example uses the push() method to append a new string to the fruits array.
jsconst fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
Remove the last item from an arrayThis example uses the pop() method to remove the last item from the fruits array.
jsconst fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange


Note: pop() can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.
Remove multiple items from the end of an arrayThis example uses the splice() method to remove the last 3 items from the fruits array.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Truncate an array down to just its first N itemsThis example uses the splice() method to truncate the fruits array down to just its first 2 items.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Remove the first item from an arrayThis example uses the shift() method to remove the first item from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple


Note: shift() can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.
Remove multiple items from the beginning of an arrayThis example uses the splice() method to remove the first 3 items from the fruits array.
jsconst fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
Add a new first item to an arrayThis example uses the unshift() method to add, at index 0, a new item to the fruits array — making it the new first item in the array.
jsconst fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
Remove a single item by indexThis example uses the splice() method to remove the string "Banana" from the fruits array — by specifying the index position of "Banana".
jsconst fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
Remove multiple items by indexThis example uses the splice() method to remove the strings "Banana" and "Strawberry" from the fruits array — by specifying the index position of "Banana", along with a count of the number of total items to remove.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Replace multiple items in an arrayThis example uses the splice() method to replace the last 2 items in the fruits array with new items.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Iterate over an arrayThis example uses a for...of loop to iterate over the fruits array, logging each item to the console.
jsconst fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry

But for...of is just one of many ways to iterate over any array; for more ways, see Loops and iteration, and see the documentation for the every(), filter(), flatMap(), map(), reduce(), and reduceRight() methods — and see the next example, which uses the forEach() method.Call a function on each element in an arrayThis example uses the forEach() method to call a function on each element in the fruits array; the function causes each item to be logged to the console, along with the item's index number.
jsconst fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
Merge multiple arrays togetherThis example uses the concat() method to merge the fruits array with a moreFruits array, to produce a new combinedFruits array. Notice that fruits and moreFruits remain unchanged.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
Copy an arrayThis example shows three ways to create a new array from the existing fruits array: first by using spread syntax, then by using the from() method, and then by using the slice() method.
jsconst fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]

All built-in array-copy operations (spread syntax, Array.from(), Array.prototype.slice(), and Array.prototype.concat()) create shallow copies. If you instead want a deep copy of an array, you can use JSON.stringify() to convert the array to a JSON string, and then JSON.parse() to convert the string back into a new array that's completely independent from the original array.
jsconst fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));

You can also create deep copies using the structuredClone() method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.
Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:
jsconst fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
Creating a two-dimensional arrayThe following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.
jsconst board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));

Here is the output:
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
Using an array to tabulate a set of valuesjsconst values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);

Results in
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
Creating an array using the result of a matchThe result of a match between a RegExp and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by RegExp.prototype.exec() and String.prototype.match().
For example:
js// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]

For more information about the result of a match, see the RegExp.prototype.exec() and String.prototype.match() pages.Mutating initial array in iterative methodsIterative methods do not mutate the array on which it is called, but the function provided as callbackFn can. The key principle to remember is that only indexes between 0 and arrayLength - 1 are visited, where arrayLength is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

callbackFn will not visit any elements added beyond the array's initial length when the call to the iterative method began.
Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Removed elements are not visited.


Warning: Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

The following examples use the forEach method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:
jsfunction testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}

Modification to indexes not visited yet will be visible once the index is reached:
jstestSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:
jstestSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4

Inserting n elements with index greater than the initial array length will not make them be visited:
jstestSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again:
jstestSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.SpecificationsSpecificationECMAScript Language Specification # sec-array-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Indexed collections guide
TypedArray
ArrayBuffer
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 18, 2023 by MDN contributors.
ArrayBufferThe ArrayBuffer object is used to represent a generic raw binary data buffer.
It is an array of bytes, often referred to in other languages as a "byte array". You cannot directly manipulate the contents of an ArrayBuffer; instead, you create one of the typed array objects or a DataView object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.
The ArrayBuffer() constructor creates a new ArrayBuffer of the given length in bytes. You can also get an array buffer from existing data, for example, from a Base64 string or from a local file.
ArrayBuffer is a transferable object.DescriptionResizing ArrayBuffersArrayBuffer objects can be made resizable by including the maxByteLength option when calling the ArrayBuffer() constructor. You can query whether an ArrayBuffer is resizable and what its maximum size is by accessing its resizable and maxByteLength properties, respectively. You can assign a new size to a resizable ArrayBuffer with a resize() call. New bytes are initialized to 0.
These features make resizing ArrayBuffers more efficient — otherwise, you have to make a copy of the buffer with a new size. It also gives JavaScript parity with WebAssembly in this regard (Wasm linear memory can be resized with WebAssembly.Memory.prototype.grow()).Transferring ArrayBuffersArrayBuffer objects can be transferred between different execution contexts, like Web Workers or Service Workers, using the structured clone algorithm. This is done by passing the ArrayBuffer as a transferable object in a call to Worker.postMessage() or ServiceWorker.postMessage(). In pure JavaScript, you can also transfer the ownership of memory from one ArrayBuffer to another using its transfer() or transferToFixedLength() method.
When an ArrayBuffer is transferred, its original copy becomes detached — this means it is no longer usable. At any moment, there will only be one copy of the ArrayBuffer that actually has access to the underlying memory. Detached buffers have the following behaviors:

byteLength becomes 0 (in both the buffer and the associated typed array views).
Methods, such as resize() and slice(), throw a TypeError when invoked. The associated typed array views' methods also throw a TypeError.

You can check whether an ArrayBuffer is detached by its detached property.Constructor
ArrayBuffer()

Creates a new ArrayBuffer object.

Static properties
ArrayBuffer[@@species]

The constructor function that is used to create derived objects.

Static methods
ArrayBuffer.isView()

Returns true if arg is one of the ArrayBuffer views, such as typed array objects or a DataView. Returns false otherwise.

Instance propertiesThese properties are defined on ArrayBuffer.prototype and shared by all ArrayBuffer instances.

ArrayBuffer.prototype.byteLength

The size, in bytes, of the ArrayBuffer. This is established when the array is constructed and can only be changed using the ArrayBuffer.prototype.resize() method if the ArrayBuffer is resizable.

ArrayBuffer.prototype.constructor

The constructor function that created the instance object. For ArrayBuffer instances, the initial value is the ArrayBuffer constructor.

ArrayBuffer.prototype.detached

Read-only. Returns true if the ArrayBuffer has been detached (transferred), or false if not.

ArrayBuffer.prototype.maxByteLength

The read-only maximum length, in bytes, that the ArrayBuffer can be resized to. This is established when the array is constructed and cannot be changed.

ArrayBuffer.prototype.resizable

Read-only. Returns true if the ArrayBuffer can be resized, or false if not.

ArrayBuffer.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "ArrayBuffer". This property is used in Object.prototype.toString().

Instance methods
ArrayBuffer.prototype.resize()

Resizes the ArrayBuffer to the specified size, in bytes.

ArrayBuffer.prototype.slice()

Returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from begin (inclusive) up to end (exclusive). If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.

ArrayBuffer.prototype.transfer()

Creates a new ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ArrayBuffer.prototype.transferToFixedLength()

Creates a new non-resizable ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ExamplesCreating an ArrayBufferIn this example, we create a 8-byte buffer with a Int32Array view referring to the buffer:
jsconst buffer = new ArrayBuffer(8);
const view = new Int32Array(buffer);
SpecificationsSpecificationECMAScript Language Specification # sec-arraybuffer-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of ArrayBuffer in core-js
JavaScript typed arrays guide
SharedArrayBuffer
RangeError: invalid array length
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 24, 2023 by MDN contributors.
AsyncFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2017.Learn moreSee full compatibilityReport feedbackThe AsyncFunction object provides methods for async functions. In JavaScript, every async function is actually an AsyncFunction object.
Note that AsyncFunction is not a global object. It can be obtained with the following code:
jsconst AsyncFunction = async function () {}.constructor;

AsyncFunction is a subclass of Function.Constructor
AsyncFunction()

Creates a new AsyncFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncFunction.prototype and shared by all AsyncFunction instances.

AsyncFunction.prototype.constructor

The constructor function that created the instance object. For AsyncFunction instances, the initial value is the AsyncFunction constructor.

AsyncFunction.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "AsyncFunction". This property is used in Object.prototype.toString().



Note: AsyncFunction instances do not have the prototype property.
Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript Language Specification # sec-async-function-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
async function
async function expression
Function
AsyncGeneratorFunction
GeneratorFunction
Functions
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
AsyncGeneratorThe AsyncGenerator object is returned by an async generator function and it conforms to both the async iterable protocol and the async iterator protocol.
Async generator methods always yield Promise objects.
AsyncGenerator is a subclass of the hidden AsyncIterator class.Try itConstructorThe AsyncGenerator constructor is not available globally. Instances of AsyncGenerator must be returned from async generator functions
jsasync function* createAsyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}
const asyncGen = createAsyncGenerator();
asyncGen.next().then((res) => console.log(res.value)); // 1
asyncGen.next().then((res) => console.log(res.value)); // 2
asyncGen.next().then((res) => console.log(res.value)); // 3

In fact, there's no JavaScript entity that corresponds to the AsyncGenerator constructor. There's only a hidden object which is the prototype object shared by all objects created by async generator functions. This object is often stylized as AsyncGenerator.prototype to make it look like a class, but it should be more appropriately called AsyncGeneratorFunction.prototype.prototype, because AsyncGeneratorFunction is an actual JavaScript entity.Instance propertiesThese properties are defined on AsyncGenerator.prototype and shared by all AsyncGenerator instances.

AsyncGenerator.prototype.constructor

The constructor function that created the instance object. For AsyncGenerator instances, the initial value is AsyncGeneratorFunction.prototype.

Note: AsyncGenerator objects do not store a reference to the async generator function that created them.


AsyncGenerator.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "AsyncGenerator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent AsyncIterator.

AsyncGenerator.prototype.next()

Returns a Promise which will be resolved with the given value yielded by the yield expression.

AsyncGenerator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

AsyncGenerator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAsync generator iterationThe following example iterates over an async generator, logging values 1–6 to the console at decreasing time intervals. Notice how each time a Promise is yielded, but it's automatically resolved within the for await...of loop.
js// An async task. Pretend it's doing something more useful
// in practice.
function delayedValue(time, value) {
  return new Promise((resolve /*, reject*/) => {
    setTimeout(() => resolve(value), time);
  });
}

async function* generate() {
  yield delayedValue(2000, 1);
  yield delayedValue(100, 2);
  yield delayedValue(500, 3);
  yield delayedValue(250, 4);
  yield delayedValue(125, 5);
  yield delayedValue(50, 6);
  console.log("All done!");
}

async function main() {
  for await (const value of generate()) {
    console.log("value", value);
  }
}

main().catch((e) => console.error(e));
SpecificationsSpecificationECMAScript Language Specification # sec-asyncgenerator-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
function*
async function*
function* expression
Generator Function
Async Generator Function
Iterators and generators guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
AsyncGeneratorFunctionThe AsyncGeneratorFunction object provides methods for async generator functions. In JavaScript, every async generator function is actually an AsyncGeneratorFunction object.
Note that AsyncGeneratorFunction is not a global object. It can be obtained with the following code:
jsconst AsyncGeneratorFunction = async function* () {}.constructor;

AsyncGeneratorFunction is a subclass of Function.Try itConstructor
AsyncGeneratorFunction()

Creates a new AsyncGeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncGeneratorFunction.prototype and shared by all AsyncGeneratorFunction instances.

AsyncGeneratorFunction.prototype.constructor

The constructor function that created the instance object. For AsyncGeneratorFunction instances, the initial value is the AsyncGeneratorFunction constructor.

AsyncGeneratorFunction.prototype.prototype

All async generator functions share the same prototype property, which is AsyncGenerator.prototype. Each async generator function instance also has its own prototype property. When the async generator function is called, the returned async generator object inherits from the async generator function's prototype property, which in turn inherits from AsyncGeneratorFunction.prototype.prototype.

AsyncGeneratorFunction.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "AsyncGeneratorFunction". This property is used in Object.prototype.toString().

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript Language Specification # sec-asyncgeneratorfunction-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
async function*
async function* expression
Function
AsyncFunction
GeneratorFunction
Functions
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
AsyncIteratorAn AsyncIterator object is an object that conforms to the async iterator protocol by providing a next() method that returns a promise fulfilling to an iterator result object. The AsyncIterator.prototype object is a hidden global object that all built-in async iterators inherit from. It provides an @@asyncIterator method that returns the async iterator object itself, making the async iterator also async iterable.
Note that AsyncIterator is not a global object, although it will be in the future with the async iterator helpers proposal. The AsyncIterator.prototype object shared by all built-in async iterators can be obtained with the following code:
jsconst AsyncIteratorPrototype = Object.getPrototypeOf(
  Object.getPrototypeOf(Object.getPrototypeOf((async function* () {})())),
);
DescriptionCurrently, the only built-in JavaScript async iterator is the AsyncGenerator object returned by async generator functions. There are some other built-in async iterators in web API, such as the one of a ReadableStream.
Each of these async iterators have a distinct prototype object, which defines the next() method used by the particular async iterator. All of these prototype objects inherit from AsyncIterator.prototype, which provides am @@asyncIterator method that returns the async iterator object itself, making the async iterator also async iterable.

Note: AsyncIterator.prototype does not implement @@iterator, so async iterators are not sync iterable by default.
Instance methods
AsyncIterator.prototype[@@asyncIterator]()

Returns the async iterator object itself. This allows async iterator objects to also be async iterable.

ExamplesUsing an async iterator as an async iterableAll built-in async iterators are also async iterable, so you can use them in a for await...of loop:
jsconst asyncIterator = (async function* () {
  yield 1;
  yield 2;
  yield 3;
})();
(async () => {
  for await (const value of asyncIterator) {
    console.log(value);
  }
})();
// Logs: 1, 2, 3
SpecificationsSpecificationECMAScript Language Specification # sec-asynciteratorprototypeBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
async function*
Iteration protocols
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
AtomicsThe Atomics namespace object contains static methods for carrying out atomic operations. They are used with SharedArrayBuffer and ArrayBuffer objects.DescriptionUnlike most global objects, Atomics is not a constructor. You cannot use it with the new operator or invoke the Atomics object as a function. All properties and methods of Atomics are static (just like the Math object).Atomic operationsWhen memory is shared, multiple threads can read and write the same data in memory. Atomic operations make sure that predictable values are written and read, that operations are finished before the next operation starts and that operations are not interrupted.Wait and notifyThe wait() and notify() methods are modeled on Linux futexes ("fast user-space mutex") and provide ways for waiting until a certain condition becomes true and are typically used as blocking constructs.Static properties
Atomics[@@toStringTag]

The initial value of the @@toStringTag property is the string "Atomics". This property is used in Object.prototype.toString().

Static methods
Atomics.add()

Adds the provided value to the existing value at the specified index of the array. Returns the old value at that index.

Atomics.and()

Computes a bitwise AND on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.compareExchange()

Stores a value at the specified index of the array, if it equals a value. Returns the old value.

Atomics.exchange()

Stores a value at the specified index of the array. Returns the old value.

Atomics.isLockFree()

An optimization primitive that can be used to determine whether to use locks or atomic operations. Returns true if an atomic operation on arrays of the given element size will be implemented using a hardware atomic operation (as opposed to a lock). Experts only.

Atomics.load()

Returns the value at the specified index of the array.

Atomics.notify()

Notifies agents that are waiting on the specified index of the array. Returns the number of agents that were notified.

Atomics.or()

Computes a bitwise OR on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.store()

Stores a value at the specified index of the array. Returns the value.

Atomics.sub()

Subtracts a value at the specified index of the array. Returns the old value at that index.

Atomics.wait()

Verifies that the specified index of the array still contains a value and sleeps awaiting or times out. Returns either "ok", "not-equal", or "timed-out". If waiting is not allowed in the calling agent then it throws an exception. (Most browsers will not allow wait() on the browser's main thread.)

Atomics.waitAsync()

Waits asynchronously (i.e. without blocking, unlike Atomics.wait) on a shared memory location and returns a Promise.

Atomics.xor()

Computes a bitwise XOR on the value at the specified index of the array with the provided value. Returns the old value at that index.

ExamplesUsing Atomicsjsconst sab = new SharedArrayBuffer(1024);
const ta = new Uint8Array(sab);

ta[0]; // 0
ta[0] = 5; // 5

Atomics.add(ta, 0, 12); // 5
Atomics.load(ta, 0); // 17

Atomics.and(ta, 0, 1); // 17
Atomics.load(ta, 0); // 1

Atomics.compareExchange(ta, 0, 5, 12); // 1
Atomics.load(ta, 0); // 1

Atomics.exchange(ta, 0, 12); // 1
Atomics.load(ta, 0); // 12

Atomics.isLockFree(1); // true
Atomics.isLockFree(2); // true
Atomics.isLockFree(3); // false
Atomics.isLockFree(4); // true

Atomics.or(ta, 0, 1); // 12
Atomics.load(ta, 0); // 13

Atomics.store(ta, 0, 12); // 12

Atomics.sub(ta, 0, 2); // 12
Atomics.load(ta, 0); // 10

Atomics.xor(ta, 0, 1); // 10
Atomics.load(ta, 0); // 11
Waiting and notifyingGiven a shared Int32Array:
jsconst sab = new SharedArrayBuffer(1024);
const int32 = new Int32Array(sab);

A reading thread is sleeping and waiting on location 0 which is expected to be 0. As long as that is true, it will not go on. However, once the writing thread has stored a new value, it will be notified by the writing thread and return the new value (123).
jsAtomics.wait(int32, 0, 0);
console.log(int32[0]); // 123

A writing thread stores a new value and notifies the waiting thread once it has written:
jsconsole.log(int32[0]); // 0;
Atomics.store(int32, 0, 123);
Atomics.notify(int32, 0, 1);
SpecificationsSpecificationECMAScript Language Specification # sec-atomics-objectBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
ArrayBuffer
JavaScript typed arrays guide
Web Workers
Shared Memory – a brief tutorial in the TC39 ecmascript-sharedmem proposal
A Taste of JavaScript's New Parallel Primitives on hacks.mozilla.org (2016)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
BigIntBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackBigInt values represent numeric values which are too large to be represented by the number primitive.DescriptionA BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
jsconst previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt("9007199254740991");
// 9007199254740991n

const hugeHex = BigInt("0x1fffffffffffff");
// 9007199254740991n

const hugeOctal = BigInt("0o377777777777777777");
// 9007199254740991n

const hugeBin = BigInt(
  "0b11111111111111111111111111111111111111111111111111111",
);
// 9007199254740991n

BigInt values are similar to Number values in some ways, but also differ in a few key matters: A BigInt value cannot be used with methods in the built-in Math object and cannot be mixed with a Number value in operations; they must be coerced to the same type. Be careful coercing values back and forth, however, as the precision of a BigInt value may be lost when it is coerced to a Number value.Type informationWhen tested against typeof, a BigInt value (bigint primitive) will give "bigint":
jstypeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

A BigInt value can also be wrapped in an Object:
jstypeof Object(1n) === "object"; // true
OperatorsMost operators support BigInts, however most do not permit operands to be of mixed types — both operands must be BigInt or neither:

Arithmetic operators: +, -, *, /, %, **
Bitwise operators: >>, <<, &, |, ^, ~
Unary negation (-)
Increment/decrement: ++, --

The boolean-returning operators allow mixing numbers and BigInts as operands:

Relational operators and equality operators: >, <, >=, <=, ==, !=, ===, !==
Logical operators only rely on the truthiness of operands

A couple of operators do not support BigInt at all:

Unary plus (+) cannot be supported due to conflicting usage in asm.js, so it has been left out in order to not break asm.js.
Unsigned right shift (>>>) is the only bitwise operator that's unsupported, as every BigInt value is signed.

Special cases:

Addition (+) involving a string and a BigInt returns a string.
Division (/) truncates fractional components towards zero, since BigInt is unable to represent fractional quantities.

jsconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const multi = previousMaxSafe * 2n; // 18014398509481982n
const subtr = multi - 10n; // 18014398509481972n
const mod = multi % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * -1n; // -18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
ComparisonsA BigInt value is not strictly equal to a Number value, but it is loosely so:
js0n === 0; // false
0n == 0; // true

A Number value and a BigInt value may be compared as usual:
js1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true

BigInt values and Number values may be mixed in arrays and sorted:
jsconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won't work since subtraction will not work with mixed types
// TypeError: can't convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]

Note that comparisons with Object-wrapped BigInt values act as with other objects, only indicating equality when the same object instance is compared:
jsObject(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true

Because coercing between Number values and BigInt values can lead to loss of precision, the following are recommended:

Only use a BigInt value when values greater than 253 are reasonably expected.
Don't coerce between BigInt values and Number values.
ConditionalsA BigInt value follows the same conversion rules as Numbers when:

it is converted to a Boolean: via the Boolean function;
when used with logical operators ||, &&, and !; or
within a conditional test like an if statement.

Namely, only 0n is falsy; everything else is truthy.
jsif (0n) {
  console.log("Hello from the if!");
} else {
  console.log("Hello from the else!");
}
// "Hello from the else!"

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
CryptographyThe operations supported on BigInt values are not constant-time and are thus open to timing attacks. JavaScript BigInts therefore could be dangerous for use in cryptography without mitigating factors. As a very generic example, an attacker could measure the time difference between 101n ** 65537n and 17n ** 9999n, and deduce the magnitude of secrets, such as private keys, based on the time elapsed. If you still have to use BigInts, take a look at the Timing attack FAQ for general advice regarding the issue.Use within JSONUsing JSON.stringify() with any BigInt value will raise a TypeError, as BigInt values aren't serialized in JSON by default. However, JSON.stringify() specifically leaves a backdoor for BigInt values: it would try to call the BigInt's toJSON() method. (It doesn't do so for any other primitive values.) Therefore, you can implement your own toJSON() method (which is one of the few cases where patching built-in objects is not explicitly discouraged):
jsBigInt.prototype.toJSON = function () {
  return this.toString();
};

Instead of throwing, JSON.stringify() now produces a string like this:
jsconsole.log(JSON.stringify({ a: 1n }));
// {"a":"1"}

If you do not wish to patch BigInt.prototype, you can use the replacer parameter of JSON.stringify to serialize BigInt values:
jsconst replacer = (key, value) =>
  typeof value === "bigint" ? value.toString() : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {"number":1,"big":"18014398509481982"}

If you have JSON data containing values you know will be large integers, you can use the reviver parameter of JSON.parse to handle them:
jsconst reviver = (key, value) => (key === "big" ? BigInt(value) : value);

const payload = '{"number":1,"big":"18014398509481982"}';
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }


Note: While it's possible to make the replacer of JSON.stringify() generic and properly serialize BigInt values for all objects, the reviver of JSON.parse() must be specific to the payload shape you expect, because the serialization is lossy: it's not possible to distinguish between a string that represents a BigInt and a normal string.
BigInt coercionMany built-in operations that expect BigInts first coerce their arguments to BigInts. The operation can be summarized as follows:

BigInts are returned as-is.
undefined and null throw a TypeError.
true turns into 1n; false turns into 0n.
Strings are converted by parsing them as if they contain an integer literal. Any parsing failure results in a SyntaxError. The syntax is a subset of string numeric literals, where decimal points or exponent indicators are not allowed.
Numbers throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [@@toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a BigInt.

The best way to achieve nearly the same effect in JavaScript is through the BigInt() function: BigInt(x) uses the same algorithm to convert x, except that Numbers don't throw a TypeError, but are converted to BigInts if they are integers.
Note that built-in operations expecting BigInts often truncate the BigInt to a fixed width after coercion. This includes BigInt.asIntN(), BigInt.asUintN(), and methods of BigInt64Array and BigUint64Array.Constructor
BigInt()

Creates a new BigInt value.

Static methods
BigInt.asIntN()

Clamps a BigInt value to a signed integer value, and returns that value.

BigInt.asUintN()

Clamps a BigInt value to an unsigned integer value, and returns that value.

Instance propertiesThese properties are defined on BigInt.prototype and shared by all BigInt instances.

BigInt.prototype.constructor

The constructor function that created the instance object. For BigInt instances, the initial value is the BigInt constructor.

BigInt.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "BigInt". This property is used in Object.prototype.toString(). However, because BigInt also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a BigInt as thisArg.

Instance methods
BigInt.prototype.toLocaleString()

Returns a string with a language-sensitive representation of this BigInt value. Overrides the Object.prototype.toLocaleString() method.

BigInt.prototype.toString()

Returns a string representing this BigInt value in the specified radix (base). Overrides the Object.prototype.toString() method.

BigInt.prototype.valueOf()

Returns this BigInt value. Overrides the Object.prototype.valueOf() method.

ExamplesCalculating Primesjs// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
SpecificationsSpecificationECMAScript Language Specification # sec-bigint-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Number
Number.MAX_SAFE_INTEGER
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 28, 2023 by MDN contributors.
BigInt64ArrayThe BigInt64Array typed array represents an array of 64-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigInt64Array is a subclass of the hidden TypedArray class.Try itConstructor
BigInt64Array()

Creates a new BigInt64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigInt64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigInt64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigInt64Array.prototype and shared by all BigInt64Array instances.

BigInt64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigInt64Array.

BigInt64Array.prototype.constructor

The constructor function that created the instance object. For BigInt64Array instances, the initial value is the BigInt64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigInt64Arrayjs// From a length
const bigint64 = new BigInt64Array(2);
bigint64[0] = 42n;
console.log(bigint64[0]); // 42n
console.log(bigint64.length); // 2
console.log(bigint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigInt64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigInt64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigInt64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const bigint64FromIterable = new BigInt64Array(iterable);
console.log(bigint64FromIterable);
// BigInt64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript Language Specification # sec-typedarray-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 15, 2024 by MDN contributors.
BigUint64ArrayThe BigUint64Array typed array represents an array of 64-bit unsigned integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigUint64Array is a subclass of the hidden TypedArray class.Constructor
BigUint64Array()

Creates a new BigUint64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigUint64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigUint64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigUint64Array.prototype and shared by all BigUint64Array instances.

BigUint64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigUint64Array.

BigUint64Array.prototype.constructor

The constructor function that created the instance object. For BigUint64Array instances, the initial value is the BigUint64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigUint64Arrayjs// From a length
const biguint64 = new BigUint64Array(2);
biguint64[0] = 42n;
console.log(biguint64[0]); // 42n
console.log(biguint64.length); // 2
console.log(biguint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigUint64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigUint64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigUint64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const biguint64FromIterable = new BigUint64Array(iterable);
console.log(biguint64FromIterable);
// BigUint64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript Language Specification # sec-typedarray-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
BooleanThe Boolean object represents a truth value: true or false.DescriptionBoolean primitives and Boolean objectsFor converting non-boolean values to boolean, use Boolean as a function or use the double NOT operator. Do not use the Boolean() constructor with new.
jsconst good = Boolean(expression);
const good2 = !!expression;

jsconst bad = new Boolean(expression); // don't use this!

This is because all objects, including a Boolean object whose wrapped value is false, are truthy and evaluate to true in places such as conditional statements. (See also the boolean coercion section below.)
jsif (new Boolean(true)) {
  console.log("This log is printed.");
}

if (new Boolean(false)) {
  console.log("This log is ALSO printed.");
}

const myFalse = new Boolean(false); // myFalse is a Boolean object (not the primitive value false)
const g = Boolean(myFalse); // g is true
const myString = new String("Hello"); // myString is a String object
const s = Boolean(myString); // s is true


Warning: You should rarely find yourself using Boolean as a constructor.
Boolean coercionMany built-in operations that expect booleans first coerce their arguments to booleans. The operation can be summarized as follows:

Booleans are returned as-is.
undefined turns into false.
null turns into false.
0, -0, and NaN turn into false; other numbers turn into true.
0n turns into false; other BigInts turn into true.
The empty string "" turns into false; other strings turn into true.
Symbols turn into true.
All objects become true.


Note: A legacy behavior makes document.all return false when used as a boolean, despite it being an object. This property is legacy and non-standard and should not be used.


Note: Unlike other type conversions like string coercion or number coercion, boolean coercion does not attempt to convert objects to primitives.

In other words, there are only a handful of values that get coerced to false — these are called falsy values. All other values are called truthy values. A value's truthiness is important when used with logical operators, conditional statements, or any boolean context.
There are two ways to achieve the same effect in JavaScript.

Double NOT: !!x negates x twice, which converts x to a boolean using the same algorithm as above.
The Boolean() function: Boolean(x) uses the same algorithm as above to convert x.

Note that truthiness is not the same as being loosely equal to true or false.
jsif ([]) {
  console.log("[] is truthy");
}
if ([] == false) {
  console.log("[] == false");
}
// [] is truthy
// [] == false

[] is truthy, but it's also loosely equal to false. It's truthy, because all objects are truthy. However, when comparing with false, which is a primitive, [] is also converted to a primitive, which is "" via Array.prototype.toString(). Comparing strings and booleans results in both being converted to numbers, and they both become 0, so [] == false is true. In general, falsiness and == false differ in the following cases:

NaN, undefined, and null are falsy but not loosely equal to false.
"0" (and other string literals that are not "" but get coerced to 0) is truthy but loosely equal to false.
Objects are always truthy, but their primitive representation may be loosely equal to false.

Truthy values are even more unlikely to be loosely equal to true. All values are either truthy or falsy, but most values are loosely equal to neither true nor false.Constructor
Boolean()

Creates a new Boolean object.

Instance propertiesThese properties are defined on Boolean.prototype and shared by all Boolean instances.

Boolean.prototype.constructor

The constructor function that created the instance object. For Boolean instances, the initial value is the Boolean constructor.

Instance methods
Boolean.prototype.toString()

Returns a string of either true or false depending upon the value of the object. Overrides the Object.prototype.toString() method.

Boolean.prototype.valueOf()

Returns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.

ExamplesCreating Boolean objects with an initial value of falsejsconst bNoParam = new Boolean();
const bZero = new Boolean(0);
const bNull = new Boolean(null);
const bEmptyString = new Boolean("");
const bfalse = new Boolean(false);
Creating Boolean objects with an initial value of truejsconst btrue = new Boolean(true);
const btrueString = new Boolean("true");
const bfalseString = new Boolean("false");
const bSuLin = new Boolean("Su Lin");
const bArrayProto = new Boolean([]);
const bObjProto = new Boolean({});
SpecificationsSpecificationECMAScript Language Specification # sec-boolean-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Boolean
Boolean primitives
Boolean data type on Wikipedia
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 12, 2024 by MDN contributors.
DataViewThe DataView view provides a low-level interface for reading and writing multiple number types in a binary ArrayBuffer, without having to care about the platform's endianness.DescriptionEndiannessMulti-byte number formats are represented in memory differently depending on machine architecture — see Endianness for an explanation. DataView accessors provide explicit control of how data is accessed, regardless of the executing computer's endianness.
jsconst littleEndian = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
  // Int16Array uses the platform's endianness.
  return new Int16Array(buffer)[0] === 256;
})();
console.log(littleEndian); // true or false
64-bit Integer ValuesSome browsers don't have support for DataView.prototype.setBigInt64() and DataView.prototype.setBigUint64(). So to enable 64-bit operations in your code that will work across browsers, you could implement your own getUint64() function, to obtain values with precision up to Number.MAX_SAFE_INTEGER — which could suffice for certain cases.
jsfunction getUint64(dataview, byteOffset, littleEndian) {
  // split 64-bit number into two 32-bit (4-byte) parts
  const left = dataview.getUint32(byteOffset, littleEndian);
  const right = dataview.getUint32(byteOffset + 4, littleEndian);

  // combine the two 32-bit values
  const combined = littleEndian
    ? left + 2 ** 32 * right
    : 2 ** 32 * left + right;

  if (!Number.isSafeInteger(combined))
    console.warn(combined, "exceeds MAX_SAFE_INTEGER. Precision may be lost");

  return combined;
}

Alternatively, if you need full 64-bit range, you can create a BigInt. Further, although native BigInts are much faster than user-land library equivalents, BigInts will always be much slower than 32-bit integers in JavaScript due to the nature of their variable size.
jsconst BigInt = window.BigInt,
  bigThirtyTwo = BigInt(32),
  bigZero = BigInt(0);
function getUint64BigInt(dataview, byteOffset, littleEndian) {
  // split 64-bit number into two 32-bit (4-byte) parts
  const left = BigInt(dataview.getUint32(byteOffset | 0, !!littleEndian) >>> 0);
  const right = BigInt(
    dataview.getUint32(((byteOffset | 0) + 4) | 0, !!littleEndian) >>> 0,
  );

  // combine the two 32-bit values and return
  return littleEndian
    ? (right << bigThirtyTwo) | left
    : (left << bigThirtyTwo) | right;
}
Constructor
DataView()

Creates a new DataView object.

Instance propertiesThese properties are defined on DataView.prototype and shared by all DataView instances.

DataView.prototype.buffer

The ArrayBuffer referenced by this view. Fixed at construction time and thus read only.

DataView.prototype.byteLength

The length (in bytes) of this view. Fixed at construction time and thus read only.

DataView.prototype.byteOffset

The offset (in bytes) of this view from the start of its ArrayBuffer. Fixed at construction time and thus read only.

DataView.prototype.constructor

The constructor function that created the instance object. For DataView instances, the initial value is the DataView constructor.

DataView.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "DataView". This property is used in Object.prototype.toString().

Instance methods
DataView.prototype.getBigInt64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit signed integer.

DataView.prototype.getBigUint64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit unsigned integer.

DataView.prototype.getFloat32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit floating point number.

DataView.prototype.getFloat64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit floating point number.

DataView.prototype.getInt16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit signed integer.

DataView.prototype.getInt32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit signed integer.

DataView.prototype.getInt8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit signed integer.

DataView.prototype.getUint16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit unsigned integer.

DataView.prototype.getUint32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit unsigned integer.

DataView.prototype.getUint8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit unsigned integer.

DataView.prototype.setBigInt64()

Takes a BigInt and stores it as a 64-bit signed integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setBigUint64()

Takes a BigInt and stores it as a 64-bit unsigned integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat32()

Takes a number and stores it as a 32-bit float in the 4 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat64()

Takes a number and stores it as a 64-bit float in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setInt16()

Takes a number and stores it as a 16-bit signed integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt32()

Takes a number and stores it as a 32-bit signed integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt8()

Takes a number and stores it as an 8-bit signed integer in the byte at the specified byte offset of this DataView.

DataView.prototype.setUint16()

Takes a number and stores it as a 16-bit unsigned integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint32()

Takes a number and stores it as a 32-bit unsigned integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint8()

Takes a number and stores it as an 8-bit unsigned integer in the byte at the specified byte offset of this DataView.

ExamplesUsing DataViewjsconst buffer = new ArrayBuffer(16);
const view = new DataView(buffer, 0);

view.setInt16(1, 42);
view.getInt16(1); // 42
SpecificationsSpecificationECMAScript Language Specification # sec-dataview-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of DataView in core-js
ArrayBuffer
SharedArrayBuffer
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 21, 2023 by MDN contributors.
DateJavaScript Date objects represent a single moment in time in a platform-independent format. Date objects encapsulate an integral number that represents milliseconds since the midnight at the beginning of January 1, 1970, UTC (the epoch).

Note: TC39 is working on Temporal, a new Date/Time API. Read more about it on the Igalia blog. It is not yet ready for production use!
DescriptionThe epoch, timestamps, and invalid dateA JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history.

Note: While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e. host system) time zone and offset.

The maximum timestamp representable by a Date object is slightly smaller than the maximum safe integer (Number.MAX_SAFE_INTEGER, which is 9,007,199,254,740,991). A Date object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the Date object holding a timestamp value of NaN, which is an "Invalid Date".
jsconsole.log(new Date(8.64e15).toString()); // "Sat Sep 13 275760 00:00:00 GMT+0000 (Coordinated Universal Time)"
console.log(new Date(8.64e15 + 1).toString()); // "Invalid Date"

There are various methods that allow you to interact with the timestamp stored in the date:

You can interact with the timestamp value directly using the getTime() and setTime() methods.
The valueOf() and [@@toPrimitive]() (when passed "number") methods — which are automatically called in number coercion — return the timestamp, causing Date objects to behave like their timestamps when used in number contexts.
All static methods (Date.now(), Date.parse(), and Date.UTC()) return timestamps instead of Date objects.
The Date() constructor can be called with a timestamp as the only argument.
Date components and time zonesA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device).

Note: UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page.

For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:

As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,
As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969.

The getTimezoneOffset() method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the Date object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the Date object and at the location of the host environment.
There are two groups of Date methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC.



Component
Local
UTC


Get
Set
Get
Set




Year
getFullYear()
setFullYear()
getUTCFullYear()
setUTCFullYear()


Month
getMonth()
setMonth()
getUTCMonth()
setUTCMonth()


Date (of month)
getDate()
setDate()
getUTCDate()
setUTCDate()


Hours
getHours()
setHours()
getUTCHours()
setUTCHours()


Minutes
getMinutes()
setMinutes()
getUTCMinutes()
setUTCMinutes()


Seconds
getSeconds()
setSeconds()
getUTCSeconds()
setUTCSeconds()


Milliseconds
getMilliseconds()
setMilliseconds()
getUTCMilliseconds()
setUTCMilliseconds()


Day (of week)
getDay()
N/A
getUTCDay()
N/A



The Date() constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. Date.UTC() works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year.

Note: Some methods, including the Date() constructor, Date.UTC(), and the deprecated getYear()/setYear() methods, interpret a two-digit year as a year in the 1900s. For example, new Date(99, 5, 24) is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information.

When a segment overflows or underflows its expected range, it usually "carries over to" or "borrows from" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.Date time string formatThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ


YYYY is the year, with four digits (0000 to 9999), or as an expanded year of + or - followed by six digits. The sign is required for expanded years. -000000 is explicitly disallowed as a valid year.
MM is the month, with two digits (01 to 12). Defaults to 01.
DD is the day of the month, with two digits (01 to 31). Defaults to 01.
T is a literal character, which indicates the beginning of the time part of the string. The T is required when specifying the time part.
HH is the hour, with two digits (00 to 23). As a special case, 24:00:00 is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to 00.
mm is the minute, with two digits (00 to 59). Defaults to 00.
ss is the second, with two digits (00 to 59). Defaults to 00.
sss is the millisecond, with three digits (000 to 999). Defaults to 000.
Z is the timezone offset, which can either be the literal character Z (indicating UTC), or + or - followed by HH:mm, the offset in hours and minutes from UTC.

Various components can be omitted, so the following are all valid:

Date-only form: YYYY, YYYY-MM, YYYY-MM-DD
Date-time form: one of the above date-only forms, followed by T, followed by HH:mm, HH:mm:ss, or HH:mm:ss.sss. Each combination can be followed by a time zone offset.

For example, "2011-10-10" (date-only form), "2011-10-10T14:48:00" (date-time form), or "2011-10-10T14:48:00.000+09:00" (date-time form with milliseconds and time zone) are all valid date time strings.
When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as local time. This is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue.
Date.parse() and the Date() constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format.
The toISOString() method returns a string representation of the date in the date time string format, with the time zone offset always set to Z (UTC).

Note: You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated.

Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, "February 30"). Implementations behave inconsistently in this case. The Date.parse() page offers more examples about these non-standard cases.Other ways to format a date
toISOString() returns a string in the format 1970-01-01T00:00:00.000Z (the date time string format introduced above, which is simplified ISO 8601). toJSON() calls toISOString() and returns the result.
toString() returns a string in the format Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time), while toDateString() and toTimeString() return the date and time parts of the string, respectively. [@@toPrimitive]() (when passed "string" or "default") calls toString() and returns the result.
toUTCString() returns a string in the format Thu, 01 Jan 1970 00:00:00 GMT (generalized RFC 7231).
toLocaleDateString(), toLocaleTimeString(), and toLocaleString() use locale-specific date and time formats, usually provided by the Intl API.

See the Formats of toString method return values section for examples.Constructor
Date()

When called as a constructor, returns a new Date object. When called as a function, returns a string representation of the current date and time.

Static methods
Date.now()

Returns the numeric value corresponding to the current time—the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.parse()

Parses a string representation of a date and returns the number of milliseconds since 1 January, 1970, 00:00:00 UTC, with leap seconds ignored.

Date.UTC()

Accepts the same parameters as the longest form of the constructor (i.e. 2 to 7) and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC, with leap seconds ignored.

Instance propertiesThese properties are defined on Date.prototype and shared by all Date instances.

Date.prototype.constructor

The constructor function that created the instance object. For Date instances, the initial value is the Date constructor.

Instance methods
Date.prototype.getDate()

Returns the day of the month (1 – 31) for the specified date according to local time.

Date.prototype.getDay()

Returns the day of the week (0 – 6) for the specified date according to local time.

Date.prototype.getFullYear()

Returns the year (4 digits for 4-digit years) of the specified date according to local time.

Date.prototype.getHours()

Returns the hour (0 – 23) in the specified date according to local time.

Date.prototype.getMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to local time.

Date.prototype.getMinutes()

Returns the minutes (0 – 59) in the specified date according to local time.

Date.prototype.getMonth()

Returns the month (0 – 11) in the specified date according to local time.

Date.prototype.getSeconds()

Returns the seconds (0 – 59) in the specified date according to local time.

Date.prototype.getTime()

Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970, 00:00:00 UTC. (Negative values are returned for prior times.)

Date.prototype.getTimezoneOffset()

Returns the time-zone offset in minutes for the current locale.

Date.prototype.getUTCDate()

Returns the day (date) of the month (1 – 31) in the specified date according to universal time.

Date.prototype.getUTCDay()

Returns the day of the week (0 – 6) in the specified date according to universal time.

Date.prototype.getUTCFullYear()

Returns the year (4 digits for 4-digit years) in the specified date according to universal time.

Date.prototype.getUTCHours()

Returns the hours (0 – 23) in the specified date according to universal time.

Date.prototype.getUTCMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to universal time.

Date.prototype.getUTCMinutes()

Returns the minutes (0 – 59) in the specified date according to universal time.

Date.prototype.getUTCMonth()

Returns the month (0 – 11) in the specified date according to universal time.

Date.prototype.getUTCSeconds()

Returns the seconds (0 – 59) in the specified date according to universal time.

Date.prototype.getYear() 
Deprecated


Returns the year (usually 2–3 digits) in the specified date according to local time. Use getFullYear() instead.

Date.prototype.setDate()

Sets the day of the month for a specified date according to local time.

Date.prototype.setFullYear()

Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time.

Date.prototype.setHours()

Sets the hours for a specified date according to local time.

Date.prototype.setMilliseconds()

Sets the milliseconds for a specified date according to local time.

Date.prototype.setMinutes()

Sets the minutes for a specified date according to local time.

Date.prototype.setMonth()

Sets the month for a specified date according to local time.

Date.prototype.setSeconds()

Sets the seconds for a specified date according to local time.

Date.prototype.setTime()

Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC. Use negative numbers for times prior.

Date.prototype.setUTCDate()

Sets the day of the month for a specified date according to universal time.

Date.prototype.setUTCFullYear()

Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time.

Date.prototype.setUTCHours()

Sets the hour for a specified date according to universal time.

Date.prototype.setUTCMilliseconds()

Sets the milliseconds for a specified date according to universal time.

Date.prototype.setUTCMinutes()

Sets the minutes for a specified date according to universal time.

Date.prototype.setUTCMonth()

Sets the month for a specified date according to universal time.

Date.prototype.setUTCSeconds()

Sets the seconds for a specified date according to universal time.

Date.prototype.setYear() 
Deprecated


Sets the year (usually 2–3 digits) for a specified date according to local time. Use setFullYear() instead.

Date.prototype.toDateString()

Returns the "date" portion of the Date as a human-readable string like 'Thu Apr 12 2018'.

Date.prototype.toISOString()

Converts a date to a string following the ISO 8601 Extended Format.

Date.prototype.toJSON()

Returns a string representing the Date using toISOString(). Intended for use by JSON.stringify().

Date.prototype.toLocaleDateString()

Returns a string with a locality sensitive representation of the date portion of this date based on system settings.

Date.prototype.toLocaleString()

Returns a string with a locality-sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.

Date.prototype.toLocaleTimeString()

Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings.

Date.prototype.toString()

Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.

Date.prototype.toTimeString()

Returns the "time" portion of the Date as a human-readable string.

Date.prototype.toUTCString()

Converts a date to a string using the UTC timezone.

Date.prototype.valueOf()

Returns the primitive value of a Date object. Overrides the Object.prototype.valueOf() method.

Date.prototype[@@toPrimitive]()

Converts this Date object to a primitive value.

ExamplesSeveral ways to create a Date objectThe following examples show several ways to create JavaScript dates:

Note: Creating a date from a string has a lot of behavior inconsistencies. See date time string format for caveats on using different formats.

jsconst today = new Date();
const birthday = new Date("December 17, 1995 03:24:00"); // DISCOURAGED: may not work in all runtimes
const birthday2 = new Date("1995-12-17T03:24:00"); // This is standardized and will work reliably
const birthday3 = new Date(1995, 11, 17); // the month is 0-indexed
const birthday4 = new Date(1995, 11, 17, 3, 24, 0);
const birthday5 = new Date(628021800000); // passing epoch timestamp
Formats of toString method return valuesjsconst date = new Date("2020-05-12T23:50:21.817Z");
date.toString(); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)
date.toDateString(); // Tue May 12 2020
date.toTimeString(); // 18:50:21 GMT-0500 (Central Daylight Time)
date[Symbol.toPrimitive]("string"); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)

date.toISOString(); // 2020-05-12T23:50:21.817Z
date.toJSON(); // 2020-05-12T23:50:21.817Z

date.toUTCString(); // Tue, 12 May 2020 23:50:21 GMT

date.toLocaleString(); // 5/12/2020, 6:50:21 PM
date.toLocaleDateString(); // 5/12/2020
date.toLocaleTimeString(); // 6:50:21 PM
To get Date, Month and Year or Timejsconst date = new Date("2000-01-17T16:45:30");
const [month, day, year] = [
  date.getMonth(),
  date.getDate(),
  date.getFullYear(),
];
// [0, 17, 2000] as month are 0-indexed
const [hour, minutes, seconds] = [
  date.getHours(),
  date.getMinutes(),
  date.getSeconds(),
];
// [16, 45, 30]
Interpretation of two-digit yearsnew Date() exhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a new Date() call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year 1900, but in other cases, as an offset from the year 2000.
jslet date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)

// Legacy method; always interprets two-digit year values as relative to 1900
date.setYear(98);
date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date.setYear(22);
date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)

So, to create and get dates between the years 0 and 99, instead use the preferred setFullYear() and getFullYear() methods:.
js// Preferred method; never interprets any value as being a relative offset,
// but instead uses the year value as-is
date.setFullYear(98);
date.getFullYear(); // 98 (not 1998)
date.setFullYear(22);
date.getFullYear(); // 22 (not 1922, not 2022)
Calculating elapsed timeThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds.
Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted.
js// Using Date objects
const start = Date.now();

// The event to time goes here:
doSomethingForALongTime();
const end = Date.now();
const elapsed = end - start; // elapsed time in milliseconds

js// Using built-in methods
const start = new Date();

// The event to time goes here:
doSomethingForALongTime();
const end = new Date();
const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds

js// To test a function and get back its return
function printElapsedTime(testFn) {
  const startTime = Date.now();
  const result = testFn();
  const endTime = Date.now();

  console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`);
  return result;
}

const yourFunctionReturn = printElapsedTime(yourFunction);


Note: In browsers that support the Web Performance API's high-resolution time feature, Performance.now() can provide more reliable and precise measurements of elapsed time than Date.now().
Get the number of seconds since the ECMAScript Epochjsconst seconds = Math.floor(Date.now() / 1000);

In this case, it's important to return only an integer—so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses Math.floor(), and not Math.round().)SpecificationsSpecificationECMAScript Language Specification # sec-date-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Date()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
decodeURI()The decodeURI() function decodes a Uniform Resource Identifier (URI) previously created by encodeURI() or a similar routine.Try itSyntaxjsdecodeURI(encodedURI)
Parameters
encodedURI

A complete, encoded Uniform Resource Identifier.

Return valueA new string representing the unencoded version of the given encoded Uniform Resource Identifier (URI).Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURI() is a function property of the global object.
The decodeURI() function decodes the URI by treating each escape sequence in the form %XX as one UTF-8 code unit (one byte). In UTF-8, the number of leading 1 bits in the first byte, which may be 0 (for 1-byte ASCII characters), 2, 3, or 4, indicates the number of bytes in the character. So by reading the first escape sequence, decodeURI() can determine how many more escape sequences to consume. If decodeURI() fails to find the expected number of sequences, or if the escape sequences don't encode a valid UTF-8 character, a URIError is thrown.
decodeURI() decodes all escape sequences, but if the escape sequence encodes one of the following characters, the escape sequence is preserved in the output string (because they are part of the URI syntax):
; / ? : @ & = + $ , #
ExamplesDecoding a Cyrillic URLjsdecodeURI(
  "https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B",
);
// "https://developer.mozilla.org/ru/docs/JavaScript_шеллы"
decodeURI() vs. decodeURIComponent()decodeURI() assumes the input is a full URI, so it does not decode characters that are part of the URI syntax.
jsdecodeURI(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript%3A a_scripting_language"

decodeURIComponent(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript: a_scripting_language"
Catching errorsjstry {
  const a = decodeURI("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
SpecificationsSpecificationECMAScript Language Specification # sec-decodeuri-encodeduriBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
decodeURIComponent()
encodeURI()
encodeURIComponent()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
decodeURIComponent()The decodeURIComponent() function decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent() or by a similar routine.Try itSyntaxjsdecodeURIComponent(encodedURI)
Parameters
encodedURI

An encoded component of a Uniform Resource Identifier.

Return valueA new string representing the decoded version of the given encoded Uniform Resource Identifier (URI) component.Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURIComponent() is a function property of the global object.
decodeURIComponent() uses the same decoding algorithm as described in decodeURI(). It decodes all escape sequences, including those that are not created by encodeURIComponent, like -.!~*'().ExamplesDecoding a Cyrillic URL componentjsdecodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");
// "JavaScript_шеллы"
Catching errorsjstry {
  const a = decodeURIComponent("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
Decoding query parameters from a URLdecodeURIComponent() cannot be used directly to parse query parameters from a URL. It needs a bit of preparation.
jsfunction decodeQueryParam(p) {
  return decodeURIComponent(p.replace(/\+/g, " "));
}

decodeQueryParam("search+query%20%28correct%29");
// 'search query (correct)'
SpecificationsSpecificationECMAScript Language Specification # sec-decodeuricomponent-encodeduricomponentBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
decodeURI
encodeURI
encodeURIComponent
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 21, 2023 by MDN contributors.
encodeURI()The encodeURI() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURIComponent(), this function encodes fewer characters, preserving those that are part of the URI syntax.Try itSyntaxjsencodeURI(uri)
Parameters
uri

A string to be encoded as a URI.

Return valueA new string representing the provided string encoded as a URI.Exceptions
URIError

Thrown if uri contains a lone surrogate.

DescriptionencodeURI() is a function property of the global object.
The encodeURI() function escapes characters by UTF-8 code units, with each octet encoded in the format %XX, left-padded with 0 if necessary. Because lone surrogates in UTF-16 do not encode any valid Unicode character, they cause encodeURI() to throw a URIError.
encodeURI() escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

; / ? : @ & = + $ , #

The characters on the second line are characters that may be part of the URI syntax, and are only escaped by encodeURIComponent(). Both encodeURI() and encodeURIComponent() do not encode the characters -.!~*'(), known as "unreserved marks", which do not have a reserved purpose but are allowed in a URI "as is". (See RFC2396)
The encodeURI() function does not encode characters that have special meaning (reserved characters) for a URI. The following example shows all the parts that a URI can possibly contain. Note how certain characters are used to signify special meaning:
urlhttp://username:password@www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor

encodeURI, as the name implies, is used to encode a URL as a whole, assuming it is already well-formed. If you want to dynamically assemble string values into a URL, you probably want to use encodeURIComponent() on each dynamic segment instead, to avoid URL syntax characters in unwanted places.
jsconst name = "Ben & Jerry's";

// This is bad:
const link = encodeURI(`https://example.com/?choice=${name}`); // "https://example.com/?choice=Ben%20&%20Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', 'Ben '], [" Jerry's", '']

// Instead:
const link = encodeURI(
  `https://example.com/?choice=${encodeURIComponent(name)}`,
);
// "https://example.com/?choice=Ben%2520%2526%2520Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', "Ben%20%26%20Jerry's"]]
ExamplesencodeURI() vs. encodeURIComponent()encodeURI() differs from encodeURIComponent() as follows:
jsconst set1 = ";/?:@&=+$,#"; // Reserved Characters
const set2 = "-.!~*'()"; // Unreserved Marks
const set3 = "ABC abc 123"; // Alphanumeric Characters + Space

console.log(encodeURI(set1)); // ;/?:@&=+$,#
console.log(encodeURI(set2)); // -.!~*'()
console.log(encodeURI(set3)); // ABC%20abc%20123 (the space gets encoded as %20)

console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24%23
console.log(encodeURIComponent(set2)); // -.!~*'()
console.log(encodeURIComponent(set3)); // ABC%20abc%20123 (the space gets encoded as %20)
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURI("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uD800");

// Lone low-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURI().Encoding for RFC3986The more recent RFC3986 makes square brackets reserved (for IPv6) and thus not encoded when forming something which could be part of a URL (such as a host). It also reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL format.
jsfunction encodeRFC3986URI(str) {
  return encodeURI(str)
    .replace(/%5B/g, "[")
    .replace(/%5D/g, "]")
    .replace(
      /[!'()*]/g,
      (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
    );
}
SpecificationsSpecificationECMAScript Language Specification # sec-encodeuri-uriBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
decodeURI()
encodeURIComponent()
decodeURIComponent()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 6, 2023 by MDN contributors.
encodeURIComponent()The encodeURIComponent() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURI(), this function encodes more characters, including those that are part of the URI syntax.Try itSyntaxjsencodeURIComponent(uriComponent)
Parameters
uriComponent

A string to be encoded as a URI component (a path, query string, fragment, etc.). Other values are converted to strings.

Return valueA new string representing the provided uriComponent encoded as a URI component.Exceptions
URIError

Thrown if uriComponent contains a lone surrogate.

DescriptionencodeURIComponent() is a function property of the global object.
encodeURIComponent() uses the same encoding algorithm as described in encodeURI(). It escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

Compared to encodeURI(), encodeURIComponent() escapes a larger set of characters. Use encodeURIComponent() on user-entered fields from forms POST'd to the server — this will encode & symbols that may inadvertently be generated during data entry for special HTML entities or other characters that require encoding/decoding. For example, if a user writes Jack & Jill, without encodeURIComponent(), the ampersand could be interpreted on the server as the start of a new field and jeopardize the integrity of the data.
For application/x-www-form-urlencoded, spaces are to be replaced by +, so one may wish to follow a encodeURIComponent() replacement with an additional replacement of %20 with +.ExamplesEncoding for Content-Disposition and Link headersThe following example provides the special encoding required within UTF-8 Content-Disposition and Link server response header parameters (e.g., UTF-8 filenames):
jsconst fileName = "my file(2).txt";
const header = `Content-Disposition: attachment; filename*=UTF-8''${encodeRFC5987ValueChars(
  fileName,
)}`;

console.log(header);
// "Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt"

function encodeRFC5987ValueChars(str) {
  return (
    encodeURIComponent(str)
      // The following creates the sequences %27 %28 %29 %2A (Note that
      // the valid encoding of "*" is %2A, which necessitates calling
      // toUpperCase() to properly encode). Although RFC3986 reserves "!",
      // RFC5987 does not, so we do not need to escape it.
      .replace(
        /['()*]/g,
        (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
      )
      // The following are not required for percent-encoding per RFC5987,
      // so we can allow for a little better readability over the wire: |`^
      .replace(/%(7C|60|5E)/g, (str, hex) =>
        String.fromCharCode(parseInt(hex, 16)),
      )
  );
}
Encoding for RFC3986The more recent RFC3986 reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL component format. It also encodes [ and ], which are part of the IPv6 URI syntax. An RFC3986-compliant encodeURI implementation should not escape them, which is demonstrated in the encodeURI() example.
jsfunction encodeRFC3986URIComponent(str) {
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
  );
}
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURIComponent("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uD800");

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURIComponent().SpecificationsSpecificationECMAScript Language Specification # sec-encodeuricomponent-uricomponentBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
decodeURI()
encodeURI()
decodeURIComponent()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
ErrorError objects are thrown when runtime errors occur. The Error object can also be used as a base object for user-defined exceptions. See below for standard built-in error types.DescriptionRuntime errors result in new Error objects being created and thrown.
Error is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().Error typesBesides the generic Error constructor, there are other core error constructors in JavaScript. For client-side exceptions, see Exception handling statements.

EvalError

Creates an instance representing an error that occurs regarding the global function eval().

RangeError

Creates an instance representing an error that occurs when a numeric variable or parameter is outside its valid range.

ReferenceError

Creates an instance representing an error that occurs when de-referencing an invalid reference.

SyntaxError

Creates an instance representing a syntax error.

TypeError

Creates an instance representing an error that occurs when a variable or parameter is not of a valid type.

URIError

Creates an instance representing an error that occurs when encodeURI() or decodeURI() are passed invalid parameters.

AggregateError

Creates an instance representing several errors wrapped in a single error when multiple errors need to be reported by an operation, for example by Promise.any().

InternalError 
Non-standard


Creates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. "too much recursion".

Constructor
Error()

Creates a new Error object.

Static methods
Error.captureStackTrace() 
Non-standard


A non-standard V8 function that creates the stack property on an Error instance.

Error.stackTraceLimit 
Non-standard


A non-standard V8 numerical property that limits how many stack frames to include in an error stacktrace.

Error.prepareStackTrace() 
Non-standard
 Optional

A non-standard V8 function that, if provided by usercode, is called by the V8 JavaScript engine for thrown exceptions, allowing the user to provide custom formatting for stacktraces.

Instance propertiesThese properties are defined on Error.prototype and shared by all Error instances.

Error.prototype.constructor

The constructor function that created the instance object. For Error instances, the initial value is the Error constructor.

Error.prototype.name

Represents the name for the type of error. For Error.prototype.name, the initial value is "Error". Subclasses like TypeError and SyntaxError provide their own name properties.

Error.prototype.stack 
Non-standard


A non-standard property for a stack trace.


These properties are own properties of each Error instance.

cause

Error cause indicating the reason why the current error is thrown — usually another caught error. For user-created Error objects, this is the value provided as the cause property of the constructor's second argument.

columnNumber 
Non-standard


A non-standard Mozilla property for the column number in the line that raised this error.

fileName 
Non-standard


A non-standard Mozilla property for the path to the file that raised this error.

lineNumber 
Non-standard


A non-standard Mozilla property for the line number in the file that raised this error.

message

Error message. For user-created Error objects, this is the string provided as the constructor's first argument.

Instance methods
Error.prototype.toString()

Returns a string representing the specified object. Overrides the Object.prototype.toString() method.

ExamplesThrowing a generic error
  Usually you create an Error object with the intention of raising it using the throw keyword.
  You can handle the error using the try...catch construct:

jstry {
  throw new Error("Whoops!");
} catch (e) {
  console.error(`${e.name}: ${e.message}`);
}
Handling a specific error typeYou can choose to handle only specific error types by testing the error type with the instanceof keyword:
jstry {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(`${e.name}: ${e.message}`);
  } else if (e instanceof RangeError) {
    console.error(`${e.name}: ${e.message}`);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
Differentiate between similar errorsSometimes a block of code can fail for reasons that require different handling, but which throw very similar errors (i.e. with the same type and message).

  If you don't have control over the original errors that are thrown, one option is to catch them and throw new Error objects that have more specific messages.
  The original error should be passed to the new Error in the constructor's options parameter as its cause property. This ensures that the original error and stack trace are available to higher-level try/catch blocks.

The example below shows this for two methods that would otherwise fail with similar errors (doFailSomeWay() and doFailAnotherWay()):
jsfunction doWork() {
  try {
    doFailSomeWay();
  } catch (err) {
    throw new Error("Failed in some way", { cause: err });
  }
  try {
    doFailAnotherWay();
  } catch (err) {
    throw new Error("Failed in another way", { cause: err });
  }
}

try {
  doWork();
} catch (err) {
  switch (err.message) {
    case "Failed in some way":
      handleFailSomeWay(err.cause);
      break;
    case "Failed in another way":
      handleFailAnotherWay(err.cause);
      break;
  }
}


Note: If you are making a library, you should prefer to use error cause to discriminate between different errors emitted — rather than asking your consumers to parse the error message. See the error cause page for an example.

Custom error types can also use the cause property, provided the subclasses' constructor passes the options parameter when calling super(). The Error() base class constructor will read options.cause and define the cause property on the new error instance.
jsclass MyError extends Error {
  constructor(message, options) {
    // Need to pass `options` as the second parameter to install the "cause" property.
    super(message, options);
  }
}

console.log(new MyError("test", { cause: new Error("cause") }).cause);
// Error: cause
Custom error typesYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. This results in cleaner and more consistent error handling code.
See "What's a good way to extend Error in JavaScript?" on StackOverflow for an in-depth discussion.

Warning: Builtin subclassing cannot be reliably transpiled to pre-ES6 code, because there's no way to construct the base class with a particular new.target without Reflect.construct(). You need additional configuration or manually call Object.setPrototypeOf(this, CustomError.prototype) at the end of the constructor; otherwise, the constructed instance will not be a CustomError instance. See the TypeScript FAQ for more information.


Note: Some browsers include the CustomError constructor in the stack trace when using ES2015 classes.

jsclass CustomError extends Error {
  constructor(foo = "bar", ...params) {
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(...params);

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    this.name = "CustomError";
    // Custom debugging information
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError("baz", "bazMessage");
} catch (e) {
  console.error(e.name); // CustomError
  console.error(e.foo); // baz
  console.error(e.message); // bazMessage
  console.error(e.stack); // stacktrace
}
SpecificationsSpecificationECMAScript Language Specification # sec-error-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Error with cause support in core-js
throw
try...catch
Stack trace API in the V8 docs
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
escape()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note: escape() is a non-standard function implemented by browsers and was only standardized for cross-engine compatibility. It is not required to be implemented by all JavaScript engines and may not work everywhere. Use encodeURIComponent() or encodeURI() if possible.

The escape() function computes a new string in which certain characters have been replaced by hexadecimal escape sequences.Syntaxjsescape(str)
Parameters
str

A string to be encoded.

Return valueA new string in which certain characters have been escaped.Descriptionescape() is a function property of the global object.
The escape() function replaces all characters with escape sequences, with the exception of ASCII word characters (A–Z, a–z, 0–9, _) and @\*_+-./. Characters are escaped by UTF-16 code units. If the code unit's value is less than 256, it is represented by a two-digit hexadecimal number in the format %XX, left-padded with 0 if necessary. Otherwise, it is represented by a four-digit hexadecimal number in the format %uXXXX, left-padded with 0 if necessary.

Note: This function was used mostly for URL encoding and is partly based on the escape format in RFC 1738. The escape format is not an escape sequence in string literals. You can replace %XX with \xXX and %uXXXX with \uXXXX to get a string containing actual string-literal escape sequences.
ExamplesUsing escape()jsescape("abc123"); // "abc123"
escape("äöü"); // "%E4%F6%FC"
escape("ć"); // "%u0107"

// special characters
escape("@*_+-./"); // "@*_+-./"
SpecificationsSpecificationECMAScript Language Specification # sec-escape-stringBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of escape in core-js
encodeURI
encodeURIComponent
unescape
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 29, 2023 by MDN contributors.
eval()
Warning: Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use eval(). See Never use eval()!, below.

The eval() function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.Try itSyntaxjseval(script)
Parameters
script

A string representing a JavaScript expression, statement, or sequence of statements. The expression can include variables and properties of existing objects. It will be parsed as a script, so import declarations (which can only exist in modules) are not allowed.

Return valueThe completion value of evaluating the given code. If the completion value is empty, undefined is returned. If script is not a string primitive, eval() returns the argument unchanged.ExceptionsThrows any exception that occurs during evaluation of the code, including SyntaxError if script fails to be parsed as a script.Descriptioneval() is a function property of the global object.
The argument of the eval() function is a string. It will evaluate the source string as a script body, which means both statements and expressions are allowed. It returns the completion value of the code. For expressions, it's the value the expression evaluates to. Many statements and declarations have completion values as well, but the result may be surprising (for example, the completion value of an assignment is the assigned value, but the completion value of let is undefined), so it's recommended to not rely on statements' completion values.
In strict mode, declaring a variable named eval or re-assigning eval is a SyntaxError.
js"use strict";

const eval = 1; // SyntaxError: Unexpected eval or arguments in strict mode

If the argument of eval() is not a string, eval() returns the argument unchanged. In the following example, passing a String object instead of a primitive causes eval() to return the String object rather than evaluating the string.
jseval(new String("2 + 2")); // returns a String object containing "2 + 2"
eval("2 + 2"); // returns 4

To work around the issue in a generic fashion, you can coerce the argument to a string yourself before passing it to eval().
jsconst expression = new String("2 + 2");
eval(String(expression)); // returns 4
Direct and indirect evalThere are two modes of eval() calls: direct eval and indirect eval. Direct eval, as the name implies, refers to directly calling the global eval function with eval(...). Everything else, including invoking it via an aliased variable, via a member access or other expression, or through the optional chaining ?. operator, is indirect.
js// Direct call
eval("x + y");

// Indirect call using the comma operator to return eval
(0, eval)("x + y");

// Indirect call through optional chaining
eval?.("x + y");

// Indirect call using a variable to store and return eval
const geval = eval;
geval("x + y");

// Indirect call through member access
const obj = { eval };
obj.eval("x + y");

Indirect eval can be seen as if the code is evaluated within a separate <script> tag. This means:

Indirect eval works in the global scope rather than the local scope, and the code being evaluated doesn't have access to local variables within the scope where it's being called.
    jsfunction test() {
  const x = 2;
  const y = 4;
  // Direct call, uses local scope
  console.log(eval("x + y")); // Result is 6
  console.log(eval?.("x + y")); // Uses global scope, throws because x is undefined
}


Indirect eval would not inherit the strictness of the surrounding context, and would only be in strict mode if the source string itself has a "use strict" directive.
    jsfunction strictContext() {
  "use strict";
  eval?.(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval?.(`"use strict"; with (Math) console.log(PI);`);
}
strictContext(); // Logs 3.141592653589793
strictContextStrictEval(); // Throws a SyntaxError because the source string is in strict mode
On the other hand, direct eval inherits the strictness of the invoking context.
    jsfunction nonStrictContext() {
  eval(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval(`with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Throws a SyntaxError because it's in strict mode


var-declared variables and function declarations would go into the surrounding scope if the source string is not interpreted in strict mode — for indirect eval, they become global variables. If it's a direct eval in a strict mode context, or if the eval source string itself is in strict mode, then var and function declarations do not "leak" into the surrounding scope.
    js// Neither context nor source string is strict,
// so var creates a variable in the surrounding scope
eval("var a = 1;");
console.log(a); // 1
// Context is not strict, but eval source is strict,
// so b is scoped to the evaluated script
eval("'use strict'; var b = 1;");
console.log(b); // ReferenceError: b is not defined

function strictContext() {
  "use strict";
  // Context is strict, but this is indirect and the source
  // string is not strict, so c is still global
  eval?.("var c = 1;");
  // Direct eval in a strict context, so d is scoped
  eval("var d = 1;");
}
strictContext();
console.log(c); // 1
console.log(d); // ReferenceError: d is not defined
let and const declarations within the evaluated string are always scoped to that script.
  
Direct eval may have access to additional contextual expressions. For example, in a function's body, one can use new.target:
    jsfunction Ctor() {
  eval("console.log(new.target)");
}
new Ctor(); // [Function: Ctor]


Never use eval()!Using direct eval() suffers from multiple problems:

eval() executes the code it's passed with the privileges of the caller. If you run eval() with a string that could be affected by a malicious party, you may end up running malicious code on the user's machine with the permissions of your webpage / extension. More importantly, allowing third-party code to access the scope in which eval() was invoked (if it's a direct eval) can lead to possible attacks that reads or changes local variables.
eval() is slower than the alternatives, since it has to invoke the JavaScript interpreter, while many other constructs are optimized by modern JS engines.
Modern JavaScript interpreters convert JavaScript to machine code. This means that any concept of variable naming gets obliterated. Thus, any use of eval() will force the browser to do long expensive variable name lookups to figure out where the variable exists in the machine code and set its value. Additionally, new things can be introduced to that variable through eval(), such as changing the type of that variable, forcing the browser to re-evaluate all of the generated machine code to compensate.
Minifiers give up on any minification if the scope is transitively depended on by eval(), because otherwise eval() cannot read the correct variable at runtime.

There are many cases where the use of eval() or related methods can be optimized or avoided altogether.
Using indirect eval()
Consider this code:
jsfunction looseJsonParse(obj) {
  return eval(`(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Date() }"));

Simply using indirect eval and forcing strict mode can make the code much better:
jsfunction looseJsonParse(obj) {
  return eval?.(`"use strict";(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Date() }"));

The two code snippets above may seem to work the same way, but they do not; the first one using direct eval suffers from multiple problems.

It is a great deal slower, due to more scope inspections. Notice c: new Date() in the evaluated string. In the indirect eval version, the object is being evaluated in the global scope, so it is safe for the interpreter to assume that Date refers to the global Date() constructor instead of a local variable called Date. However, in the code using direct eval, the interpreter cannot assume this. For example, in the following code, Date in the evaluated string doesn't refer to window.Date().
    jsfunction looseJsonParse(obj) {
  function Date() {}
  return eval(`(${obj})`);
}
console.log(looseJsonParse(`{ a: 4 - 1, b: function () {}, c: new Date() }`));
Thus, in the eval() version of the code, the browser is forced to make the expensive lookup call to check to see if there are any local variables called Date().
  
If not using strict mode, var declarations within the eval() source becomes variables in the surrounding scope. This leads to hard-to-debug issues if the string is acquired from external input, especially if there's an existing variable with the same name.
Direct eval can read and mutate bindings in the surrounding scope, which may lead to external input corrupting local data.
When using direct eval, especially when the eval source cannot be proven to be in strict mode, the engine — and build tools — have to disable all optimizations related to inlining, because the eval() source can depend on any variable name in its surrounding scope.

However, using indirect eval() does not allow passing extra bindings other than existing global variables for the evaluated source to read. If you need to specify additional variables that the evaluated source should have access to, consider using the Function() constructor.
Using the Function() constructor
The Function() constructor is very similar to the indirect eval example above: it also evaluates the JavaScript source passed to it in the global scope without reading or mutating any local bindings, and therefore allows engines to do more optimizations than direct eval().
The difference between eval() and Function() is that the source string passed to Function() is parsed as a function body, not as a script. There are a few nuances — for example, you can use return statements at the top level of a function body, but not in a script.
The Function() constructor is useful if you wish to create local bindings within your eval source, by passing the variables as parameter bindings.
jsfunction Date(n) {
  return [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday",
  ][n % 7 || 0];
}
function runCodeWithDateFunction(obj) {
  return Function("Date", `"use strict";return (${obj});`)(Date);
}
console.log(runCodeWithDateFunction("Date(5)")); // Saturday

Both eval() and Function() implicitly evaluate arbitrary code, and are forbidden in strict CSP settings. There are also additional safer (and faster!) alternatives to eval() or Function() for common use-cases.
Using bracket accessors
You should not use eval() to access properties dynamically. Consider the following example where the property of the object to be accessed is not known until the code is executed. This can be done with eval():
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"

const result = eval(`obj.${propName}`);

However, eval() is not necessary here — in fact, it's more error-prone, because if propName is not a valid identifier, it leads to a syntax error. Moreover, if getPropName is not a function you control, this may lead to execution of arbitrary code. Instead, use the property accessors, which are much faster and safer:
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"
const result = obj[propName]; // obj["a"] is the same as obj.a

You can even use this method to access descendant properties. Using eval(), this would look like:
jsconst obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"

const result = eval(`obj.${propPath}`); // 0

Avoiding eval() here could be done by splitting the property path and looping through the different properties:
jsfunction getDescendantProp(obj, desc) {
  const arr = desc.split(".");
  while (arr.length) {
    obj = obj[arr.shift()];
  }
  return obj;
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = getDescendantProp(obj, propPath); // 0

Setting a property that way works similarly:
jsfunction setDescendantProp(obj, desc, value) {
  const arr = desc.split(".");
  while (arr.length > 1) {
    obj = obj[arr.shift()];
  }
  return (obj[arr[0]] = value);
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = setDescendantProp(obj, propPath, 1); // obj.a.b.c is now 1

However, beware that using bracket accessors with unconstrained input is not safe either — it may lead to object injection attacks.
Using callbacks
JavaScript has first-class functions, which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:
js// Instead of setTimeout("…", 1000) use:
setTimeout(() => {
  // …
}, 1000);

// Instead of elt.setAttribute("onclick", "…") use:
elt.addEventListener("click", () => {
  // …
});

Closures are also helpful as a way to create parameterized functions without concatenating strings.
Using JSON
If the string you're calling eval() on contains data (for example, an array: "[1, 2, 3]"), as opposed to code, you should consider switching to JSON, which allows the string to use a subset of JavaScript syntax to represent data.
Note that since JSON syntax is limited compared to JavaScript syntax, many valid JavaScript literals will not parse as JSON. For example, trailing commas are not allowed in JSON, and property names (keys) in object literals must be enclosed in quotes. Be sure to use a JSON serializer to generate strings that will be later parsed as JSON.
Passing carefully constrained data instead of arbitrary code is a good idea in general. For example, an extension designed to scrape contents of web-pages could have the scraping rules defined in XPath instead of JavaScript code.ExamplesUsing eval()
  In the following code, both of the statements containing eval() return 42.
  The first evaluates the string "x + y + 1"; the second evaluates the string
  "42".

jsconst x = 2;
const y = 39;
const z = "42";
eval("x + y + 1"); // 42
eval(z); // 42
eval() returns the completion value of statementseval() returns the completion value of statements. For if, it would be the last expression or statement evaluated.
jsconst str = "if (a) { 1 + 1 } else { 1 + 2 }";
let a = true;
let b = eval(str);

console.log(`b is: ${b}`); // b is: 2

a = false;
b = eval(str);

console.log(`b is: ${b}`); // b is: 3

The following example uses eval() to evaluate the string str. This string consists of JavaScript statements that assign z a value of 42 if x is five, and assign 0 to z otherwise. When the second statement is executed, eval() will cause these statements to be performed, and it will also evaluate the set of statements and return the value that is assigned to z, because the completion value of an assignment is the assigned value.
jsconst x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
} else {
  z = 0;
}`;

console.log("z is ", eval(str)); // z is 42  z is 42

If you assign multiple values then the last value is returned.
jslet x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
  x = 420;
} else {
  z = 0;
}`;

console.log("x is", eval(str)); // z is 42  x is 420
eval() as a string defining function requires "(" and ")" as prefix and suffixjs// This is a function declaration
const fctStr1 = "function a() {}";
// This is a function expression
const fctStr2 = "(function b() {})";
const fct1 = eval(fctStr1); // return undefined, but `a` is available as a global function now
const fct2 = eval(fctStr2); // return the function `b`
SpecificationsSpecificationECMAScript Language Specification # sec-eval-xBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Property accessors
WebExtensions: Using eval in content scripts
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 15, 2023 by MDN contributors.
EvalErrorThe EvalError object indicates an error regarding the global eval() function. This exception is not thrown by JavaScript anymore, however the EvalError object remains for compatibility.
EvalError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
EvalError is a subclass of Error.Constructor
EvalError()

Creates a new EvalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on EvalError.prototype and shared by all EvalError instances.

EvalError.prototype.constructor

The constructor function that created the instance object. For EvalError instances, the initial value is the EvalError constructor.

EvalError.prototype.name

Represents the name for the type of error. For EvalError.prototype.name, the initial value is "EvalError".

Instance methodsInherits instance methods from its parent Error.ExamplesCreating an EvalErrorjstry {
  throw new EvalError("Hello");
} catch (e) {
  console.log(e instanceof EvalError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "EvalError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript Language Specification # sec-native-error-types-used-in-this-standard-evalerrorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
eval()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on May 26, 2023 by MDN contributors.
FinalizationRegistryA FinalizationRegistry object lets you request a callback when a value is garbage-collected.DescriptionFinalizationRegistry provides a way to request that a cleanup callback get called at some point when a value registered with the registry has been reclaimed (garbage-collected). (Cleanup callbacks are sometimes called finalizers.)

Note: Cleanup callbacks should not be used for essential program logic. See Notes on cleanup callbacks for details.

You create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});

Then you register any value you want a cleanup callback for by calling the register method, passing in the value and a held value for it:
jsregistry.register(target, "some value");

The registry does not keep a strong reference to the value, as that would defeat the purpose (if the registry held it strongly, the value would never be reclaimed). In JavaScript, objects and non-registered symbols are garbage collectable, so they can be registered in a FinalizationRegistry object as the target or the token.
If target is reclaimed, your cleanup callback may be called at some point with the held value you provided for it ("some value" in the above). The held value can be any value you like: a primitive or an object, even undefined. If the held value is an object, the registry keeps a strong reference to it (so it can pass it to your cleanup callback later).
If you might want to unregister a registered target value later, you pass a third value, which is the unregistration token you'll use later when calling the registry's unregister function to unregister the value. The registry only keeps a weak reference to the unregister token.
It's common to use the target value itself as the unregister token, which is just fine:
jsregistry.register(target, "some value", target);
// …

// some time later, if you don't care about `target` anymore, unregister it
registry.unregister(target);

It doesn't have to be the same value, though; it can be a different one:
jsregistry.register(target, "some value", token);
// …

// some time later
registry.unregister(token);
Avoid where possibleCorrect use of FinalizationRegistry takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.
Here are some specific points included by the authors in the proposal that introduced FinalizationRegistry:

Garbage collectors are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:

One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.
Garbage collection work can be split up over time using incremental and concurrent techniques.
Various runtime heuristics can be used to balance memory usage, responsiveness.
The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).
Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.
Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.

Notes on cleanup callbacks
Developers shouldn't rely on cleanup callbacks for essential program logic. Cleanup callbacks may be useful for reducing memory usage across the course of a program, but are unlikely to be useful otherwise.
If your code has just registered a value to the registry, that target will not be reclaimed until the end of the current JavaScript job. See notes on WeakRefs for details.
A conforming JavaScript implementation, even one that does garbage collection, is not required to call cleanup callbacks. When and whether it does so is entirely down to the implementation of the JavaScript engine. When a registered object is reclaimed, any cleanup callbacks for it may be called then, or some time later, or not at all.
It's likely that major implementations will call cleanup callbacks at some point during execution, but those calls may be substantially after the related object was reclaimed. Furthermore, if there is an object registered in two registries, there is no guarantee that the two callbacks are called next to each other — one may be called and the other never called, or the other may be called much later.
There are also situations where even implementations that normally call cleanup callbacks are unlikely to call them:
    
When the JavaScript program shuts down entirely (for instance, closing a tab in a browser).
When the FinalizationRegistry instance itself is no longer reachable by JavaScript code.


If the target of a WeakRef is also in a FinalizationRegistry, the WeakRef's target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls deref on a WeakRef for the object, it will receive undefined.
Constructor
FinalizationRegistry()

Creates a new FinalizationRegistry object.

Instance propertiesThese properties are defined on FinalizationRegistry.prototype and shared by all FinalizationRegistry instances.

FinalizationRegistry.prototype.constructor

The constructor function that created the instance object. For FinalizationRegistry instances, the initial value is the FinalizationRegistry constructor.

FinalizationRegistry.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "FinalizationRegistry". This property is used in Object.prototype.toString().

Instance methods
FinalizationRegistry.prototype.register()

Registers an object with the registry in order to get a cleanup callback when/if the object is garbage-collected.

FinalizationRegistry.prototype.unregister()

Unregisters an object from the registry.

ExamplesCreating a new registryYou create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});
Registering objects for cleanupThen you register any objects you want a cleanup callback for by calling the register method, passing in the object and a held value for it:
jsregistry.register(theObject, "some value");
Callbacks never called synchronouslyNo matter how much pressure you put on the garbage collector, the cleanup callback will never be called synchronously. The object may be reclaimed synchronously, but the callback will always be called sometime after the current job finishes:
jslet counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000) return;
  counter++;
  allocateMemory();
})();

console.log("Main job ends");
// Logs:
// Main job ends
// Array gets garbage collected at 5001

However, if you allow a little break between each allocation, the callback may be called sooner:
jslet arrayCollected = false;
let counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
  arrayCollected = true;
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000 || arrayCollected) return;
  counter++;
  // Use setTimeout to make each allocateMemory a different job
  setTimeout(allocateMemory);
})();

console.log("Main job ends");

There's no guarantee that the callback will be called sooner or if it will be called at all, but there's a possibility that the logged message has a counter value smaller than 5000.SpecificationsSpecificationECMAScript Language Specification # sec-finalization-registry-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
WeakRef
WeakSet
WeakMap
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jun 20, 2023 by MDN contributors.
Float32ArrayThe Float32Array typed array represents an array of 32-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float32Array is a subclass of the hidden TypedArray class.Constructor
Float32Array()

Creates a new Float32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Float32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float32Array.prototype and shared by all Float32Array instances.

Float32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Float32Array.

Float32Array.prototype.constructor

The constructor function that created the instance object. For Float32Array instances, the initial value is the Float32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float32Arrayjs// From a length
const float32 = new Float32Array(2);
float32[0] = 42;
console.log(float32[0]); // 42
console.log(float32.length); // 2
console.log(float32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Float32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Float32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float32FromIterable = new Float32Array(iterable);
console.log(float32FromIterable);
// Float32Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Float32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Float64ArrayThe Float64Array typed array represents an array of 64-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float64Array is a subclass of the hidden TypedArray class.Constructor
Float64Array()

Creates a new Float64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of Float64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float64Array.prototype and shared by all Float64Array instances.

Float64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a Float64Array.

Float64Array.prototype.constructor

The constructor function that created the instance object. For Float64Array instances, the initial value is the Float64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float64Arrayjs// From a length
const float64 = new Float64Array(2);
float64[0] = 42;
console.log(float64[0]); // 42
console.log(float64.length); // 2
console.log(float64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new Float64Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float64Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new Float64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float64FromIterable = new Float64Array(iterable);
console.log(float64FromIterable);
// Float64Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Float64Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
FunctionThe Function object provides methods for functions. In JavaScript, every function is actually a Function object.Constructor
Function()

Creates a new Function object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to eval(). However, unlike eval(), the Function constructor creates functions that execute in the global scope only.

Instance propertiesThese properties are defined on Function.prototype and shared by all Function instances.

Function.prototype.arguments 
Deprecated
 
Non-standard


Represents the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError. Use the arguments object inside function closures instead.

Function.prototype.caller 
Deprecated
 
Non-standard


Represents the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.

Function.prototype.constructor

The constructor function that created the instance object. For Function instances, the initial value is the Function constructor.


These properties are own properties of each Function instance.

displayName 
Non-standard
 Optional

The display name of the function.

length

Specifies the number of arguments expected by the function.

name

The name of the function.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methods
Function.prototype.apply()

Calls a function with a given this value and optional arguments provided as an array (or an array-like object).

Function.prototype.bind()

Creates a new function that, when called, has its this keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

Function.prototype.call()

Calls a function with a given this value and optional arguments.

Function.prototype.toString()


      Returns a string representing the source code of the function.
      Overrides the Object.prototype.toString method.
    

Function.prototype[@@hasInstance]()

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the instanceof operator.

ExamplesDifference between Function constructor and function declarationFunctions created with the Function constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the Function constructor was created. This is different from using eval() with code for a function expression.
js// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20

While this code works in web browsers, f1() will produce a ReferenceError in Node.js, as x will not be found. This is because the top-level scope in Node is not the global scope, and x will be local to the module.SpecificationsSpecificationECMAScript Language Specification # sec-function-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
function
function expression
AsyncFunction
AsyncGeneratorFunction
GeneratorFunction
Functions
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
GeneratorThe Generator object is returned by a generator function and it conforms to both the iterable protocol and the iterator protocol.
Generator is a subclass of the hidden Iterator class.Try itConstructorThe Generator constructor is not available globally. Instances of Generator must be returned from generator functions:
jsfunction* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generator(); // "Generator { }"

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3

In fact, there's no JavaScript entity that corresponds to the Generator constructor. There's only a hidden object which is the prototype object shared by all objects created by generator functions. This object is often stylized as Generator.prototype to make it look like a class, but it should be more appropriately called GeneratorFunction.prototype.prototype, because GeneratorFunction is an actual JavaScript entity.Instance propertiesThese properties are defined on Generator.prototype and shared by all Generator instances.

Generator.prototype.constructor

The constructor function that created the instance object. For Generator instances, the initial value is GeneratorFunction.prototype.

Note: Generator objects do not store a reference to the generator function that created them.


Generator.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "Generator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent Iterator.

Generator.prototype.next()

Returns a value yielded by the yield expression.

Generator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

Generator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAn infinite iteratorWith a generator function, values are not evaluated until they are needed. Therefore a generator allows us to define a potentially infinite data structure.
jsfunction* infinite() {
  let index = 0;

  while (true) {
    yield index++;
  }
}

const generator = infinite(); // "Generator { }"

console.log(generator.next().value); // 0
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
// …
SpecificationsSpecificationECMAScript Language Specification # sec-generator-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
function*
function* expression
GeneratorFunction
Iteration protocols
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
GeneratorFunctionThe GeneratorFunction object provides methods for generator functions. In JavaScript, every generator function is actually a GeneratorFunction object.
Note that GeneratorFunction is not a global object. It can be obtained with the following code:
jsconst GeneratorFunction = function* () {}.constructor;

GeneratorFunction is a subclass of Function.Try itConstructor
GeneratorFunction()

Creates a new GeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on GeneratorFunction.prototype and shared by all GeneratorFunction instances.

GeneratorFunction.prototype.constructor

The constructor function that created the instance object. For GeneratorFunction instances, the initial value is the GeneratorFunction constructor.

GeneratorFunction.prototype.prototype

All generator functions share the same prototype property, which is Generator.prototype. Each generator function instance also has its own prototype property. When the generator function is called, the returned generator object inherits from the generator function's prototype property, which in turn inherits from GeneratorFunction.prototype.prototype.

GeneratorFunction.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "GeneratorFunction". This property is used in Object.prototype.toString().

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript Language Specification # sec-generatorfunction-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
function*
function* expression
Function
AsyncFunction
AsyncGeneratorFunction
Functions
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
globalThisThe globalThis global property contains the global this value, which is usually akin to the global object.Try itValueThe global this object.


Property attributes of globalThis




Writable
yes


Enumerable
no


Configurable
yes




Note: The globalThis property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.
DescriptionHistorically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use window, self, or frames - but in Web Workers only self will work. In Node.js none of these work, and you must instead use global. The this keyword could be used inside functions running in non–strict mode, but this will be undefined in modules and inside functions running in strict mode. You can also use Function('return this')(), but environments that disable eval(), like CSP in browsers, prevent use of Function in this way.
The globalThis property provides a standard way of accessing the global this value (and hence the global object itself) across environments. Unlike similar properties such as window and self, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the this value is globalThis.

Note: globalThis is generally the same concept as the global object (i.e. adding properties to globalThis makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for globalThis that's unrelated to the global object.
HTML and the WindowProxyIn many engines globalThis will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a Proxy around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.NamingSeveral other popular name choices such as self and global were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.
globalThis is, quite literally, the global this value. It's the same value as the this value in a non-strict function called without an object. It's also the value of this in the global scope of a script.ExamplesSearch for the global across environmentsUsually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.
jsconsole.log(window.Math === Math); // true

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills.
Prior to globalThis, the only reliable cross-platform way to get the global object for an environment was Function('return this')(). However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source):
jsfunction check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();

After obtaining the global object, we can define new globals on it. For example, adding an implementation for Intl:
jsif (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}

With globalThis available, the additional search for the global across environments is not necessary anymore:
jsif (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
SpecificationsSpecificationECMAScript Language Specification # sec-globalthisBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of globalThis in core-js
this
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
InfinityThe Infinity global property is a numeric value representing infinity.Try itValueThe same number value as Number.POSITIVE_INFINITY.


Property attributes of Infinity




Writable
no


Enumerable
no


Configurable
no


DescriptionInfinity is a property of the global object. In other words, it is a variable in global scope.
The value Infinity (positive infinity) is greater than any other number.
This value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details.ExamplesUsing Infinityjsconsole.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(Math.pow(10, 1000)); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
SpecificationsSpecificationECMAScript Language Specification # sec-value-properties-of-the-global-object-infinityBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Number.NEGATIVE_INFINITY
Number.POSITIVE_INFINITY
Number.isFinite
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Apr 28, 2023 by MDN contributors.
Int16ArrayThe Int16Array typed array represents an array of 16-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int16Array is a subclass of the hidden TypedArray class.Constructor
Int16Array()

Creates a new Int16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Int16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int16Array.prototype and shared by all Int16Array instances.

Int16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Int16Array.

Int16Array.prototype.constructor

The constructor function that created the instance object. For Int16Array instances, the initial value is the Int16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int16Arrayjs// From a length
const int16 = new Int16Array(2);
int16[0] = 42;
console.log(int16[0]); // 42
console.log(int16.length); // 2
console.log(int16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Int16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(16);
const z = new Int16Array(buffer, 2, 4);
console.log(z.byteOffset); // 2

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int16FromIterable = new Int16Array(iterable);
console.log(int16FromIterable);
// Int16Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Int16Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Int32ArrayThe Int32Array typed array represents an array of 32-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int32Array is a subclass of the hidden TypedArray class.Constructor
Int32Array()

Creates a new Int32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Int32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int32Array.prototype and shared by all Int32Array instances.

Int32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Int32Array.

Int32Array.prototype.constructor

The constructor function that created the instance object. For Int32Array instances, the initial value is the Int32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int32Arrayjs// From a length
const int32 = new Int32Array(2);
int32[0] = 42;
console.log(int32[0]); // 42
console.log(int32.length); // 2
console.log(int32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Int32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Int32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int32FromIterable = new Int32Array(iterable);
console.log(int32FromIterable);
// Int32Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Int32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Int8ArrayThe Int8Array typed array represents an array of 8-bit signed integers. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int8Array is a subclass of the hidden TypedArray class.Constructor
Int8Array()

Creates a new Int8Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int8Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of Int8Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int8Array.prototype and shared by all Int8Array instances.

Int8Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of a Int8Array.

Int8Array.prototype.constructor

The constructor function that created the instance object. For Int8Array instances, the initial value is the Int8Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int8Arrayjs// From a length
const int8 = new Int8Array(2);
int8[0] = 42;
console.log(int8[0]); // 42
console.log(int8.length); // 2
console.log(int8.BYTES_PER_ELEMENT); // 1

// From an array
const x = new Int8Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int8Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(8);
const z = new Int8Array(buffer, 1, 4);
console.log(z.byteOffset); // 1

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int8FromIterable = new Int8Array(iterable);
console.log(int8FromIterable);
// Int8Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Int8Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
InternalErrorNon-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
The InternalError object indicates an error that occurred internally in the JavaScript engine.
Example cases are mostly when something is too large, e.g.:

"too many switch cases",
"too many parentheses in regular expression",
"array initializer too large",
"too much recursion".

InternalError is a subclass of Error.Constructor
InternalError() 
Non-standard


Creates a new InternalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on InternalError.prototype and shared by all InternalError instances.

InternalError.prototype.constructor

The constructor function that created the instance object. For InternalError instances, the initial value is the InternalError constructor.

InternalError.prototype.name

Represents the name for the type of error. For InternalError.prototype.name, the initial value is "InternalError".

Instance methodsInherits instance methods from its parent Error.ExamplesToo much recursionThis recursive function runs 10 times, as per the exit condition.
jsfunction loop(x) {
  // "x >= 10" is the exit condition
  if (x >= 10) return;

  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

Setting this condition to an extremely high value, may not work:
jsfunction loop(x) {
  if (x >= 1000000000000) return;

  // do stuff
  loop(x + 1);
}
loop(0);

// InternalError: too much recursion

For more information, see InternalError: too much recursion.SpecificationsNot part of any standard.Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
InternalError: too much recursion
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
IntlThe Intl namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions. Collectively, they comprise the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, date and time formatting, and more.DescriptionUnlike most global objects, Intl is not a constructor. You cannot use it with the new operator or invoke the Intl object as a function. All properties and methods of Intl are static (just like the Math object).
The internationalization constructors as well as several language sensitive methods of other constructors (listed under See also) use a common pattern for identifying locales and determining the one they will actually use: they all accept locales and options arguments, and negotiate the requested locale(s) against the locales they support using an algorithm specified in the options.localeMatcher property.locales argumentThe locales argument is used to determine the locale used in a given operation. The JavaScript implementation examines locales, and then computes a locale it understands that comes closest to satisfying the expressed preference. locales may be:

undefined (or omitted): The implementation's default locale will be used.
A locale: A locale identifier or an Intl.Locale object that wraps a locale identifier.
A list of locales: Any other value, that will be converted into an object and then treated as an array of locales.

In the latter two cases, the actual locale used is the best-supported locale determined by locale negotiation. If a locale identifier is not a string or an object, a TypeError is thrown. If a locale identifier is a string that's syntactically invalid, a RangeError is thrown. If a locale identifier is well-formed but the implementation doesn't recognize it, it is ignored and the next locale in the list is considered, eventually falling back to the system's locale. However, you shouldn't rely on a particular locale name being ignored, because the implementation may add data for any locale in the future. For example, new Intl.DateTimeFormat("default") uses the implementation's default locale only because "default" is syntactically valid but not recognized as any locale.
A locale identifier is a string that consists of:

A language subtag with 2–3 or 5–8 letters
A script subtag with 4 letters Optional
A region subtag with either 2 letters or 3 digits Optional
One or more variant subtags (all of which must be unique), each with either 5–8 alphanumerals or a digit followed by 3 alphanumerals Optional
One or more BCP 47 extension sequences Optional
A private-use extension sequence Optional

Each subtag and sequence are separated by hyphens. Locale identifiers are case-insensitive ASCII. However, it's conventional to use title case (the first letter is capitalized, successive letters are lower case) for script subtags, upper case for region subtags, and lower case for everything else. For example:

"hi": Hindi (language)
"de-AT": German (language) as used in Austria (region)
"zh-Hans-CN": Chinese (language) written in simplified characters (script) as used in China (region)
"en-emodeng": English (language) in the "Early modern English" dialect (variant)

Subtags identifying languages, scripts, regions (including countries), and (rarely used) variants are registered in the IANA Language Subtag Registry. This registry is periodically updated over time, and implementations may not always be up to date, so don't rely too much on subtags being universally supported.
BCP 47 extension sequences consist of a single digit or letter (other than "x") and one or more two- to eight-letter or digit subtags separated by hyphens. Only one sequence is permitted for each digit or letter: "de-a-foo-a-foo" is invalid. BCP 47 extension subtags are defined in the Unicode CLDR Project. Currently only two extensions have defined semantics:

The "u" (Unicode) extension can be used to request additional customization of Intl API objects. Examples:
    
"de-DE-u-co-phonebk": Use the phonebook variant of the German sort order, which interprets umlauted vowels as corresponding character pairs: ä → ae, ö → oe, ü → ue.
"th-TH-u-nu-thai": Use Thai digits (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) in number formatting.
"ja-JP-u-ca-japanese": Use the Japanese calendar in date and time formatting, so that 2013 is expressed as the year 25 of the Heisei period, or 平成 25.
"en-GB-u-ca-islamic": use British English with the Islamic (Hijri) calendar, where the Gregorian date 14 October, 2017 is the Hijri date 24 Muharram, 1439.


The "t" (transformed) extension indicates transformed content: for example, text that was translated from another locale. No Intl functionality currently considers the "t" extension. However, this extension sometimes contains a nested locale (with no extensions): for example, the transformed extension in "de-t-en" contains the locale identifier for English. If a nested locale is present, it must be a valid locale identifier. For example, because "en-emodeng-emodeng" is invalid (because it contains a duplicate emodeng variant subtag), "de-t-en-emodeng-emodeng" is also invalid.

Finally, a private-use extension sequence using the letter "x" may appear, followed by one or more one- to eight-letter or digit subtags separated by hyphens. This allows applications to encode information for their own private use, that will be ignored by all Intl operations.options argumentThe options argument must be an object with properties that vary between constructors and functions. If the options argument is not provided or is undefined, default values are used for all properties.
One property is supported by all language sensitive constructors and functions: The localeMatcher property, whose value must be a string "lookup" or "best fit" and which selects one of the locale matching algorithms described below.Locale identification and negotiationThe list of locales specified by the locales argument, after Unicode extensions have been removed from them, is interpreted as a prioritized request from the application. The runtime compares it against the locales it has available and picks the best one available. Two matching algorithms exist: the "lookup" matcher follows the Lookup algorithm specified in BCP 47; the "best fit" matcher lets the runtime provide a locale that's at least, but possibly more, suited for the request than the result of the Lookup algorithm. If the application doesn't provide a locales argument, or the runtime doesn't have a locale that matches the request, then the runtime's default locale is used. The matcher can be selected using a property of the options argument (see below).
If the selected locale identifier had a Unicode extension sequence, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the locale identifier. For example, the "co" key (collation) is only supported by Intl.Collator, and its "phonebk" value is only supported for German.Static properties
Intl.Collator

Constructor for collators, which are objects that enable language-sensitive string comparison.

Intl.DateTimeFormat

Constructor for objects that enable language-sensitive date and time formatting.

Intl.DisplayNames

Constructor for objects that enable the consistent translation of language, region and script display names.

Intl.DurationFormat 
Experimental


Constructor for objects that enable locale-sensitive duration formatting.

Intl.ListFormat

Constructor for objects that enable language-sensitive list formatting.

Intl.Locale

Constructor for objects that represents a Unicode locale identifier.

Intl.NumberFormat

Constructor for objects that enable language-sensitive number formatting.

Intl.PluralRules

Constructor for objects that enable plural-sensitive formatting and language-specific rules for plurals.

Intl.RelativeTimeFormat

Constructor for objects that enable language-sensitive relative time formatting.

Intl.Segmenter

Constructor for objects that enable locale-sensitive text segmentation.

Intl[@@toStringTag]

The initial value of the @@toStringTag property is the string "Intl". This property is used in Object.prototype.toString().

Static methods
Intl.getCanonicalLocales()

Returns canonical locale names.

Intl.supportedValuesOf()

Returns a sorted array containing the supported unique calendar, collation, currency, numbering systems, or unit values supported by the implementation.

ExamplesFormatting dates and numbersYou can use Intl to format dates and numbers in a form that's conventional for a specific language and region:
jsconst count = 26254.39;
const date = new Date("2012-05-24");

function log(locale) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(
      locale,
    ).format(count)}`,
  );
}

log("en-US"); // 5/24/2012 26,254.39

log("de-DE"); // 24.5.2012 26.254,39
Using the browser's preferred languageInstead of passing a hardcoded locale name to the Intl methods, you can use the user's preferred language provided by navigator.language:
jsconst date = new Date("2012-05-24");

const formattedDate = new Intl.DateTimeFormat(navigator.language).format(date);

Alternatively, the navigator.languages property provides a sorted list of the user's preferred languages. This list can be passed directly to the Intl constructors to implement preference-based fallback selection of locales. The locale negotiation process is used to pick the most appropriate locale available:
jsconst count = 26254.39;

const formattedCount = new Intl.NumberFormat(navigator.languages).format(count);
SpecificationsSpecificationECMAScript Internationalization API Specification # intl-objectBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
String.prototype.localeCompare()
Number.prototype.toLocaleString()
Date.prototype.toLocaleString()
Date.prototype.toLocaleDateString()
Date.prototype.toLocaleTimeString()
navigator.language
navigator.languages
The ECMAScript Internationalization API by Norbert Lindenberg (2012)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 20, 2023 by MDN contributors.
isFinite()The isFinite() function determines whether a value is finite, first converting the value to a number if necessary. A finite number is one that's not NaN or ±Infinity. Because coercion inside the isFinite() function can be surprising, you may prefer to use Number.isFinite().Try itSyntaxjsisFinite(value)
Parameters
value

The value to be tested.

Return valuefalse if the given value is NaN, Infinity, or -Infinity after being converted to a number; otherwise, true.DescriptionisFinite() is a function property of the global object.
When the argument to the isFinite() function is not of type Number, the value is first coerced to a number, and the resulting value is then compared against NaN and ±Infinity. This is as confusing as the behavior of isNaN — for example, isFinite("1") is true.
Number.isFinite() is a more reliable way to test whether a value is a finite number value, because it returns false for any non-number input.ExamplesUsing isFinite()jsisFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(0); // true
isFinite(2e64); // true
isFinite(910); // true

// Would've been false with the more robust Number.isFinite():
isFinite(null); // true
isFinite("0"); // true
SpecificationsSpecificationECMAScript Language Specification # sec-isfinite-numberBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Number.isFinite()
Number.NaN
Number.POSITIVE_INFINITY
Number.NEGATIVE_INFINITY
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 30, 2023 by MDN contributors.
isNaN()The isNaN() function determines whether a value is NaN, first converting the value to a number if necessary. Because coercion inside the isNaN() function can be surprising, you may prefer to use Number.isNaN().Try itSyntaxjsisNaN(value)
Parameters
value

The value to be tested.

Return valuetrue if the given value is NaN after being converted to a number; otherwise, false.DescriptionisNaN() is a function property of the global object.
For number values, isNaN() tests if the number is the value NaN. When the argument to the isNaN() function is not of type Number, the value is first coerced to a number, and the resulting value is then compared against NaN.
This behavior of isNaN() for non-numeric arguments can be confusing! For example, an empty string is coerced to 0, while a boolean is coerced to 0 or 1; both values are intuitively "not numbers", but they don't evaluate to NaN, so isNaN() returns false. Therefore, isNaN() answers neither the question "is the input the floating point NaN value" nor the question "is the input not a number".
Number.isNaN() is a more reliable way to test whether a value is the number value NaN or not. Alternatively, the expression x !== x can be used, and neither of the solutions is subject to the false positives that make the global isNaN() unreliable. To test if a value is a number, use typeof x === "number".
The isNaN() function answers the question "is the input functionally equivalent to NaN when used in a number context". If isNaN(x) returns false, you can use x in an arithmetic expression as if it's a valid number that's not NaN. If isNaN(x) returns true, x will get coerced to NaN and make most arithmetic expressions return NaN (because NaN propagates). You can use this, for example, to test whether an argument to a function is arithmetically processable (usable "like" a number), and handle values that are not number-like by throwing an error, providing a default value, etc. This way, you can have a function that makes use of the full versatility JavaScript provides by implicitly converting values depending on context.

Note: The + operator performs both number addition and string concatenation. Therefore, even if isNaN() returns false for both operands, the + operator may still return a string, because it's not used as an arithmetic operator. For example, isNaN("1") returns false, but "1" + 1 returns "11". To be sure that you are working with numbers, coerce the value to a number and use Number.isNaN() to test the result.
ExamplesNote how isNaN() returns true for values that are not the value NaN but are not numbers either:
jsisNaN(NaN); // true
isNaN(undefined); // true
isNaN({}); // true

isNaN(true); // false
isNaN(null); // false
isNaN(37); // false

// Strings
isNaN("37"); // false: "37" is converted to the number 37 which is not NaN
isNaN("37.37"); // false: "37.37" is converted to the number 37.37 which is not NaN
isNaN("37,5"); // true
isNaN("123ABC"); // true: Number("123ABC") is NaN
isNaN(""); // false: the empty string is converted to 0 which is not NaN
isNaN(" "); // false: a string with spaces is converted to 0 which is not NaN

// Dates
isNaN(new Date()); // false; Date objects can be converted to a number (timestamp)
isNaN(new Date().toString()); // true; the string representation of a Date object cannot be parsed as a number

// Arrays
isNaN([]); // false; the primitive representation is "", which coverts to the number 0
isNaN([1]); // false; the primitive representation is "1"
isNaN([1, 2]); // true; the primitive representation is "1,2", which cannot be parsed as number
SpecificationsSpecificationECMAScript Language Specification # sec-isnan-numberBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
NaN
Number.isNaN()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 29, 2023 by MDN contributors.
IteratorAn Iterator object is an object that conforms to the iterator protocol by providing a next() method that returns an iterator result object. All built-in iterators inherit from the Iterator class. The Iterator class provides a @@iterator method that returns the iterator object itself, making the iterator also iterable. It also provides some helper methods for working with iterators.DescriptionThe following are all built-in JavaScript iterators:

The Array Iterator returned by Array.prototype.values(), Array.prototype.keys(), Array.prototype.entries(), Array.prototype[@@iterator](), TypedArray.prototype.values(), TypedArray.prototype.keys(), TypedArray.prototype.entries(), TypedArray.prototype[@@iterator](), and arguments[@@iterator]().
The String Iterator returned by String.prototype[@@iterator]().
The Map Iterator returned by Map.prototype.values(), Map.prototype.keys(), Map.prototype.entries(), and Map.prototype[@@iterator]().
The Set Iterator returned by Set.prototype.values(), Set.prototype.keys(), Set.prototype.entries(), and Set.prototype[@@iterator]().
The RegExp String Iterator returned by RegExp.prototype[@@matchAll]() and String.prototype.matchAll().
The Generator object returned by generator functions.
The Segments Iterator returned by the [@@iterator]() method of the Segments object returned by Intl.Segmenter.prototype.segment().
The Iterator Helper returned by iterator helper methods such as Iterator.prototype.filter() and Iterator.prototype.map().

Each of these iterators have a distinct prototype object, which defines the next() method used by the particular iterator. For example, all string iterator objects inherit from a hidden object StringIteratorPrototype, which has a next() method that iterates this string by code points. StringIteratorPrototype also has a @@toStringTag property whose initial value is the string "String Iterator". This property is used in Object.prototype.toString(). Similarly, other iterator prototypes also have their own @@toStringTag values, which are the same as the names given above.
All of these prototype objects inherit from Iterator.prototype, which provides a @@iterator method that returns the iterator object itself, making the iterator also iterable.Iterator helpers
Note: These methods are iterator helpers, not iterable helpers, because the only requirement for an object to be iterable is just the presence of a @@iterator method. There is no shared prototype to install these methods on.

The Iterator class itself provides some helper methods for working with iterators. For example, you may be tempted to do the following:
jsconst nameToDeposit = new Map([
  ["Anne", 1000],
  ["Bert", 1500],
  ["Carl", 2000],
]);

const totalDeposit = [...nameToDeposit.values()].reduce((a, b) => a + b);

This first converts the iterator returned by Map.prototype.values() to an array, then uses the Array.prototype.reduce() method to calculate the sum. However, this both creates an intermediate array and iterates the array twice. Instead, you can use the reduce() method of the iterator itself:
jsconst totalDeposit = nameToDeposit.values().reduce((a, b) => a + b);

This method is more efficient, because it only iterates the iterator once, without memorizing any intermediate values. Iterator helper methods are necessary to work with infinite iterators:
jsfunction* fibonacci() {
  let current = 1;
  let next = 1;
  while (true) {
    yield current;
    [current, next] = [next, current + next];
  }
}

const seq = fibonacci();
const firstThreeDigitTerm = seq.find((n) => n >= 100);

You cannot convert seq to an array, because it is infinite. Instead, you can use the find() method of the iterator itself, which only iterates seq as far as necessary to find the first value that satisfies the condition.
You will find many iterator methods analogous to array methods, such as:



Iterator method
Array method




Iterator.prototype.every()
Array.prototype.every()


Iterator.prototype.filter()
Array.prototype.filter()


Iterator.prototype.find()
Array.prototype.find()


Iterator.prototype.flatMap()
Array.prototype.flatMap()


Iterator.prototype.forEach()
Array.prototype.forEach()


Iterator.prototype.map()
Array.prototype.map()


Iterator.prototype.reduce()
Array.prototype.reduce()


Iterator.prototype.some()
Array.prototype.some()



Iterator.prototype.drop() and Iterator.prototype.take() combined are somewhat analogous to Array.prototype.slice().
Among these methods, filter(), flatMap(), map(), drop(), and take() return a new Iterator Helper object. The iterator helper is also an Iterator instance, making the helper methods chainable. All iterator helper objects inherit from a common prototype object, which implements the iterator protocol:

next()

Calls the next() method of the underlying iterator, applies the helper method to the result, and returns the result.

return()

Calls the return() method of the underlying iterator, and returns the result.


The iterator helper shares the same data source as the underlying iterator, so iterating the iterator helper causes the underlying iterator to be iterated as well. There is no way to "fork" an iterator to allow it to be iterated multiple times.
jsconst it = [1, 2, 3].values();
const it2 = it.drop(0); // Essentially a copy
console.log(it.next().value); // 1
console.log(it2.next().value); // 2
console.log(it.next().value); // 3
Proper iteratorsThere are two kinds of "iterators": objects that conform to the iterator protocol (which, at its minimum, only requires the presence of a next() method), and objects that inherit from the Iterator class, which enjoy the helper methods. They do not entail each other — objects that inherit from Iterator do not automatically become iterators, because the Iterator class does not define a next() method. Instead, the object needs to define a next() method itself. A proper iterator is one that both conforms to the iterator protocol and inherits from Iterator, and most code expect iterators to be proper iterators and iterables to return proper iterators. To create proper iterators, define a class that extends Iterator, or use the Iterator.from() method.
jsclass MyIterator extends Iterator {
  next() {
    // …
  }
}

const myIterator = Iterator.from({
  next() {
    // …
  },
});
Constructor
Iterator() 
Experimental


Intended to be extended by other classes that create iterators. Throws an error when constructed by itself.

Static methods
Iterator.from() 
Experimental


Creates a new Iterator object from an iterator or iterable object.

Instance propertiesThese properties are defined on Iterator.prototype and shared by all Iterator instances.

Iterator.prototype.constructor

The constructor function that created the instance object. For Iterator instances, the initial value is the Iterator constructor.

Iterator.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "Iterator". This property is used in Object.prototype.toString().

Note: Unlike the @@toStringTag on most built-in classes, Iterator.prototype[@@toStringTag] is writable for web compatibility reasons.


Instance methods
Iterator.prototype.drop() 
Experimental


Returns a new iterator helper that skips the given number of elements at the start of this iterator.

Iterator.prototype.every() 
Experimental


Tests whether all elements produced by the iterator pass the test implemented by the provided function.

Iterator.prototype.filter() 
Experimental


Returns a new iterator helper that yields only those elements of the iterator for which the provided callback function returns true.

Iterator.prototype.find() 
Experimental


Returns the first element produced by the iterator that satisfies the provided testing function. If no values satisfy the testing function, undefined is returned.

Iterator.prototype.flatMap() 
Experimental


Returns a new iterator helper that takes each element in the original iterator, runs it through a mapping function, and yields elements returned by the mapping function (which are contained in another iterator or iterable).

Iterator.prototype.forEach() 
Experimental


Executes a provided function once for each element produced by the iterator.

Iterator.prototype.map() 
Experimental


Returns a new iterator helper that yields elements of the iterator, each transformed by a mapping function.

Iterator.prototype.reduce() 
Experimental


Executes a user-supplied "reducer" callback function on each element produced by the iterator, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements is a single value.

Iterator.prototype.some() 
Experimental


Tests whether at least one element in the iterator passes the test implemented by the provided function. It returns a boolean value.

Iterator.prototype.take() 
Experimental


Returns a new iterator helper that yields the given number of elements in this iterator and then terminates.

Iterator.prototype.toArray() 
Experimental


Creates a new Array instance populated with the elements yielded from the iterator.

Iterator.prototype[@@iterator]()

Returns the iterator object itself. This allows iterator objects to also be iterable.

ExamplesUsing an iterator as an iterableAll built-in iterators are also iterable, so you can use them in a for...of loop:
jsconst arrIterator = [1, 2, 3].values();
for (const value of arrIterator) {
  console.log(value);
}
// Logs: 1, 2, 3
SpecificationsSpecificationECMAScript Language Specification # sec-%iteratorprototype%-objectBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Iterator in core-js
function*
Iteration protocols
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
JSONThe JSON namespace object contains static methods for parsing values from and converting values to JavaScript Object Notation (JSON).DescriptionUnlike most global objects, JSON is not a constructor. You cannot use it with the new operator or invoke the JSON object as a function. All properties and methods of JSON are static (just like the Math object).JavaScript and JSON differencesJSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and null. It is based upon JavaScript syntax, but is distinct from JavaScript: most of JavaScript is not JSON. For example:

Objects and Arrays

Property names must be double-quoted strings; trailing commas are forbidden.

Numbers

Leading zeros are prohibited. A decimal point must be followed by at least one digit. NaN and Infinity are unsupported.


Any JSON text is a valid JavaScript expression, but only after the JSON superset revision. Before the revision, U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR are allowed in string literals and property keys in JSON; but the same use in JavaScript string literals is a SyntaxError.
Other differences include allowing only double-quoted strings and no support for undefined or comments. For those who wish to use a more human-friendly configuration format based on JSON, there is JSON5, used by the Babel compiler, and the more commonly used YAML.
The same text may represent different values in JavaScript object literals vs. JSON as well. For more information, see Object literal syntax vs. JSON.Full JSON grammarValid JSON syntax is formally defined by the following grammar, expressed in ABNF, and copied from IETF JSON standard (RFC):
JSON-text = object / array
begin-array     = ws %x5B ws  ; [ left square bracket
begin-object    = ws %x7B ws  ; { left curly bracket
end-array       = ws %x5D ws  ; ] right square bracket
end-object      = ws %x7D ws  ; } right curly bracket
name-separator  = ws %x3A ws  ; : colon
value-separator = ws %x2C ws  ; , comma
ws = *(
     %x20 /              ; Space
     %x09 /              ; Horizontal tab
     %x0A /              ; Line feed or New line
     %x0D                ; Carriage return
     )
value = false / null / true / object / array / number / string
false = %x66.61.6c.73.65   ; false
null  = %x6e.75.6c.6c      ; null
true  = %x74.72.75.65      ; true
object = begin-object [ member *( value-separator member ) ]
         end-object
member = string name-separator value
array = begin-array [ value *( value-separator value ) ] end-array
number = [ minus ] int [ frac ] [ exp ]
decimal-point = %x2E       ; .
digit1-9 = %x31-39         ; 1-9
e = %x65 / %x45            ; e E
exp = e [ minus / plus ] 1*DIGIT
frac = decimal-point 1*DIGIT
int = zero / ( digit1-9 *DIGIT )
minus = %x2D               ; -
plus = %x2B                ; +
zero = %x30                ; 0
string = quotation-mark *char quotation-mark
char = unescaped /
    escape (
        %x22 /          ; "    quotation mark  U+0022
        %x5C /          ; \    reverse solidus U+005C
        %x2F /          ; /    solidus         U+002F
        %x62 /          ; b    backspace       U+0008
        %x66 /          ; f    form feed       U+000C
        %x6E /          ; n    line feed       U+000A
        %x72 /          ; r    carriage return U+000D
        %x74 /          ; t    tab             U+0009
        %x75 4HEXDIG )  ; uXXXX                U+XXXX
escape = %x5C              ; \
quotation-mark = %x22      ; "
unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
HEXDIG = DIGIT / %x41-46 / %x61-66   ; 0-9, A-F, or a-f
       ; HEXDIG equivalent to HEXDIG rule in [RFC5234]
DIGIT = %x30-39            ; 0-9
      ; DIGIT equivalent to DIGIT rule in [RFC5234]

Insignificant whitespace may be present anywhere except within a JSONNumber (numbers must contain no whitespace) or JSONString (where it is interpreted as the corresponding character in the string, or would cause an error). The tab character (U+0009), carriage return (U+000D), line feed (U+000A), and space (U+0020) characters are the only valid whitespace characters.Static properties
JSON[@@toStringTag]

The initial value of the @@toStringTag property is the string "JSON". This property is used in Object.prototype.toString().

Static methods
JSON.parse()

Parse a piece of string text as JSON, optionally transforming the produced value and its properties, and return the value.

JSON.stringify()

Return a JSON string corresponding to the specified value, optionally including only certain properties or replacing property values in a user-defined manner.

ExamplesExample JSONjson{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}

You can use the JSON.parse() method to convert the above JSON string into a JavaScript object:
jsconst jsonText = `{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}`;

console.log(JSON.parse(jsonText));
SpecificationsSpecificationECMAScript Language Specification # sec-json-objectBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Date.prototype.toJSON()
JSON Diff
JSON Beautifier/editor
JSON Parser
JSON Validator
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Map
  The Map object holds key-value pairs and remembers the original insertion order of the keys.
  Any value (both objects and primitive values) may be used as either a key or a value.
Try itDescriptionMap objects are collections of key-value pairs. A key in the Map may only occur once; it is unique in the Map's collection. A Map object is iterated by key-value pairs — a for...of loop returns a 2-member array of [key, value] for each iteration. Iteration happens in insertion order, which corresponds to the order in which each key-value pair was first inserted into the map by the set() method (that is, there wasn't a key with the same value already in the map when set() was called).
The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Key equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.Objects vs. Maps
Object is similar to Map—both let you set keys to
  values, retrieve those values, delete keys, and detect whether something is
  stored at a key. For this reason (and because there were no built-in
  alternatives), Object has been used as Map historically.


  However, there are important differences that make Map preferable in some
  cases:





Map
Object




Accidental Keys

        A Map does not contain any keys by default. It only
        contains what is explicitly put into it.
      


          An Object has a prototype, so it contains default keys
          that could collide with your own keys if you're not careful.
        


Note: This can be bypassed by using
            Object.create(null),
            but this is seldom done.
          




Security
A Map is safe to use with user-provided keys and values.


          Setting user-provided key-value pairs on an Object may allow
          an attacker to override the object's prototype, which can lead to
          object injection attacks
. Like the accidental keys issue, this can also be mitigated by using
          a null-prototype object.
        



Key Types

        A Map's keys can be any value (including functions,
        objects, or any primitive).
      

        The keys of an Object must be either a
        String or a Symbol.
      


Key Order


          The keys in Map are ordered in a simple, straightforward
          way: A Map object iterates entries, keys, and values in
          the order of entry insertion.
        



          Although the keys of an ordinary Object are ordered now,
          this was not always the case, and the order is complex. As a result,
          it's best not to rely on property order.
        

          The order was first defined for own properties only in ECMAScript
          2015; ECMAScript 2020 defines order for inherited properties as well.
          But note that no single mechanism
          iterates
          all of an object's properties; the various mechanisms
          each include different subsets of properties.
          (for-in
          includes only enumerable string-keyed properties;
          Object.keys includes only own, enumerable,
          string-keyed properties;
          Object.getOwnPropertyNames includes own,
          string-keyed properties even if non-enumerable;
          Object.getOwnPropertySymbols does the same
          for just Symbol-keyed properties, etc.)
        




Size


        The number of items in a Map is easily retrieved from its
        size property.
      
Determining the number of items in an Object is more roundabout and less efficient. A common way to do it is through the length of the array returned from Object.keys().


Iteration

        A Map is an
        iterable, so it can be directly iterated.
      


Object does not implement an iteration protocol, and so objects are not directly iterable using the JavaScript
          for...of
          statement (by default).
        

Note:


              An object can implement the iteration protocol, or you can get an
              iterable for an object using Object.keys or Object.entries.
            

              The
              for...in
              statement allows you to iterate over the
              enumerable properties of an object.
            





Performance


          Performs better in scenarios involving frequent additions and removals
          of key-value pairs.
        


Not optimized for frequent additions and removals of key-value pairs.



Serialization and parsing

No native support for serialization or parsing.

          (But you can build your own serialization and parsing support for
          Map by using JSON.stringify()
          with its replacer argument, and by using
          JSON.parse() with its
          reviver argument. See the Stack Overflow question
          How do you JSON.stringify an ES6 Map?).
        



          Native support for serialization from Object to
          JSON, using JSON.stringify().
        

          Native support for parsing from JSON to Object,
          using JSON.parse().
        



Setting object properties
  Setting Object properties works for Map objects as well, and can cause
  considerable confusion.

Therefore, this appears to work in a way:
jsconst wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }


  But that way of setting a property does not interact with the Map data
  structure. It uses the feature of the generic object. The value of 'bla' is not
  stored in the Map for queries. Other operations on the data fail:

jswrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }


  The correct usage for storing data in the Map is through the set(key, value)
  method.

jsconst contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
Map-like browser APIsBrowser Map-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a Map.

  Just like Map, entries can be iterated in the same order that they were added to the object.
  Map-like objects and Map also have properties and methods that share the same name and behavior.
  However unlike Map they only allow specific predefined types for the keys and values of each entry.


  The allowed types are set in the specification IDL definition.
  For example, RTCStatsReport is a Map-like object that must use strings for keys and objects for values.
  This is defined in the specification IDL below:

webidlinterface RTCStatsReport {
  readonly maplike<DOMString, object>;
};

Map-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Map-like objects have the property size, and the methods: entries(), forEach(), get(), has(), keys(), values(), and @@iterator.
Writeable Map-like objects additionally have the methods: clear(), delete(), and set().

The methods and properties have the same behavior as the equivalent entities in Map, except for the restriction on the types of the keys and values.
The following are examples of read-only Map-like browser objects:

AudioParamMap
RTCStatsReport
EventCounts
KeyboardLayoutMap
MIDIInputMap
MIDIOutputMap
Constructor
Map()

Creates a new Map object.

Static properties
Map[@@species]

The constructor function that is used to create derived objects.

Static methods
Map.groupBy()

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned Map uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

Instance propertiesThese properties are defined on Map.prototype and shared by all Map instances.

Map.prototype.constructor

The constructor function that created the instance object. For Map instances, the initial value is the Map constructor.

Map.prototype.size

Returns the number of key/value pairs in the Map object.

Map.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "Map". This property is used in Object.prototype.toString().

Instance methods
Map.prototype.clear()

Removes all key-value pairs from the Map object.

Map.prototype.delete()


      Returns true if an element in the Map object existed and has been
      removed, or false if the element does not exist. map.has(key)
      will return false afterwards.
    

Map.prototype.entries()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

Map.prototype.forEach()

Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.

Map.prototype.get()

Returns the value associated to the passed key, or undefined if there is none.

Map.prototype.has()

Returns a boolean indicating whether a value has been associated with the passed key in the Map object or not.

Map.prototype.keys()

Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.

Map.prototype.set()

Sets the value for the passed key in the Map object. Returns the Map object.

Map.prototype.values()

Returns a new Iterator object that contains the values for each element in the Map object in insertion order.

Map.prototype[@@iterator]()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

ExamplesUsing the Map objectjsconst myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(function () {})); // undefined, because keyFunc !== function () {}
Using NaN as Map keys
NaN can also be used as a key. Even though every NaN is
  not equal to itself (NaN !== NaN is true), the following example works because
  NaNs are indistinguishable from each other:

jsconst myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
Iterating Map with for...ofMaps can be iterated using a for...of loop:
jsconst myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
Iterating Map with forEach()
  Maps can be iterated using the
  forEach() method:

jsmyMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
Relation with Array objectsjsconst kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
Cloning and merging MapsJust like Arrays, Maps can be cloned:
jsconst original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)


Note: Keep in mind that the data itself is not cloned.

Maps can be merged, maintaining key uniqueness:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three

Maps can be merged with Arrays, too:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "eins"]]);

console.log(merged.get(1)); // eins
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
SpecificationsSpecificationECMAScript Language Specification # sec-map-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill for Map in core-js
Set
WeakMap
WeakSet
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 30, 2023 by MDN contributors.
MathThe Math namespace object contains static properties and methods for mathematical constants and functions.
Math works with the Number type. It doesn't work with BigInt.DescriptionUnlike most global objects, Math is not a constructor. You cannot use it with the new operator or invoke the Math object as a function. All properties and methods of Math are static.

Note: Many Math functions have a precision that's implementation-dependent.
This means that different browsers can give a different result. Even the same JavaScript engine on a different OS or architecture can give different results!
Static properties
Math.E

Euler's number and the base of natural logarithms; approximately 2.718.

Math.LN10

Natural logarithm of 10; approximately 2.303.

Math.LN2

Natural logarithm of 2; approximately 0.693.

Math.LOG10E

Base-10 logarithm of E; approximately 0.434.

Math.LOG2E

Base-2 logarithm of E; approximately 1.443.

Math.PI

Ratio of a circle's circumference to its diameter; approximately 3.14159.

Math.SQRT1_2

Square root of ½; approximately 0.707.

Math.SQRT2

Square root of 2; approximately 1.414.

Math[@@toStringTag]

The initial value of the @@toStringTag property is the string "Math". This property is used in Object.prototype.toString().

Static methods
Math.abs()

Returns the absolute value of x.

Math.acos()

Returns the arccosine of x.

Math.acosh()

Returns the hyperbolic arccosine of x.

Math.asin()

Returns the arcsine of x.

Math.asinh()

Returns the hyperbolic arcsine of a number.

Math.atan()

Returns the arctangent of x.

Math.atan2()

Returns the arctangent of the quotient of its arguments.

Math.atanh()

Returns the hyperbolic arctangent of x.

Math.cbrt()

Returns the cube root of x.

Math.ceil()

Returns the smallest integer greater than or equal to x.

Math.clz32()

Returns the number of leading zero bits of the 32-bit integer x.

Math.cos()

Returns the cosine of x.

Math.cosh()

Returns the hyperbolic cosine of x.

Math.exp()

Returns ex, where x is the argument, and e is Euler's number (2.718…, the base of the natural logarithm).

Math.expm1()

Returns subtracting 1 from exp(x).

Math.floor()

Returns the largest integer less than or equal to x.

Math.fround()

Returns the nearest single precision float representation of x.

Math.hypot()

Returns the square root of the sum of squares of its arguments.

Math.imul()

Returns the result of the 32-bit integer multiplication of x and y.

Math.log()

Returns the natural logarithm (㏒e; also, ㏑) of x.

Math.log10()

Returns the base-10 logarithm of x.

Math.log1p()

Returns the natural logarithm (㏒e; also ㏑) of 1 + x for the number x.

Math.log2()

Returns the base-2 logarithm of x.

Math.max()

Returns the largest of zero or more numbers.

Math.min()

Returns the smallest of zero or more numbers.

Math.pow()

Returns base x to the exponent power y (that is, xy).

Math.random()

Returns a pseudo-random number between 0 and 1.

Math.round()

Returns the value of the number x rounded to the nearest integer.

Math.sign()

Returns the sign of the x, indicating whether x is positive, negative, or zero.

Math.sin()

Returns the sine of x.

Math.sinh()

Returns the hyperbolic sine of x.

Math.sqrt()

Returns the positive square root of x.

Math.tan()

Returns the tangent of x.

Math.tanh()

Returns the hyperbolic tangent of x.

Math.trunc()

Returns the integer portion of x, removing any fractional digits.

ExamplesConverting between degrees and radiansThe trigonometric functions sin(), cos(), tan(), asin(), acos(), atan(), and atan2() expect (and return) angles in radians.
Since humans tend to think in degrees, and some functions (such as CSS transforms) can accept degrees, it is a good idea to keep functions handy that convert between the two:
jsfunction degToRad(degrees) {
  return degrees * (Math.PI / 180);
}

function radToDeg(rad) {
  return rad / (Math.PI / 180);
}
Calculating the height of an equilateral triangleIf we want to calculate the height of an equilateral triangle, and we know its side length is 100, we can use the formulae length of the adjacent multiplied by the tangent of the angle is equal to the opposite.



In JavaScript, we can do this with the following:
js50 * Math.tan(degToRad(60));

We use our degToRad() function to convert 60 degrees to radians, as Math.tan() expects an input value in radians.Returning a random integer between two boundsThis can be achieved with a combination of Math.random() and Math.floor():
jsfunction random(min, max) {
  const num = Math.floor(Math.random() * (max - min + 1)) + min;
  return num;
}

random(1, 10);
SpecificationsSpecificationECMAScript Language Specification # sec-math-objectBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Number
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 2, 2024 by MDN contributors.
NaNThe NaN global property is a value representing Not-A-Number.Try itValueThe same number value as Number.NaN.


Property attributes of NaN




Writable
no


Enumerable
no


Configurable
no


DescriptionNaN is a property of the global object. In other words, it is a variable in global scope.
In modern browsers, NaN is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.
There are five different types of operations that return NaN:

Failed number conversion (e.g. explicit ones like parseInt("blabla"), Number(undefined), or implicit ones like Math.abs(undefined))
Math operation where the result is not a real number (e.g. Math.sqrt(-1))
Indeterminate form (e.g. 0 * Infinity, 1 ** Infinity, Infinity / Infinity, Infinity - Infinity)
A method or expression whose operand is or gets coerced to NaN (e.g. 7 ** NaN, 7 * "blabla") — this means NaN is contagious
Other cases where an invalid value is to be represented as a number (e.g. an invalid Date new Date("blabla").getTime(), "".charCodeAt(1))

NaN and its behaviors are not invented by JavaScript. Its semantics in floating point arithmetic (including that NaN !== NaN) are specified by IEEE 754. NaN's behaviors include:

If NaN is involved in a mathematical operation (but not bitwise operations), the result is usually also NaN. (See counter-example below.)
When NaN is one of the operands of any relational comparison (>, <, >=, <=), the result is always false.
NaN compares unequal (via ==, !=, ===, and !==) to any other value — including to another NaN value.

NaN is also one of the falsy values in JavaScript.ExamplesTesting against NaNTo tell if a value is NaN, use Number.isNaN() or isNaN() to most clearly determine whether a value is NaN — or, since NaN is the only value that compares unequal to itself, you can perform a self-comparison like x !== x.
jsNaN === NaN; // false
Number.NaN === NaN; // false
isNaN(NaN); // true
isNaN(Number.NaN); // true
Number.isNaN(NaN); // true

function valueIsNaN(v) {
  return v !== v;
}
valueIsNaN(1); // false
valueIsNaN(NaN); // true
valueIsNaN(Number.NaN); // true

However, do note the difference between isNaN() and Number.isNaN(): the former will return true if the value is currently NaN, or if it is going to be NaN after it is coerced to a number, while the latter will return true only if the value is currently NaN:
jsisNaN("hello world"); // true
Number.isNaN("hello world"); // false

For the same reason, using a BigInt value will throw an error with isNaN() and not with Number.isNaN():
jsisNaN(1n); // TypeError: Conversion from 'BigInt' to 'number' is not allowed.
Number.isNaN(1n); // false

Additionally, some array methods cannot find NaN, while others can. Namely, the index-finding ones (indexOf(), lastIndexOf()) cannot find NaN, while the value-finding ones (includes()) can:
jsconst arr = [2, 4, NaN, 12];
arr.indexOf(NaN); // -1
arr.includes(NaN); // true

// Methods accepting a properly defined predicate can always find NaN
arr.findIndex((n) => Number.isNaN(n)); // 2

For more information about NaN and its comparison, see Equality comparison and sameness.Observably distinct NaN valuesThere's a motivation for NaN being unequal to itself. It's possible to produce two floating point numbers with different binary representations but are both NaN, because in IEEE 754 encoding, any floating point number with exponent 0x7ff and a non-zero mantissa is NaN. In JavaScript, you can do bit-level manipulation using typed arrays.
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
const m = f2b(NaN);
// Change the sign bit, which doesn't matter for NaN
n[7] += 2 ** 7;
// n[0] += 2**7; for big endian processors
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 255]
// Change the first bit, which is the least significant bit of the mantissa and doesn't matter for NaN
m[0] = 1;
// m[7] = 1; for big endian processors
const nan3 = b2f(m);
console.log(nan3); // NaN
console.log(Object.is(nan3, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan3)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
Silently escaping NaNNaN propagates through mathematical operations, so it's usually sufficient to test for NaN once at the end of calculation to detect error conditions. The only case where NaN gets silently escaped is when using exponentiation with an exponent of 0, which immediately returns 1 without testing the base's value.
jsNaN ** 0 === 1; // true
SpecificationsSpecificationECMAScript Language Specification # sec-value-properties-of-the-global-object-nanBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Number.NaN
Number.isNaN()
isNaN()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 6, 2023 by MDN contributors.
NumberNumber values represent floating-point numbers like 37 or -9.25.
The Number constructor contains constants and methods for working with numbers. Values of other types can be converted to numbers using the Number() function.DescriptionNumbers are most commonly expressed in literal forms like 255 or 3.14159. The lexical grammar contains a more detailed reference.
js255; // two-hundred and fifty-five
255.0; // same number
255 === 255.0; // true
255 === 0xff; // true (hexadecimal notation)
255 === 0b11111111; // true (binary notation)
255 === 0.255e3; // true (decimal exponential notation)

A number literal like 37 in JavaScript code is a floating-point value, not an integer. There is no separate integer type in common everyday use. (JavaScript also has a BigInt type, but it's not designed to replace Number for everyday uses. 37 is still a number, not a BigInt.)
When used as a function, Number(value) converts a string or other value to the Number type. If the value can't be converted, it returns NaN.
jsNumber("123"); // returns the number 123
Number("123") === 123; // true

Number("unicorn"); // NaN
Number(undefined); // NaN
Number encodingThe JavaScript Number type is a double-precision 64-bit binary format IEEE 754 value, like double in Java or C#. This means it can represent fractional values, but there are some limits to the stored number's magnitude and precision. Very briefly, an IEEE 754 double-precision number uses 64 bits to represent 3 parts:

1 bit for the sign (positive or negative)
11 bits for the exponent (-1022 to 1023)
52 bits for the mantissa (representing a number between 0 and 1)

The mantissa (also called significand) is the part of the number representing the actual value (significant digits). The exponent is the power of 2 that the mantissa should be multiplied by. Thinking about it as scientific notation:




Number
=
(

−
1


)
sign

⋅
(
1
+
mantissa
)
⋅

2
exponent


\text{Number} = ({-1})^{\text{sign}} \cdot (1 + \text{mantissa}) \cdot 2^{\text{exponent}}



The mantissa is stored with 52 bits, interpreted as digits after 1.… in a binary fractional number. Therefore, the mantissa's precision is 2-52 (obtainable via Number.EPSILON), or about 15 to 17 decimal places; arithmetic above that level of precision is subject to rounding.
The largest value a number can hold is 21023 × (2 - 2-52) (with the exponent being 1023 and the mantissa being 0.1111… in base 2), which is obtainable via Number.MAX_VALUE. Values higher than that are replaced with the special number constant Infinity.
Integers can only be represented without loss of precision in the range -253 + 1 to 253 - 1, inclusive (obtainable via Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER), because the mantissa can only hold 53 bits (including the leading 1).
More details on this are described in the ECMAScript standard.Number coercionMany built-in operations that expect numbers first coerce their arguments to numbers (which is largely why Number objects behave similarly to number primitives). The operation can be summarized as follows:

Numbers are returned as-is.
undefined turns into NaN.
null turns into 0.
true turns into 1; false turns into 0.
Strings are converted by parsing them as if they contain a number literal. Parsing failure results in NaN. There are some minor differences compared to an actual number literal:
    
Leading and trailing whitespace/line terminators are ignored.
A leading 0 digit does not cause the number to become an octal literal (or get rejected in strict mode).
+ and - are allowed at the start of the string to indicate its sign. (In actual code, they "look like" part of the literal, but are actually separate unary operators.) However, the sign can only appear once, and must not be followed by whitespace.
Infinity and -Infinity are recognized as literals. In actual code, they are global variables.
Empty or whitespace-only strings are converted to 0.
Numeric separators are not allowed.


BigInts throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [@@toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a number.

There are two ways to achieve nearly the same effect in JavaScript.

Unary plus: +x does exactly the number coercion steps explained above to convert x.
The Number() function: Number(x) uses the same algorithm to convert x, except that BigInts don't throw a TypeError, but return their number value, with possible loss of precision.

Number.parseFloat() and Number.parseInt() are similar to Number() but only convert strings, and have slightly different parsing rules. For example, parseInt() doesn't recognize the decimal point, and parseFloat() doesn't recognize the 0x prefix.
Integer conversion
Some operations expect integers, most notably those that work with array/string indices, date/time components, and number radixes. After performing the number coercion steps above, the result is truncated to an integer (by discarding the fractional part). If the number is ±Infinity, it's returned as-is. If the number is NaN or -0, it's returned as 0. The result is therefore always an integer (which is not -0) or ±Infinity.
Notably, when converted to integers, both undefined and null become 0, because undefined is converted to NaN, which also becomes 0.
Fixed-width number conversion
JavaScript has some lower-level functions that deal with the binary encoding of integer numbers, most notably bitwise operators and TypedArray objects. Bitwise operators always convert the operands to 32-bit integers. In these cases, after converting the value to a number, the number is then normalized to the given width by first truncating the fractional part and then taking the lowest bits in the integer's two's complement encoding.
jsnew Int32Array([1.1, 1.9, -1.1, -1.9]); // Int32Array(4) [ 1, 1, -1, -1 ]

new Int8Array([257, -257]); // Int8Array(2) [ 1, -1 ]
// 257 = 0001 0000 0001
//     =      0000 0001 (mod 2^8)
//     = 1
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = -1 (as signed integer)

new Uint8Array([257, -257]); // Uint8Array(2) [ 1, 255 ]
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = 255 (as unsigned integer)
Constructor
Number()

Creates a new Number value.


When Number is called as a constructor (with new), it creates a Number object, which is not a primitive. For example, typeof new Number(42) === "object", and new Number(42) !== 42 (although new Number(42) == 42).

Warning: You should rarely find yourself using Number as a constructor.
Static properties
Number.EPSILON

The smallest interval between two representable numbers.

Number.MAX_SAFE_INTEGER

The maximum safe integer in JavaScript (253 - 1).

Number.MAX_VALUE

The largest positive representable number.

Number.MIN_SAFE_INTEGER

The minimum safe integer in JavaScript (-(253 - 1)).

Number.MIN_VALUE

The smallest positive representable number—that is, the positive number closest to zero (without actually being zero).

Number.NaN

Special "Not a Number" value.

Number.NEGATIVE_INFINITY

Special value representing negative infinity. Returned on overflow.

Number.POSITIVE_INFINITY

Special value representing infinity. Returned on overflow.

Static methods
Number.isFinite()

Determine whether the passed value is a finite number.

Number.isInteger()

Determine whether the passed value is an integer.

Number.isNaN()

Determine whether the passed value is NaN.

Number.isSafeInteger()

Determine whether the passed value is a safe integer (number between -(253 - 1) and 253 - 1).

Number.parseFloat()

This is the same as the global parseFloat() function.

Number.parseInt()

This is the same as the global parseInt() function.

Instance propertiesThese properties are defined on Number.prototype and shared by all Number instances.

Number.prototype.constructor

The constructor function that created the instance object. For Number instances, the initial value is the Number constructor.

Instance methods
Number.prototype.toExponential()

Returns a string representing the number in exponential notation.

Number.prototype.toFixed()

Returns a string representing the number in fixed-point notation.

Number.prototype.toLocaleString()

Returns a string with a language sensitive representation of this number. Overrides the Object.prototype.toLocaleString() method.

Number.prototype.toPrecision()

Returns a string representing the number to a specified precision in fixed-point or exponential notation.

Number.prototype.toString()

Returns a string representing the specified object in the specified radix ("base"). Overrides the Object.prototype.toString() method.

Number.prototype.valueOf()

Returns the primitive value of the specified object. Overrides the Object.prototype.valueOf() method.

ExamplesUsing the Number object to assign values to numeric variablesThe following example uses the Number object's properties to assign values to several numeric variables:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;
Integer range for NumberThe following example shows the minimum and maximum integer values that can be represented as Number object.
jsconst biggestInt = Number.MAX_SAFE_INTEGER; // (2**53 - 1) => 9007199254740991
const smallestInt = Number.MIN_SAFE_INTEGER; // -(2**53 - 1) => -9007199254740991

When parsing data that has been serialized to JSON, integer values falling outside of this range can be expected to become corrupted when JSON parser coerces them to Number type.
A possible workaround is to use String instead.
Larger numbers can be represented using the BigInt type.Using Number() to convert a Date objectThe following example converts the Date object to a numerical value using Number as a function:
jsconst d = new Date("1995-12-17T03:24:00");
console.log(Number(d));

This logs 819199440000.Convert numeric strings and null to numbersjsNumber("123"); // 123
Number("123") === 123; // true
Number("12.3"); // 12.3
Number("12.00"); // 12
Number("123e-1"); // 12.3
Number(""); // 0
Number(null); // 0
Number("0x11"); // 17
Number("0b11"); // 3
Number("0o11"); // 9
Number("foo"); // NaN
Number("100a"); // NaN
Number("-Infinity"); // -Infinity
SpecificationsSpecificationECMAScript Language Specification # sec-number-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of modern Number behavior (with support binary and octal literals) in core-js
NaN
Arithmetic operators
Math
BigInt
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 18, 2023 by MDN contributors.
ObjectThe Object type represents one of JavaScript's data types. It is used to store various keyed collections and more complex entities. Objects can be created using the Object() constructor or the object initializer / literal syntax.DescriptionNearly all objects in JavaScript are instances of Object; a typical object inherits properties (including methods) from Object.prototype, although these properties may be shadowed (a.k.a. overridden). The only objects that don't inherit from Object.prototype are those with null prototype, or descended from other null prototype objects.
Changes to the Object.prototype object are seen by all objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior. To make it more secure, Object.prototype is the only object in the core JavaScript language that has immutable prototype — the prototype of Object.prototype is always null and not changeable.Object prototype propertiesYou should avoid calling any Object.prototype method directly from the instance, especially those that are not intended to be polymorphic (i.e. only its initial behavior makes sense and no descending object could override it in a meaningful way). All objects descending from Object.prototype may define a custom own property that has the same name, but with entirely different semantics from what you expect. Furthermore, these properties are not inherited by null-prototype objects. All modern JavaScript utilities for working with objects are static. More specifically:

valueOf(), toString(), and toLocaleString() exist to be polymorphic and you should expect the object to define its own implementation with sensible behaviors, so you can call them as instance methods. However, valueOf() and toString() are usually implicitly called through type conversion and you don't need to call them yourself in your code.
__defineGetter__(), __defineSetter__(), __lookupGetter__(), and __lookupSetter__() are deprecated and should not be used. Use the static alternatives Object.defineProperty() and Object.getOwnPropertyDescriptor() instead.
The __proto__ property is deprecated and should not be used. The Object.getPrototypeOf() and Object.setPrototypeOf() alternatives are static methods.
The propertyIsEnumerable() and hasOwnProperty() methods can be replaced with the Object.getOwnPropertyDescriptor() and Object.hasOwn() static methods, respectively.
The isPrototypeOf() method can usually be replaced with instanceof, if you are checking the prototype property of a constructor.

In case where a semantically equivalent static method doesn't exist, or if you really want to use the Object.prototype method, you should directly call() the Object.prototype method on your target object instead, to prevent the object from having an overriding property that produces unexpected results.
jsconst obj = {
  foo: 1,
  // You should not define such a method on your own object,
  // but you may not be able to prevent it from happening if
  // you are receiving the object from external input
  propertyIsEnumerable() {
    return false;
  },
};

obj.propertyIsEnumerable("foo"); // false; unexpected result
Object.prototype.propertyIsEnumerable.call(obj, "foo"); // true; expected result
Deleting a property from an objectThere isn't any method in an Object itself to delete its own properties (such as Map.prototype.delete()). To do so, one must use the delete operator.null-prototype objectsAlmost all objects in JavaScript ultimately inherit from Object.prototype (see inheritance and the prototype chain). However, you may create null-prototype objects using Object.create(null) or the object initializer syntax with __proto__: null (note: the __proto__ key in object literals is different from the deprecated Object.prototype.__proto__ property). You can also change the prototype of an existing object to null by calling Object.setPrototypeOf(obj, null).
jsconst obj = Object.create(null);
const obj2 = { __proto__: null };

An object with a null prototype can behave in unexpected ways, because it doesn't inherit any object methods from Object.prototype. This is especially true when debugging, since common object-property converting/detecting utility functions may generate errors, or lose information (especially if using silent error-traps that ignore errors).
For example, the lack of Object.prototype.toString() often makes debugging intractable:
jsconst normalObj = {}; // create a normal object
const nullProtoObj = Object.create(null); // create an object with "null" prototype

console.log(`normalObj is: ${normalObj}`); // shows "normalObj is: [object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // throws error: Cannot convert object to primitive value

alert(normalObj); // shows [object Object]
alert(nullProtoObj); // throws error: Cannot convert object to primitive value

Other methods will fail as well.
jsnormalObj.valueOf(); // shows {}
nullProtoObj.valueOf(); // throws error: nullProtoObj.valueOf is not a function

normalObj.hasOwnProperty("p"); // shows "true"
nullProtoObj.hasOwnProperty("p"); // throws error: nullProtoObj.hasOwnProperty is not a function

normalObj.constructor; // shows "Object() { [native code] }"
nullProtoObj.constructor; // shows "undefined"

We can add the toString method back to the null-prototype object by assigning it one:
jsnullProtoObj.toString = Object.prototype.toString; // since new object lacks toString, add the original generic one back

console.log(nullProtoObj.toString()); // shows "[object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // shows "nullProtoObj is: [object Object]"

Unlike normal objects, in which toString() is on the object's prototype, the toString() method here is an own property of nullProtoObj. This is because nullProtoObj has no (null) prototype.
You can also revert a null-prototype object back to an ordinary object using Object.setPrototypeOf(nullProtoObj, Object.prototype).
In practice, objects with null prototype are usually used as a cheap substitute for maps. The presence of Object.prototype properties will cause some bugs:
jsconst ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

function getAge(name) {
  return ages[name];
}

hasPerson("hasOwnProperty"); // true
getAge("toString"); // [Function: toString]

Using a null-prototype object removes this hazard without introducing too much complexity to the hasPerson and getAge functions:
jsconst ages = Object.create(null, {
  alice: { value: 18, enumerable: true },
  bob: { value: 27, enumerable: true },
});

hasPerson("hasOwnProperty"); // false
getAge("toString"); // undefined

In such case, the addition of any method should be done cautiously, as they can be confused with the other key-value pairs stored as data.
Making your object not inherit from Object.prototype also prevents prototype pollution attacks. If a malicious script adds a property to Object.prototype, it will be accessible on every object in your program, except objects that have null prototype.
jsconst user = {};

// A malicious script:
Object.prototype.authenticated = true;

// Unexpectedly allowing unauthenticated user to pass through
if (user.authenticated) {
  // access confidential data
}

JavaScript also has built-in APIs that produce null-prototype objects, especially those that use objects as ad hoc key-value collections. For example:

The return value of Object.groupBy()
The groups and indices.groups properties of the result of RegExp.prototype.exec()
Array.prototype[@@unscopables] (all @@unscopables objects should have null-prototype)
import.meta
Module namespace objects, obtained through import * as ns from "module"; or import()

The term "null-prototype object" often also includes any object without Object.prototype in its prototype chain. Such objects can be created with extends null when using classes.Object coercionMany built-in operations that expect objects first coerce their arguments to objects. The operation can be summarized as follows:

Objects are returned as-is.
undefined and null throw a TypeError.
Number, String, Boolean, Symbol, BigInt primitives are wrapped into their corresponding object wrappers.

There are two ways to achieve nearly the same effect in JavaScript.

Object.prototype.valueOf(): Object.prototype.valueOf.call(x) does exactly the object coercion steps explained above to convert x.
The Object() function: Object(x) uses the same algorithm to convert x, except that undefined and null don't throw a TypeError, but return a plain object.

Places that use object coercion include:

The object parameter of for...in loops.
The this value of Array methods.
Parameters of Object methods such as Object.keys().
Auto-boxing when a property is accessed on a primitive value, since primitives do not have properties.
The this value when calling a non-strict function. Primitives are boxed while null and undefined are replaced with the global object.

Unlike conversion to primitives, the object coercion process itself is not observable in any way, since it doesn't invoke custom code like toString or valueOf methods.Constructor
Object()

Turns the input into an object.

Static methods
Object.assign()

Copies the values of all enumerable own properties from one or more source objects to a target object.

Object.create()

Creates a new object with the specified prototype object and properties.

Object.defineProperties()

Adds the named properties described by the given descriptors to an object.

Object.defineProperty()

Adds the named property described by a given descriptor to an object.

Object.entries()

Returns an array containing all of the [key, value] pairs of a given object's own enumerable string properties.

Object.freeze()

Freezes an object. Other code cannot delete or change its properties.

Object.fromEntries()

Returns a new object from an iterable of [key, value] pairs. (This is the reverse of Object.entries).

Object.getOwnPropertyDescriptor()

Returns a property descriptor for a named property on an object.

Object.getOwnPropertyDescriptors()

Returns an object containing all own property descriptors for an object.

Object.getOwnPropertyNames()

Returns an array containing the names of all of the given object's own enumerable and non-enumerable properties.

Object.getOwnPropertySymbols()

Returns an array of all symbol properties found directly upon a given object.

Object.getPrototypeOf()

Returns the prototype (internal [[Prototype]] property) of the specified object.

Object.groupBy()

Groups the elements of a given iterable according to the string values returned by a provided callback function. The returned object has separate properties for each group, containing arrays with the elements in the group.

Object.hasOwn()

Returns true if the specified object has the indicated property as its own property, or false if the property is inherited or does not exist.

Object.is()

Compares if two values are the same value. Equates all NaN values (which differs from both IsLooselyEqual used by == and IsStrictlyEqual used by ===).

Object.isExtensible()

Determines if extending of an object is allowed.

Object.isFrozen()

Determines if an object was frozen.

Object.isSealed()

Determines if an object is sealed.

Object.keys()

Returns an array containing the names of all of the given object's own enumerable string properties.

Object.preventExtensions()

Prevents any extensions of an object.

Object.seal()

Prevents other code from deleting properties of an object.

Object.setPrototypeOf()

Sets the object's prototype (its internal [[Prototype]] property).

Object.values()

Returns an array containing the values that correspond to all of a given object's own enumerable string properties.

Instance propertiesThese properties are defined on Object.prototype and shared by all Object instances.

Object.prototype.__proto__ 
Deprecated


Points to the object which was used as prototype when the object was instantiated.

Object.prototype.constructor

The constructor function that created the instance object. For plain Object instances, the initial value is the Object constructor. Instances of other constructors each inherit the constructor property from their respective Constructor.prototype object.

Instance methods
Object.prototype.__defineGetter__() 
Deprecated


Associates a function with a property that, when accessed, executes that function and returns its return value.

Object.prototype.__defineSetter__() 
Deprecated


Associates a function with a property that, when set, executes that function which modifies the property.

Object.prototype.__lookupGetter__() 
Deprecated


Returns the function bound as a getter to the specified property.

Object.prototype.__lookupSetter__() 
Deprecated


Returns the function bound as a setter to the specified property.

Object.prototype.hasOwnProperty()

Returns a boolean indicating whether an object contains the specified property as a direct property of that object and not inherited through the prototype chain.

Object.prototype.isPrototypeOf()

Returns a boolean indicating whether the object this method is called upon is in the prototype chain of the specified object.

Object.prototype.propertyIsEnumerable()

Returns a boolean indicating whether the specified property is the object's enumerable own property.

Object.prototype.toLocaleString()

Calls toString().

Object.prototype.toString()

Returns a string representation of the object.

Object.prototype.valueOf()

Returns the primitive value of the specified object.

ExamplesConstructing empty objectsThe following example creates empty objects using the new keyword with different arguments:
jsconst o1 = new Object();
const o2 = new Object(undefined);
const o3 = new Object(null);
Using Object() constructor to turn primitives into an Object of their respective typeYou can use the Object() constructor to create an object wrapper of a primitive value.
The following examples create variables o1 and o2 which are objects storing Boolean and BigInt values:
js// Equivalent to const o1 = new Boolean(true)
const o1 = new Object(true);

// No equivalent because BigInt() can't be called as a constructor,
// and calling it as a regular function won't create an object
const o2 = new Object(1n);
Object prototypesWhen altering the behavior of existing Object.prototype methods, consider injecting code by wrapping your extension before or after the existing logic. For example, this (untested) code will pre-conditionally execute custom logic before the built-in logic or someone else's extension is executed.
When modifying prototypes with hooks, pass this and the arguments (the call state) to the current behavior by calling apply() on the function. This pattern can be used for any prototype, such as Node.prototype, Function.prototype, etc.
jsconst current = Object.prototype.valueOf;

// Since my property "-prop-value" is cross-cutting and isn't always
// on the same prototype chain, I want to modify Object.prototype:
Object.prototype.valueOf = function (...args) {
  if (Object.hasOwn(this, "-prop-value")) {
    return this["-prop-value"];
  } else {
    // It doesn't look like one of my objects, so let's fall back on
    // the default behavior by reproducing the current behavior as best we can.
    // The apply behaves like "super" in some other languages.
    // Even though valueOf() doesn't take arguments, some other hook may.
    return current.apply(this, args);
  }
};


Warning: Modifying the prototype property of any built-in constructor is considered a bad practice and risks forward compatibility.

You can read more about prototypes in Inheritance and the prototype chain.SpecificationsSpecificationECMAScript Language Specification # sec-object-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Object initializer
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 30, 2023 by MDN contributors.
parseFloat()The parseFloat() function parses a string argument and returns a floating point number.Try itSyntaxjsparseFloat(string)
Parameters
string

The value to parse, coerced to a string. Leading whitespace in this argument is ignored.

Return valueA floating point number parsed from the given string, or NaN when the first non-whitespace character cannot be converted to a number.

Note: JavaScript does not have the distinction of "floating point numbers" and "integers" on the language level. parseInt() and parseFloat() only differ in their parsing behavior, but not necessarily their return values. For example, parseInt("42") and parseFloat("42") would return the same value: a Number 42.
DescriptionThe parseFloat function converts its first argument to a string, parses that string as a decimal number literal, then returns a number or NaN. The number syntax it accepts can be summarized as:

The characters accepted by parseFloat() are plus sign (+), minus sign (- U+002D HYPHEN-MINUS), decimal digits (0 – 9), decimal point (.), exponent indicator (e or E), and the "Infinity" literal.
The +/- signs can only appear strictly at the beginning of the string, or immediately following the e/E character. The decimal point can only appear once, and only before the e/E character. The e/E character can only appear once, and only if there is at least one digit before it.
Leading spaces in the argument are trimmed and ignored.
parseFloat() can also parse and return Infinity or -Infinity if the string starts with "Infinity" or "-Infinity" preceded by none or more white spaces.
parseFloat() picks the longest substring starting from the beginning that generates a valid number literal. If it encounters an invalid character, it returns the number represented up to that point, ignoring the invalid character and all characters following it.
If the argument's first character can't start a legal number literal per the syntax above, parseFloat returns NaN.

Syntax-wise, parseFloat() parses a subset of the syntax that the Number() function accepts. Namely, parseFloat() does not support non-decimal literals with 0x, 0b, or 0o prefixes but supports everything else. However, parseFloat() is more lenient than Number() because it ignores trailing invalid characters, which would cause Number() to return NaN.
Similar to number literals and Number(), the number returned from parseFloat() may not be exactly equal to the number represented by the string, due to floating point range and inaccuracy. For numbers outside the -1.7976931348623158e+308 – 1.7976931348623158e+308 range (see Number.MAX_VALUE), -Infinity or Infinity is returned.ExamplesUsing parseFloat()The following examples all return 3.14:
jsparseFloat(3.14);
parseFloat("3.14");
parseFloat("  3.14  ");
parseFloat("314e-2");
parseFloat("0.0314E+2");
parseFloat("3.14some non-digit characters");
parseFloat({
  toString() {
    return "3.14";
  },
});
parseFloat() returning NaNThe following example returns NaN:
jsparseFloat("FF2");

Anecdotally, because the string NaN itself is invalid syntax as accepted by parseFloat(), passing "NaN" returns NaN as well.
jsparseFloat("NaN"); // NaN
Returning InfinityInfinity values are returned when the number is outside the double-precision 64-bit IEEE 754-2019 format range:
jsparseFloat("1.7976931348623159e+308"); // Infinity
parseFloat("-1.7976931348623159e+308"); // -Infinity

Infinity is also returned when the string starts with "Infinity" or "-Infinity":
jsparseFloat("Infinity"); // Infinity
parseFloat("-Infinity"); // -Infinity
Interaction with BigInt valuesparseFloat() does not handle BigInt values. It stops at the n character, and treats the preceding string as a normal integer, with possible loss of precision. If a BigInt value is passed to parseFloat(), it will be converted to a string, and the string will be parsed as a floating-point number, which may result in loss of precision as well.
jsparseFloat(900719925474099267n); // 900719925474099300
parseFloat("900719925474099267n"); // 900719925474099300

You should pass the string to the BigInt() function instead, without the trailing n character.
jsBigInt("900719925474099267");
// 900719925474099267n
SpecificationsSpecificationECMAScript Language Specification # sec-parsefloat-stringBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
parseInt()
Number.parseFloat()
Number.parseInt()
Number.prototype.toFixed()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
parseInt()The parseInt() function parses a string argument and returns an integer of the specified radix (the base in mathematical numeral systems).Try itSyntaxjsparseInt(string)
parseInt(string, radix)
Parameters
string

A string starting with an integer. Leading whitespace in this argument is ignored.

radix Optional

An integer between 2 and 36 that represents the radix (the base in mathematical numeral systems) of the string. It is converted to a 32-bit integer; if it's nonzero and outside the range of [2, 36] after conversion, the function will always return NaN. If 0 or not provided, the radix will be inferred based on string's value. Be careful — this does not always default to 10! The description below explains in more detail what happens when radix is not provided.

Return valueAn integer parsed from the given string, or NaN when

the radix as a 32-bit integer is smaller than 2 or bigger than 36, or
the first non-whitespace character cannot be converted to a number.


Note: JavaScript does not have the distinction of "floating point numbers" and "integers" on the language level. parseInt() and parseFloat() only differ in their parsing behavior, but not necessarily their return values. For example, parseInt("42") and parseFloat("42") would return the same value: a Number 42.
DescriptionThe parseInt function converts its first argument to a string, parses that string, then returns an integer or NaN.
If not NaN, the return value will be the integer that is the first argument taken as a number in the specified radix. (For example, a radix of 10 converts from a decimal number, 8 converts from octal, 16 from hexadecimal, and so on.)
The radix argument is converted to a number. If it's unprovided, or if the value becomes 0, NaN or Infinity (undefined is coerced to NaN), JavaScript assumes the following:

If the input string, with leading whitespace and possible +/- signs removed, begins with 0x or 0X (a zero, followed by lowercase or uppercase X), radix is assumed to be 16 and the rest of the string is parsed as a hexadecimal number.
If the input string begins with any other value, the radix is 10 (decimal).


Note: Other prefixes like 0b, which are valid in number literals, are treated as normal digits by parseInt(). parseInt() does not treat strings beginning with a 0 character as octal values either. The only prefix that parseInt() recognizes is 0x or 0X for hexadecimal values — everything else is parsed as a decimal value if radix is missing. Number() or BigInt() can be used instead to parse these prefixes.

If the radix is 16, parseInt() allows the string to be optionally prefixed by 0x or 0X after the optional sign character (+/-).
If the radix value (coerced if necessary) is not in range [2, 36] (inclusive) parseInt returns NaN.
For radices above 10, letters of the English alphabet indicate numerals greater than 9. For example, for hexadecimal numbers (base 16), A through F are used. The letters are case-insensitive.
parseInt understands exactly two signs: + for positive, and - for negative. It is done as an initial step in the parsing after whitespace is removed. If no signs are found, the algorithm moves to the following step; otherwise, it removes the sign and runs the number-parsing on the rest of the string.
If parseInt encounters a character that is not a numeral in the specified radix, it ignores it and all succeeding characters and returns the integer value parsed up to that point. For example, although 1e3 technically encodes an integer (and will be correctly parsed to the integer 1000 by parseFloat()), parseInt("1e3", 10) returns 1, because e is not a valid numeral in base 10. Because . is not a numeral either, the return value will always be an integer.
If the first character cannot be converted to a number with the radix in use, parseInt returns NaN. Leading whitespace is allowed.
For arithmetic purposes, the NaN value is not a number in any radix. You can call the Number.isNaN function to determine if the result of parseInt is NaN. If NaN is passed on to arithmetic operations, the operation result will also be NaN.
Because large numbers use the e character in their string representation (e.g. 6.022e23 for 6.022 × 1023), using parseInt to truncate numbers will produce unexpected results when used on very large or very small numbers. parseInt should not be used as a substitute for Math.trunc().
To convert a number to its string literal in a particular radix, use thatNumber.toString(radix).
Because parseInt() returns a number, it may suffer from loss of precision if the integer represented by the string is outside the safe range. The BigInt() function supports parsing integers of arbitrary length accurately, by returning a BigInt.ExamplesUsing parseInt()The following examples all return 15:
jsparseInt("0xF", 16);
parseInt("F", 16);
parseInt("17", 8);
parseInt("015", 10); // but `parseInt('015', 8)` will return 13
parseInt("15,123", 10);
parseInt("FXX123", 16);
parseInt("1111", 2);
parseInt("15 * 3", 10);
parseInt("15e2", 10);
parseInt("15px", 10);
parseInt("12", 13);

The following examples all return NaN:
jsparseInt("Hello", 8); // Not a number at all
parseInt("546", 2); // Digits other than 0 or 1 are invalid for binary radix

The following examples all return -15:
jsparseInt("-F", 16);
parseInt("-0F", 16);
parseInt("-0XF", 16);
parseInt("-17", 8);
parseInt("-15", 10);
parseInt("-1111", 2);
parseInt("-15e1", 10);
parseInt("-12", 13);

The following example returns 224:
jsparseInt("0e0", 16);

parseInt() does not handle BigInt values. It stops at the n character, and treats the preceding string as a normal integer, with possible loss of precision.
jsparseInt("900719925474099267n");
// 900719925474099300

You should pass the string to the BigInt() function instead, without the trailing n character.
jsBigInt("900719925474099267");
// 900719925474099267n

parseInt doesn't work with numeric separators:
jsparseInt("123_456"); // 123
Using parseInt() on non-stringsparseInt() can have interesting results when working on non-strings combined with a high radix; for example, 36 (which makes all alphanumeric characters valid numeric digits).
jsparseInt(null, 36); // 1112745: The string "null" is 1112745 in base 36
parseInt(undefined, 36); // 86464843759093: The string "undefined" is 86464843759093 in base 36

In general, it's a bad idea to use parseInt() on non-strings, especially to use it as a substitution for Math.trunc(). It may work on small numbers:
jsparseInt(15.99, 10); // 15
parseInt(-15.1, 10); // -15

However, it only happens to work because the string representation of these numbers uses basic fractional notation ("15.99", "-15.1"), where parseInt() stops at the decimal point. Numbers greater than or equal to 1e+21 or less than or equal to 1e-7 use exponential notation ("1.5e+22", "1.51e-8") in their string representation, and parseInt() will stop at the e character or decimal point, which always comes after the first digit. This means for large and small numbers, parseInt() will return a one-digit integer:
jsparseInt(4.7 * 1e22, 10); // Very large number becomes 4
parseInt(0.00000000000434, 10); // Very small number becomes 4

parseInt(0.0000001, 10); // 1
parseInt(0.000000123, 10); // 1
parseInt(1e-7, 10); // 1
parseInt(1000000000000000000000, 10); // 1
parseInt(123000000000000000000000, 10); // 1
parseInt(1e21, 10); // 1
SpecificationsSpecificationECMAScript Language Specification # sec-parseint-string-radixBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
parseFloat()
Number() constructor
Number.parseFloat()
Number.parseInt()
isNaN()
Number.prototype.toString()
Object.prototype.valueOf()
BigInt() constructor
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 29, 2023 by MDN contributors.
PromiseThe Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
To learn about the way promises work and how you can use them, we advise you to read Using promises first.DescriptionA Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.
A Promise is in one of these states:

pending: initial state, neither fulfilled nor rejected.
fulfilled: meaning that the operation was completed successfully.
rejected: meaning that the operation failed.


  The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error).
  When either of these options occur, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.

A promise is said to be settled if it is either fulfilled or rejected, but not pending.



You will also hear the term resolved used with promises — this means that the promise is settled or "locked-in" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, "resolved" promises are often equivalent to "fulfilled" promises, but as illustrated in "States and fates", resolved promises can be pending or rejected as well. For example:
jsnew Promise((resolveOuter) => {
  resolveOuter(
    new Promise((resolveInner) => {
      setTimeout(resolveInner, 1000);
    }),
  );
});

This promise is already resolved at the time when it's created (because the resolveOuter is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the "resolution" is often done behind the scenes and not observable, and only its fulfillment or rejection are.

Note: Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call "promises", e.g. Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g. f = () => expression to create the lazily-evaluated expression, and f() to evaluate the expression immediately.
Chained PromisesThe methods Promise.prototype.then(), Promise.prototype.catch(), and Promise.prototype.finally() are used to associate further action with a promise that becomes settled. As these methods return promises, they can be chained.
The .then() method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. Each .then() returns a newly generated promise object, which can optionally be used for chaining; for example:
jsconst myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);

Processing continues to the next link of the chain even when a .then() lacks a callback function. Therefore, a chain can safely omit every rejection callback function until the final .catch().
Handling a rejected promise in each .then() has consequences further down the promise chain. Sometimes there is no choice, because an error must be handled immediately. In such cases we must throw an error of some type to maintain error state down the chain. On the other hand, in the absence of an immediate need, it is simpler to leave out error handling until a final .catch() statement. A .catch() is really just a .then() without a slot for a callback function for the case when the promise is fulfilled.
jsmyPromise
  .then(handleFulfilledA)
  .then(handleFulfilledB)
  .then(handleFulfilledC)
  .catch(handleRejectedAny);

Using arrow functions for the callback functions, implementation of the promise chain might look something like this:
jsmyPromise
  .then((value) => `${value} and bar`)
  .then((value) => `${value} and bar again`)
  .then((value) => `${value} and again`)
  .then((value) => `${value} and again`)
  .then((value) => {
    console.log(value);
  })
  .catch((err) => {
    console.error(err);
  });


Note: For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence.

The termination condition of a promise determines the "settled" state of the next promise in the chain. A "fulfilled" state indicates a successful completion of the promise, while a "rejected" state indicates a lack of success. The return value of each fulfilled promise in the chain is passed along to the next .then(), while the reason for rejection is passed along to the next rejection-handler function in the chain.
The promises of a chain are nested in one another, but get popped like the top of a stack. The first promise in the chain is most deeply nested and is the first to pop.
(promise D, (promise C, (promise B, (promise A) ) ) )

When a nextValue is a promise, the effect is a dynamic replacement. The return causes a promise to be popped, but the nextValue promise is pushed into its place. For the nesting shown above, suppose the .then() associated with "promise B" returns a nextValue of "promise X". The resulting nesting would look like this:
(promise D, (promise C, (promise X) ) )

A promise can participate in more than one nesting. For the following code, the transition of promiseA into a "settled" state will cause both instances of .then() to be invoked.
jsconst promiseA = new Promise(myExecutorFunc);
const promiseB = promiseA.then(handleFulfilled1, handleRejected1);
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);

An action can be assigned to an already "settled" promise. In that case, the action (if appropriate) will be performed at the first asynchronous opportunity. Note that promises are guaranteed to be asynchronous. Therefore, an action for an already "settled" promise will occur only after the stack has cleared and a clock-tick has passed. The effect is much like that of setTimeout(action, 0).
jsconst promiseA = new Promise((resolve, reject) => {
  resolve(777);
});
// At this point, "promiseA" is already settled.
promiseA.then((val) => console.log("asynchronous logging has val:", val));
console.log("immediate logging");

// produces output in this order:
// immediate logging
// asynchronous logging has val: 777
ThenablesThe JavaScript ecosystem had made multiple Promise implementations long before it became part of the language. Despite being represented differently internally, at the minimum, all Promise-like objects implement the Thenable interface. A thenable implements the .then() method, which is called with two callbacks: one for when the promise is fulfilled, one for when it's rejected. Promises are thenables as well.
To interoperate with the existing Promise implementations, the language allows using thenables in place of promises. For example, Promise.resolve will not only resolve promises, but also trace thenables.
jsconst aThenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      // The thenable is fulfilled with another thenable
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};

Promise.resolve(aThenable); // A promise fulfilled with 42
Promise concurrencyThe Promise class offers four static methods to facilitate async task concurrency:

Promise.all()

Fulfills when all of the promises fulfill; rejects when any of the promises rejects.

Promise.allSettled()

Fulfills when all promises settle.

Promise.any()

Fulfills when any of the promises fulfills; rejects when all of the promises reject.

Promise.race()

Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects.


All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor — accepting a single executor function that can be called with the resolve and reject callbacks as parameters. The subclass must also have a resolve static method that can be called like Promise.resolve() to resolve values to promises.
Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads.Constructor
Promise()

Creates a new Promise object. The constructor is primarily used to wrap functions that do not already support promises.

Static properties
Promise[@@species]

Returns the constructor used to construct return values from promise methods.

Static methods
Promise.all()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises reject, with this first rejection reason.

Promise.allSettled()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises settle (including when an empty iterable is passed), with an array of objects that describe the outcome of each promise.

Promise.any()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when any of the input's promises fulfill, with this first fulfillment value. It rejects when all of the input's promises reject (including when an empty iterable is passed), with an AggregateError containing an array of rejection reasons.

Promise.race()

Takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.

Promise.reject()

Returns a new Promise object that is rejected with the given reason.

Promise.resolve()

Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e. has a then method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value.

Promise.withResolvers()

Returns an object containing a new Promise object and two functions to resolve or reject it, corresponding to the two parameters passed to the executor of the Promise() constructor.

Instance propertiesThese properties are defined on Promise.prototype and shared by all Promise instances.

Promise.prototype.constructor

The constructor function that created the instance object. For Promise instances, the initial value is the Promise constructor.

Promise.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "Promise". This property is used in Object.prototype.toString().

Instance methods
Promise.prototype.catch()

Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.

Promise.prototype.finally()

Appends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected.

Promise.prototype.then()

Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e. if the relevant handler onFulfilled or onRejected is not a function).

ExamplesBasic Examplejsconst myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.
  // In this example, we use setTimeout(...) to simulate async code.
  // In reality, you will probably be using something like XHR or an HTML API.
  setTimeout(() => {
    resolve("Success!"); // Yay! Everything went well!
  }, 250);
});

myFirstPromise.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log(`Yay! ${successMessage}`);
});
Example with diverse situationsThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of .then() calls, and typically (but not necessarily) has a single .catch() at the end, optionally followed by .finally(). In this example, the promise chain is initiated by a custom-written new Promise() construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise.
The example function tetheredGetNumber() shows that a promise generator will utilize reject() while setting up an asynchronous call, or within the call-back, or both. The function promiseGetWord() illustrates how an API function might generate and return a promise in a self-contained manner.
Note that the function troubleWithGetNumber() ends with a throw. That is forced because a promise chain goes through all the .then() promises, even after an error, and without the throw, the error would seem "fixed". This is a hassle, and for this reason, it is common to omit onRejected throughout the chain of .then() promises, and just have a single onRejected in the final catch().
This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the threshold values.
js// To experiment with error handling, "threshold" values cause errors randomly
const THRESHOLD_A = 8; // can use zero 0 to guarantee error

function tetheredGetNumber(resolve, reject) {
  setTimeout(() => {
    const randomInt = Date.now();
    const value = randomInt % 10;
    if (value < THRESHOLD_A) {
      resolve(value);
    } else {
      reject(`Too large: ${value}`);
    }
  }, 500);
}

function determineParity(value) {
  const isOdd = value % 2 === 1;
  return { value, isOdd };
}

function troubleWithGetNumber(reason) {
  const err = new Error("Trouble getting number", { cause: reason });
  console.error(err);
  throw err;
}

function promiseGetWord(parityInfo) {
  return new Promise((resolve, reject) => {
    const { value, isOdd } = parityInfo;
    if (value >= THRESHOLD_A - 1) {
      reject(`Still too large: ${value}`);
    } else {
      parityInfo.wordEvenOdd = isOdd ? "odd" : "even";
      resolve(parityInfo);
    }
  });
}

new Promise(tetheredGetNumber)
  .then(determineParity, troubleWithGetNumber)
  .then(promiseGetWord)
  .then((info) => {
    console.log(`Got: ${info.value}, ${info.wordEvenOdd}`);
    return info;
  })
  .catch((reason) => {
    if (reason.cause) {
      console.error("Had previously handled error");
    } else {
      console.error(`Trouble with promiseGetWord(): ${reason}`);
    }
  })
  .finally((info) => console.log("All done"));
Advanced ExampleThis small example shows the mechanism of a Promise. The testPromise() method is called each time the <button> is clicked. It creates a promise that will be fulfilled, using setTimeout(), to the promise count (number starting from 1) every 1-3 seconds, at random. The Promise() constructor is used to create the promise.
The fulfillment of the promise is logged, via a fulfill callback set using p1.then(). A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise.
By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another.
HTML
html<button id="make-promise">Make a promise!</button>
<div id="log"></div>

JavaScript
js"use strict";

let promiseCount = 0;

function testPromise() {
  const thisPromiseCount = ++promiseCount;
  const log = document.getElementById("log");
  // begin
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Started<br>`);
  // We make a new promise: we promise a numeric count of this promise,
  // starting from 1 (after waiting 3s)
  const p1 = new Promise((resolve, reject) => {
    // The executor function is called with the ability
    // to resolve or reject the promise
    log.insertAdjacentHTML(
      "beforeend",
      `${thisPromiseCount}) Promise constructor<br>`,
    );
    // This is only an example to create asynchronism
    setTimeout(
      () => {
        // We fulfill the promise
        resolve(thisPromiseCount);
      },
      Math.random() * 2000 + 1000,
    );
  });

  // We define what to do when the promise is resolved with the then() call,
  // and what to do when the promise is rejected with the catch() call
  p1.then((val) => {
    // Log the fulfillment value
    log.insertAdjacentHTML("beforeend", `${val}) Promise fulfilled<br>`);
  }).catch((reason) => {
    // Log the rejection reason
    console.log(`Handle rejected promise (${reason}) here.`);
  });
  // end
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Promise made<br>`);
}

const btn = document.getElementById("make-promise");
btn.addEventListener("click", testPromise);

ResultLoading an image with XHRAnother simple example using Promise and XMLHttpRequest to load an image is available at the MDN GitHub js-examples repository. You can also see it in action. Each step is commented on and allows you to follow the Promise and XHR architecture closely.Incumbent settings object trackingA settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code.
To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like Array and Error. Each settings object has its own "copy" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call.
To illustrate this a bit further we can take a look at how an <iframe> embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built-in function — there is no user
  // code on the stack, so which realm do we use?
  setTimeout(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

The same concept applies to promises. If we modify the above example a little bit, we get this:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built in function — there is no user
  // code on the stack — which realm do we use?
  Promise.resolve(undefined).then(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

If we change this so that the <iframe> in the document is listening to post messages, we can observe the effect of the incumbent settings object:
html<!-- y.html -->
<!doctype html>
<iframe src="x.html"></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  Promise.resolve(undefined).then(bound);
</script>

html<!-- x.html -->
<!doctype html>
<script>
  window.addEventListener(
    "message",
    (event) => {
      document.querySelector("#text").textContent = "hello";
      // this code will only run in browsers that track the incumbent settings object
      console.log(event);
    },
    false,
  );
</script>

In the above example, the inner text of the <iframe> will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message.

Note: Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari.
SpecificationsSpecificationECMAScript Language Specification # sec-promise-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Promise in core-js
Using promises guide
Promises/A+ specification
JavaScript Promises: an introduction on web.dev (2013)
Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript slide show by Domenic Denicola (2011)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 29, 2023 by MDN contributors.
ProxyThe Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.DescriptionThe Proxy object allows you to create an object that can be used in place of the original object, but which may redefine fundamental Object operations like getting, setting, and defining properties. Proxy objects are commonly used to log property accesses, validate, format, or sanitize inputs, and so on.
You create a Proxy with two parameters:

target: the original object which you want to proxy
handler: an object that defines which operations will be intercepted and how to redefine intercepted operations.

For example, this code creates a proxy for the target object.
jsconst target = {
  message1: "hello",
  message2: "everyone",
};

const handler1 = {};

const proxy1 = new Proxy(target, handler1);

Because the handler is empty, this proxy behaves just like the original target:
jsconsole.log(proxy1.message1); // hello
console.log(proxy1.message2); // everyone

To customize the proxy, we define functions on the handler object:
jsconst target = {
  message1: "hello",
  message2: "everyone",
};

const handler2 = {
  get(target, prop, receiver) {
    return "world";
  },
};

const proxy2 = new Proxy(target, handler2);

Here we've provided an implementation of the get() handler, which intercepts attempts to access properties in the target.
Handler functions are sometimes called traps, presumably because they trap calls to the target object. The very simple trap in handler2 above redefines all property accessors:
jsconsole.log(proxy2.message1); // world
console.log(proxy2.message2); // world

Proxies are often used with the Reflect object, which provides some methods with the same names as the Proxy traps. The Reflect methods provide the reflective semantics for invoking the corresponding object internal methods. For example, we can call Reflect.get if we don't wish to redefine the object's behavior:
jsconst target = {
  message1: "hello",
  message2: "everyone",
};

const handler3 = {
  get(target, prop, receiver) {
    if (prop === "message2") {
      return "world";
    }
    return Reflect.get(...arguments);
  },
};

const proxy3 = new Proxy(target, handler3);

console.log(proxy3.message1); // hello
console.log(proxy3.message2); // world

The Reflect method still interacts with the object through object internal methods — it doesn't "de-proxify" the proxy if it's invoked on a proxy. If you use Reflect methods within a proxy trap, and the Reflect method call gets intercepted by the trap again, there may be infinite recursion.TerminologyThe following terms are used when talking about the functionality of proxies.

handler

The object passed as the second argument to the Proxy constructor. It contains the traps which define the behavior of the proxy.

trap

The function that define the behavior for the corresponding object internal method. (This is analogous to the concept of traps in operating systems.)

target

Object which the proxy virtualizes. It is often used as storage backend for the proxy. Invariants (semantics that remain unchanged) regarding object non-extensibility or non-configurable properties are verified against the target.

invariants

Semantics that remain unchanged when implementing custom operations. If your trap implementation violates the invariants of a handler, a TypeError will be thrown.

Object internal methodsObjects are collections of properties. However, the language doesn't provide any machinery to directly manipulate data stored in the object — rather, the object defines some internal methods specifying how it can be interacted with. For example, when you read obj.x, you may expect the following to happen:

The x property is searched up the prototype chain until it is found.
If x is a data property, the property descriptor's value attribute is returned.
If x is an accessor property, the getter is invoked, and the return value of the getter is returned.

There isn't anything special about this process in the language — it's just because ordinary objects, by default, have a [[Get]] internal method that is defined with this behavior. The obj.x property access syntax simply invokes the [[Get]] method on the object, and the object uses its own internal method implementation to determine what to return.
As another example, arrays differ from normal objects, because they have a magic length property that, when modified, automatically allocates empty slots or removes elements from the array. Similarly, adding array elements automatically changes the length property. This is because arrays have a [[DefineOwnProperty]] internal method that knows to update length when an integer index is written to, or update the array contents when length is written to. Such objects whose internal methods have different implementations from ordinary objects are called exotic objects. Proxy enable developers to define their own exotic objects with full capacity.
All objects have the following internal methods:



Internal method
Corresponding trap




[[GetPrototypeOf]]
getPrototypeOf()


[[SetPrototypeOf]]
setPrototypeOf()


[[IsExtensible]]
isExtensible()


[[PreventExtensions]]
preventExtensions()


[[GetOwnProperty]]
getOwnPropertyDescriptor()


[[DefineOwnProperty]]
defineProperty()


[[HasProperty]]
has()


[[Get]]
get()


[[Set]]
set()


[[Delete]]
deleteProperty()


[[OwnPropertyKeys]]
ownKeys()



Function objects also have the following internal methods:



Internal method
Corresponding trap




[[Call]]
apply()


[[Construct]]
construct()



It's important to realize that all interactions with an object eventually boils down to the invocation of one of these internal methods, and that they are all customizable through proxies. This means almost no behavior (except certain critical invariants) is guaranteed in the language — everything is defined by the object itself. When you run delete obj.x, there's no guarantee that "x" in obj returns false afterwards — it depends on the object's implementations of [[Delete]] and [[HasProperty]]. A delete obj.x may log things to the console, modify some global state, or even define a new property instead of deleting the existing one, although these semantics should be avoided in your own code.
All internal methods are called by the language itself, and are not directly accessible in JavaScript code. The Reflect namespace offers methods that do little more than call the internal methods, besides some input normalization/validation. In each trap's page, we list several typical situations when the trap is invoked, but these internal methods are called in a lot of places. For example, array methods read and write to array through these internal methods, so methods like push() would also invoke get() and set() traps.
Most of the internal methods are straightforward in what they do. The only two that may be confusable are [[Set]] and [[DefineOwnProperty]]. For normal objects, the former invokes setters; the latter doesn't. (And [[Set]] calls [[DefineOwnProperty]] internally if there's no existing property or the property is a data property.) While you may know that the obj.x = 1 syntax uses [[Set]], and Object.defineProperty() uses [[DefineOwnProperty]], it's not immediately apparent what semantics other built-in methods and syntaxes use. For example, class fields use the [[DefineOwnProperty]] semantic, which is why setters defined in the superclass are not invoked when a field is declared on the derived class.Constructor
Proxy()

Creates a new Proxy object.



Note: There's no Proxy.prototype property, so Proxy instances do not have any special properties or methods.
Static methods
Proxy.revocable()

Creates a revocable Proxy object.

ExamplesBasic exampleIn this simple example, the number 37 gets returned as the default value when the property name is not in the object. It is using the get() handler.
jsconst handler = {
  get(obj, prop) {
    return prop in obj ? obj[prop] : 37;
  },
};

const p = new Proxy({}, handler);
p.a = 1;
p.b = undefined;

console.log(p.a, p.b); // 1, undefined

console.log("c" in p, p.c); // false, 37
No-op forwarding proxyIn this example, we are using a native JavaScript object to which our proxy will forward all operations that are applied to it.
jsconst target = {};
const p = new Proxy(target, {});

p.a = 37; // Operation forwarded to the target

console.log(target.a); // 37 (The operation has been properly forwarded!)

Note that while this "no-op" works for plain JavaScript objects, it does not work for native objects, such as DOM elements, Map objects, or anything that has internal slots. See no private property forwarding for more information.No private property forwardingA proxy is still another object with a different identity — it's a proxy that operates between the wrapped object and the outside. As such, the proxy does not have direct access to the original object's private properties.
jsclass Secret {
  #secret;
  constructor(secret) {
    this.#secret = secret;
  }
  get secret() {
    return this.#secret.replace(/\d+/, "[REDACTED]");
  }
}

const aSecret = new Secret("123456");
console.log(aSecret.secret); // [REDACTED]
// Looks like a no-op forwarding...
const proxy = new Proxy(aSecret, {});
console.log(proxy.secret); // TypeError: Cannot read private member #secret from an object whose class did not declare it

This is because when the proxy's get trap is invoked, the this value is the proxy instead of the original secret, so #secret is not accessible. To fix this, use the original secret as this:
jsconst proxy = new Proxy(aSecret, {
  get(target, prop, receiver) {
    // By default, it looks like Reflect.get(target, prop, receiver)
    // which has a different value of `this`
    return target[prop];
  },
});
console.log(proxy.secret);

For methods, this means you have to redirect the method's this value to the original object as well:
jsclass Secret {
  #x = 1;
  x() {
    return this.#x;
  }
}

const aSecret = new Secret();
const proxy = new Proxy(aSecret, {
  get(target, prop, receiver) {
    const value = target[prop];
    if (value instanceof Function) {
      return function (...args) {
        return value.apply(this === receiver ? target : this, args);
      };
    }
    return value;
  },
});
console.log(proxy.x());

Some native JavaScript objects have properties called internal slots, which are not accessible from JavaScript code. For example, Map objects have an internal slot called [[MapData]], which stores the key-value pairs of the map. As such, you cannot trivially create a forwarding proxy for a map:
jsconst proxy = new Proxy(new Map(), {});
console.log(proxy.size); // TypeError: get size method called on incompatible Proxy

You have to use the "this-recovering" proxy illustrated above to work around this.ValidationWith a Proxy, you can easily validate the passed value for an object. This example uses the set() handler.
jsconst validator = {
  set(obj, prop, value) {
    if (prop === "age") {
      if (!Number.isInteger(value)) {
        throw new TypeError("The age is not an integer");
      }
      if (value > 200) {
        throw new RangeError("The age seems invalid");
      }
    }

    // The default behavior to store the value
    obj[prop] = value;

    // Indicate success
    return true;
  },
};

const person = new Proxy({}, validator);

person.age = 100;
console.log(person.age); // 100
person.age = "young"; // Throws an exception
person.age = 300; // Throws an exception
Manipulating DOM nodesIn this example we use Proxy to toggle an attribute of two different elements: so when we set the attribute on one element, the attribute is unset on the other one.
We create a view object which is a proxy for an object with a selected property. The proxy handler defines the set() handler.
When we assign an HTML element to view.selected, the element's 'aria-selected' attribute is set to true. If we then assign a different element to view.selected, this element's 'aria-selected' attribute is set to true and the previous element's 'aria-selected' attribute is automatically set to false.
jsconst view = new Proxy(
  {
    selected: null,
  },
  {
    set(obj, prop, newval) {
      const oldval = obj[prop];

      if (prop === "selected") {
        if (oldval) {
          oldval.setAttribute("aria-selected", "false");
        }
        if (newval) {
          newval.setAttribute("aria-selected", "true");
        }
      }

      // The default behavior to store the value
      obj[prop] = newval;

      // Indicate success
      return true;
    },
  },
);

const item1 = document.getElementById("item-1");
const item2 = document.getElementById("item-2");

// select item1:
view.selected = item1;

console.log(`item1: ${item1.getAttribute("aria-selected")}`);
// item1: true

// selecting item2 de-selects item1:
view.selected = item2;

console.log(`item1: ${item1.getAttribute("aria-selected")}`);
// item1: false

console.log(`item2: ${item2.getAttribute("aria-selected")}`);
// item2: true
Value correction and an extra propertyThe products proxy object evaluates the passed value and converts it to an array if needed. The object also supports an extra property called latestBrowser both as a getter and a setter.
jsconst products = new Proxy(
  {
    browsers: ["Firefox", "Chrome"],
  },
  {
    get(obj, prop) {
      // An extra property
      if (prop === "latestBrowser") {
        return obj.browsers[obj.browsers.length - 1];
      }

      // The default behavior to return the value
      return obj[prop];
    },
    set(obj, prop, value) {
      // An extra property
      if (prop === "latestBrowser") {
        obj.browsers.push(value);
        return true;
      }

      // Convert the value if it is not an array
      if (typeof value === "string") {
        value = [value];
      }

      // The default behavior to store the value
      obj[prop] = value;

      // Indicate success
      return true;
    },
  },
);

console.log(products.browsers);
//  ['Firefox', 'Chrome']

products.browsers = "Safari";
//  pass a string (by mistake)

console.log(products.browsers);
//  ['Safari'] <- no problem, the value is an array

products.latestBrowser = "Edge";

console.log(products.browsers);
//  ['Safari', 'Edge']

console.log(products.latestBrowser);
//  'Edge'
A complete traps list exampleNow in order to create a complete sample traps list, for didactic purposes, we will try to proxify a non-native object that is particularly suited to this type of operation: the docCookies global object created by a simple cookie framework.
js/*
  const docCookies = ... get the "docCookies" object here:
  https://reference.codeproject.com/dom/document/cookie/simple_document.cookie_framework
*/

const docCookies = new Proxy(docCookies, {
  get(target, key) {
    return target[key] ?? target.getItem(key) ?? undefined;
  },
  set(target, key, value) {
    if (key in target) {
      return false;
    }
    return target.setItem(key, value);
  },
  deleteProperty(target, key) {
    if (!(key in target)) {
      return false;
    }
    return target.removeItem(key);
  },
  ownKeys(target) {
    return target.keys();
  },
  has(target, key) {
    return key in target || target.hasItem(key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor && "value" in descriptor) {
      target.setItem(key, descriptor.value);
    }
    return target;
  },
  getOwnPropertyDescriptor(target, key) {
    const value = target.getItem(key);
    return value
      ? {
          value,
          writable: true,
          enumerable: true,
          configurable: false,
        }
      : undefined;
  },
});

/* Cookies test */

console.log((docCookies.myCookie1 = "First value"));
console.log(docCookies.getItem("myCookie1"));

docCookies.setItem("myCookie1", "Changed value");
console.log(docCookies.myCookie1);
SpecificationsSpecificationECMAScript Language Specification # sec-proxy-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Proxies are awesome presentation by Brendan Eich at JSConf (2014)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
RangeErrorThe RangeError object indicates an error when a value is not in the set or range of allowed values.DescriptionA RangeError is thrown when trying to pass a value as an argument to a function that does not allow a range that includes the value.
This can be encountered when:

passing a value that is not one of the allowed string values to String.prototype.normalize(), or
when attempting to create an array of an illegal length with the Array constructor, or
when passing bad values to the numeric methods Number.prototype.toExponential(), Number.prototype.toFixed() or Number.prototype.toPrecision().

RangeError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
RangeError is a subclass of Error.Constructor
RangeError()

Creates a new RangeError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on RangeError.prototype and shared by all RangeError instances.

RangeError.prototype.constructor

The constructor function that created the instance object. For RangeError instances, the initial value is the RangeError constructor.

RangeError.prototype.name

Represents the name for the type of error. For RangeError.prototype.name, the initial value is "RangeError".

Instance methodsInherits instance methods from its parent Error.ExamplesUsing RangeError (for numeric values)jsfunction check(n) {
  if (!(n >= -500 && n <= 500)) {
    throw new RangeError("The argument must be between -500 and 500.");
  }
}

try {
  check(2000);
} catch (error) {
  if (error instanceof RangeError) {
    // Handle the error
  }
}
Using RangeError (for non-numeric values)jsfunction check(value) {
  if (!["apple", "banana", "carrot"].includes(value)) {
    throw new RangeError(
      'The argument must be an "apple", "banana", or "carrot".',
    );
  }
}

try {
  check("cabbage");
} catch (error) {
  if (error instanceof RangeError) {
    // Handle the error
  }
}
SpecificationsSpecificationECMAScript Language Specification # sec-native-error-types-used-in-this-standard-rangeerrorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
Array
Number.prototype.toExponential()
Number.prototype.toFixed()
Number.prototype.toPrecision()
String.prototype.normalize()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 21, 2023 by MDN contributors.
ReferenceErrorThe ReferenceError object represents an error when a variable that doesn't exist (or hasn't yet been initialized) in the current scope is referenced.
ReferenceError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
ReferenceError is a subclass of Error.Constructor
ReferenceError()

Creates a new ReferenceError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on ReferenceError.prototype and shared by all ReferenceError instances.

ReferenceError.prototype.constructor

The constructor function that created the instance object. For ReferenceError instances, the initial value is the ReferenceError constructor.

ReferenceError.prototype.name

Represents the name for the type of error. For ReferenceError.prototype.name, the initial value is "ReferenceError".

Instance methodsInherits instance methods from its parent Error.ExamplesCatching a ReferenceErrorjstry {
  let a = undefinedVariable;
} catch (e) {
  console.log(e instanceof ReferenceError); // true
  console.log(e.message); // "undefinedVariable is not defined"
  console.log(e.name); // "ReferenceError"
  console.log(e.stack); // Stack of the error
}
Creating a ReferenceErrorjstry {
  throw new ReferenceError("Hello");
} catch (e) {
  console.log(e instanceof ReferenceError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "ReferenceError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript Language Specification # sec-native-error-types-used-in-this-standard-referenceerrorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on May 26, 2023 by MDN contributors.
ReflectThe Reflect namespace object contains static methods for invoking interceptable JavaScript object internal methods. The methods are the same as those of proxy handlers.DescriptionUnlike most global objects, Reflect is not a constructor. You cannot use it with the new operator or invoke the Reflect object as a function. All properties and methods of Reflect are static (just like the Math object).
The Reflect object provides a collection of static functions which have the same names as the proxy handler methods.
The major use case of Reflect is to provide default forwarding behavior in Proxy handler traps. A trap is used to intercept an operation on an object — it provides a custom implementation for an object internal method. The Reflect API is used to invoke the corresponding internal method. For example, the code below creates a proxy p with a deleteProperty trap that intercepts the [[Delete]] internal method. Reflect.deleteProperty() is used to invoke the default [[Delete]] behavior on targetObject directly. You can replace it with delete, but using Reflect saves you from having to remember the syntax that each internal method corresponds to.
jsconst p = new Proxy(
  {},
  {
    deleteProperty(targetObject, property) {
      // Custom functionality: log the deletion
      console.log("Deleting property:", property);

      // Execute the default introspection behavior
      return Reflect.deleteProperty(targetObject, property);
    },
  },
);

The Reflect methods also allow finer control of how the internal method is invoked. For example, Reflect.construct() is the only way to construct a target function with a specific new.target value. If you use the new operator to invoke a function, the new.target value is always the function itself. This has important effects with subclassing. For another example, Reflect.get() allows you to run a getter with a custom this value, while property accessors always use the current object as the this value.
Nearly every Reflect method's behavior can be done with some other syntax or method. Some of these methods have corresponding static methods of the same name on Object, although they do have some subtle differences. For the exact differences, see the description for each Reflect method.Static properties
Reflect[@@toStringTag]

The initial value of the @@toStringTag property is the string "Reflect". This property is used in Object.prototype.toString().

Static methods
Reflect.apply()

Calls a target function with arguments as specified by the argumentsList parameter. See also Function.prototype.apply().

Reflect.construct()

The new operator as a function. Equivalent to calling new target(...argumentsList). Also provides the option to specify a different prototype.

Reflect.defineProperty()

Similar to Object.defineProperty(). Returns a boolean that is true if the property was successfully defined.

Reflect.deleteProperty()

The delete operator as a function. Equivalent to calling delete target[propertyKey].

Reflect.get()

Returns the value of the property. Works like getting a property from an object (target[propertyKey]) as a function.

Reflect.getOwnPropertyDescriptor()

Similar to Object.getOwnPropertyDescriptor(). Returns a property descriptor of the given property if it exists on the object, undefined otherwise.

Reflect.getPrototypeOf()

Same as Object.getPrototypeOf().

Reflect.has()

Returns a boolean indicating whether the target has the property. Either as own or inherited. Works like the in operator as a function.

Reflect.isExtensible()

Same as Object.isExtensible(). Returns a boolean that is true if the target is extensible.

Reflect.ownKeys()

Returns an array of the target object's own (not inherited) property keys.

Reflect.preventExtensions()

Similar to Object.preventExtensions(). Returns a boolean that is true if the update was successful.

Reflect.set()

A function that assigns values to properties. Returns a boolean that is true if the update was successful.

Reflect.setPrototypeOf()

A function that sets the prototype of an object. Returns a boolean that is true if the update was successful.

ExamplesDetecting whether an object contains certain propertiesjsconst duck = {
  name: "Maurice",
  color: "white",
  greeting() {
    console.log(`Quaaaack! My name is ${this.name}`);
  },
};

Reflect.has(duck, "color");
// true
Reflect.has(duck, "haircut");
// false
Returning the object's own keysjsReflect.ownKeys(duck);
// [ "name", "color", "greeting" ]
Adding a new property to the objectjsReflect.set(duck, "eyes", "black");
// returns "true" if successful
// "duck" now contains the property "eyes: 'black'"
SpecificationsSpecificationECMAScript Language Specification # sec-reflect-objectBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Proxy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 21, 2023 by MDN contributors.
RegExpThe RegExp object is used for matching text with a pattern.
For an introduction to regular expressions, read the Regular expressions chapter in the JavaScript guide. For detailed information of regular expression syntax, read the regular expression reference.DescriptionLiteral notation and constructorThere are two ways to create a RegExp object: a literal notation and a constructor.

The literal notation takes a pattern between two slashes, followed by optional flags, after the second slash.
The constructor function takes either a string or a RegExp object as its first parameter and a string of optional flags as its second parameter.

The following three expressions create the same regular expression object:
jsconst re = /ab+c/i; // literal notation
// OR
const re = new RegExp("ab+c", "i"); // constructor with string pattern as first argument
// OR
const re = new RegExp(/ab+c/, "i"); // constructor with regular expression literal as first argument

Before regular expressions can be used, they have to be compiled. This process allows them to perform matches more efficiently. More about the process can be found in dotnet docs.
The literal notation results in compilation of the regular expression when the expression is evaluated. On the other hand, the constructor of the RegExp object, new RegExp('ab+c'), results in runtime compilation of the regular expression.
Use a string as the first argument to the RegExp() constructor when you want to build the regular expression from dynamic input.Flags in constructorThe expression new RegExp(/ab+c/, flags) will create a new RegExp using the source of the first parameter and the flags provided by the second.
When using the constructor function, the normal string escape rules (preceding special characters with \ when included in a string) are necessary.
For example, the following are equivalent:
jsconst re = /\w+/;
// OR
const re = new RegExp("\\w+");
Special handling for regexes
Note: Whether something is a "regex" can be duck-typed. It doesn't have to be a RegExp!

Some built-in methods would treat regexes specially. They decide whether x is a regex through multiple steps:

x must be an object (not a primitive).
If x[Symbol.match] is not undefined, check if it's truthy.
Otherwise, if x[Symbol.match] is undefined, check if x had been created with the RegExp constructor. (This step should rarely happen, since if x is a RegExp object that have not been tampered with, it should have a Symbol.match property.)

Note that in most cases, it would go through the Symbol.match check, which means:

An actual RegExp object whose Symbol.match property's value is falsy but not undefined (even with everything else intact, like exec and @@replace) can be used as if it's not a regex.
A non-RegExp object with a Symbol.match property will be treated as if it's a regex.

This choice was made because @@match is the most indicative property that something is intended to be used for matching. (exec could also be used, but because it's not a symbol property, there would be too many false positives.) The places that treat regexes specially include:

String.prototype.endsWith(), startsWith(), and includes() throw a TypeError if the first argument is a regex.
String.prototype.matchAll() and replaceAll() check whether the global flag is set if the first argument is a regex before invoking its @@matchAll or @@replace method.
The RegExp() constructor directly returns the pattern argument only if pattern is a regex (among a few other conditions). If pattern is a regex, it would also interrogate pattern's source and flags properties instead of coercing pattern to a string.

For example, String.prototype.endsWith() would coerce all inputs to strings, but it would throw if the argument is a regex, because it's only designed to match strings, and using a regex is likely a developer mistake.
js"foobar".endsWith({ toString: () => "bar" }); // true
"foobar".endsWith(/bar/); // TypeError: First argument to String.prototype.endsWith must not be a regular expression

You can get around the check by setting @@match to a falsy value that's not undefined. This would mean that the regex cannot be used for String.prototype.match() (since without @@match, match() would construct a new RegExp object with the two enclosing slashes added by re.toString()), but it can be used for virtually everything else.
jsconst re = /bar/g;
re[Symbol.match] = false;
"/bar/g".endsWith(re); // true
re.exec("bar"); // [ 'bar', index: 0, input: 'bar', groups: undefined ]
"bar & bar".replace(re, "foo"); // 'foo & foo'
Perl-like RegExp propertiesNote that several of the RegExp properties have both long and short (Perl-like) names. Both names always refer to the same value. (Perl is the programming language from which JavaScript modeled its regular expressions.) See also deprecated RegExp properties.Constructor
RegExp()

Creates a new RegExp object.

Static properties
RegExp.$1, …, RegExp.$9 
Deprecated


Static read-only properties that contain parenthesized substring matches.

RegExp.input ($_) 
Deprecated


A static property that contains the last string against which a regular expression was successfully matched.

RegExp.lastMatch ($&) 
Deprecated


A static read-only property that contains the last matched substring.

RegExp.lastParen ($+) 
Deprecated


A static read-only property that contains the last parenthesized substring match.

RegExp.leftContext ($`) 
Deprecated


A static read-only property that contains the substring preceding the most recent match.

RegExp.rightContext ($') 
Deprecated


A static read-only property that contains the substring following the most recent match.

RegExp[@@species]

The constructor function that is used to create derived objects.

Instance propertiesThese properties are defined on RegExp.prototype and shared by all RegExp instances.

RegExp.prototype.constructor

The constructor function that created the instance object. For RegExp instances, the initial value is the RegExp constructor.

RegExp.prototype.dotAll

Whether . matches newlines or not.

RegExp.prototype.flags

A string that contains the flags of the RegExp object.

RegExp.prototype.global

Whether to test the regular expression against all possible matches in a string, or only against the first.

RegExp.prototype.hasIndices

Whether the regular expression result exposes the start and end indices of captured substrings.

RegExp.prototype.ignoreCase

Whether to ignore case while attempting a match in a string.

RegExp.prototype.multiline

Whether or not to search in strings across multiple lines.

RegExp.prototype.source

The text of the pattern.

RegExp.prototype.sticky

Whether or not the search is sticky.

RegExp.prototype.unicode

Whether or not Unicode features are enabled.

RegExp.prototype.unicodeSets

Whether or not the v flag, an upgrade to the u mode, is enabled.


These properties are own properties of each RegExp instance.

lastIndex

The index at which to start the next match.

Instance methods
RegExp.prototype.compile() 
Deprecated


(Re-)compiles a regular expression during execution of a script.

RegExp.prototype.exec()

Executes a search for a match in its string parameter.

RegExp.prototype.test()

Tests for a match in its string parameter.

RegExp.prototype.toString()

Returns a string representing the specified object. Overrides the Object.prototype.toString() method.

RegExp.prototype[@@match]()

Performs match to given string and returns match result.

RegExp.prototype[@@matchAll]()

Returns all matches of the regular expression against a string.

RegExp.prototype[@@replace]()

Replaces matches in given string with new substring.

RegExp.prototype[@@search]()

Searches the match in given string and returns the index the pattern found in the string.

RegExp.prototype[@@split]()

Splits given string into an array by separating the string into substrings.

ExamplesUsing a regular expression to change data formatThe following script uses the String.prototype.replace() method to match a name in the format first last and output it in the format last, first.
In the replacement text, the script uses $1 and $2 to indicate the results of the corresponding matching parentheses in the regular expression pattern.
jsconst re = /(\w+)\s(\w+)/;
const str = "Maria Cruz";
const newstr = str.replace(re, "$2, $1");
console.log(newstr);

This displays "Cruz, Maria".Using regular expression to split lines with different line endings/ends of line/line breaksThe default line ending varies depending on the platform (Unix, Windows, etc.). The line splitting provided in this example works on all platforms.
jsconst text = "Some text\nAnd some more\r\nAnd yet\rThis is the end";
const lines = text.split(/\r\n|\r|\n/);
console.log(lines); // [ 'Some text', 'And some more', 'And yet', 'This is the end' ]

Note that the order of the patterns in the regular expression matters.Using regular expression on multiple linesjsconst s = "Please yes\nmake my day!";

s.match(/yes.*day/);
// Returns null

s.match(/yes[^]*day/);
// Returns ["yes\nmake my day"]
Using a regular expression with the sticky flagThe sticky flag indicates that the regular expression performs sticky matching in the target string by attempting to match starting at RegExp.prototype.lastIndex.
jsconst str = "#foo#";
const regex = /foo/y;

regex.lastIndex = 1;
regex.test(str); // true
regex.lastIndex = 5;
regex.test(str); // false (lastIndex is taken into account with sticky flag)
regex.lastIndex; // 0 (reset after match failure)
The difference between the sticky flag and the global flagWith the sticky flag y, the next match has to happen at the lastIndex position, while with the global flag g, the match can happen at the lastIndex position or later:
jsconst re = /\d/y;
let r;
while ((r = re.exec("123 456"))) {
  console.log(r, "AND re.lastIndex", re.lastIndex);
}

// [ '1', index: 0, input: '123 456', groups: undefined ] AND re.lastIndex 1
// [ '2', index: 1, input: '123 456', groups: undefined ] AND re.lastIndex 2
// [ '3', index: 2, input: '123 456', groups: undefined ] AND re.lastIndex 3
//  … and no more match.

With the global flag g, all 6 digits would be matched, not just 3.Regular expression and Unicode characters\w and \W only matches ASCII based characters; for example, a to z, A to Z, 0 to 9, and _.
To match characters from other languages such as Cyrillic or Hebrew, use \uhhhh, where hhhh is the character's Unicode value in hexadecimal.
This example demonstrates how one can separate out Unicode characters from a word.
jsconst text = "Образец text на русском языке";
const regex = /[\u0400-\u04FF]+/g;

const match = regex.exec(text);
console.log(match[0]); // 'Образец'
console.log(regex.lastIndex); // 7

const match2 = regex.exec(text);
console.log(match2[0]); // 'на' (did not log 'text')
console.log(regex.lastIndex); // 15

// and so on

The Unicode property escapes feature provides a simpler way to target particular Unicode ranges, by allowing for statements like \p{scx=Cyrl} (to match any Cyrillic letter), or \p{L}/u (to match a letter from any language).Extracting subdomain name from URLjsconst url = "http://xxx.domain.com";
console.log(/^https?:\/\/(.+?)\./.exec(url)[1]); // 'xxx'


Note: Instead of using regular expressions for parsing URLs, it is usually better to use the browsers built-in URL parser by using the URL API.
Building a regular expression from dynamic inputsjsconst breakfasts = ["bacon", "eggs", "oatmeal", "toast", "cereal"];
const order = "Let me get some bacon and eggs, please";

order.match(new RegExp(`\\b(${breakfasts.join("|")})\\b`, "g"));
// Returns ['bacon', 'eggs']
SpecificationsSpecificationECMAScript Language Specification # sec-regexp-regular-expression-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.Firefox-specific notesStarting with Firefox 34, in the case of a capturing group with quantifiers preventing its exercise, the matched text for a capturing group is now undefined instead of an empty string:
js// Firefox 33 or older
"x".replace(/x(.)?/g, (m, group) => {
  console.log(`group: ${JSON.stringify(group)}`);
});
// group: ""

// Firefox 34 or newer
"x".replace(/x(.)?/g, (m, group) => {
  console.log(`group: ${group}`);
});
// group: undefined

Note that due to web compatibility, RegExp.$N will still return an empty string instead of undefined (bug 1053944).See also
Polyfill of many modern RegExp features (dotAll, sticky flags, named capture groups, etc.) in core-js
Regular expressions guide
Regular expressions
String.prototype.match()
String.prototype.replace()
String.prototype.split()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 23, 2023 by MDN contributors.
SetThe Set object lets you store unique values of any type, whether primitive values or object references.DescriptionSet objects are collections of values. A value in the set may only occur once; it is unique in the set's collection. You can iterate through the elements of a set in insertion order. The insertion order corresponds to the order in which each element was inserted into the set by the add() method successfully (that is, there wasn't an identical element already in the set when add() was called).
The specification requires sets to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Value equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.PerformanceThe has method checks if a value is in the set, using an approach that is, on average, quicker than testing most of the elements that have previously been added to the set. In particular, it is, on average, faster than the Array.prototype.includes method when an array has a length equal to a set's size.Set compositionThe Set object provides some methods that allow you to compose sets like you would with mathematical operations. These methods include:



Method
Return type
Mathematical equivalent
Venn diagram




A.difference(B)
Set




A
∖
B

A\setminus B








A.intersection(B)
Set




A
∩
B

A\cap B








A.symmetricDifference(B)
Set




(
A
∖
B
)
∪
(
B
∖
A
)

(A\setminus B)\cup(B\setminus A)








A.union(B)
Set




A
∪
B

A\cup B








A.isDisjointFrom(B)
Boolean




A
∩
B
=
∅

A\cap B = \empty








A.isSubsetOf(B)
Boolean




A
⊆
B

A\subseteq B








A.isSupersetOf(B)
Boolean




A
⊇
B

A\supseteq B









To make them more generalizable, these methods don't just accept Set objects, but anything that's set-like.Set-like objectsAll set composition methods require this to be an actual Set instance, but their arguments just need to be set-like. A set-like object is an object that provides the following:

A size property that contains a number.
A has() method that takes an element and returns a boolean.
A keys() method that returns an iterator of the elements in the set.

For example, Map objects are set-like because they also have size, has(), and keys(), so they behave just like sets of keys when used in set methods:
jsconst a = new Set([1, 2, 3]);
const b = new Map([
  [1, "one"],
  [2, "two"],
  [4, "four"],
]);
console.log(a.union(b)); // Set(4) {1, 2, 3, 4}


Note: The set-like protocol invokes the keys() method instead of [@@iterator]() to produce elements. This is to make maps valid set-like objects, because for maps, the iterator produces entries but the has() method takes keys.

Arrays are not set-like because they don't have a has() method or the size property, and their keys() method produces indices instead of elements. WeakSet objects are also not set-like because they don't have a keys() method.Set-like browser APIsBrowser Set-like objects (or "setlike objects") are Web API interfaces that behave in many ways like a Set.

  Just like Set, elements can be iterated in the same order that they were added to the object.
  Set-like objects and Set also have properties and methods that share the same name and behavior.
  However unlike Set they only allow a specific predefined type for each entry.


  The allowed types are set in the specification IDL definition.
  For example, GPUSupportedFeatures is a Set-like object that must use strings as the key/value.
  This is defined in the specification IDL below:

webidlinterface GPUSupportedFeatures {
  readonly setlike<DOMString>;
};

Set-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Set-like objects have the property size, and the methods: entries(), forEach(), has(), keys(), values(), and @@iterator.
Writeable Set-like objects additionally have the methods: clear(), delete(), and add().

The methods and properties have the same behavior as the equivalent entities in Set, except for the restriction on the types of the entry.
The following are examples of read-only Set-like browser objects:

GPUSupportedFeatures
XRAnchorSet

The following are examples of writable Set-like browser objects:

CustomStateSet
FontFaceSet
Highlight
Constructor
Set()

Creates a new Set object.

Static properties
Set[@@species]

The constructor function that is used to create derived objects.

Instance propertiesThese properties are defined on Set.prototype and shared by all Set instances.

Set.prototype.constructor

The constructor function that created the instance object. For Set instances, the initial value is the Set constructor.

Set.prototype.size

Returns the number of values in the Set object.

Set.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "Set". This property is used in Object.prototype.toString().

Instance methods
Set.prototype.add()

Inserts a new element with a specified value in to a Set object, if there isn't an element with the same value already in the Set.

Set.prototype.clear()

Removes all elements from the Set object.

Set.prototype.delete()

Removes the element associated to the value and returns a boolean asserting whether an element was successfully removed or not. Set.prototype.has(value) will return false afterwards.

Set.prototype.difference()

Takes a set and returns a new set containing elements in this set but not in the given set.

Set.prototype.entries()

Returns a new iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. This is similar to the Map object, so that each entry's key is the same as its value for a Set.

Set.prototype.forEach()

Calls callbackFn once for each value present in the Set object, in insertion order. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackFn.

Set.prototype.has()

Returns a boolean asserting whether an element is present with the given value in the Set object or not.

Set.prototype.intersection()

Takes a set and returns a new set containing elements in both this set and the given set.

Set.prototype.isDisjointFrom()

Takes a set and returns a boolean indicating if this set has no elements in common with the given set.

Set.prototype.isSubsetOf()

Takes a set and returns a boolean indicating if all elements of this set are in the given set.

Set.prototype.isSupersetOf()

Takes a set and returns a boolean indicating if all elements of the given set are in this set.

Set.prototype.keys()

An alias for Set.prototype.values().

Set.prototype.symmetricDifference()

Takes a set and returns a new set containing elements which are in either this set or the given set, but not in both.

Set.prototype.union()

Takes a set and returns a new set containing elements which are in either or both of this set and the given set.

Set.prototype.values()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

Set.prototype[@@iterator]()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

ExamplesUsing the Set objectjsconst mySet1 = new Set();

mySet1.add(1); // Set(1) { 1 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add("some text"); // Set(3) { 1, 5, 'some text' }
const o = { a: 1, b: 2 };
mySet1.add(o);

mySet1.add({ a: 1, b: 2 }); // o is referencing a different object, so this is okay

mySet1.has(1); // true
mySet1.has(3); // false, since 3 has not been added to the set
mySet1.has(5); // true
mySet1.has(Math.sqrt(25)); // true
mySet1.has("Some Text".toLowerCase()); // true
mySet1.has(o); // true

mySet1.size; // 5

mySet1.delete(5); // removes 5 from the set
mySet1.has(5); // false, 5 has been removed

mySet1.size; // 4, since we just removed one value

mySet1.add(5); // Set(5) { 1, 'some text', {...}, {...}, 5 } - a previously deleted item will be added as a new item, it will not retain its original position before deletion

console.log(mySet1); // Set(5) { 1, "some text", {…}, {…}, 5 }
Iterating setsThe iteration over a set visits elements in insertion order.
jsfor (const item of mySet1) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.keys()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.values()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// key and value are the same here
for (const [key, value] of mySet1.entries()) {
  console.log(key);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// Convert Set object to an Array object, with Array.from
const myArr = Array.from(mySet1); // [1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2}, 5]

// the following will also work if run in an HTML document
mySet1.add(document.body);
mySet1.has(document.querySelector("body")); // true

// converting between Set and Array
const mySet2 = new Set([1, 2, 3, 4]);
console.log(mySet2.size); // 4
console.log([...mySet2]); // [1, 2, 3, 4]

// intersect can be simulated via
const intersection = new Set([...mySet1].filter((x) => mySet2.has(x)));

// difference can be simulated via
const difference = new Set([...mySet1].filter((x) => !mySet2.has(x)));

// Iterate set entries with forEach()
mySet2.forEach((value) => {
  console.log(value);
});
// 1
// 2
// 3
// 4
Implementing basic set operationsjsfunction isSuperset(set, subset) {
  for (const elem of subset) {
    if (!set.has(elem)) {
      return false;
    }
  }
  return true;
}

function union(setA, setB) {
  const _union = new Set(setA);
  for (const elem of setB) {
    _union.add(elem);
  }
  return _union;
}

function intersection(setA, setB) {
  const _intersection = new Set();
  for (const elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem);
    }
  }
  return _intersection;
}

function symmetricDifference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    if (_difference.has(elem)) {
      _difference.delete(elem);
    } else {
      _difference.add(elem);
    }
  }
  return _difference;
}

function difference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}

// Examples
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 3]);
const setC = new Set([3, 4, 5, 6]);

isSuperset(setA, setB); // returns true
union(setA, setC); // returns Set {1, 2, 3, 4, 5, 6}
intersection(setA, setC); // returns Set {3, 4}
symmetricDifference(setA, setC); // returns Set {1, 2, 5, 6}
difference(setA, setC); // returns Set {1, 2}
Relation to arraysjsconst myArray = ["value1", "value2", "value3"];

// Use the regular Set constructor to transform an Array into a Set
const mySet = new Set(myArray);

mySet.has("value1"); // returns true

// Use the spread syntax to transform a set into an Array.
console.log([...mySet]); // Will show you exactly the same Array as myArray
Remove duplicate elements from an arrayjs// Use to remove duplicate elements from an array
const numbers = [2, 13, 4, 4, 2, 13, 13, 4, 4, 5, 5, 6, 6, 7, 5, 32, 13, 4, 5];

console.log([...new Set(numbers)]); // [2, 13, 4, 5, 6, 7, 32]
Relation to stringsjs// Case sensitive (set will contain "F" and "f")
new Set("Firefox"); // Set(7) [ "F", "i", "r", "e", "f", "o", "x" ]

// Duplicate omission ("f" occurs twice in the string but set will contain only one)
new Set("firefox"); // Set(6) [ "f", "i", "r", "e", "o", "x" ]
Use a set to ensure the uniqueness of a list of valuesjsconst array = Array.from(document.querySelectorAll("[id]")).map((e) => e.id);

const set = new Set(array);
console.assert(set.size === array.length);
SpecificationsSpecificationECMAScript Language Specification # sec-set-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Set in core-js
Map
WeakMap
WeakSet
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 31, 2024 by MDN contributors.
SharedArrayBufferThe SharedArrayBuffer object is used to represent a generic raw binary data buffer, similar to the ArrayBuffer object, but in a way that they can be used to create views on shared memory. A SharedArrayBuffer is not a Transferable Object, unlike an ArrayBuffer which is transferable.DescriptionTo share memory using SharedArrayBuffer objects from one agent in the cluster to another (an agent is either the web page's main program or one of its web workers), postMessage and structured cloning is used.
The structured clone algorithm accepts SharedArrayBuffer objects and typed arrays mapped onto SharedArrayBuffer objects. In both cases, the SharedArrayBuffer object is transmitted to the receiver resulting in a new, private SharedArrayBuffer object in the receiving agent (just as for ArrayBuffer). However, the shared data block referenced by the two SharedArrayBuffer objects is the same data block, and a side effect to the block in one agent will eventually become visible in the other agent.
jsconst sab = new SharedArrayBuffer(1024);
worker.postMessage(sab);

Shared memory can be created and updated simultaneously in workers or the main thread. Depending on the system (the CPU, the OS, the Browser) it can take a while until the change is propagated to all contexts. To synchronize, atomic operations are needed.
SharedArrayBuffer objects are used by some web APIs, such as:

WebGLRenderingContext.bufferData()
WebGLRenderingContext.bufferSubData()
WebGL2RenderingContext.getBufferSubData()
Security requirementsShared memory and high-resolution timers were effectively disabled at the start of 2018 in light of Spectre. In 2020, a new, secure approach has been standardized to re-enable shared memory.
As a baseline requirement, your document needs to be in a secure context.
For top-level documents, two headers need to be set to cross-origin isolate your site:

Cross-Origin-Opener-Policy with same-origin as value (protects your origin from attackers)
Cross-Origin-Embedder-Policy with require-corp or credentialless as value (protects victims from your origin)

httpCross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp

To check if cross origin isolation has been successful, you can test against the crossOriginIsolated property available to window and worker contexts:
jsconst myWorker = new Worker("worker.js");

if (crossOriginIsolated) {
  const buffer = new SharedArrayBuffer(16);
  myWorker.postMessage(buffer);
} else {
  const buffer = new ArrayBuffer(16);
  myWorker.postMessage(buffer);
}

With these two headers set, postMessage() no longer throws for SharedArrayBuffer objects and shared memory across threads is therefore available.
Nested documents and dedicated workers need to set the Cross-Origin-Embedder-Policy header as well, with the same value. No further changes are needed for same-origin nested documents and subresources. Same-site (but cross-origin) nested documents and subresources need to set the Cross-Origin-Resource-Policy header with same-site as value. And their cross-origin (and cross-site) counterparts need to set the same header with cross-origin as value. Note that setting the Cross-Origin-Resource-Policy header to any other value than same-origin opens up the resource to potential attacks, such as Spectre.
Note that the Cross-Origin-Opener-Policy header limits your ability to retain a reference to popups. Direct access between two top-level window contexts essentially only work if they are same-origin and carry the same two headers with the same two values.API availabilityDepending on whether the above security measures are taken, the various memory-sharing APIs have different availabilities:

The Atomics object is always available.
SharedArrayBuffer objects are in principle always available, but unfortunately the constructor on the global object is hidden, unless the two headers mentioned above are set, for compatibility with web content. There is hope that this restriction can be removed in the future. WebAssembly.Memory can still be used to get an instance.
Unless the two headers mentioned above are set, the various postMessage() APIs will throw for SharedArrayBuffer objects. If they are set, postMessage() on Window objects and dedicated workers will function and allow for memory sharing.
WebAssembly shared memoryWebAssembly.Memory objects can be created with the shared constructor flag. When this flag is set to true, the constructed Memory object can be shared between workers via postMessage(), just like SharedArrayBuffer, and the backing buffer of the Memory object is a SharedArrayBuffer. Therefore, the requirements listed above for sharing a SharedArrayBuffer between workers also apply to sharing a WebAssembly.Memory.
The WebAssembly Threads proposal also defines a new set of atomic instructions. Just as SharedArrayBuffer and its methods are unconditionally enabled (and only sharing between threads is gated on the new headers), the WebAssembly atomic instructions are also unconditionally allowed.Growing SharedArrayBuffersSharedArrayBuffer objects can be made growable by including the maxByteLength option when calling the SharedArrayBuffer() constructor. You can query whether a SharedArrayBuffer is growable and what its maximum size is by accessing its growable and maxByteLength properties, respectively. You can assign a new size to a growable SharedArrayBuffer with a grow() call. New bytes are initialized to 0.
These features make growing SharedArrayBuffers more efficient — otherwise, you have to make a copy of the buffer with a new size. It also gives JavaScript parity with WebAssembly in this regard (Wasm linear memory can be resized with WebAssembly.Memory.prototype.grow()).
For security reasons, SharedArrayBuffers cannot be reduced in size, only grown.Constructor
SharedArrayBuffer()

Creates a new SharedArrayBuffer object.

Static properties
SharedArrayBuffer[@@species]

Returns the constructor used to construct return values from SharedArrayBuffer methods.

Instance propertiesThese properties are defined on SharedArrayBuffer.prototype and shared by all SharedArrayBuffer instances.

SharedArrayBuffer.prototype.byteLength

The size, in bytes, of the array. This is established when the array is constructed and can only be changed using the SharedArrayBuffer.prototype.grow() method if the SharedArrayBuffer is growable.

SharedArrayBuffer.prototype.constructor

The constructor function that created the instance object. For SharedArrayBuffer instances, the initial value is the SharedArrayBuffer constructor.

SharedArrayBuffer.prototype.growable

Read-only. Returns true if the SharedArrayBuffer can be grown, or false if not.

SharedArrayBuffer.prototype.maxByteLength

The read-only maximum length, in bytes, that the SharedArrayBuffer can be grown to. This is established when the array is constructed and cannot be changed.

SharedArrayBuffer.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "SharedArrayBuffer". This property is used in Object.prototype.toString().

Instance methods
SharedArrayBuffer.prototype.grow()

Grows the SharedArrayBuffer to the specified size, in bytes.

SharedArrayBuffer.prototype.slice()

Returns a new SharedArrayBuffer whose contents are a copy of this SharedArrayBuffer's bytes from begin, inclusive, up to end, exclusive. If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.

ExamplesCreating a new SharedArrayBufferjsconst sab = new SharedArrayBuffer(1024);
Slicing the SharedArrayBufferjssab.slice(); // SharedArrayBuffer { byteLength: 1024 }
sab.slice(2); // SharedArrayBuffer { byteLength: 1022 }
sab.slice(-2); // SharedArrayBuffer { byteLength: 2 }
sab.slice(0, 1); // SharedArrayBuffer { byteLength: 1 }
Using it in a WebGL bufferjsconst canvas = document.querySelector("canvas");
const gl = canvas.getContext("webgl");
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, sab, gl.STATIC_DRAW);
SpecificationsSpecificationECMAScript Language Specification # sec-sharedarraybuffer-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Atomics
ArrayBuffer
JavaScript typed arrays guide
Web Workers
Shared Memory – a brief tutorial in the TC39 ecmascript-sharedmem proposal
A Taste of JavaScript's New Parallel Primitives on hacks.mozilla.org (2016)
COOP and COEP explained by the Chrome team (2020)
Cross-Origin-Opener-Policy
Cross-Origin-Embedder-Policy
Cross-Origin-Resource-Policy
crossOriginIsolated
SharedArrayBuffer updates in Android Chrome 88 and Desktop Chrome 92 on developer.chrome.com (2021)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 3, 2023 by MDN contributors.
String
  The String object is used to represent and manipulate a
  sequence of characters.
Description
  Strings are useful for holding data that can be represented in text form. Some of the
  most-used operations on strings are to check their length, to build and concatenate them using the
  + and += string operators,
  checking for the existence or location of substrings with the
  indexOf() method, or extracting substrings
  with the substring() method.
Creating strings
  Strings can be created as primitives, from string literals, or as objects, using the
  String() constructor:

jsconst string1 = "A string primitive";
const string2 = 'Also a string primitive';
const string3 = `Yet another string primitive`;

jsconst string4 = new String("A String object");


  String primitives and string objects share many behaviors, but have other important differences and caveats.
  See "String primitives and String objects" below.


  String literals can be specified using single or double quotes, which are treated
  identically, or using the backtick character `. This last form specifies a template literal:
  with this form you can interpolate expressions. For more information on the syntax of string literals, see lexical grammar.
Character access
  There are two ways to access an individual character in a string. The first is the
  charAt() method:

js"cat".charAt(1); // gives value "a"

The other way is to treat the string as an array-like object, where individual characters correspond to a numerical index:
js"cat"[1]; // gives value "a"


  When using bracket notation for character access, attempting to delete or assign a
  value to these properties will not succeed. The properties involved are neither writable
  nor configurable. (See Object.defineProperty() for more information.)
Comparing stringsUse the less-than and greater-than operators to compare strings:
jsconst a = "a";
const b = "b";
if (a < b) {
  // true
  console.log(`${a} is less than ${b}`);
} else if (a > b) {
  console.log(`${a} is greater than ${b}`);
} else {
  console.log(`${a} and ${b} are equal.`);
}

Note that all comparison operators, including === and ==, compare strings case-sensitively. A common way to compare strings case-insensitively is to convert both to the same case (upper or lower) before comparing them.
jsfunction areEqualCaseInsensitive(str1, str2) {
  return str1.toUpperCase() === str2.toUpperCase();
}

The choice of whether to transform by toUpperCase() or toLowerCase() is mostly arbitrary, and neither one is fully robust when extending beyond the Latin alphabet. For example, the German lowercase letter ß and ss are both transformed to SS by toUpperCase(), while the Turkish letter ı would be falsely reported as unequal to I by toLowerCase() unless specifically using toLocaleLowerCase("tr").
jsconst areEqualInUpperCase = (str1, str2) =>
  str1.toUpperCase() === str2.toUpperCase();
const areEqualInLowerCase = (str1, str2) =>
  str1.toLowerCase() === str2.toLowerCase();

areEqualInUpperCase("ß", "ss"); // true; should be false
areEqualInLowerCase("ı", "I"); // false; should be true

A locale-aware and robust solution for testing case-insensitive equality is to use the Intl.Collator API or the string's localeCompare() method — they share the same interface — with the sensitivity option set to "accent" or "base".
jsconst areEqual = (str1, str2, locale = "en-US") =>
  str1.localeCompare(str2, locale, { sensitivity: "accent" }) === 0;

areEqual("ß", "ss", "de"); // false
areEqual("ı", "I", "tr"); // true

The localeCompare() method enables string comparison in a similar fashion as strcmp() — it allows sorting strings in a locale-aware manner.String primitives and String objects
  Note that JavaScript distinguishes between String objects and
  primitive string values. (The same is true of
  Boolean and Numbers.)


  String literals (denoted by double or single quotes) and strings returned from
  String calls in a non-constructor context (that is, called without using
  the new keyword) are primitive strings. In contexts where a
  method is to be invoked on a primitive string or a property lookup occurs, JavaScript
  will automatically wrap the string primitive and call the method or perform the property
  lookup on the wrapper object instead.

jsconst strPrim = "foo"; // A literal is a string primitive
const strPrim2 = String(1); // Coerced into the string primitive "1"
const strPrim3 = String(true); // Coerced into the string primitive "true"
const strObj = new String(strPrim); // String with new returns a string wrapper object.

console.log(typeof strPrim); // "string"
console.log(typeof strPrim2); // "string"
console.log(typeof strPrim3); // "string"
console.log(typeof strObj); // "object"


Warning: You should rarely find yourself using String as a constructor.


  String primitives and String objects also give different results when
  using eval(). Primitives passed to
  eval are treated as source code; String objects are treated as
  all other objects are, by returning the object. For example:

jsconst s1 = "2 + 2"; // creates a string primitive
const s2 = new String("2 + 2"); // creates a String object
console.log(eval(s1)); // returns the number 4
console.log(eval(s2)); // returns the string "2 + 2"


  For these reasons, the code may break when it encounters String objects
  when it expects a primitive string instead, although generally, authors need not worry
  about the distinction.


  A String object can always be converted to its primitive counterpart with
  the valueOf() method.

jsconsole.log(eval(s2.valueOf())); // returns the number 4
String coercionMany built-in operations that expect strings first coerce their arguments to strings (which is largely why String objects behave similarly to string primitives). The operation can be summarized as follows:

Strings are returned as-is.
undefined turns into "undefined".
null turns into "null".
true turns into "true"; false turns into "false".
Numbers are converted with the same algorithm as toString(10).
BigInts are converted with the same algorithm as toString(10).
Symbols throw a TypeError.
Objects are first converted to a primitive by calling its [@@toPrimitive]() (with "string" as hint), toString(), and valueOf() methods, in that order. The resulting primitive is then converted to a string.

There are several ways to achieve nearly the same effect in JavaScript.

Template literal: `${x}` does exactly the string coercion steps explained above for the embedded expression.
The String() function: String(x) uses the same algorithm to convert x, except that Symbols don't throw a TypeError, but return "Symbol(description)", where description is the description of the Symbol.
Using the + operator: "" + x coerces its operand to a primitive instead of a string, and, for some objects, has entirely different behaviors from normal string coercion. See its reference page for more details.

Depending on your use case, you may want to use `${x}` (to mimic built-in behavior) or String(x) (to handle symbol values without throwing an error), but you should not use "" + x.UTF-16 characters, Unicode code points, and grapheme clustersStrings are represented fundamentally as sequences of UTF-16 code units. In UTF-16 encoding, every code unit is exact 16 bits long. This means there are a maximum of 216, or 65536 possible characters representable as single UTF-16 code units. This character set is called the basic multilingual plane (BMP), and includes the most common characters like the Latin, Greek, Cyrillic alphabets, as well as many East Asian characters. Each code unit can be written in a string with \u followed by exactly four hex digits.
However, the entire Unicode character set is much, much bigger than 65536. The extra characters are stored in UTF-16 as surrogate pairs, which are pairs of 16-bit code units that represent a single character. To avoid ambiguity, the two parts of the pair must be between 0xD800 and 0xDFFF, and these code units are not used to encode single-code-unit characters. (More precisely, leading surrogates, also called high-surrogate code units, have values between 0xD800 and 0xDBFF, inclusive, while trailing surrogates, also called low-surrogate code units, have values between 0xDC00 and 0xDFFF, inclusive.) Each Unicode character, comprised of one or two UTF-16 code units, is also called a Unicode code point. Each Unicode code point can be written in a string with \u{xxxxxx} where xxxxxx represents 1–6 hex digits.
A "lone surrogate" is a 16-bit code unit satisfying one of the descriptions below:

It is in the range 0xD800–0xDBFF, inclusive (i.e. is a leading surrogate), but it is the last code unit in the string, or the next code unit is not a trailing surrogate.
It is in the range 0xDC00–0xDFFF, inclusive (i.e. is a trailing surrogate), but it is the first code unit in the string, or the previous code unit is not a leading surrogate.

Lone surrogates do not represent any Unicode character. Although most JavaScript built-in methods handle them correctly because they all work based on UTF-16 code units, lone surrogates are often not valid values when interacting with other systems — for example, encodeURI() will throw a URIError for lone surrogates, because URI encoding uses UTF-8 encoding, which does not have any encoding for lone surrogates. Strings not containing any lone surrogates are called well-formed strings, and are safe to be used with functions that do not deal with UTF-16 (such as encodeURI() or TextEncoder). You can check if a string is well-formed with the isWellFormed() method, or sanitize lone surrogates with the toWellFormed() method.
On top of Unicode characters, there are certain sequences of Unicode characters that should be treated as one visual unit, known as a grapheme cluster. The most common case is emojis: many emojis that have a range of variations are actually formed by multiple emojis, usually joined by the <ZWJ> (U+200D) character.
You must be careful which level of characters you are iterating on. For example, split("") will split by UTF-16 code units and will separate surrogate pairs. String indexes also refer to the index of each UTF-16 code unit. On the other hand, @@iterator() iterates by Unicode code points. Iterating through grapheme clusters will require some custom code.
js"😄".split(""); // ['\ud83d', '\ude04']; splits into two lone surrogates

// "Backhand Index Pointing Right: Dark Skin Tone"
[..."👉🏿"]; // ['👉', '🏿']
// splits into the basic "Backhand Index Pointing Right" emoji and
// the "Dark skin tone" emoji

// "Family: Man, Boy"
[..."👨‍👦"]; // [ '👨', '‍', '👦' ]
// splits into the "Man" and "Boy" emoji, joined by a ZWJ

// The United Nations flag
[..."🇺🇳"]; // [ '🇺', '🇳' ]
// splits into two "region indicator" letters "U" and "N".
// All flag emojis are formed by joining two region indicator letters
Constructor
String()


      Creates a new String object. It performs type conversion when called as
      a function, rather than as a constructor, which is usually more useful.
    

Static methods
String.fromCharCode()

Returns a string created by using the specified sequence of Unicode values.

String.fromCodePoint()

Returns a string created by using the specified sequence of code points.

String.raw()

Returns a string created from a raw template string.

Instance propertiesThese properties are defined on String.prototype and shared by all String instances.

String.prototype.constructor

The constructor function that created the instance object. For String instances, the initial value is the String constructor.


These properties are own properties of each String instance.

length

Reflects the length of the string. Read-only.

Instance methods
String.prototype.at()

Returns the character (exactly one UTF-16 code unit) at the specified index. Accepts negative integers, which count back from the last string character.

String.prototype.charAt()


      Returns the character (exactly one UTF-16 code unit) at the specified
      index.
    

String.prototype.charCodeAt()


      Returns a number that is the UTF-16 code unit value at the given
      index.
    

String.prototype.codePointAt()


      Returns a nonnegative integer Number that is the code point value of the UTF-16
      encoded code point starting at the specified pos.
    

String.prototype.concat()

Combines the text of two (or more) strings and returns a new string.

String.prototype.endsWith()


      Determines whether a string ends with the characters of the string
      searchString.
    

String.prototype.includes()

Determines whether the calling string contains searchString.

String.prototype.indexOf()


      Returns the index within the calling String object of the first
      occurrence of searchValue, or -1 if not found.
    

String.prototype.isWellFormed()

Returns a boolean indicating whether this string contains any lone surrogates.

String.prototype.lastIndexOf()


      Returns the index within the calling String object of the last
      occurrence of searchValue, or -1 if not found.
    

String.prototype.localeCompare()


      Returns a number indicating whether the reference string
      compareString comes before, after, or is equivalent to the
      given string in sort order.
    

String.prototype.match()

Used to match regular expression regexp against a string.

String.prototype.matchAll()

Returns an iterator of all regexp's matches.

String.prototype.normalize()

Returns the Unicode Normalization Form of the calling string value.

String.prototype.padEnd()


      Pads the current string from the end with a given string and returns a new string of
      the length targetLength.
    

String.prototype.padStart()


      Pads the current string from the start with a given string and returns a new string
      of the length targetLength.
    

String.prototype.repeat()


      Returns a string consisting of the elements of the object repeated
      count times.
    

String.prototype.replace()


      Used to replace occurrences of searchFor using
      replaceWith. searchFor may be a string
      or Regular Expression, and replaceWith may be a string or
      function.
    

String.prototype.replaceAll()


      Used to replace all occurrences of searchFor using
      replaceWith. searchFor may be a string
      or Regular Expression, and replaceWith may be a string or
      function.
    

String.prototype.search()


      Search for a match between a regular expression regexp and
      the calling string.
    

String.prototype.slice()

Extracts a section of a string and returns a new string.

String.prototype.split()


      Returns an array of strings populated by splitting the calling string at occurrences
      of the substring sep.
    

String.prototype.startsWith()


      Determines whether the calling string begins with the characters of string
      searchString.
    

String.prototype.substr() 
Deprecated


Returns a portion of the string, starting at the specified index and extending for a given number of characters afterwards.

String.prototype.substring()


      Returns a new string containing characters of the calling string from (or between)
      the specified index (or indices).
    

String.prototype.toLocaleLowerCase()


      The characters within a string are converted to lowercase while respecting the
      current locale.
    

      For most languages, this will return the same as
      toLowerCase().
    

String.prototype.toLocaleUpperCase()


      The characters within a string are converted to uppercase while respecting the
      current locale.
    

      For most languages, this will return the same as
      toUpperCase().
    

String.prototype.toLowerCase()

Returns the calling string value converted to lowercase.

String.prototype.toString()


      Returns a string representing the specified object. Overrides the
      Object.prototype.toString() method.
    

String.prototype.toUpperCase()

Returns the calling string value converted to uppercase.

String.prototype.toWellFormed()

Returns a string where all lone surrogates of this string are replaced with the Unicode replacement character U+FFFD.

String.prototype.trim()

Trims whitespace from the beginning and end of the string.

String.prototype.trimEnd()

Trims whitespace from the end of the string.

String.prototype.trimStart()

Trims whitespace from the beginning of the string.

String.prototype.valueOf()


      Returns the primitive value of the specified object. Overrides the
      Object.prototype.valueOf() method.
    

String.prototype[@@iterator]()


      Returns a new iterator object that iterates over the code points of a String value,
      returning each code point as a String value.
    

HTML wrapper methods
Warning: Deprecated. Avoid these methods.
They are of limited use, as they are based on a very old HTML standard and provide only a subset of the currently available HTML tags and attributes. Many of them create deprecated or non-standard markup today. In addition, they do simple string concatenation without any validation or sanitation, which makes them a potential security threat when directly inserted using innerHTML. Use DOM APIs such as document.createElement() instead.


String.prototype.anchor() 
Deprecated


<a name="name"> (hypertext target)

String.prototype.big() 
Deprecated

<big>
String.prototype.blink() 
Deprecated


<blink>

String.prototype.bold() 
Deprecated

<b>
String.prototype.fixed() 
Deprecated

<tt>
String.prototype.fontcolor() 
Deprecated


<font color="color">

String.prototype.fontsize() 
Deprecated


<font size="size">

String.prototype.italics() 
Deprecated

<i>
String.prototype.link() 
Deprecated


<a href="url"> (link to URL)

String.prototype.small() 
Deprecated

<small>
String.prototype.strike() 
Deprecated

<strike>
String.prototype.sub() 
Deprecated

<sub>
String.prototype.sup() 
Deprecated

<sup>

Note that these methods do not check if the string itself contains HTML tags, so it's possible to create invalid HTML:
js"</b>".bold(); // <b></b></b>

The only escaping they do is to replace " in the attribute value (for anchor(), fontcolor(), fontsize(), and link()) with &quot;.
js"foo".anchor('"Hello"'); // <a name="&quot;Hello&quot;">foo</a>
ExamplesString conversionThe String() function is a more reliable way of converting values to strings than calling the toString() method of the value, as the former works when used on null and undefined. For example:
js// You cannot access properties on null or undefined

const nullVar = null;
nullVar.toString(); // TypeError: Cannot read properties of null
String(nullVar); // "null"

const undefinedVar = undefined;
undefinedVar.toString(); // TypeError: Cannot read properties of undefined
String(undefinedVar); // "undefined"
SpecificationsSpecificationECMAScript Language Specification # sec-string-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Text formatting guide
RegExp
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 26, 2023 by MDN contributors.
SymbolSymbol is a built-in object whose constructor returns a symbol primitive — also called a Symbol value or just a Symbol — that's guaranteed to be unique. Symbols are often used to add unique property keys to an object that won't collide with keys any other code might add to the object, and which are hidden from any mechanisms other code will typically use to access the object. That enables a form of weak encapsulation, or a weak form of information hiding.
Every Symbol() call is guaranteed to return a unique Symbol. Every Symbol.for("key") call will always return the same Symbol for a given value of "key". When Symbol.for("key") is called, if a Symbol with the given key can be found in the global Symbol registry, that Symbol is returned. Otherwise, a new Symbol is created, added to the global Symbol registry under the given key, and returned.DescriptionTo create a new primitive Symbol, you write Symbol() with an optional string as its description:
jsconst sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");

The above code creates three new Symbols. Note that Symbol("foo") does not coerce the string "foo" into a Symbol. It creates a new Symbol each time:
jsSymbol("foo") === Symbol("foo"); // false

The following syntax with the new operator will throw a TypeError:
jsconst sym = new Symbol(); // TypeError

This prevents authors from creating an explicit Symbol wrapper object instead of a new Symbol value and might be surprising as creating explicit wrapper objects around primitive data types is generally possible (for example, new Boolean, new String and new Number).
If you really want to create a Symbol wrapper object, you can use the Object() function:
jsconst sym = Symbol("foo");
typeof sym; // "symbol"
const symObj = Object(sym);
typeof symObj; // "object"

Because symbols are the only primitive data type that has reference identity (that is, you cannot create the same symbol twice), they behave like objects in some way. For example, they are garbage collectable and can therefore be stored in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Shared Symbols in the global Symbol registryThe above syntax using the Symbol() function will create a Symbol whose value remains unique throughout the lifetime of the program. To create Symbols available across files and even across realms (each of which has its own global scope), use the methods Symbol.for() and Symbol.keyFor() to set and retrieve Symbols from the global Symbol registry.
Note that the "global Symbol registry" is only a fictitious concept and may not correspond to any internal data structure in the JavaScript engine — and even if such a registry exists, its content is not available to the JavaScript code, except through the for() and keyFor() methods.
The method Symbol.for(tokenString) takes a string key and returns a symbol value from the registry, while Symbol.keyFor(symbolValue) takes a symbol value and returns the string key corresponding to it. Each is the other's inverse, so the following is true:
jsSymbol.keyFor(Symbol.for("tokenString")) === "tokenString"; // true

Because registered symbols can be arbitrarily created anywhere, they behave almost exactly like the strings they wrap. Therefore, they are not guaranteed to be unique and are not garbage collectable. Therefore, registered symbols are disallowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Well-known SymbolsAll static properties of the Symbol constructor are Symbols themselves, whose values are constant across realms. They are known as well-known Symbols, and their purpose is to serve as "protocols" for certain built-in JavaScript operations, allowing users to customize the language's behavior. For example, if a constructor function has a method with Symbol.hasInstance as its name, this method will encode its behavior with the instanceof operator.
Prior to well-known Symbols, JavaScript used normal properties to implement certain built-in operations. For example, the JSON.stringify function will attempt to call each object's toJSON() method, and the String function will call the object's toString() and valueOf() methods. However, as more operations are added to the language, designating each operation a "magic property" can break backward compatibility and make the language's behavior harder to reason with. Well-known Symbols allow the customizations to be "invisible" from normal code, which typically only read string properties.
In MDN and other sources, well-known symbol values are stylized by prefixing @@. For example, Symbol.hasInstance is written as @@hasInstance. This is because symbols don't have actual literal formats, but using Symbol.hasInstance does not reflect the ability of using other aliases to refer to the same symbol. This is like the difference between Function.name and "Function".
Well-known symbols do not have the concept of garbage collectability, because they come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Finding Symbol properties on objectsThe method Object.getOwnPropertySymbols() returns an array of Symbols and lets you find Symbol properties on a given object. Note that every object is initialized with no own Symbol properties, so that this array will be empty unless you've set Symbol properties on the object.Constructor
Symbol()

Creates a new Symbol object. It is not a constructor in the traditional sense, because it can only be called as a function, instead of being constructed with new Symbol().

Static propertiesThe static properties are all well-known Symbols. In these Symbols' descriptions, we will use language like "Symbol.hasInstance is a method determining…", but bear in mind that this is referring to the semantic of an object's method having this Symbol as the method name (because well-known Symbols act as "protocols"), not describing the value of the Symbol itself.

Symbol.asyncIterator

A method that returns the default AsyncIterator for an object. Used by for await...of.

Symbol.hasInstance

A method determining if a constructor object recognizes an object as its instance. Used by instanceof.

Symbol.isConcatSpreadable

A Boolean value indicating if an object should be flattened to its array elements. Used by Array.prototype.concat().

Symbol.iterator

A method returning the default iterator for an object. Used by for...of.

Symbol.match

A method that matches against a string, also used to determine if an object may be used as a regular expression. Used by String.prototype.match().

Symbol.matchAll

A method that returns an iterator, that yields matches of the regular expression against a string. Used by String.prototype.matchAll().

Symbol.replace

A method that replaces matched substrings of a string. Used by String.prototype.replace().

Symbol.search

A method that returns the index within a string that matches the regular expression. Used by String.prototype.search().

Symbol.species

A constructor function that is used to create derived objects.

Symbol.split

A method that splits a string at the indices that match a regular expression. Used by String.prototype.split().

Symbol.toPrimitive

A method converting an object to a primitive value.

Symbol.toStringTag

A string value used for the default description of an object. Used by Object.prototype.toString().

Symbol.unscopables

An object value of whose own and inherited property names are excluded from the with environment bindings of the associated object.

Static methods
Symbol.for()

Searches for existing Symbols with the given key and returns it if found. Otherwise a new Symbol gets created in the global Symbol registry with key.

Symbol.keyFor()

Retrieves a shared Symbol key from the global Symbol registry for the given Symbol.

Instance propertiesThese properties are defined on Symbol.prototype and shared by all Symbol instances.

Symbol.prototype.constructor

The constructor function that created the instance object. For Symbol instances, the initial value is the Symbol constructor.

Symbol.prototype.description

A read-only string containing the description of the Symbol.

Symbol.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "Symbol". This property is used in Object.prototype.toString(). However, because Symbol also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a symbol as thisArg.

Instance methods
Symbol.prototype.toString()

Returns a string containing the description of the Symbol. Overrides the Object.prototype.toString() method.

Symbol.prototype.valueOf()

Returns the Symbol. Overrides the Object.prototype.valueOf() method.

Symbol.prototype[@@toPrimitive]()

Returns the Symbol.

ExamplesUsing the typeof operator with SymbolsThe typeof operator can help you to identify Symbols.
jstypeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";
Symbol type conversionsSome things to note when working with type conversion of Symbols.


    When trying to convert a Symbol to a number, a TypeError will be thrown
    (e.g. +sym or sym | 0).
  
When using loose equality, Object(sym) == sym returns true.
Symbol("foo") + "bar" throws a TypeError (can't convert Symbol to string). This prevents you from silently creating a new string property name from a Symbol, for example.
The "safer" String(sym) conversion works like a call to Symbol.prototype.toString() with Symbols, but note that new String(sym) will throw.
Symbols and for...in iterationSymbols are not enumerable in for...in iterations. In addition, Object.getOwnPropertyNames() will not return Symbol object properties, however, you can use Object.getOwnPropertySymbols() to get these.
jsconst obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (const i in obj) {
  console.log(i);
}
// "c" "d"
Symbols and JSON.stringify()Symbol-keyed properties will be completely ignored when using JSON.stringify():
jsJSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

For more details, see JSON.stringify().Symbol wrapper objects as property keysWhen a Symbol wrapper object is used as a property key, this object will be coerced to its wrapped Symbol:
jsconst sym = Symbol("foo");
const obj = { [sym]: 1 };
obj[sym]; // 1
obj[Object(sym)]; // still 1
SpecificationsSpecificationECMAScript Language Specification # sec-symbol-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Symbol in core-js
typeof
JavaScript data types and data structures
ES6 In Depth: Symbols on hacks.mozilla.org (2015)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxErrorThe SyntaxError object represents an error when trying to interpret syntactically invalid code. It is thrown when the JavaScript engine encounters tokens or token order that does not conform to the syntax of the language when parsing code.
SyntaxError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
SyntaxError is a subclass of Error.Constructor
SyntaxError()

Creates a new SyntaxError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on SyntaxError.prototype and shared by all SyntaxError instances.

SyntaxError.prototype.constructor

The constructor function that created the instance object. For SyntaxError instances, the initial value is the SyntaxError constructor.

SyntaxError.prototype.name

Represents the name for the type of error. For SyntaxError.prototype.name, the initial value is "SyntaxError".

Instance methodsInherits instance methods from its parent Error.ExamplesCatching a SyntaxErrorjstry {
  eval("hoo bar");
} catch (e) {
  console.log(e instanceof SyntaxError); // true
  console.log(e.message);
  console.log(e.name); // "SyntaxError"
  console.log(e.stack); // Stack of the error
}
Creating a SyntaxErrorjstry {
  throw new SyntaxError("Hello");
} catch (e) {
  console.log(e instanceof SyntaxError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "SyntaxError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript Language Specification # sec-native-error-types-used-in-this-standard-syntaxerrorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on May 26, 2023 by MDN contributors.
TypedArray
  A TypedArray object describes an array-like view of an
  underlying binary data buffer.
  There is no global property named TypedArray, nor is there a
  directly visible TypedArray constructor. Instead, there are a number of
  different global properties, whose values are typed array constructors for specific
  element types, listed below. On the following pages you will find common properties and
  methods that can be used with any typed array containing elements of any type.
Try itDescriptionThe TypedArray constructor (often referred to as %TypedArray% to indicate its "intrinsicness", since it does not correspond to any global exposed to a JavaScript program) serves as the common superclass of all TypedArray subclasses. Think about %TypedArray% as an "abstract class" providing a common interface of utility methods for all typed array subclasses. This constructor is not directly exposed: there is no global TypedArray property. It is only accessible through Object.getPrototypeOf(Int8Array) and similar.
When creating an instance of a TypedArray subclass (e.g. Int8Array), an array buffer is created internally in memory or, if an ArrayBuffer object is given as constructor argument, that ArrayBuffer is used instead. The buffer address is saved as an internal property of the instance and all the methods of %TypedArray%.prototype will set and get values based on that array buffer address.TypedArray objects


Type
Value Range
Size in bytes
Web IDL type




Int8Array
-128 to 127
1
byte


Uint8Array
0 to 255
1
octet


Uint8ClampedArray
0 to 255
1
octet


Int16Array
-32768 to 32767
2
short


Uint16Array
0 to 65535
2
unsigned short


Int32Array
-2147483648 to 2147483647
4
long


Uint32Array
0 to 4294967295
4
unsigned long


Float32Array
-3.4e38 to 3.4e38
4
unrestricted float


Float64Array
-1.8e308 to 1.8e308
8
unrestricted double


BigInt64Array
-263 to 263 - 1
8
bigint


BigUint64Array
0 to 264 - 1
8
bigint


Value encoding and normalizationAll typed arrays operate on ArrayBuffers, where you can observe the exact byte representation of each element, so how the numbers are encoded in binary format is significant.

Unsigned integer arrays (Uint8Array, Uint16Array, Uint32Array, and BigUint64Array) store the number directly in binary.
Signed integer arrays (Int8Array, Int16Array, Int32Array, and BigInt64Array) store the number using two's complement.
Floating-point arrays (Float32Array and Float64Array) store the number using IEEE 754 floating-point format. The Number reference has more information about the exact format. JavaScript numbers use double precision floating point format by default, which is the same as Float64Array. Float32Array uses 23 (instead of 52) bits for the mantissa and 8 (instead of 11) bits for the exponent. Note that the spec requires all NaN values to use the same bit encoding, but the exact bit pattern is implementation-dependent.
Uint8ClampedArray is a special case. It stores the number in binary like Uint8Array does, but when you store a number outside the range, it clamps the number to the range 0 to 255 by mathematical value, instead of truncating the most significant bits.

All typed arrays except Int8Array, Uint8Array, and Uint8ClampedArray store each element using multiple bytes. These bytes can either be ordered from most significant to least significant (big-endian) or from least significant to most significant (little-endian). See Endianness for more explanation. Typed arrays always use the platform's native byte order. If you want to specify the endianness when writing and reading from buffers, you should use a DataView instead.
When writing to these typed arrays, values that are outside the representable range are normalized.

All integer arrays (except Uint8ClampedArray) use fixed-width number conversion, which first truncates the decimal part of the number and then takes the lowest bits.
Uint8ClampedArray first clamps the number to the range 0 to 255 (values greater than 255 become 255 and values less than 0 become 0). It then rounds (instead of flooring) the result to the nearest integer, with half-to-even; meaning if the number is exactly between two integers, it rounds to the nearest even integer. For example, 0.5 becomes 0, 1.5 becomes 2, and 2.5 becomes 2.
Float32Array performs a "round to even" to convert 64-bit floating point numbers to 32-bit. This is the same algorithm as provided by Math.fround().
Behavior when viewing a resizable bufferWhen a TypedArray is created as a view of a resizable buffer, resizing the underlying buffer will have different effects on the size of the TypedArray depending on whether the TypedArray is constructed as length-tracking.
If a typed array is created without a specific size by omitting the third parameter or passing undefined, the typed array will become length-tracking, and will automatically resize to fit the underlying buffer as the latter is resized:
jsconst buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2

buffer.resize(12);

console.log(float32.byteLength); // 12
console.log(float32.length); // 3

If a typed array is created with a specific size using the third length parameter, it won't resize to contain the buffer as the latter is grown:
jsconst buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer, 0, 2);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2
console.log(float32[0]); // 0, the initial value

buffer.resize(12);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2
console.log(float32[0]); // 0, the initial value

When a buffer is shrunk, the viewing typed array may become out of bounds, in which case the typed array's observed size will decrease to 0. This is the only case where a non-length-tracking typed array's length may change.
jsconst buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer, 0, 2);

buffer.resize(7);

console.log(float32.byteLength); // 0
console.log(float32.length); // 0
console.log(float32[0]); // undefined

If you then grow the buffer again to bring the typed array back in bounds, the typed array's size will be restored to its original value.
jsbuffer.resize(8);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2
console.log(float32[0]); // 0 - back in bounds again!

The same can happen for length-tracking typed arrays as well, if the buffer is shrunk beyond the byteOffset.
jsconst buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer, 4);
// float32 is length-tracking, but it only extends from the 4th byte
// to the end of the buffer, so if the buffer is resized to be shorter
// than 4 bytes, the typed array will become out of bounds
buffer.resize(3);
console.log(float32.byteLength); // 0
ConstructorThis object cannot be instantiated directly — attempting to construct it with new throws a TypeError.
jsnew (Object.getPrototypeOf(Int8Array))();
// TypeError: Abstract class TypedArray not directly constructable

Instead, you create an instance of a typed array of a particular type, such as an Int8Array or a BigInt64Array. These objects all have a common syntax for their constructors:
jsnew TypedArray()
new TypedArray(length)
new TypedArray(typedArray)
new TypedArray(object)

new TypedArray(buffer)
new TypedArray(buffer, byteOffset)
new TypedArray(buffer, byteOffset, length)

Where TypedArray is a constructor for one of the concrete types.

Note: All TypedArray subclasses' constructors can only be constructed with new. Attempting to call one without new throws a TypeError.
Parameters
typedArray

When called with an instance of a TypedArray subclass, the typedArray gets copied into a new typed array. For a non-bigint TypedArray constructor, the typedArray parameter can only be of one of the non-bigint types (such as Int32Array). Similarly, for a bigint TypedArray constructor (BigInt64Array or BigUint64Array), the typedArray parameter can only be of one of the bigint types. Each value in typedArray is converted to the corresponding type of the constructor before being copied into the new array. The length of the new typed array will be same as the length of the typedArray argument.

object

When called with an object that's not a TypedArray instance, a new typed array is created in the same way as the TypedArray.from() method.

length Optional

When called with a non-object, the parameter will be treated as a number specifying the length of the typed array. An internal array buffer is created in memory, of size length multiplied by BYTES_PER_ELEMENT bytes, filled with zeros. Omitting all parameters is equivalent to using 0 as length.

buffer, byteOffset Optional, length Optional

When called with an ArrayBuffer or SharedArrayBuffer instance, and optionally a byteOffset and a length argument, a new typed array view is created that views the specified buffer. The byteOffset (in bytes) and length (in number of elements, each occupying BYTES_PER_ELEMENT bytes) parameters specify the memory range that will be exposed by the typed array view. If both are omitted, all of buffer is viewed; if only length is omitted, the remainder of buffer starting from byteOffset is viewed. If length is omitted, the typed array becomes length-tracking.

ExceptionsAll TypeArray subclass constructors operate in the same way. They would all throw the following exceptions:

TypeError

Thrown in one of the following cases:

A typedArray is passed but it is a bigint type while the current constructor is not, or vice versa.
A typedArray is passed but the buffer it's viewing is detached, or a detached buffer is directly passed.


RangeError

Thrown in one of the following cases:

The new typed array's length is too large.
The length of buffer (if the length parameter is not specified) or byteOffset is not an integral multiple of the new typed array's element size.
byteOffset is not a valid array index (an integer between 0 and 253 - 1).
When creating a view from a buffer, the bounds are outside the buffer. In other words, byteOffset + length * TypedArray.BYTES_PER_ELEMENT > buffer.byteLength.


Static propertiesThese properties are defined on the TypedArray constructor object and are thus shared by all TypedArray subclass constructors.

TypedArray[@@species]

The constructor function used to create derived objects.


All TypedArray subclasses also have the following static properties:

TypedArray.BYTES_PER_ELEMENT

Returns a number value of the element size for the different TypedArray objects.

Static methodsThese methods are defined on the TypedArray constructor object and are thus shared by all TypedArray subclass constructors.

TypedArray.from()

Creates a new TypedArray from an array-like or iterable object. See also Array.from().

TypedArray.of()

Creates a new TypedArray with a variable number of arguments. See also Array.of().

Instance propertiesThese properties are defined on TypedArray.prototype and shared by all TypedArray subclass instances.

TypedArray.prototype.buffer

Returns the ArrayBuffer referenced by the typed array.

TypedArray.prototype.byteLength

Returns the length (in bytes) of the typed array.

TypedArray.prototype.byteOffset

Returns the offset (in bytes) of the typed array from the start of its ArrayBuffer.

TypedArray.prototype.constructor

The constructor function that created the instance object. TypedArray.prototype.constructor is the hidden TypedArray constructor function, but each typed array subclass also defines its own constructor property.

TypedArray.prototype.length

Returns the number of elements held in the typed array.

TypedArray.prototype[@@toStringTag]

The initial value of the TypedArray.prototype[@@toStringTag] property is a getter that returns the same string as the typed array constructor's name. It returns undefined if the this value is not one of the typed array subclasses. This property is used in Object.prototype.toString(). However, because TypedArray also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a typed array as thisArg.


All TypedArray subclasses also have the following instance properties:

TypedArray.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size for the different TypedArray objects.

Instance methodsThese methods are defined on the TypedArray prototype object and are thus shared by all TypedArray subclass instances.

TypedArray.prototype.at()

Takes an integer value and returns the item at that index. This method allows for negative integers, which count back from the last item.

TypedArray.prototype.copyWithin()

Copies a sequence of array elements within the array. See also Array.prototype.copyWithin().

TypedArray.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in the array. See also Array.prototype.entries().

TypedArray.prototype.every()

Tests whether all elements in the array pass the test provided by a function. See also Array.prototype.every().

TypedArray.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value. See also Array.prototype.fill().

TypedArray.prototype.filter()

Creates a new array with all of the elements of this array for which the provided filtering function returns true. See also Array.prototype.filter().

TypedArray.prototype.find()

Returns the first element in the array that satisfies a provided testing function, or undefined if no appropriate element is found. See also Array.prototype.find().

TypedArray.prototype.findIndex()

Returns the first index value in the array that has an element that satisfies a provided testing function, or -1 if no appropriate element was found. See also Array.prototype.findIndex().

TypedArray.prototype.findLast()

Returns the value of the last element in the array that satisfies a provided testing function, or undefined if no appropriate element is found. See also Array.prototype.findLast().

TypedArray.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies a provided testing function, or -1 if no appropriate element was found. See also Array.prototype.findLastIndex().

TypedArray.prototype.forEach()

Calls a function for each element in the array. See also Array.prototype.forEach().

TypedArray.prototype.includes()

Determines whether a typed array includes a certain element, returning true or false as appropriate. See also Array.prototype.includes().

TypedArray.prototype.indexOf()

Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found. See also Array.prototype.indexOf().

TypedArray.prototype.join()

Joins all elements of an array into a string. See also Array.prototype.join().

TypedArray.prototype.keys()

Returns a new array iterator that contains the keys for each index in the array. See also Array.prototype.keys().

TypedArray.prototype.lastIndexOf()

Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found. See also Array.prototype.lastIndexOf().

TypedArray.prototype.map()

Creates a new array with the results of calling a provided function on every element in this array. See also Array.prototype.map().

TypedArray.prototype.reduce()

Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value. See also Array.prototype.reduce().

TypedArray.prototype.reduceRight()

Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value. See also Array.prototype.reduceRight().

TypedArray.prototype.reverse()

Reverses the order of the elements of an array — the first becomes the last, and the last becomes the first. See also Array.prototype.reverse().

TypedArray.prototype.set()

Stores multiple values in the typed array, reading input values from a specified array.

TypedArray.prototype.slice()

Extracts a section of an array and returns a new array. See also Array.prototype.slice().

TypedArray.prototype.some()

Returns true if at least one element in this array satisfies the provided testing function. See also Array.prototype.some().

TypedArray.prototype.sort()

Sorts the elements of an array in place and returns the array. See also Array.prototype.sort().

TypedArray.prototype.subarray()

Returns a new TypedArray from the given start and end element index.

TypedArray.prototype.toLocaleString()

Returns a localized string representing the array and its elements. See also Array.prototype.toLocaleString().

TypedArray.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

TypedArray.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

TypedArray.prototype.toString()

Returns a string representing the array and its elements. See also Array.prototype.toString().

TypedArray.prototype.values()

Returns a new array iterator object that contains the values for each index in the array. See also Array.prototype.values().

TypedArray.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

TypedArray.prototype[@@iterator]()

Returns a new array iterator object that contains the values for each index in the array.

ExamplesProperty access
  You can reference elements in the array using standard array index syntax (that is,
  using bracket notation). However, getting or setting indexed properties on typed arrays
  will not search in the prototype chain for this property, even when the indices are out
  of bound. Indexed properties will consult the ArrayBuffer and will never
  look at object properties. You can still use named properties, just like with all
  objects.

js// Setting and getting using standard array syntax
const int16 = new Int16Array(2);
int16[0] = 42;
console.log(int16[0]); // 42

// Indexed properties on prototypes are not consulted (Fx 25)
Int8Array.prototype[20] = "foo";
new Int8Array(32)[20]; // 0
// even when out of bound
Int8Array.prototype[20] = "foo";
new Int8Array(8)[20]; // undefined
// or with negative integers
Int8Array.prototype[-1] = "foo";
new Int8Array(8)[-1]; // undefined

// Named properties are allowed, though (Fx 30)
Int8Array.prototype.foo = "bar";
new Int8Array(32).foo; // "bar"
Cannot be frozen
TypedArrays that aren't empty cannot be frozen, as their
  underlying ArrayBuffer could be mutated through another
  TypedArray view of the buffer. This would mean that the object
  would never genuinely be frozen.

jsconst i8 = Int8Array.of(1, 2, 3);
Object.freeze(i8);
// TypeError: Cannot freeze array buffer views with elements
ByteOffset must be aligned
  When constructing a TypedArray as a view onto an
  ArrayBuffer, the byteOffset argument must be aligned to its
  element size; in other words, the offset must be a multiple of
  BYTES_PER_ELEMENT.

jsconst i32 = new Int32Array(new ArrayBuffer(4), 1);
// RangeError: start offset of Int32Array should be a multiple of 4

jsconst i32 = new Int32Array(new ArrayBuffer(4), 0);
ByteLength must be aligned
  Like the byteOffset parameter, the byteLength property of an
  ArrayBuffer passed to a TypedArray's constructor
  must be a multiple of the constructor's BYTES_PER_ELEMENT.

jsconst i32 = new Int32Array(new ArrayBuffer(3));
// RangeError: byte length of Int32Array should be a multiple of 4

jsconst i32 = new Int32Array(new ArrayBuffer(4));
SpecificationsSpecificationECMAScript Language Specification # sec-typedarray-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of typed arrays in core-js
JavaScript typed arrays guide
ArrayBuffer
DataView
TextDecoder
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
TypeErrorThe TypeError object represents an error when an operation could not be performed, typically (but not exclusively) when a value is not of the expected type.
A TypeError may be thrown when:

an operand or argument passed to a function is incompatible with the type expected by that operator or function; or
when attempting to modify a value that cannot be changed; or
when attempting to use a value in an inappropriate way.

TypeError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
TypeError is a subclass of Error.Constructor
TypeError()

Creates a new TypeError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on TypeError.prototype and shared by all TypeError instances.

TypeError.prototype.constructor

The constructor function that created the instance object. For TypeError instances, the initial value is the TypeError constructor.

TypeError.prototype.name

Represents the name for the type of error. For TypeError.prototype.name, the initial value is "TypeError".

Instance methodsInherits instance methods from its parent Error.ExamplesCatching a TypeErrorjstry {
  null.f();
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "null has no properties"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
Creating a TypeErrorjstry {
  throw new TypeError("Hello");
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript Language Specification # sec-native-error-types-used-in-this-standard-typeerrorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on May 26, 2023 by MDN contributors.
Uint16ArrayThe Uint16Array typed array represents an array of 16-bit unsigned integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Uint16Array is a subclass of the hidden TypedArray class.Constructor
Uint16Array()

Creates a new Uint16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Uint16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Uint16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Uint16Array.prototype and shared by all Uint16Array instances.

Uint16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Uint16Array.

Uint16Array.prototype.constructor

The constructor function that created the instance object. For Uint16Array instances, the initial value is the Uint16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Uint16Arrayjs// From a length
const uint16 = new Uint16Array(2);
uint16[0] = 42;
console.log(uint16[0]); // 42
console.log(uint16.length); // 2
console.log(uint16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Uint16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Uint16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(16);
const z = new Uint16Array(buffer, 2, 4);
console.log(z.byteOffset); // 2

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const uint16FromIterable = new Uint16Array(iterable);
console.log(uint16FromIterable);
// Uint16Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Uint16Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Uint32ArrayThe Uint32Array typed array represents an array of 32-bit unsigned integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Uint32Array is a subclass of the hidden TypedArray class.Constructor
Uint32Array()

Creates a new Uint32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Uint32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Uint32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Uint32Array.prototype and shared by all Uint32Array instances.

Uint32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Uint32Array.

Uint32Array.prototype.constructor

The constructor function that created the instance object. For Uint32Array instances, the initial value is the Uint32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Uint32Arrayjs// From a length
const uint32 = new Uint32Array(2);
uint32[0] = 42;
console.log(uint32[0]); // 42
console.log(uint32.length); // 2
console.log(uint32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Uint32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Uint32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Uint32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const uint32FromIterable = new Uint32Array(iterable);
console.log(uint32FromIterable);
// Uint32Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Uint32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Uint8ArrayThe Uint8Array typed array represents an array of 8-bit unsigned integers. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Uint8Array is a subclass of the hidden TypedArray class.Constructor
Uint8Array()

Creates a new Uint8Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Uint8Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of Uint8Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Uint8Array.prototype and shared by all Uint8Array instances.

Uint8Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of a Uint8Array.

Uint8Array.prototype.constructor

The constructor function that created the instance object. For Uint8Array instances, the initial value is the Uint8Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Uint8Arrayjs// From a length
const uint8 = new Uint8Array(2);
uint8[0] = 42;
console.log(uint8[0]); // 42
console.log(uint8.length); // 2
console.log(uint8.BYTES_PER_ELEMENT); // 1

// From an array
const x = new Uint8Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Uint8Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(8);
const z = new Uint8Array(buffer, 1, 4);
console.log(z.byteOffset); // 1

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const uint8FromIterable = new Uint8Array(iterable);
console.log(uint8FromIterable);
// Uint8Array [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Uint8Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Uint8ClampedArrayThe Uint8ClampedArray typed array represents an array of 8-bit unsigned integers clamped to 0–255. The contents are initialized to 0. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Uint8ClampedArray is a subclass of the hidden TypedArray class.Constructor
Uint8ClampedArray()

Creates a new Uint8ClampedArray object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Uint8ClampedArray.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of Uint8ClampedArray.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Uint8ClampedArray.prototype and shared by all Uint8ClampedArray instances.

Uint8ClampedArray.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of a Uint8ClampedArray.

Uint8ClampedArray.prototype.constructor

The constructor function that created the instance object. For Uint8ClampedArray instances, the initial value is the Uint8ClampedArray constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Uint8ClampedArrayjs// From a length
const uint8c = new Uint8ClampedArray(2);
uint8c[0] = 42;
uint8c[1] = 1337;
console.log(uint8c[0]); // 42
console.log(uint8c[1]); // 255 (clamped)
console.log(uint8c.length); // 2
console.log(uint8c.BYTES_PER_ELEMENT); // 1

// From an array
const x = new Uint8ClampedArray([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Uint8ClampedArray(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(8);
const z = new Uint8ClampedArray(buffer, 1, 4);
console.log(z.byteOffset); // 1

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const uint8cFromIterable = new Uint8ClampedArray(iterable);
console.log(uint8cFromIterable);
// Uint8ClampedArray [1, 2, 3]
SpecificationsSpecificationECMAScript Language Specification # table-49Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of Uint8ClampedArray in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
undefined
  The undefined global property represents the primitive
  value undefined. It is one of JavaScript's
  primitive types.
Try itValueThe primitive value undefined.


Property attributes of undefined




Writable
no


Enumerable
no


Configurable
no


Descriptionundefined is a property of the global object. That is, it is a variable in global scope.
In all non-legacy browsers, undefined is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.

  A variable that has not been assigned a value is of type undefined. A
  method or statement also returns undefined if the variable that is being
  evaluated does not have an assigned value. A function returns undefined if
  a value was not returned.


Note: While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved word), doing so is a very bad idea that will make your code difficult to maintain and debug.
js// DON'T DO THIS

(() => {
  const undefined = "foo";
  console.log(undefined, typeof undefined); // foo string
})();

((undefined) => {
  console.log(undefined, typeof undefined); // foo string
})("foo");

ExamplesStrict equality and undefined
  You can use undefined and the strict equality and inequality operators to
  determine whether a variable has a value. In the following code, the variable
  x is not initialized, and the if statement evaluates to true.

jslet x;
if (x === undefined) {
  // these statements execute
} else {
  // these statements do not execute
}



Note: The strict equality operator (as opposed to the
    standard equality operator) must be used here, because
    x == undefined also checks whether x is null,
    while strict equality doesn't. This is because null is not equivalent to
    undefined.
  
See Equality comparison and sameness for details.
typeof operator and undefinedAlternatively, typeof can be used:
jslet x;
if (typeof x === "undefined") {
  // these statements execute
}


  One reason to use typeof is that it does not throw an
  error if the variable has not been declared.

js// x has not been declared before
// evaluates to true without errors
if (typeof x === "undefined") {
  // these statements execute
}

// Throws a ReferenceError
if (x === undefined) {
}


  However, there is another alternative. JavaScript is a statically scoped language, so
  knowing if a variable is declared can be read by seeing whether it is declared in an
  enclosing context.


  The global scope is bound to the global object, so
  checking the existence of a variable in the global context can be done by checking the
  existence of a property on the global object, using the
  in operator, for instance:

jsif ("x" in window) {
  // These statements execute only if x is defined globally
}
void operator and undefinedThe void operator is a third alternative.
jslet x;
if (x === void 0) {
  // these statements execute
}

// y has not been declared before
if (y === void 0) {
  // throws Uncaught ReferenceError: y is not defined
}
SpecificationsSpecificationECMAScript Language Specification # sec-undefinedBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
JavaScript data types and data structures
null
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
unescape()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note: unescape() is a non-standard function implemented by browsers and was only standardized for cross-engine compatibility. It is not required to be implemented by all JavaScript engines and may not work everywhere. Use decodeURIComponent() or decodeURI() if possible.

The unescape() function computes a new string in which hexadecimal escape sequences are replaced with the characters that they represent. The escape sequences might be introduced by a function like escape().Syntaxjsunescape(str)
Parameters
str

A string to be decoded.

Return valueA new string in which certain characters have been unescaped.Descriptionunescape() is a function property of the global object.
The unescape() function replaces any escape sequence with the character that it represents. Specifically, it replaces any escape sequence of the form %XX or %uXXXX (where X represents one hexadecimal digit) with the character that has the hexadecimal value XX/XXXX. If the escape sequence is not a valid escape sequence (for example, if % is followed by one or no hex digit), it is left as-is.

Note: This function was used mostly for URL encoding and is partly based on the escape format in RFC 1738. The unescape() function does not evaluate escape sequences in string literals. You can replace \xXX with %XX and \uXXXX with %uXXXX to get a string that can be handled by unescape().
ExamplesUsing unescape()jsunescape("abc123"); // "abc123"
unescape("%E4%F6%FC"); // "äöü"
unescape("%u0107"); // "ć"
SpecificationsSpecificationECMAScript Language Specification # sec-unescape-stringBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of unescape in core-js
decodeURI
decodeURIComponent
escape
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on May 16, 2023 by MDN contributors.
URIErrorThe URIError object represents an error when a global URI handling function was used in a wrong way.
URIError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
URIError is a subclass of Error.Constructor
URIError()

Creates a new URIError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on URIError.prototype and shared by all URIError instances.

URIError.prototype.constructor

The constructor function that created the instance object. For URIError instances, the initial value is the URIError constructor.

URIError.prototype.name

Represents the name for the type of error. For URIError.prototype.name, the initial value is "URIError".

Instance methodsInherits instance methods from its parent Error.ExamplesCatching an URIErrorjstry {
  decodeURIComponent("%");
} catch (e) {
  console.log(e instanceof URIError); // true
  console.log(e.message); // "malformed URI sequence"
  console.log(e.name); // "URIError"
  console.log(e.stack); // Stack of the error
}
Creating an URIErrorjstry {
  throw new URIError("Hello");
} catch (e) {
  console.log(e instanceof URIError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "URIError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript Language Specification # sec-native-error-types-used-in-this-standard-urierrorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
WeakMapA WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.
WeakMap allows associating data to objects in a way that doesn't prevent the key objects from being collected, even if the values reference the keys. However, a WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration; if a WeakMap exposed any method to obtain a list of its keys, the list would depend on the state of garbage collection, introducing non-determinism. If you want to have a list of keys, you should use a Map rather than a WeakMap.
You can learn more about WeakMap in the WeakMap object section of the Keyed collections guide.DescriptionKeys of WeakMaps must be garbage-collectable. Most primitive data types can be arbitrarily created and don't have a lifetime, so they cannot be used as keys. Objects and non-registered symbols can be used as keys because they are garbage-collectable.Why WeakMap?A map API could be implemented in JavaScript with two arrays (one for keys, one for values) shared by the four API methods. Setting elements on this map would involve pushing a key and value onto the end of each of those arrays simultaneously. As a result, the indices of the key and value would correspond to both arrays. Getting values from the map would involve iterating through all keys to find a match, then using the index of this match to retrieve the corresponding value from the array of values.
Such an implementation would have two main inconveniences:

The first one is an O(n) set and search (n being the number of keys in the map) since both operations must iterate through the list of keys to find a matching value.
The second inconvenience is a memory leak because the arrays ensure that references to each key and each value are maintained indefinitely. These references prevent the keys from being garbage collected, even if there are no other references to the object. This would also prevent the corresponding values from being garbage collected.

By contrast, in a WeakMap, a key object refers strongly to its contents as long as the key is not garbage collected, but weakly from then on. As such, a WeakMap:

does not prevent garbage collection, which eventually removes references to the key object
allows garbage collection of any values if their key objects are not referenced from somewhere other than a WeakMap

A WeakMap can be a particularly useful construct when mapping keys to information about the key that is valuable only if the key has not been garbage collected.
But because a WeakMap doesn't allow observing the liveness of its keys, its keys are not enumerable. There is no method to obtain a list of the keys. If there were, the list would depend on the state of garbage collection, introducing non-determinism. If you want to have a list of keys, you should use a Map.Constructor
WeakMap()

Creates a new WeakMap object.

Instance propertiesThese properties are defined on WeakMap.prototype and shared by all WeakMap instances.

WeakMap.prototype.constructor

The constructor function that created the instance object. For WeakMap instances, the initial value is the WeakMap constructor.

WeakMap.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "WeakMap". This property is used in Object.prototype.toString().

Instance methods
WeakMap.prototype.delete()

Removes any value associated to the key. WeakMap.prototype.has(key) will return false afterwards.

WeakMap.prototype.get()

Returns the value associated to the key, or undefined if there is none.

WeakMap.prototype.has()

Returns a Boolean asserting whether a value has been associated to the key in the WeakMap object or not.

WeakMap.prototype.set()

Sets the value for the key in the WeakMap object. Returns the WeakMap object.

ExamplesUsing WeakMapjsconst wm1 = new WeakMap();
const wm2 = new WeakMap();
const wm3 = new WeakMap();
const o1 = {};
const o2 = function () {};
const o3 = window;

wm1.set(o1, 37);
wm1.set(o2, "azerty");
wm2.set(o1, o2); // a value can be anything, including an object or a function
wm2.set(o2, undefined);
wm2.set(wm1, wm2); // keys and values can be any objects. Even WeakMaps!

wm1.get(o2); // "azerty"
wm2.get(o2); // undefined, because that is the set value
wm2.get(o3); // undefined, because there is no key for o3 on wm2

wm1.has(o2); // true
wm2.has(o2); // true (even if the value itself is 'undefined')
wm2.has(o3); // false

wm3.set(o1, 37);
wm3.get(o1); // 37

wm1.has(o1); // true
wm1.delete(o1);
wm1.has(o1); // false
Implementing a WeakMap-like class with a .clear() methodjsclass ClearableWeakMap {
  #wm;
  constructor(init) {
    this.#wm = new WeakMap(init);
  }
  clear() {
    this.#wm = new WeakMap();
  }
  delete(k) {
    return this.#wm.delete(k);
  }
  get(k) {
    return this.#wm.get(k);
  }
  has(k) {
    return this.#wm.has(k);
  }
  set(k, v) {
    this.#wm.set(k, v);
    return this;
  }
}
Emulating private membersDevelopers can use a WeakMap to associate private data to an object, with the following benefits:

Compared to a Map, a WeakMap does not hold strong references to the object used as the key, so the metadata shares the same lifetime as the object itself, avoiding memory leaks.
Compared to using non-enumerable and/or Symbol properties, a WeakMap is external to the object and there is no way for user code to retrieve the metadata through reflective methods like Object.getOwnPropertySymbols.
Compared to a closure, the same WeakMap can be reused for all instances created from a constructor, making it more memory-efficient, and allows different instances of the same class to read the private members of each other.

jslet Thing;

{
  const privateScope = new WeakMap();
  let counter = 0;

  Thing = function () {
    this.someProperty = "foo";

    privateScope.set(this, {
      hidden: ++counter,
    });
  };

  Thing.prototype.showPublic = function () {
    return this.someProperty;
  };

  Thing.prototype.showPrivate = function () {
    return privateScope.get(this).hidden;
  };
}

console.log(typeof privateScope);
// "undefined"

const thing = new Thing();

console.log(thing);
// Thing {someProperty: "foo"}

thing.showPublic();
// "foo"

thing.showPrivate();
// 1

This is roughly equivalent to the following, using private fields:
jsclass Thing {
  static #counter = 0;
  #hidden;
  constructor() {
    this.someProperty = "foo";
    this.#hidden = ++Thing.#counter;
  }
  showPublic() {
    return this.someProperty;
  }
  showPrivate() {
    return this.#hidden;
  }
}

console.log(thing);
// Thing {someProperty: "foo"}

thing.showPublic();
// "foo"

thing.showPrivate();
// 1
Associating metadataA WeakMap can be used to associate metadata with an object, without affecting the lifetime of the object itself. This is very similar to the private members example, since private members are also modelled as external metadata that doesn't participate in prototypical inheritance.
This use case can be extended to already-created objects. For example, on the web, we may want to associate extra data with a DOM element, which the DOM element may access later. A common approach is to attach the data as a property:
jsconst buttons = document.querySelectorAll(".button");
buttons.forEach((button) => {
  button.clicked = false;
  button.addEventListener("click", () => {
    button.clicked = true;
    const currentButtons = [...document.querySelectorAll(".button")];
    if (currentButtons.every((button) => button.clicked)) {
      console.log("All buttons have been clicked!");
    }
  });
});

This approach works, but it has a few pitfalls:

The clicked property is enumerable, so it will show up in Object.keys(button), for...in loops, etc. This can be mitigated by using Object.defineProperty(), but that makes the code more verbose.
The clicked property is a normal string property, so it can be accessed and overwritten by other code. This can be mitigated by using a Symbol key, but the key would still be accessible via Object.getOwnPropertySymbols().

Using a WeakMap fixes these:
jsconst buttons = document.querySelectorAll(".button");
const clicked = new WeakMap();
buttons.forEach((button) => {
  clicked.set(button, false);
  button.addEventListener("click", () => {
    clicked.set(button, true);
    const currentButtons = [...document.querySelectorAll(".button")];
    if (currentButtons.every((button) => clicked.get(button))) {
      console.log("All buttons have been clicked!");
    }
  });
});

Here, only code that has access to clicked knows the clicked state of each button, and external code can't modify the states. In addition, if any of the buttons gets removed from the DOM, the associated metadata will automatically get garbage-collected.CachingYou can associate objects passed to a function with the result of the function, so that if the same object is passed again, the cached result can be returned without re-executing the function. This is useful if the function is pure (i.e. it doesn't mutate any outside objects or cause other observable side effects).
jsconst cache = new WeakMap();
function handleObjectValues(obj) {
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  const result = Object.values(obj).map(heavyComputation);
  cache.set(obj, result);
  return result;
}

This only works if your function's input is an object. Moreover, even if the input is never passed in again, the result still remains forever in the cache. A more effective way is to use a Map paired with WeakRef objects, which allows you to associate any type of input value with its respective (potentially large) computation result. See the WeakRefs and FinalizationRegistry example for more details.SpecificationsSpecificationECMAScript Language Specification # sec-weakmap-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of WeakMap in core-js
Keyed collections
Hiding Implementation Details with ECMAScript 6 WeakMaps by Nick Fitzgerald (2014)
Map
Set
WeakSet
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
WeakRefA WeakRef object lets you hold a weak reference to another object, without preventing that object from getting garbage-collected.DescriptionA WeakRef object contains a weak reference to an object, which is called its target or referent. A weak reference to an object is a reference that does not prevent the object from being reclaimed by the garbage collector. In contrast, a normal (or strong) reference keeps an object in memory. When an object no longer has any strong references to it, the JavaScript engine's garbage collector may destroy the object and reclaim its memory. If that happens, you can't get the object from a weak reference anymore.
Because non-registered symbols are also garbage collectable, they can also be used as the target of a WeakRef object. However, the use case of this is limited.Avoid where possibleCorrect use of WeakRef takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.
Here are some specific points included by the authors in the proposal that introduced WeakRef:

Garbage collectors are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:

One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.
Garbage collection work can be split up over time using incremental and concurrent techniques.
Various runtime heuristics can be used to balance memory usage, responsiveness.
The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).
Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.
Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.

Notes on WeakRefs
If your code has just created a WeakRef for a target object, or has gotten a target object from a WeakRef's deref method, that target object will not be reclaimed until the end of the current JavaScript job (including any promise reaction jobs that run at the end of a script job). That is, you can only "see" an object get reclaimed between turns of the event loop. This is primarily to avoid making the behavior of any given JavaScript engine's garbage collector apparent in code — because if it were, people would write code relying on that behavior, which would break when the garbage collector's behavior changed. (Garbage collection is a hard problem; JavaScript engine implementers are constantly refining and improving how it works.)
If multiple WeakRefs have the same target, they're consistent with one another. The result of calling deref on one of them will match the result of calling deref on another of them (in the same job), you won't get the target object from one of them but undefined from another.
If the target of a WeakRef is also in a FinalizationRegistry, the WeakRef's target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls deref on a WeakRef for the object, it will receive undefined.
You cannot change the target of a WeakRef, it will always only ever be the original target object or undefined when that target has been reclaimed.
A WeakRef might never return undefined from deref, even if nothing strongly holds the target, because the garbage collector may never decide to reclaim the object.
Constructor
WeakRef()

Creates a new WeakRef object.

Instance propertiesThese properties are defined on WeakRef.prototype and shared by all WeakRef instances.

WeakRef.prototype.constructor Optional

The constructor function that created the instance object. For WeakRef instances, the initial value is the WeakRef constructor.

Note: This property is marked as "normative optional" in the specification, which means a conforming implementation may not expose the constructor property. This prevents arbitrary code from obtaining the WeakRef constructor and being able to observe garbage collection. However, all major engines do expose it by default.


WeakRef.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "WeakRef". This property is used in Object.prototype.toString().

Instance methods
WeakRef.prototype.deref()

Returns the WeakRef object's target object, or undefined if the target object has been reclaimed.

ExamplesUsing a WeakRef objectThis example starts a counter shown in a DOM element, stopping when the element doesn't exist anymore:
jsclass Counter {
  constructor(element) {
    // Remember a weak reference to the DOM element
    this.ref = new WeakRef(element);
    this.start();
  }

  start() {
    if (this.timer) {
      return;
    }

    this.count = 0;

    const tick = () => {
      // Get the element from the weak reference, if it still exists
      const element = this.ref.deref();
      if (element) {
        element.textContent = ++this.count;
      } else {
        // The element doesn't exist anymore
        console.log("The element is gone.");
        this.stop();
        this.ref = null;
      }
    };

    tick();
    this.timer = setInterval(tick, 1000);
  }

  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = 0;
    }
  }
}

const counter = new Counter(document.getElementById("counter"));
setTimeout(() => {
  document.getElementById("counter").remove();
}, 5000);
SpecificationsSpecificationECMAScript Language Specification # sec-weak-ref-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
FinalizationRegistry
WeakSet
WeakMap
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
WeakSetA WeakSet is a collection of garbage-collectable values, including objects and non-registered symbols. A value in the WeakSet may only occur once. It is unique in the WeakSet's collection.DescriptionValues of WeakSets must be garbage-collectable. Most primitive data types can be arbitrarily created and don't have a lifetime, so they cannot be stored. Objects and non-registered symbols can be stored because they are garbage-collectable.
The main differences to the Set object are:

WeakSets are collections of objects and symbols only. They cannot contain arbitrary values of any type, as Sets can.
The WeakSet is weak, meaning references to objects in a WeakSet are held weakly. If no other references to a value stored in the WeakSet exist, those values can be garbage collected.
    
Note: This also means that there is no list of current values stored in the collection. WeakSets are not enumerable.


Use case: Detecting circular referencesFunctions that call themselves recursively need a way of guarding against circular data structures by tracking which objects have already been processed.
WeakSets are ideal for this purpose:
js// Execute a callback on everything stored inside an object
function execRecursively(fn, subject, _refs = new WeakSet()) {
  // Avoid infinite recursion
  if (_refs.has(subject)) {
    return;
  }

  fn(subject);
  if (typeof subject === "object" && subject) {
    _refs.add(subject);
    for (const key in subject) {
      execRecursively(fn, subject[key], _refs);
    }
    _refs.delete(subject);
  }
}

const foo = {
  foo: "Foo",
  bar: {
    bar: "Bar",
  },
};

foo.bar.baz = foo; // Circular reference!
execRecursively((obj) => console.log(obj), foo);

Here, a WeakSet is created on the first run, and passed along with every subsequent function call (using the internal _refs parameter).
The number of objects or their traversal order is immaterial, so a WeakSet is more suitable (and performant) than a Set for tracking object references, especially if a very large number of objects is involved.Constructor
WeakSet()

Creates a new WeakSet object.

Instance propertiesThese properties are defined on WeakSet.prototype and shared by all WeakSet instances.

WeakSet.prototype.constructor

The constructor function that created the instance object. For WeakSet instances, the initial value is the WeakSet constructor.

WeakSet.prototype[@@toStringTag]

The initial value of the @@toStringTag property is the string "WeakSet". This property is used in Object.prototype.toString().

Instance methods
WeakSet.prototype.add()

Appends value to the WeakSet object.

WeakSet.prototype.delete()

Removes value from the WeakSet. WeakSet.prototype.has(value) will return false afterwards.

WeakSet.prototype.has()

Returns a boolean asserting whether value is present in the WeakSet object or not.

ExamplesUsing the WeakSet objectjsconst ws = new WeakSet();
const foo = {};
const bar = {};

ws.add(foo);
ws.add(bar);

ws.has(foo); // true
ws.has(bar); // true

ws.delete(foo); // removes foo from the set
ws.has(foo); // false, foo has been removed
ws.has(bar); // true, bar is retained

Note that foo !== bar. While they are similar objects, they are not the same object. And so they are both added to the set.SpecificationsSpecificationECMAScript Language Specification # sec-weakset-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of WeakSet in core-js
Map
Set
WeakMap
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
Expressions and operatorsThis chapter documents all the JavaScript language operators, expressions and keywords.Expressions and operators by categoryFor an alphabetical listing see the sidebar on the left.Primary expressionsBasic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators).

this

The this keyword refers to a special property of an execution context.

Literals

Basic null, boolean, number, and string literals.

[]

Array initializer/literal syntax.

{}

Object initializer/literal syntax.

function

The function keyword defines a function expression.

class

The class keyword defines a class expression.

function*

The function* keyword defines a generator function expression.

async function

The async function defines an async function expression.

async function*

The async function* keywords define an async generator function expression.

/ab+c/i

Regular expression literal syntax.

`string`

Template literal syntax.

( )

Grouping operator.

Left-hand-side expressionsLeft values are the destination of an assignment.

Property accessors

Member operators provide access to a property or method of an object (object.property and object["property"]).

?.

The optional chaining operator returns undefined instead of causing an error if a reference is nullish (null or undefined).

new

The new operator creates an instance of a constructor.

new.target

In constructors, new.target refers to the constructor that was invoked by new.

import.meta

An object exposing context-specific metadata to a JavaScript module.

super

The super keyword calls the parent constructor or allows accessing properties of the parent object.

import()

The import() syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

Increment and decrementPostfix/prefix increment and postfix/prefix decrement operators.

A++

Postfix increment operator.

A--

Postfix decrement operator.

++A

Prefix increment operator.

--A

Prefix decrement operator.

Unary operatorsA unary operation is an operation with only one operand.

delete

The delete operator deletes a property from an object.

void

The void operator evaluates an expression and discards its return value.

typeof

The typeof operator determines the type of a given object.

+

The unary plus operator converts its operand to Number type.

-

The unary negation operator converts its operand to Number type and then negates it.

~

Bitwise NOT operator.

!

Logical NOT operator.

await

Pause and resume an async function and wait for the promise's fulfillment/rejection.

Arithmetic operatorsArithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

**

Exponentiation operator.

*

Multiplication operator.

/

Division operator.

%

Remainder operator.

+ (Plus)

Addition operator.

-

Subtraction operator.

Relational operatorsA comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

< (Less than)

Less than operator.

> (Greater than)

Greater than operator.

<=

Less than or equal operator.

>=

Greater than or equal operator.

instanceof

The instanceof operator determines whether an object is an instance of another object.

in

The in operator determines whether an object has a given property.



Note: => is not an operator, but the notation for Arrow functions.
Equality operatorsThe result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

==

Equality operator.

!=

Inequality operator.

===

Strict equality operator.

!==

Strict inequality operator.

Bitwise shift operatorsOperations to shift all bits of the operand.

<<

Bitwise left shift operator.

>>

Bitwise right shift operator.

>>>

Bitwise unsigned right shift operator.

Binary bitwise operatorsBitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

&

Bitwise AND.

|

Bitwise OR.

^

Bitwise XOR.

Binary logical operatorsLogical operators implement boolean (logical) values and have short-circuiting behavior.

&&

Logical AND.

||

Logical OR.

??

Nullish Coalescing Operator.

Conditional (ternary) operator
(condition ? ifTrue : ifFalse)

The conditional operator returns one of two values based on the logical value of the condition.

Assignment operatorsAn assignment operator assigns a value to its left operand based on the value of its right operand.

=

Assignment operator.

*=

Multiplication assignment.

/=

Division assignment.

%=

Remainder assignment.

+=

Addition assignment.

-=

Subtraction assignment

<<=

Left shift assignment.

>>=

Right shift assignment.

>>>=

Unsigned right shift assignment.

&=

Bitwise AND assignment.

^=

Bitwise XOR assignment.

|=

Bitwise OR assignment.

**=

Exponentiation assignment.

&&=

Logical AND assignment.

||=

Logical OR assignment.

??=

Nullish coalescing assignment.

[a, b] = arr, { a, b } = obj

Destructuring assignment allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

Yield operators
yield

Pause and resume a generator function.

yield*

Delegate to another generator function or iterable object.

Spread syntax
...obj

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

Comma operator
,

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

SpecificationsSpecificationECMAScript Language Specification # sec-addition-operator-plusECMAScript Language Specification # sec-assignment-operatorsECMAScript Language Specification # sec-async-function-definitionsECMAScript Language Specification # sec-async-generator-function-definitionsECMAScript Language Specification # prod-BitwiseANDExpressionECMAScript Language Specification # sec-bitwise-not-operatorECMAScript Language Specification # prod-BitwiseORExpressionECMAScript Language Specification # prod-BitwiseXORExpressionECMAScript Language Specification # sec-class-definitionsECMAScript Language Specification # sec-comma-operatorECMAScript Language Specification # sec-conditional-operatorECMAScript Language Specification # sec-postfix-decrement-operatorECMAScript Language Specification # sec-delete-operatorECMAScript Language Specification # sec-destructuring-assignmentECMAScript Language Specification # sec-destructuring-binding-patternsECMAScript Language Specification # sec-multiplicative-operatorsECMAScript Language Specification # sec-equality-operatorsECMAScript Language Specification # sec-exp-operatorECMAScript Language Specification # sec-function-definitionsECMAScript Language Specification # sec-generator-function-definitionsECMAScript Language Specification # sec-relational-operatorsECMAScript Language Specification # sec-grouping-operatorECMAScript Language Specification # sec-import-callsECMAScript Language Specification # prod-ImportMetaHTML Standard # hostgetimportmetapropertiesECMAScript Language Specification # sec-postfix-increment-operatorECMAScript Language Specification # sec-left-shift-operatorECMAScript Language Specification # prod-LogicalANDExpressionECMAScript Language Specification # sec-logical-not-operatorECMAScript Language Specification # prod-LogicalORExpressionECMAScript Language Specification # sec-new-operatorECMAScript Language Specification # sec-built-in-function-objectsECMAScript Language Specification # sec-null-valueECMAScript Language Specification # prod-CoalesceExpressionECMAScript Language Specification # sec-object-initializerECMAScript Language Specification # prod-OptionalExpressionECMAScript Language Specification # sec-property-accessorsECMAScript Language Specification # sec-signed-right-shift-operatorECMAScript Language Specification # prod-SpreadElementECMAScript Language Specification # prod-ArgumentListECMAScript Language Specification # prod-PropertyDefinitionECMAScript Language Specification # sec-subtraction-operator-minusECMAScript Language Specification # sec-super-keywordECMAScript Language Specification # sec-this-keywordECMAScript Language Specification # sec-typeof-operatorECMAScript Language Specification # sec-unary-minus-operatorECMAScript Language Specification # sec-unary-plus-operatorECMAScript Language Specification # sec-unsigned-right-shift-operatorECMAScript Language Specification # sec-void-operatorECMAScript Language Specification # prod-YieldExpressionECMAScript Language Specification # sec-generator-function-definitions-runtime-semantics-evaluationBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Operator precedence
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Addition (+)The addition (+) operator produces the sum of numeric operands or string concatenation.Try itSyntaxjsx + y
DescriptionThe + operator is overloaded for two distinct operations: numeric addition and string concatenation. When evaluating, it first coerces both operands to primitives. Then, the two operands' types are tested:

If one side is a string, the other operand is also converted to a string and they are concatenated.
If they are both BigInts, BigInt addition is performed. If one side is a BigInt but the other is not, a TypeError is thrown.
Otherwise, both sides are converted to numbers, and numeric addition is performed.

String concatenation is often thought to be equivalent with template literals or String.prototype.concat(), but they are not. Addition coerces the expression to a primitive, which calls valueOf() in priority; on the other hand, template literals and concat() coerce the expression to a string, which calls toString() in priority. If the expression has a @@toPrimitive method, string concatenation calls it with "default" as hint, while template literals use "string". This is important for objects that have different string and primitive representations — such as Temporal, whose valueOf() method throws.
jsconst t = Temporal.Now.instant();
"" + t; // Throws TypeError
`${t}`; // '2022-07-31T04:48:56.113918308Z'
"".concat(t); // '2022-07-31T04:48:56.113918308Z'

You are advised to not use "" + x to perform string coercion.ExamplesNumber additionjs// Number + Number -> addition
1 + 2; // 3

// Boolean + Number -> addition
true + 1; // 2

// Boolean + Boolean -> addition
false + false; // 0
BigInt additionjs// BigInt + BigInt -> addition
1n + 2n; // 3n

// BigInt + Number -> throws TypeError
1n + 2; // TypeError: Cannot mix BigInt and other types, use explicit conversions

// To add a BigInt to a non-BigInt, convert either operand
1n + BigInt(2); // 3n
Number(1n) + 2; // 3
String concatenationjs// String + String -> concatenation
"foo" + "bar"; // "foobar"

// Number + String -> concatenation
5 + "foo"; // "5foo"

// String + Boolean -> concatenation
"foo" + false; // "foofalse"

// String + Number -> concatenation
"2" + 2; // "22"
SpecificationsSpecificationECMAScript Language Specification # sec-addition-operator-plusBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Subtraction (-)
Division (/)
Multiplication (*)
Remainder (%)
Exponentiation (**)
Increment (++)
Decrement (--)
Unary negation (-)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Addition assignment (+=)The addition assignment (+=) operator performs addition (which is either numeric addition or string concatenation) on the two operands and assigns the result to the left operand.Try itSyntaxjsx += y
Descriptionx += y is equivalent to x = x + y, except that the expression x is only evaluated once.ExamplesUsing addition assignmentjslet baz = true;

// Boolean + Number -> addition
baz += 1; // 2

// Number + Boolean -> addition
baz += false; // 2

jslet foo = "foo";

// String + Boolean -> concatenation
foo += false; // "foofalse"

// String + String -> concatenation
foo += "bar"; // "foofalsebar"

jslet bar = 5;

// Number + Number -> addition
bar += 2; // 7

// Number + String -> concatenation
bar += "foo"; // "7foo"

jslet x = 1n;

// BigInt + BigInt -> addition
x += 2n; // 3n

// BigInt + Number -> throws TypeError
x += 1; // TypeError: Cannot mix BigInt and other types, use explicit conversions
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Addition (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Assignment (=)The assignment (=) operator is used to assign a value to a variable or property. The assignment expression itself has a value, which is the assigned value. This allows multiple assignments to be chained in order to assign a single value to multiple variables.Try itSyntaxjsx = y
Parameters
x

A valid assignment target, including an identifier or a property accessor. It can also be a destructuring assignment pattern.

y

An expression specifying the value to be assigned to x.

Return valueThe value of y.Exceptions
ReferenceError

Thrown in strict mode if assigning to an identifier that is not declared in the scope.

TypeError

Thrown in strict mode if assigning to a property that is not modifiable.

DescriptionThe assignment operator is completely different from the equals (=) sign used as syntactic separators in other locations, which include:

Initializers of var, let, and const declarations
Default values of destructuring
Default parameters
Initializers of class fields

All these places accept an assignment expression on the right-hand side of the =, so if you have multiple equals signs chained together:
jsconst x = y = 5;

This is equivalent to:
jsconst x = (y = 5);

Which means y must be a pre-existing variable, and x is a newly declared const variable. y is assigned the value 5, and x is initialized with the value of the y = 5 expression, which is also 5. If y is not a pre-existing variable, a global variable y is implicitly created in non-strict mode, or a ReferenceError is thrown in strict mode. To declare two variables within the same declaration, use:
jsconst x = 5,
  y = 5;
ExamplesSimple assignment and chainingjslet x = 5;
let y = 10;
let z = 25;

x = y; // x is 10
x = y = z; // x, y and z are all 25
Value of assignment expressionsThe assignment expression itself evaluates to the value of the right-hand side, so you can log the value and assign to a variable at the same time.
jslet x;
console.log(x); // undefined
console.log(x = 2); // 2
console.log(x); // 2
Unqualified identifier assignmentThe global object sits at the top of the scope chain. When attempting to resolve a name to a value, the scope chain is searched. This means that properties on the global object are conveniently visible from every scope, without having to qualify the names with globalThis. or window. or global..
Because the global object has a String property (Object.hasOwn(globalThis, "String")), you can use the following code:
jsfunction foo() {
  String("s"); // The function `String` is globally available
}

So the global object will ultimately be searched for unqualified identifiers. You don't have to type globalThis.String; you can just type the unqualified String. To make this feature more conceptually consistent, assignment to unqualified identifiers will assume you want to create a property with that name on the global object (with globalThis. omitted), if there is no variable of the same name declared in the scope chain.
jsfoo = "f"; // In non-strict mode, assumes you want to create a property named `foo` on the global object
Object.hasOwn(globalThis, "foo"); // true

In strict mode, assignment to an unqualified identifier in strict mode will result in a ReferenceError, to avoid the accidental creation of properties on the global object.
Note that the implication of the above is that, contrary to popular misinformation, JavaScript does not have implicit or undeclared variables. It just conflates the global object with the global scope and allows omitting the global object qualifier during property creation.Assignment with destructuringThe left-hand side of can also be an assignment pattern. This allows assigning to multiple variables at once.
jsconst result = /(a+)(b+)(c+)/.exec("aaabcc");
let a = "",
  b = "",
  c = "";
[, a, b, c] = result;
console.log(a, b, c); // "aaa" "b" "cc"

For more information, see Destructuring assignment.SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Destructuring assignment
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 1, 2023 by MDN contributors.
async function expressionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2017.Learn moreSee full compatibilityReport feedbackThe async function keywords can be used to define an async function inside an expression.
You can also define async functions using the async function declaration or the arrow syntax.Syntaxjsasync function (param0) {
  statements
}
async function (param0, param1) {
  statements
}
async function (param0, param1, /* …, */ paramN) {
  statements
}

async function name(param0) {
  statements
}
async function name(param0, param1) {
  statements
}
async function name(param0, param1, /* …, */ paramN) {
  statements
}


Note: An expression statement cannot begin with the keywords async function to avoid ambiguity with an async function declaration. The async function keywords only begin an expression when they appear in a context that cannot accept statements.
Parameters
name Optional

The function name. Can be omitted, in which case the function is anonymous. The name is only local to the function body.

paramN Optional

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference.

statements Optional

The statements which comprise the body of the function.

DescriptionAn async function expression is very similar to, and has almost the same syntax as, an async function declaration. The main difference between an async function expression and an async function declaration is the function name, which can be omitted in async function expressions to create anonymous functions. An async function expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined, allowing you to mimic top-level await. See also the chapter about functions for more information.ExamplesUsing async function expressionjsfunction resolveAfter2Seconds(x) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(x);
    }, 2000);
  });
}

// async function expression assigned to a variable
const add = async function (x) {
  const a = await resolveAfter2Seconds(20);
  const b = await resolveAfter2Seconds(30);
  return x + a + b;
};

add(10).then((v) => {
  console.log(v); // prints 60 after 4 seconds.
});

// async function expression used as an IIFE
(async function (x) {
  const p1 = resolveAfter2Seconds(20);
  const p2 = resolveAfter2Seconds(30);
  return x + (await p1) + (await p2);
})(10).then((v) => {
  console.log(v); // prints 60 after 2 seconds.
});
SpecificationsSpecificationECMAScript Language Specification # sec-async-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
async function
AsyncFunction
await
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 23, 2023 by MDN contributors.
async function* expressionThe async function* keywords can be used to define an async generator function inside an expression.
You can also define async generator functions using the async function* declaration.Try itSyntaxjsasync function* (param0) {
  statements
}
async function* (param0, param1) {
  statements
}
async function* (param0, param1, /* …, */ paramN) {
  statements
}

async function* name(param0) {
  statements
}
async function* name(param0, param1) {
  statements
}
async function* name(param0, param1, /* …, */ paramN) {
  statements
}


Note: An expression statement cannot begin with the keywords async function to avoid ambiguity with an async function* declaration. The async function keywords only begin an expression when they appear in a context that cannot accept statements.
Parameters
name Optional

The function name. Can be omitted, in which case the function is anonymous. The name is only local to the function body.

paramN Optional

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference.

statements Optional

The statements which comprise the body of the function.

DescriptionAn async function* expression is very similar to, and has almost the same syntax as, an async function* declaration. The main difference between an async function* expression and an async function* declaration is the function name, which can be omitted in async function* expressions to create anonymous functions. An async function* expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined, allowing you to create an ad-hoc async iterable object. See also the chapter about functions for more information.ExamplesUsing async function* expressionThe following example defines an unnamed asynchronous generator function and assigns it to x. The function yields the square of its argument:
jsconst x = async function* (y) {
  yield Promise.resolve(y * y);
};
x(6)
  .next()
  .then((res) => console.log(res.value)); // 36
SpecificationsSpecificationECMAScript Language Specification # sec-async-generator-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
async function*
AsyncGeneratorFunction
Iteration protocols
yield
yield*
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 23, 2023 by MDN contributors.
awaitBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2017.Learn moreSee full compatibilityReport feedbackThe await operator is used to wait for a Promise and get its fulfillment value. It can only be used inside an async function or at the top level of a module.Syntaxjsawait expression
Parameters
expression

A Promise, a thenable object, or any value to wait for.

Return valueThe fulfillment value of the promise or thenable object, or, if the expression is not thenable, the expression's own value.ExceptionsThrows the rejection reason if the promise or thenable object is rejected.Descriptionawait is usually used to unwrap promises by passing a Promise as the expression. Using await pauses the execution of its surrounding async function until the promise is settled (that is, fulfilled or rejected). When execution resumes, the value of the await expression becomes that of the fulfilled promise.
If the promise is rejected, the await expression throws the rejected value. The function containing the await expression will appear in the stack trace of the error. Otherwise, if the rejected promise is not awaited or is immediately returned, the caller function will not appear in the stack trace.
The expression is resolved in the same way as Promise.resolve(): it's always converted to a native Promise and then awaited. If the expression is a:

Native Promise (which means expression belongs to Promise or a subclass, and expression.constructor === Promise): The promise is directly used and awaited natively, without calling then().
Thenable object (including non-native promises, polyfill, proxy, child class, etc.): A new promise is constructed with the native Promise() constructor by calling the object's then() method and passing in a handler that calls the resolve callback.
Non-thenable value: An already-fulfilled Promise is constructed and used.

Even when the used promise is already fulfilled, the async function's execution still pauses until the next tick. In the meantime, the caller of the async function resumes execution. See example below.
Because await is only valid inside async functions and modules, which themselves are asynchronous and return promises, the await expression never blocks the main thread and only defers execution of code that actually depends on the result, i.e. anything after the await expression.ExamplesAwaiting a promise to be fulfilledIf a Promise is passed to an await expression, it waits for the Promise to be fulfilled and returns the fulfilled value.
jsfunction resolveAfter2Seconds(x) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(x);
    }, 2000);
  });
}

async function f1() {
  const x = await resolveAfter2Seconds(10);
  console.log(x); // 10
}

f1();
Thenable objectsThenable objects are resolved just the same as actual Promise objects.
jsasync function f() {
  const thenable = {
    then(resolve, _reject) {
      resolve("resolved!");
    },
  };
  console.log(await thenable); // "resolved!"
}

f();

They can also be rejected:
jsasync function f() {
  const thenable = {
    then(resolve, reject) {
      reject(new Error("rejected!"));
    },
  };
  await thenable; // Throws Error: rejected!
}

f();
Conversion to promiseIf the value is not a Promise, await converts the value to a resolved Promise, and waits for it. The awaited value's identity doesn't change as long as it doesn't have a then property that's callable.
jsasync function f3() {
  const y = await 20;
  console.log(y); // 20

  const obj = {};
  console.log((await obj) === obj); // true
}

f3();
Handling rejected promisesIf the Promise is rejected, the rejected value is thrown.
jsasync function f4() {
  try {
    const z = await Promise.reject(30);
  } catch (e) {
    console.error(e); // 30
  }
}

f4();

You can handle rejected promises without a try block by chaining a catch() handler before awaiting the promise.
jsconst response = await promisedFunction().catch((err) => {
  console.error(err);
  return "default response";
});
// response will be "default response" if the promise is rejected

This is built on the assumption that promisedFunction() never synchronously throws an error, but always returns a rejected promise. This is the case for most properly-designed promise-based functions, which usually look like:
jsfunction promisedFunction() {
  // Immediately return a promise to minimize chance of an error being thrown
  return new Promise((resolve, reject) => {
    // do something async
  });
}

However, if promisedFunction() does throw an error synchronously, the error won't be caught by the catch() handler. In this case, the try...catch statement is necessary.Top level awaitYou can use the await keyword on its own (outside of an async function) at the top level of a module. This means that modules with child modules that use await will wait for the child modules to execute before they themselves run, all while not blocking other child modules from loading.
Here is an example of a simple module using the Fetch API and specifying await within the export statement. Any modules that include this will wait for the fetch to resolve before running any code.
js// fetch request
const colors = fetch("../data/colors.json").then((response) => response.json());

export default await colors;
Control flow effects of awaitWhen an await is encountered in code (either in an async function or in a module), the awaited expression is executed, while all code that depends on the expression's value is paused and pushed into the microtask queue. The main thread is then freed for the next task in the event loop. This happens even if the awaited value is an already-resolved promise or not a promise. For example, consider the following code:
jsasync function foo(name) {
  console.log(name, "start");
  console.log(name, "middle");
  console.log(name, "end");
}

foo("First");
foo("Second");

// First start
// First middle
// First end
// Second start
// Second middle
// Second end

In this case, the two async functions are synchronous in effect, because they don't contain any await expression. The three statements happen in the same tick. In promise terms, the function corresponds to:
jsfunction foo(name) {
  return new Promise((resolve) => {
    console.log(name, "start");
    console.log(name, "middle");
    console.log(name, "end");
    resolve();
  });
}

However, as soon as there's one await, the function becomes asynchronous, and execution of following statements is deferred to the next tick.
jsasync function foo(name) {
  console.log(name, "start");
  await console.log(name, "middle");
  console.log(name, "end");
}

foo("First");
foo("Second");

// First start
// First middle
// Second start
// Second middle
// First end
// Second end

This corresponds to:
jsfunction foo(name) {
  return new Promise((resolve) => {
    console.log(name, "start");
    resolve(console.log(name, "middle"));
  }).then(() => {
    console.log(name, "end");
  });
}

While the extra then() handler is not necessary, and the handler can be merged with the executor passed to the constructor, the then() handler's existence means the code will take one extra tick to complete. The same happens for await. Therefore, make sure to use await only when necessary (to unwrap promises into their values).
Other microtasks can execute before the async function resumes. This example uses queueMicrotask() to demonstrate how the microtask queue is processed when each await expression is encountered.
jslet i = 0;

queueMicrotask(function test() {
  i++;
  console.log("microtask", i);
  if (i < 3) {
    queueMicrotask(test);
  }
});

(async () => {
  console.log("async function start");
  for (let i = 1; i < 3; i++) {
    await null;
    console.log("async function resume", i);
  }
  await null;
  console.log("async function end");
})();

queueMicrotask(() => {
  console.log("queueMicrotask() after calling async function");
});

console.log("script sync part end");

// Logs:
// async function start
// script sync part end
// microtask 1
// async function resume 1
// queueMicrotask() after calling async function
// microtask 2
// async function resume 2
// microtask 3
// async function end

In this example, the test() function is always called before the async function resumes, so the microtasks they each schedule are always executed in an intertwined fashion. On the other hand, because both await and queueMicrotask() schedule microtasks, the order of execution is always based on the order of scheduling. This is why the "queueMicrotask() after calling async function" log happens after the async function resumes for the first time.Improving stack traceSometimes, the await is omitted when a promise is directly returned from an async function.
jsasync function noAwait() {
  // Some actions...

  return /* await */ lastAsyncTask();
}

However, consider the case where lastAsyncTask asynchronously throws an error.
jsasync function lastAsyncTask() {
  await null;
  throw new Error("failed");
}

async function noAwait() {
  return lastAsyncTask();
}

noAwait();

// Error: failed
//    at lastAsyncTask

Only lastAsyncTask appears in the stack trace, because the promise is rejected after it has already been returned from noAwait — in some sense, the promise is unrelated to noAwait. To improve the stack trace, you can use await to unwrap the promise, so that the exception gets thrown into the current function. The exception will then be immediately wrapped into a new rejected promise, but during error creation, the caller will appear in the stack trace.
jsasync function lastAsyncTask() {
  await null;
  throw new Error("failed");
}

async function withAwait() {
  return await lastAsyncTask();
}

withAwait();

// Error: failed
//    at lastAsyncTask
//    at async withAwait

However, there's a little performance penalty coming with return await because the promise has to be unwrapped and wrapped again.SpecificationsSpecificationECMAScript Language Specification # sec-async-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
async function
async function expression
AsyncFunction
Top-level await on v8.dev (2019)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jun 29, 2023 by MDN contributors.
Bitwise AND (&)The bitwise AND (&) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bits of both operands are 1.Try itSyntaxjsx & y
DescriptionThe & operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt AND if both operands become BigInts; otherwise, it converts both operands to 32-bit integers and performs number bitwise AND. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
The operator operates on the operands' bit representations in two's complement. Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on. The operator is applied to each pair of bits, and the result is constructed bitwise.
The truth table for the AND operation is:



x
y
x AND y




0
0
0


0
1
0


1
0
0


1
1
1



     9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 & 9 (base 10) = 00000000000000000000000000001000 (base 2) = 8 (base 10)

Numbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001

For BigInts, there's no truncation. Conceptually, understand positive BigInts as having an infinite number of leading 0 bits, and negative BigInts having an infinite number of leading 1 bits.
Bitwise ANDing any number x with -1 returns x converted to a 32-bit integer. Do not use & -1 to truncate numbers to integers; use Math.trunc() instead.ExamplesUsing bitwise ANDjs// 9  (00000000000000000000000000001001)
// 14 (00000000000000000000000000001110)

14 & 9;
// 8  (00000000000000000000000000001000)

14n & 9n; // 8n
SpecificationsSpecificationECMAScript Language Specification # prod-BitwiseANDExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Bitwise operators in the JS guide
Bitwise AND assignment (&=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 18, 2023 by MDN contributors.
Bitwise AND assignment (&=)The bitwise AND assignment (&=) operator performs bitwise AND on the two operands and assigns the result to the left operand.Try itSyntaxjsx &= y
Descriptionx &= y is equivalent to x = x & y, except that the expression x is only evaluated once.ExamplesUsing bitwise AND assignmentjslet a = 5;
// 5:     00000000000000000000000000000101
// 2:     00000000000000000000000000000010
a &= 2; // 0

let b = 5n;
b &= 2n; // 0n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Bitwise AND (&)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Bitwise NOT (~)The bitwise NOT (~) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bit of the operand is 0, and a 0 otherwise.Try itSyntaxjs~x
DescriptionThe ~ operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces the operand to a numeric value and tests the type of it. It performs BigInt NOT if the operand becomes a BigInt; otherwise, it converts the operand to a 32-bit integer and performs number bitwise NOT.
The operator operates on the operands' bit representations in two's complement. The operator is applied to each bit, and the result is constructed bitwise.
The truth table for the NOT operation is:



x
NOT x




0
1


1
0



 9 (base 10) = 00000000000000000000000000001001 (base 2)
               --------------------------------
~9 (base 10) = 11111111111111111111111111110110 (base 2) = -10 (base 10)

Numbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001

For BigInts, there's no truncation. Conceptually, understand positive BigInts as having an infinite number of leading 0 bits, and negative BigInts having an infinite number of leading 1 bits.
Bitwise NOTing any 32-bit integer x yields -(x + 1). For example, ~-5 yields 4.
Bitwise NOTing any number x twice returns x converted to a 32-bit integer. Do not use ~~x to truncate numbers to integers; use Math.trunc() instead. Due to using 32-bit representation for numbers, both ~-1 and ~4294967295 (232 - 1) result in 0.ExamplesUsing bitwise NOTjs~0; // -1
~-1; // 0
~1; // -2

~0n; // -1n
~4294967295n; // -4294967296n
SpecificationsSpecificationECMAScript Language Specification # sec-bitwise-not-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Bitwise operators in the JS guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Bitwise OR (|)The bitwise OR (|) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bits of either or both operands are 1.Try itSyntaxjsx | y
DescriptionThe | operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt OR if both operands become BigInts; otherwise, it converts both operands to 32-bit integers and performs number bitwise OR. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
The operator operates on the operands' bit representations in two's complement. Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on. The operator is applied to each pair of bits, and the result is constructed bitwise.
The truth table for the OR operation is:



x
y
x OR y




0
0
0


0
1
1


1
0
1


1
1
1



     9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 | 9 (base 10) = 00000000000000000000000000001111 (base 2) = 15 (base 10)

Numbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001

For BigInts, there's no truncation. Conceptually, understand positive BigInts as having an infinite number of leading 0 bits, and negative BigInts having an infinite number of leading 1 bits.
Bitwise ORing any number x with 0 returns x converted to a 32-bit integer. Do not use | 0 to truncate numbers to integers; use Math.trunc() instead.ExamplesUsing bitwise ORjs// 9  (00000000000000000000000000001001)
// 14 (00000000000000000000000000001110)

14 | 9;
// 15 (00000000000000000000000000001111)

14n | 9n; // 15n
SpecificationsSpecificationECMAScript Language Specification # prod-BitwiseORExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Bitwise operators in the JS guide
Bitwise OR assignment (|=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 18, 2023 by MDN contributors.
Bitwise OR assignment (|=)The bitwise OR assignment (|=) operator performs bitwise OR on the two operands and assigns the result to the left operand.Try itSyntaxjsx |= y
Descriptionx |= y is equivalent to x = x | y, except that the expression x is only evaluated once.ExamplesUsing bitwise OR assignmentjslet a = 5;
a |= 2; // 7
// 5: 00000000000000000000000000000101
// 2: 00000000000000000000000000000010
// -----------------------------------
// 7: 00000000000000000000000000000111

let b = 5n;
b |= 2n; // 7n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Bitwise OR (|)
Logical OR assignment (||=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Bitwise XOR (^)The bitwise XOR (^) operator returns a number or BigInt whose binary representation has a 1 in each bit position for which the corresponding bits of either but not both operands are 1.Try itSyntaxjsx ^ y
DescriptionThe ^ operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt XOR if both operands become BigInts; otherwise, it converts both operands to 32-bit integers and performs number bitwise XOR. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
The operator operates on the operands' bit representations in two's complement. Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on. The operator is applied to each pair of bits, and the result is constructed bitwise.
The truth table for the XOR operation is:



x
y
x XOR y




0
0
0


0
1
1


1
0
1


1
1
0



     9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 ^ 9 (base 10) = 00000000000000000000000000000111 (base 2) = 7 (base 10)

Numbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001

For BigInts, there's no truncation. Conceptually, understand positive BigInts as having an infinite number of leading 0 bits, and negative BigInts having an infinite number of leading 1 bits.
Bitwise XORing any number x with 0 returns x converted to a 32-bit integer. Do not use ^ 0 to truncate numbers to integers; use Math.trunc() instead.ExamplesUsing bitwise XORjs// 9  (00000000000000000000000000001001)
// 14 (00000000000000000000000000001110)

14 ^ 9;
// 7  (00000000000000000000000000000111)

14n ^ 9n; // 7n
SpecificationsSpecificationECMAScript Language Specification # prod-BitwiseXORExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Bitwise operators in the JS guide
Bitwise XOR assignment (^=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 18, 2023 by MDN contributors.
Bitwise XOR assignment (^=)The bitwise XOR assignment (^=) operator performs bitwise XOR on the two operands and assigns the result to the left operand.Try itSyntaxjsx ^= y
Descriptionx ^= y is equivalent to x = x ^ y, except that the expression x is only evaluated once.ExamplesUsing bitwise XOR assignmentjslet a = 5; // (00000000000000000000000000000101)
a ^= 3; // (00000000000000000000000000000011)

console.log(a); // 6 (00000000000000000000000000000110)

let b = 5; // (00000000000000000000000000000101)
b ^= 0; // (00000000000000000000000000000000)

console.log(b); // 5 (00000000000000000000000000000101)

let c = 5n;
c ^= 3n;
console.log(c); // 6n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Bitwise XOR (^)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
class expressionThe class keyword can be used to define a class inside an expression.
You can also define classes using the class declaration.Try itSyntaxjsclass {
  // class body
}
class name {
  // class body
}


Note: An expression statement cannot begin with the keyword class to avoid ambiguity with a class declaration. The class keyword only begins an expression when it appears in a context that cannot accept statements.
DescriptionA class expression is very similar to, and has almost the same syntax as, a class declaration. As with class declarations, the body of a class expression is executed in strict mode. The main difference between a class expression and a class declaration is the class name, which can be omitted in class expressions to create anonymous classes. Class expressions allow you to redefine classes, while redeclaring a class using class declarations throws a SyntaxError. See also the chapter about classes for more information.ExamplesA simple class expressionThis is just a simple anonymous class expression which you can refer to using the variable Foo.
jsconst Foo = class {
  constructor() {}
  bar() {
    return "Hello World!";
  }
};

const instance = new Foo();
instance.bar(); // "Hello World!"
Foo.name; // "Foo"
Named class expressionsIf you want to refer to the current class inside the class body, you can create a named class expression. The name is only visible within the scope of the class expression itself.
jsconst Foo = class NamedFoo {
  constructor() {}
  whoIsThere() {
    return NamedFoo.name;
  }
};
const bar = new Foo();
bar.whoIsThere(); // "NamedFoo"
NamedFoo.name; // ReferenceError: NamedFoo is not defined
Foo.name; // "NamedFoo"
SpecificationsSpecificationECMAScript Language Specification # sec-class-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
class
Classes
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
Comma operator (,)The comma (,) operator evaluates each of its operands (from left to right) and returns the value of the last operand. This is commonly used to provide multiple updaters to a for loop's afterthought.Try itSyntaxjsexpr1, expr2, expr3/* , … */
Parameters
expr1, expr2, expr3, …

One or more expressions, the last of which is returned as the value of the compound expression.

DescriptionYou can use the comma operator when you want to include multiple expressions in a location that requires a single expression. The most common usage of this operator is to supply multiple updaters in a for loop.
Because all expressions except the last are evaluated and then discarded, these expressions must have side effects to be useful. Common expressions that have side effects are assignments, function calls, and ++ and -- operators. Others may also have side effects if they invoke getters or trigger type coercions.
The comma operator has the lowest precedence of all operators. If you want to incorporate a comma-joined expression into a bigger expression, you must parenthesize it.
The comma operator is completely different from commas used as syntactic separators in other locations, which include:

Elements in array initializers ([1, 2, 3])
Properties in object initializers ({ a: 1, b: 2 })
Parameters in function declarations/expressions (function f(a, b) { … })
Arguments in function calls (f(1, 2))
Binding lists in let, const, or var declarations (const a = 1, b = 2;)
Import lists in import declarations (import { a, b } from "c";)
Export lists in export declarations (export { a, b };)

In fact, although some of these places accept almost all expressions, they don't accept comma-joined expressions because that would be ambiguous with the syntactic comma separators. In this case, you must parenthesize the comma-joined expression. For example, the following is a const declaration that declares two variables, where the comma is not the comma operator:
jsconst a = 1, b = 2;

It is different from the following, where b = 2 is an assignment expression, not a declaration. The value of a is 2, the return value of the assignment, while the value of 1 is discarded:
jsconst a = (1, b = 2);

Comma operators cannot appear as trailing commas.ExamplesUsing the comma operator in a for loopIf a is a 2-dimensional array with 10 elements on each side, the following code uses the comma operator to increment i and decrement j at once, thus printing the values of the diagonal elements in the array:
jsconst a = Array.from({ length: 10 }, () =>
  Array.from({ length: 10 }, Math.random),
); // A 10×10 array of random numbers

for (let i = 0, j = 9; i <= 9; i++, j--) {
  console.log(`a[${i}][${j}] = ${a[i][j]}`);
}
Using the comma operator to join assignmentsBecause commas have the lowest precedence — even lower than assignment — commas can be used to join multiple assignment expressions. In the following example, a is set to the value of b = 3 (which is 3). Then, the c = 4 expression evaluates and its result becomes the return value of the entire comma expression.
jslet a, b, c;

a = b = 3, c = 4; // Returns 4
console.log(a); // 3 (left-most)

let x, y, z;

x = (y = 5, z = 6); // Returns 6
console.log(x); // 6 (right-most)
Processing and then returningAnother example that one could make with the comma operator is processing before returning. As stated, only the last element will be returned but all others are going to be evaluated as well. So, one could do:
jsfunction myFunc() {
  let x = 0;

  return (x += 1, x); // the same as return ++x;
}

This is especially useful for one-line arrow functions. The following example uses a single map() to get both the sum of an array and the squares of its elements, which would otherwise require two iterations, one with reduce() and one with map():
jslet sum = 0;
const squares = [1, 2, 3, 4, 5].map((x) => ((sum += x), x * x));
console.log(squares); // [1, 4, 9, 16, 25]
console.log(sum); // 15
Discarding reference bindingThe comma operator always returns the last expression as a value instead of a reference. This causes some contextual information such as the this binding to be lost. For example, a property access returns a reference to the function, which also remembers the object that it's accessed on, so that calling the property works properly. If the method is returned from a comma expression, then the function is called as if it's a new function value, and this is undefined.
jsconst obj = {
  value: "obj",
  method() {
    console.log(this.value);
  },
};

obj.method(); // "obj"
(obj.method)(); // "obj" (the grouping operator still returns the reference)
(0, obj.method)(); // undefined (the comma operator returns a new value)

You can enter indirect eval with this technique, because direct eval requires the function call to happen on the reference to the eval() function.
jsglobalThis.isDirectEval = false;

{
  const isDirectEval = true;
  console.log(eval("isDirectEval")); // true
  console.log((eval)("isDirectEval")); // true (the grouping operator still returns a reference to `eval`)
  console.log((0, eval)("isDirectEval")); // false (the comma operator returns a new value)
}
SpecificationsSpecificationECMAScript Language Specification # sec-comma-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
for
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Conditional (ternary) operator
  The conditional (ternary) operator is the only JavaScript operator that takes three operands:
  a condition followed by a question mark (?), then an expression to execute if the condition is truthy followed by a colon (:), and finally the expression to execute if the condition is falsy.
  This operator is frequently used as an alternative to an if...else statement.
Try itSyntaxjscondition ? exprIfTrue : exprIfFalse
Parameters
condition

An expression whose value is used as a condition.

exprIfTrue

An expression which is executed if the condition evaluates to a truthy value (one which equals or can be converted to true).

exprIfFalse

An expression which is executed if the condition is falsy (that is, has a value which can be converted to false).

Description
  Besides false, possible falsy expressions are: null, NaN, 0, the empty string (""), and undefined.
  If condition is any of these, the result of the conditional expression will be the result of executing the expression exprIfFalse.
ExamplesA simple examplejsconst age = 26;
const beverage = age >= 21 ? "Beer" : "Juice";
console.log(beverage); // "Beer"
Handling null valuesOne common usage is to handle a value that may be null:
jsconst greeting = (person) => {
  const name = person ? person.name : "stranger";
  return `Howdy, ${name}`;
};

console.log(greeting({ name: "Alice" })); // "Howdy, Alice"
console.log(greeting(null)); // "Howdy, stranger"
Conditional chainsThe ternary operator is right-associative, which means it can be "chained" in the following way, similar to an if … else if … else if … else chain:
jsfunction example() {
  return condition1 ? value1
    : condition2 ? value2
    : condition3 ? value3
    : value4;
}

This is equivalent to the following if...else chain.
jsfunction example() {
  if (condition1) {
    return value1;
  } else if (condition2) {
    return value2;
  } else if (condition3) {
    return value3;
  } else {
    return value4;
  }
}
SpecificationsSpecificationECMAScript Language Specification # sec-conditional-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
if...else
Nullish coalescing operator (??)
Optional chaining (?.)
Making decisions in your code — conditionals
Expressions and operators guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Decrement (--)The decrement (--) operator decrements (subtracts one from) its operand and returns the value before or after the decrement, depending on where the operator is placed.Try itSyntaxjsx--
--x
DescriptionThe -- operator is overloaded for two types of operands: number and BigInt. It first coerces the operand to a numeric value and tests the type of it. It performs BigInt decrement if the operand becomes a BigInt; otherwise, it performs number decrement.
If used postfix, with operator after operand (for example, x--), the decrement operator decrements and returns the value before decrementing.
If used prefix, with operator before operand (for example, --x), the decrement operator decrements and returns the value after decrementing.
The decrement operator can only be applied on operands that are references (variables and object properties; i.e. valid assignment targets). --x itself evaluates to a value, not a reference, so you cannot chain multiple decrement operators together.
js--(--x); // SyntaxError: Invalid left-hand side expression in prefix operation
ExamplesPostfix decrementjslet x = 3;
const y = x--;
// x is 2; y is 3

let x2 = 3n;
const y2 = x2--;
// x2 is 2n; y2 is 3n
Prefix decrementjslet x = 3;
const y = --x;
// x is 2; y = 2

let x2 = 3n;
const y2 = --x2;
// x2 is 2n; y2 is 2n
SpecificationsSpecificationECMAScript Language Specification # sec-postfix-decrement-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Division (/)
Multiplication (*)
Remainder (%)
Exponentiation (**)
Increment (++)
Unary negation (-)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
deleteThe delete operator removes a property from an object. If the property's value is an object and there are no more references to the object, the object held by that property is eventually released automatically.Try itSyntaxjsdelete object.property
delete object[property]


Note: The syntax allows a wider range of expressions following the delete operator, but only the above forms lead to meaningful behaviors.
Parameters
object

The name of an object, or an expression evaluating to an object.

property

The property to delete.

Return valuetrue for all cases except when the property is an own non-configurable property, in which case false is returned in non-strict mode.Exceptions
TypeError

Thrown in strict mode if the property is an own non-configurable property.

ReferenceError

Thrown if object is super.

DescriptionThe delete operator has the same precedence as other unary operators like typeof. Therefore, it accepts any expression formed by higher-precedence operators. However, the following forms lead to early syntax errors in strict mode:
jsdelete identifier;
delete object.#privateProperty;

Because classes are automatically in strict mode, and private properties can only be legally referenced in class bodies, this means private properties can never be deleted. While delete identifier may work if identifier refers to a configurable property of the global object, you should avoid this form and prefix it with globalThis instead.
While other expressions are accepted, they don't lead to meaningful behaviors:
jsdelete console.log(1);
// Logs 1, returns true, but nothing deleted

The delete operator removes a given property from an object. On successful deletion, it will return true, else false will be returned. Unlike what common belief suggests (perhaps due to other programming languages like delete in C++), the delete operator has nothing to do with directly freeing memory. Memory management is done indirectly via breaking references. See the memory management page for more details.
It is important to consider the following scenarios:

If the property which you are trying to delete does not exist, delete will not have any effect and will return true.
delete only has an effect on own properties. If a property with the same name exists on the object's prototype chain, then after deletion, the object will use the property from the prototype chain.
Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().
Deleting variables, including function parameters, never works. delete variable will throw a SyntaxError in strict mode, and will have no effect in non-strict mode.
    
Any variable declared with var cannot be deleted from the global scope or from a function's scope, because while they may be attached to the global object, they are not configurable.
Any variable declared with let or const cannot be deleted from the scope within which they were defined, because they are not attached to an object.


ExamplesUsing delete
Note: The following example uses non-strict-mode only features, like implicitly creating global variables and deleting identifiers, which are forbidden in strict mode.

js// Creates the property empCount on the global scope.
// Since we are using var, this is marked as non-configurable.
var empCount = 43;

// Creates the property EmployeeDetails on the global scope.
// Since it was defined without "var", it is marked configurable.
EmployeeDetails = {
  name: "xyz",
  age: 5,
  designation: "Developer",
};

// delete can be used to remove properties from objects.
delete EmployeeDetails.name; // returns true

// Even when the property does not exist, delete returns "true".
delete EmployeeDetails.salary; // returns true

// EmployeeDetails is a property of the global scope.
delete EmployeeDetails; // returns true

// On the contrary, empCount is not configurable
// since var was used.
delete empCount; // returns false

// delete also does not affect built-in static properties
// that are non-configurable.
delete Math.PI; // returns false

function f() {
  var z = 44;

  // delete doesn't affect local variable names
  delete z; // returns false
}
delete and the prototype chainIn the following example, we delete an own property of an object while a property with the same name is available on the prototype chain:
jsfunction Foo() {
  this.bar = 10;
}

Foo.prototype.bar = 42;

const foo = new Foo();

// foo.bar is associated with the
// own property.
console.log(foo.bar); // 10

// Delete the own property within the
// foo object.
delete foo.bar; // returns true

// foo.bar is still available in the
// prototype chain.
console.log(foo.bar); // 42

// Delete the property on the prototype.
delete Foo.prototype.bar; // returns true

// The "bar" property can no longer be
// inherited from Foo since it has been
// deleted.
console.log(foo.bar); // undefined
Deleting array elementsWhen you delete an array element, the array length is not affected. This holds even if you delete the last element of the array.
When the delete operator removes an array element, that element is no longer in the array. In the following example, trees[3] is removed with delete.
jsconst trees = ["redwood", "bay", "cedar", "oak", "maple"];
delete trees[3];
console.log(3 in trees); // false

This creates a sparse array with an empty slot. If you want an array element to exist but have an undefined value, use the undefined value instead of the delete operator. In the following example, trees[3] is assigned the value undefined, but the array element still exists:
jsconst trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees[3] = undefined;
console.log(3 in trees); // true

If instead, you want to remove an array element by changing the contents of the array, use the splice() method. In the following example, trees[3] is removed from the array completely using splice():
jsconst trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees.splice(3, 1);
console.log(trees); // ["redwood", "bay", "cedar", "maple"]
Deleting non-configurable propertiesWhen a property is marked as non-configurable, delete won't have any effect, and will return false. In strict mode, this will raise a TypeError.
jsconst Employee = {};
Object.defineProperty(Employee, "name", { configurable: false });

console.log(delete Employee.name); // returns false

var creates non-configurable properties that cannot be deleted with the delete operator:
js// Since "nameOther" is added using with the
// var keyword, it is marked as non-configurable
var nameOther = "XYZ";

// We can access this global property using:
Object.getOwnPropertyDescriptor(globalThis, "nameOther");
// {
//   value: "XYZ",
//   writable: true,
//   enumerable: true,
//   configurable: false
// }

delete globalThis.nameOther; // return false

In strict mode, this would raise an exception.Deleting global propertiesIf a global property is configurable (for example, via direct property assignment), it can be deleted, and subsequent references to them as global variables will produce a ReferenceError.
jsglobalThis.globalVar = 1;
console.log(globalVar); // 1
// In non-strict mode, you can use `delete globalVar` as well
delete globalThis.globalVar;
console.log(globalVar); // ReferenceError: globalVar is not defined
SpecificationsSpecificationECMAScript Language Specification # sec-delete-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
In depth analysis on delete
Reflect.deleteProperty()
Map.prototype.delete()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Destructuring assignmentThe destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.Try itSyntaxjsconst [a, b] = array;
const [a, , b] = array;
const [a = aDefault, b] = array;
const [a, b, ...rest] = array;
const [a, , b, ...rest] = array;
const [a, b, ...{ pop, push }] = array;
const [a, b, ...[c, d]] = array;

const { a, b } = obj;
const { a: a1, b: b1 } = obj;
const { a: a1 = aDefault, b = bDefault } = obj;
const { a, b, ...rest } = obj;
const { a: a1, b: b1, ...rest } = obj;
const { [key]: a } = obj;

let a, b, a1, b1, c, d, rest, pop, push;
[a, b] = array;
[a, , b] = array;
[a = aDefault, b] = array;
[a, b, ...rest] = array;
[a, , b, ...rest] = array;
[a, b, ...{ pop, push }] = array;
[a, b, ...[c, d]] = array;

({ a, b } = obj); // parentheses are required
({ a: a1, b: b1 } = obj);
({ a: a1 = aDefault, b = bDefault } = obj);
({ a, b, ...rest } = obj);
({ a: a1, b: b1, ...rest } = obj);
DescriptionThe object and array literal expressions provide an easy way to create ad hoc packages of data.
jsconst x = [1, 2, 3, 4, 5];

The destructuring assignment uses similar syntax but uses it on the left-hand side of the assignment instead. It defines which values to unpack from the sourced variable.
jsconst x = [1, 2, 3, 4, 5];
const [y, z] = x;
console.log(y); // 1
console.log(z); // 2

Similarly, you can destructure objects on the left-hand side of the assignment.
jsconst obj = { a: 1, b: 2 };
const { a, b } = obj;
// is equivalent to:
// const a = obj.a;
// const b = obj.b;

This capability is similar to features present in languages such as Perl and Python.
For features specific to array or object destructuring, refer to the individual examples below.Binding and assignmentFor both object and array destructuring, there are two kinds of destructuring patterns: binding pattern and assignment pattern, with slightly different syntaxes.
In binding patterns, the pattern starts with a declaration keyword (var, let, or const). Then, each individual property must either be bound to a variable or further destructured.
jsconst obj = { a: 1, b: { c: 2 } };
const {
  a,
  b: { c: d },
} = obj;
// Two variables are bound: `a` and `d`

All variables share the same declaration, so if you want some variables to be re-assignable but others to be read-only, you may have to destructure twice — once with let, once with const.
jsconst obj = { a: 1, b: { c: 2 } };
const { a } = obj; // a is constant
let {
  b: { c: d },
} = obj; // d is re-assignable

In many other syntaxes where the language binds a variable for you, you can use a binding destructuring pattern. These include:

The looping variable of for...in for...of, and for await...of loops;
Function parameters;
The catch binding variable.

In assignment patterns, the pattern does not start with a keyword. Each destructured property is assigned to a target of assignment — which may either be declared beforehand with var or let, or is a property of another object — in general, anything that can appear on the left-hand side of an assignment expression.
jsconst numbers = [];
const obj = { a: 1, b: 2 };
({ a: numbers[0], b: numbers[1] } = obj);
// The properties `a` and `b` are assigned to properties of `numbers`


Note: The parentheses ( ... ) around the assignment statement are required when using object literal destructuring assignment without a declaration.
{ a, b } = { a: 1, b: 2 } is not valid stand-alone syntax, as the { a, b } on the left-hand side is considered a block and not an object literal according to the rules of expression statements. However, ({ a, b } = { a: 1, b: 2 }) is valid, as is const { a, b } = { a: 1, b: 2 }.
If your coding style does not include trailing semicolons, the ( ... ) expression needs to be preceded by a semicolon, or it may be used to execute a function on the previous line.

Note that the equivalent binding pattern of the code above is not valid syntax:
jsconst numbers = [];
const obj = { a: 1, b: 2 };
const { a: numbers[0], b: numbers[1] } = obj;

// This is equivalent to:
//   const numbers[0] = obj.a;
//   const numbers[1] = obj.b;
// Which definitely is not valid.

You can only use assignment patterns as the left-hand side of the assignment operator. You cannot use them with compound assignment operators such as += or *=.Default valueEach destructured property can have a default value. The default value is used when the property is not present, or has value undefined. It is not used if the property has value null.
jsconst [a = 1] = []; // a is 1
const { b = 2 } = { b: undefined }; // b is 2
const { c = 2 } = { c: null }; // c is null

The default value can be any expression. It will only be evaluated when necessary.
jsconst { b = console.log("hey") } = { b: 2 };
// Does not log anything, because `b` is defined and there's no need
// to evaluate the default value.
Rest propertyYou can end a destructuring pattern with a rest property ...rest. This pattern will store all remaining properties of the object or array into a new object or array.
jsconst { a, ...others } = { a: 1, b: 2, c: 3 };
console.log(others); // { b: 2, c: 3 }

const [first, ...others2] = [1, 2, 3];
console.log(others2); // [2, 3]

The rest property must be the last in the pattern, and must not have a trailing comma.
jsconst [a, ...b,] = [1, 2, 3];

// SyntaxError: rest element may not have a trailing comma
// Always consider using rest operator as the last element
ExamplesArray destructuringBasic variable assignment
jsconst foo = ["one", "two", "three"];

const [red, yellow, green] = foo;
console.log(red); // "one"
console.log(yellow); // "two"
console.log(green); // "three"

Destructuring with more elements than the source
In an array destructuring from an array of length N specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than N, only the first N variables are assigned values. The values of the remaining variables will be undefined.
jsconst foo = ["one", "two"];

const [red, yellow, green, blue] = foo;
console.log(red); // "one"
console.log(yellow); // "two"
console.log(green); // undefined
console.log(blue); // undefined

Swapping variables
Two variables values can be swapped in one destructuring expression.
Without destructuring assignment, swapping two values requires a temporary variable (or, in some low-level languages, the XOR-swap trick).
jslet a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1

const arr = [1, 2, 3];
[arr[2], arr[1]] = [arr[1], arr[2]];
console.log(arr); // [1, 3, 2]

Parsing an array returned from a function
It's always been possible to return an array from a function. Destructuring can make working with an array return value more concise.
In this example, f() returns the values [1, 2] as its output, which can be parsed in a single line with destructuring.
jsfunction f() {
  return [1, 2];
}

const [a, b] = f();
console.log(a); // 1
console.log(b); // 2

Ignoring some returned values
You can ignore return values that you're not interested in:
jsfunction f() {
  return [1, 2, 3];
}

const [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

const [c] = f();
console.log(c); // 1

You can also ignore all returned values:
js[, ,] = f();

Using a binding pattern as the rest property
The rest property of array destructuring assignment can be another array or object binding pattern. The inner destructuring destructures from the array created after collecting the rest elements, so you cannot access any properties present on the original iterable in this way.
jsconst [a, b, ...{ length }] = [1, 2, 3];
console.log(a, b, length); // 1 2 1

jsconst [a, b, ...[c, d]] = [1, 2, 3, 4];
console.log(a, b, c, d); // 1 2 3 4

These binding patterns can even be nested, as long as each rest property is the last in the list.
jsconst [a, b, ...[c, d, ...[e, f]]] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c, d, e, f); // 1 2 3 4 5 6

On the other hand, object destructuring can only have an identifier as the rest property.
jsconst { a, ...{ b } } = { a: 1, b: 2 };
// SyntaxError: `...` must be followed by an identifier in declaration contexts

let a, b;
({ a, ...{ b } } = { a: 1, b: 2 });
// SyntaxError: `...` must be followed by an assignable reference in assignment contexts

Unpacking values from a regular expression match
When the regular expression exec() method finds a match, it returns an array containing first the entire matched portion of the string and then the portions of the string that matched each parenthesized group in the regular expression. Destructuring assignment allows you to unpack the parts out of this array easily, ignoring the full match if it is not needed.
jsfunction parseProtocol(url) {
  const parsedURL = /^(\w+):\/\/([^/]+)\/(.*)$/.exec(url);
  if (!parsedURL) {
    return false;
  }
  console.log(parsedURL);
  // ["https://developer.mozilla.org/en-US/docs/Web/JavaScript",
  // "https", "developer.mozilla.org", "en-US/docs/Web/JavaScript"]

  const [, protocol, fullhost, fullpath] = parsedURL;
  return protocol;
}

console.log(
  parseProtocol("https://developer.mozilla.org/en-US/docs/Web/JavaScript"),
);
// "https"

Using array destructuring on any iterable
Array destructuring calls the iterable protocol of the right-hand side. Therefore, any iterable, not necessarily arrays, can be destructured.
jsconst [a, b] = new Map([
  [1, 2],
  [3, 4],
]);
console.log(a, b); // [1, 2] [3, 4]

Non-iterables cannot be destructured as arrays.
jsconst obj = { 0: "a", 1: "b", length: 2 };
const [a, b] = obj;
// TypeError: obj is not iterable

Iterables are only iterated until all bindings are assigned.
jsconst obj = {
  *[Symbol.iterator]() {
    for (const v of [0, 1, 2, 3]) {
      console.log(v);
      yield v;
    }
  },
};
const [a, b] = obj; // Only logs 0 and 1

The rest binding is eagerly evaluated and creates a new array, instead of using the old iterable.
jsconst obj = {
  *[Symbol.iterator]() {
    for (const v of [0, 1, 2, 3]) {
      console.log(v);
      yield v;
    }
  },
};
const [a, b, ...rest] = obj; // Logs 0 1 2 3
console.log(rest); // [2, 3] (an array)
Object destructuringBasic assignment
jsconst user = {
  id: 42,
  isVerified: true,
};

const { id, isVerified } = user;

console.log(id); // 42
console.log(isVerified); // true

Assigning to new variable names
A property can be unpacked from an object and assigned to a variable with a different name than the object property.
jsconst o = { p: 42, q: true };
const { p: foo, q: bar } = o;

console.log(foo); // 42
console.log(bar); // true

Here, for example, const { p: foo } = o takes from the object o the property named p and assigns it to a local variable named foo.
Assigning to new variable names and providing default values
A property can be both

Unpacked from an object and assigned to a variable with a different name.
Assigned a default value in case the unpacked value is undefined.

jsconst { a: aa = 10, b: bb = 5 } = { a: 3 };

console.log(aa); // 3
console.log(bb); // 5

Unpacking properties from objects passed as a function parameter

  Objects passed into function parameters can also be unpacked into variables, which may then be accessed within the function body.
  As for object assignment, the destructuring syntax allows for the new variable to have the same name or a different name than the original property, and to assign default values for the case when the original object does not define the property.

Consider this object, which contains information about a user.
jsconst user = {
  id: 42,
  displayName: "jdoe",
  fullName: {
    firstName: "Jane",
    lastName: "Doe",
  },
};


  Here we show how to unpack a property of the passed object into a variable with the same name.
  The parameter value { id } indicates that the id property of the object passed to the function should be unpacked into a variable with the same name, which can then be used within the function.

jsfunction userId({ id }) {
  return id;
}

console.log(userId(user)); // 42


  You can define the name of the unpacked variable.
  Here we unpack the property named displayName, and rename it to dname for use within the function body.

jsfunction userDisplayName({ displayName: dname }) {
  return dname;
}

console.log(userDisplayName(user)); // "jdoe"


  Nested objects can also be unpacked.
  The example below shows the property fullname.firstName being unpacked into a variable called name.

jsfunction whois({ displayName, fullName: { firstName: name } }) {
  return `${displayName} is ${name}`;
}

console.log(whois(user)); // "jdoe is Jane"

Setting a function parameter's default value
Default values can be specified using =, and will be used as variable values if a specified property does not exist in the passed object.
Below we show a function where the default size is 'big', default co-ordinates are x: 0, y: 0 and default radius is 25.
jsfunction drawChart({
  size = "big",
  coords = { x: 0, y: 0 },
  radius = 25,
} = {}) {
  console.log(size, coords, radius);
  // do some chart drawing
}

drawChart({
  coords: { x: 18, y: 30 },
  radius: 30,
});

In the function signature for drawChart above, the destructured left-hand side has a default value of an empty object = {}.
You could have also written the function without that default. However, if you leave out that default value, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can call drawChart() without supplying any parameters. Otherwise, you need to at least supply an empty object literal.
For more information, see Default parameters > Destructured parameter with default value assignment.
Nested object and array destructuring
jsconst metadata = {
  title: "Scratchpad",
  translations: [
    {
      locale: "de",
      localizationTags: [],
      lastEdit: "2014-04-14T08:43:37",
      url: "/de/docs/Tools/Scratchpad",
      title: "JavaScript-Umgebung",
    },
  ],
  url: "/en-US/docs/Tools/Scratchpad",
};

const {
  title: englishTitle, // rename
  translations: [
    {
      title: localeTitle, // rename
    },
  ],
} = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle); // "JavaScript-Umgebung"

For of iteration and destructuring
jsconst people = [
  {
    name: "Mike Smith",
    family: {
      mother: "Jane Smith",
      father: "Harry Smith",
      sister: "Samantha Smith",
    },
    age: 35,
  },
  {
    name: "Tom Jones",
    family: {
      mother: "Norah Jones",
      father: "Richard Jones",
      brother: "Howard Jones",
    },
    age: 25,
  },
];

for (const {
  name: n,
  family: { father: f },
} of people) {
  console.log(`Name: ${n}, Father: ${f}`);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"

Computed object property names and destructuring
Computed property names, like on object literals, can be used with destructuring.
jsconst key = "z";
const { [key]: foo } = { z: "bar" };

console.log(foo); // "bar"

Invalid JavaScript identifier as a property name
Destructuring can be used with property names that are not valid JavaScript identifiers by providing an alternative identifier that is valid.
jsconst foo = { "fizz-buzz": true };
const { "fizz-buzz": fizzBuzz } = foo;

console.log(fizzBuzz); // true
Destructuring primitive valuesObject destructuring is almost equivalent to property accessing. This means if you try to destruct a primitive value, the value will get wrapped into the corresponding wrapper object and the property is accessed on the wrapper object.
jsconst { a, toFixed } = 1;
console.log(a, toFixed); // undefined ƒ toFixed() { [native code] }

Same as accessing properties, destructuring null or undefined throws a TypeError.
jsconst { a } = undefined; // TypeError: Cannot destructure property 'a' of 'undefined' as it is undefined.
const { b } = null; // TypeError: Cannot destructure property 'b' of 'null' as it is null.

This happens even when the pattern is empty.
jsconst {} = null; // TypeError: Cannot destructure 'null' as it is null.

Combined array and object destructuring
Array and object destructuring can be combined. Say you want the third element in the array props below, and then you want the name property in the object, you can do the following:
jsconst props = [
  { id: 1, name: "Fizz" },
  { id: 2, name: "Buzz" },
  { id: 3, name: "FizzBuzz" },
];

const [, , { name }] = props;

console.log(name); // "FizzBuzz"

The prototype chain is looked up when the object is deconstructed
When deconstructing an object, if a property is not accessed in itself, it will continue to look up along the prototype chain.
jsconst obj = {
  self: "123",
  __proto__: {
    prot: "456",
  },
};
const { self, prot } = obj;

console.log(self); // "123"
console.log(prot); // "456"
SpecificationsSpecificationECMAScript Language Specification # sec-destructuring-assignmentECMAScript Language Specification # sec-destructuring-binding-patternsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators
ES6 in Depth: Destructuring on hacks.mozilla.org (2015)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
Division (/)The division (/) operator produces the quotient of its operands where the left operand is the dividend and the right operand is the divisor.Try itSyntaxjsx / y
DescriptionThe / operator is overloaded for two types of operands: number and BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt division if both operands become BigInts; otherwise, it performs number division. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
For BigInt division, the result is the quotient of the two operands truncated towards zero, and the remainder is discarded. A RangeError is thrown if the divisor y is 0n. This is because number division by zero returns Infinity or -Infinity, but BigInt has no concept of infinity.ExamplesBasic divisionjs1 / 2; // 0.5

Math.floor(3 / 2); // 1

1.0 / 2.0; // 0.5

1n / 2n; // 0n
5n / 3n; // 1n
-1n / 3n; // 0n
1n / -3n; // 0n

2n / 2; // TypeError: Cannot mix BigInt and other types, use explicit conversions

// To do division with a BigInt and a non-BigInt, convert either operand
2n / BigInt(2); // 1n
Number(2n) / 2; // 1
Division by zerojs2.0 / 0; // Infinity

2.0 / 0.0; // Infinity, because 0.0 === 0

2.0 / -0.0; // -Infinity

2n / 0n; // RangeError: Division by zero
SpecificationsSpecificationECMAScript Language Specification # sec-multiplicative-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Multiplication (*)
Remainder (%)
Exponentiation (**)
Increment (++)
Decrement (--)
Unary negation (-)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 19, 2023 by MDN contributors.
Division assignment (/=)The division assignment (/=) operator performs division on the two operands and assigns the result to the left operand.Try itSyntaxjsx /= y
Descriptionx /= y is equivalent to x = x / y, except that the expression x is only evaluated once.ExamplesUsing division assignmentjslet bar = 5;

bar /= 2; // 2.5
bar /= 2; // 1.25
bar /= 0; // Infinity
bar /= "foo"; // NaN

let foo = 3n;
foo /= 2n; // 1n
foo /= 2n; // 0n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Division (/)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Equality (==)
  The equality (==) operator checks whether its two operands are equal,
  returning a Boolean result.
  Unlike the strict equality operator,
  it attempts to convert and compare operands that are of different types.
Try itSyntaxjsx == y
DescriptionThe equality operators (== and !=) provide the IsLooselyEqual semantic. This can be roughly summarized as follows:

If the operands have the same type, they are compared as follows:
    
Object: return true only if both operands reference the same object.
String: return true only if both operands have the same characters in the same order.
Number: return true only if both operands have the same value. +0 and -0 are treated as the same value. If either operand is NaN, return false; so, NaN is never equal to NaN.
Boolean: return true only if operands are both true or both false.
BigInt: return true only if both operands have the same value.
Symbol: return true only if both operands reference the same symbol.


If one of the operands is null or undefined, the other must also be null or undefined to return true. Otherwise return false.
If one of the operands is an object and the other is a primitive, convert the object to a primitive.
At this step, both operands are converted to primitives (one of String, Number, Boolean, Symbol, and BigInt). The rest of the conversion is done case-by-case.
    
If they are of the same type, compare them using step 1.
If one of the operands is a Symbol but the other is not, return false.
If one of the operands is a Boolean but the other is not, convert the boolean to a number: true is converted to 1, and false is converted to 0. Then compare the two operands loosely again.
Number to String: convert the string to a number. Conversion failure results in NaN, which will guarantee the equality to be false.
Number to BigInt: compare by their numeric value. If the number is ±Infinity or NaN, return false.
String to BigInt: convert the string to a BigInt using the same algorithm as the BigInt() constructor. If conversion fails, return false.



Loose equality is symmetric: A == B always has identical semantics to B == A for any values of A and B (except for the order of applied conversions).
The most notable difference between this operator and the strict equality (===) operator is that the strict equality operator does not attempt type conversion. Instead, the strict equality operator always considers operands of different types to be different. The strict equality operator essentially carries out only step 1, and then returns false for all other cases.
There's a "willful violation" of the above algorithm: if one of the operands is document.all, it is treated as if it's undefined. This means that document.all == null is true, but document.all === undefined && document.all === null is false.ExamplesComparison with no type conversionjs1 == 1; // true
"hello" == "hello"; // true
Comparison with type conversionjs"1" == 1; // true
1 == "1"; // true
0 == false; // true
0 == null; // false
0 == undefined; // false
0 == !!null; // true, look at Logical NOT operator
0 == !!undefined; // true, look at Logical NOT operator
null == undefined; // true

const number1 = new Number(3);
const number2 = new Number(3);
number1 == 3; // true
number1 == number2; // false
Comparison of objectsjsconst object1 = {
  key: "value",
};

const object2 = {
  key: "value",
};

console.log(object1 == object2); // false
console.log(object1 == object1); // true
Comparing strings and String objects
  Note that strings constructed using new String() are objects. If you
  compare one of these with a string literal, the String object will be
  converted to a string literal and the contents will be compared. However, if both
  operands are String objects, then they are compared as objects and must
  reference the same object for comparison to succeed:

jsconst string1 = "hello";
const string2 = String("hello");
const string3 = new String("hello");
const string4 = new String("hello");

console.log(string1 == string2); // true
console.log(string1 == string3); // true
console.log(string2 == string3); // true
console.log(string3 == string4); // false
console.log(string4 == string4); // true
Comparing Dates and stringsjsconst d = new Date("1995-12-17T03:24:00");
const s = d.toString(); // for example: "Sun Dec 17 1995 03:24:00 GMT-0800 (Pacific Standard Time)"
console.log(d == s); //true
Comparing arrays and stringsjsconst a = [1, 2, 3];
const b = "1,2,3";
a == b; // true, `a` converts to string

const c = [true, 0.5, "hey"];
const d = c.toString(); // "true,0.5,hey"
c == d; // true
SpecificationsSpecificationECMAScript Language Specification # sec-equality-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Inequality (!=)
Strict equality (===)
Strict inequality (!==)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Exponentiation (**)The exponentiation (**) operator returns the result of raising the first operand to the power of the second operand. It is equivalent to Math.pow(), except it also accepts BigInts as operands.Try itSyntaxjsx ** y
DescriptionThe ** operator is overloaded for two types of operands: number and BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt exponentiation if both operands become BigInts; otherwise, it performs number exponentiation. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
For both numbers and BigInts, 0 raised to a positive power returns 0, and 0 raised to a power of 0 returns 1. For numbers, 0 raised to a negative number returns Infinity, while -0 raised to a negative number returns -Infinity.
NaN ** 0 (and the equivalent Math.pow(NaN, 0)) is the only case where NaN doesn't propagate through mathematical operations — it returns 1 despite the operand being NaN. In addition, the behavior where base is 1 and exponent is non-finite (±Infinity or NaN) is different from IEEE 754, which specifies that the result should be 1, whereas JavaScript returns NaN to preserve backward compatibility with its original behavior.
For BigInt exponentiation, a RangeError is thrown if the exponent y is negative. This is because any negative exponent would likely result in a value between 0 and 1 (unless the base is 1, -1, or 0), which is rounded to zero, and is likely a developer mistake.
The exponentiation operator is right-associative: a ** b ** c is equal to a ** (b ** c).
In most languages, such as PHP, Python, and others that have an exponentiation operator (**), the exponentiation operator is defined to have a higher precedence than unary operators, such as unary + and unary -, but there are a few exceptions. For example, in Bash, the ** operator is defined to have a lower precedence than unary operators.
In JavaScript, it is impossible to write an ambiguous exponentiation expression. That is, you cannot put a unary operator (with precedence 14, including +/-/~/!/++/--/delete/void/typeof/await) immediately before the base number; doing so will cause a SyntaxError.
For example, -2 ** 2 is 4 in Bash, but is -4 in other languages (such as Python). This is invalid in JavaScript, as the operation is ambiguous. You have to parenthesize either side — for example, as -(2 ** 2) — to make the intention unambiguous.
Note that some programming languages use the caret symbol ^ for exponentiation, but JavaScript uses that symbol for the bitwise XOR operator.ExamplesBasic exponentiationjs2 ** 3; // 8
3 ** 2; // 9
3 ** 2.5; // 15.588457268119896
10 ** -1; // 0.1
2 ** 1024; // Infinity
NaN ** 2; // NaN
NaN ** 0; // 1
1 ** Infinity; // NaN

2n ** 3n; // 8n
2n ** 1024n; // A very large number, but not Infinity

2n ** 2; // TypeError: Cannot mix BigInt and other types, use explicit conversions

// To do exponentiation with a BigInt and a non-BigInt, convert either operand
2n ** BigInt(2); // 4n
Number(2n) ** 2; // 4
Associativityjs2 ** 3 ** 2; // 512
2 ** (3 ** 2); // 512
(2 ** 3) ** 2; // 64
Usage with unary operatorsTo invert the sign of the result of an exponentiation expression:
js-(2 ** 2); // -4

To force the base of an exponentiation expression to be a negative number:
js(-2) ** 2; // 4
SpecificationsSpecificationECMAScript Language Specification # sec-exp-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Division (/)
Multiplication (*)
Remainder (%)
Increment (++)
Decrement (--)
Unary negation (-)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 20, 2024 by MDN contributors.
Exponentiation assignment (**=)The **exponentiation assignment (**=)** operator performs exponentiation on the two operands and assigns the result to the left operand.Try itSyntaxjsx **= y
Descriptionx **= y is equivalent to x = x ** y, except that the expression x is only evaluated once.ExamplesUsing exponentiation assignmentjslet bar = 5;

bar **= 2; // 25
bar **= "foo"; // NaN

let foo = 3n;
foo **= 2n; // 9n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Exponentiation (**)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 14, 2023 by MDN contributors.
function expressionThe function keyword can be used to define a function inside an expression.
You can also define functions using the function declaration or the arrow syntax.Try itSyntaxjsfunction (param0) {
  statements
}
function (param0, param1) {
  statements
}
function (param0, param1, /* …, */ paramN) {
  statements
}

function name(param0) {
  statements
}
function name(param0, param1) {
  statements
}
function name(param0, param1, /* …, */ paramN) {
  statements
}


Note: An expression statement cannot begin with the keyword function to avoid ambiguity with a function declaration. The function keyword only begins an expression when it appears in a context that cannot accept statements.
Parameters
name Optional

The function name. Can be omitted, in which case the function is anonymous. The name is only local to the function body.

paramN Optional

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference.

statements Optional

The statements which comprise the body of the function.

DescriptionA function expression is very similar to, and has almost the same syntax as, a function declaration. The main difference between a function expression and a function declaration is the function name, which can be omitted in function expressions to create anonymous functions. A function expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined. See also the chapter about functions for more information.Function expression hoistingFunction expressions in JavaScript are not hoisted, unlike function declarations. You can't use function expressions before you create them:
jsconsole.log(notHoisted); // undefined
// Even though the variable name is hoisted,
// the definition isn't. so it's undefined.
notHoisted(); // TypeError: notHoisted is not a function

var notHoisted = function () {
  console.log("bar");
};
Named function expressionIf you want to refer to the current function inside the function body, you need to create a named function expression. This name is then local only to the function body (scope). This avoids using the deprecated arguments.callee property to call the function recursively.
jsconst math = {
  factit: function factorial(n) {
    console.log(n);
    if (n <= 1) {
      return 1;
    }
    return n * factorial(n - 1);
  },
};

math.factit(3); //3;2;1;

If a function expression is named, the name property of the function is set to that name, instead of the implicit name inferred from syntax (such as the variable the function is assigned to).
Unlike declarations, the name of the function expressions is read-only.
jsfunction foo() {
  foo = 1;
}
foo();
console.log(foo); // 1
(function foo() {
  foo = 1; // TypeError: Assignment to constant variable.
})();
ExamplesUsing function expressionThe following example defines an unnamed function and assigns it to x. The function returns the square of its argument:
jsconst x = function (y) {
  return y * y;
};
Using a function as a callbackMore commonly it is used as a callback:
jsbutton.addEventListener("click", function (event) {
  console.log("button is clicked!");
});
Using an Immediately Invoked Function Expression (IIFE)An anonymous function is created and called:
js(function () {
  console.log("Code runs!");
})();

// or

!function () {
  console.log("Code runs!");
}();
SpecificationsSpecificationECMAScript Language Specification # sec-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
function
Function
Arrow functions
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 23, 2023 by MDN contributors.
function* expressionThe function* keyword can be used to define a generator function inside an expression.
You can also define generator functions using the function* declaration.Try itSyntaxjsfunction* (param0) {
  statements
}
function* (param0, param1) {
  statements
}
function* (param0, param1, /* …, */ paramN) {
  statements
}

function* name(param0) {
  statements
}
function* name(param0, param1) {
  statements
}
function* name(param0, param1, /* …, */ paramN) {
  statements
}


Note: An expression statement cannot begin with the keyword function to avoid ambiguity with a function* declaration. The function keyword only begins an expression when it appears in a context that cannot accept statements.
Parameters
name Optional

The function name. Can be omitted, in which case the function is anonymous. The name is only local to the function body.

paramN Optional

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference.

statements Optional

The statements which comprise the body of the function.

DescriptionA function* expression is very similar to, and has almost the same syntax as, a function* declaration. The main difference between a function* expression and a function* declaration is the function name, which can be omitted in function* expressions to create anonymous functions. A function* expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined, allowing you to create an ad-hoc iterable iterator object. See also the chapter about functions for more information.ExamplesUsing function* expressionThe following example defines an unnamed generator function and assigns it to x. The function yields the square of its argument:
jsconst x = function* (y) {
  yield y * y;
};
SpecificationsSpecificationECMAScript Language Specification # sec-generator-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
function*
GeneratorFunction
Iteration protocols
yield
yield*
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 23, 2023 by MDN contributors.
Greater than (>)
  The greater than (>) operator returns true if the left
  operand is greater than the right operand, and false otherwise.
Try itSyntaxjsx > y
DescriptionThe operands are compared using the same algorithm as the Less than operator, except the two operands are swapped. x > y is generally equivalent to y < x, except that x > y coerces x to a primitive before y, while y < x coerces y to a primitive before x. Because coercion may have side effects, the order of the operands may matter.ExamplesString to string comparisonjs"a" > "b"; // false
"a" > "a"; // false
"a" > "3"; // true
String to number comparisonjs"5" > 3; // true
"3" > 3; // false
"3" > 5; // false

"hello" > 5; // false
5 > "hello"; // false

"5" > 3n; // true
"3" > 5n; // false
Number to Number comparisonjs5 > 3; // true
3 > 3; // false
3 > 5; // false
Number to BigInt comparisonjs5n > 3; // true
3 > 5n; // false
Comparing Boolean, null, undefined, NaNjstrue > false; // true
false > true; // false

true > 0; // true
true > 1; // false

null > 0; // false
1 > null; // true

undefined > 3; // false
3 > undefined; // false

3 > NaN; // false
NaN > 3; // false
SpecificationsSpecificationECMAScript Language Specification # sec-relational-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Greater than or equal (>=)
Less than (<)
Less than or equal (<=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Greater than or equal (>=)
  The greater than or equal (>=) operator returns true if
  the left operand is greater than or equal to the right operand, and false
  otherwise.
Try itSyntaxjsx >= y
DescriptionThe operands are compared using the same algorithm as the Less than operator, with the result negated. x >= y is generally equivalent to !(x < y), except for two cases where x >= y and x < y are both false:

If one of the operands gets converted to a BigInt, while the other gets converted to a string that cannot be converted to a BigInt value (it throws a syntax error when passed to BigInt()).
If one of the operands gets converted to NaN. (For example, strings that cannot be converted to numbers, or undefined.)

x >= y is generally equivalent to x > y || x == y, except for a few cases:

When one of x or y is null, and the other is something that's not null and becomes 0 when coerced to numeric (including 0, 0n, false, "", "0", new Date(0), etc.): x >= y is true, while x > y || x == y is false.
When one of x or y is undefined, and the other is one of null or undefined: x >= y is false, while x == y is true.
When x and y are the same object that becomes NaN after the first step of Less than (such as new Date(NaN)): x >= y is false, while x == y is true.
When x and y are different objects that become the same value after the first step of Less than: x >= y is true, while x > y || x == y is false.
ExamplesString to string comparisonjs"a" >= "b"; // false
"a" >= "a"; // true
"a" >= "3"; // true
String to number comparisonjs"5" >= 3; // true
"3" >= 3; // true
"3" >= 5; // false

"hello" >= 5; // false
5 >= "hello"; // false
Number to Number comparisonjs5 >= 3; // true
3 >= 3; // true
3 >= 5; // false
Number to BigInt comparisonjs5n >= 3; // true
3 >= 3n; // true
3 >= 5n; // false
Comparing Boolean, null, undefined, NaNjstrue >= false; // true
true >= true; // true
false >= true; // false

true >= 0; // true
true >= 1; // true

null >= 0; // true
1 >= null; // true

undefined >= 3; // false
3 >= undefined; // false

3 >= NaN; // false
NaN >= 3; // false
SpecificationsSpecificationECMAScript Language Specification # sec-relational-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Greater than (>)
Less than (<)
Less than or equal (<=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Grouping operator ( )The grouping ( ) operator controls the precedence of evaluation in expressions. It also acts as a container for arbitrary expressions in certain syntactic constructs, where ambiguity or syntax errors would otherwise occur.Try itSyntaxjs(expression)
Parameters
expression

Any expression to be evaluated, including comma-joined expressions.

DescriptionThe grouping operator consists of a pair of parentheses around an expression that groups the contents. The operator overrides the normal operator precedence, so that operators with lower precedence (as low as the comma operator) can be evaluated before an operator with higher precedence.ExamplesUsing the grouping operatorEvaluating addition and subtraction before multiplication and division.
jsconst a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7

// now overriding precedence
// addition before multiplication
(a + b) * c; // 9

// which is equivalent to
a * c + b * c; // 9

Notice in these examples that the order in which the operators evaluate has changed, but the order in which the operands evaluate has not. For example, in this code, the function invocations a(), b(), and c() are evaluated left-to-right (the normal order of evaluation) before the operator order is considered.
jsa() * (b() + c());

The function a will be called before the function b, which will be called before the function c. For more on operator precedence, see its reference page.Using the grouping operator to eliminate parsing ambiguityAn expression statement cannot start with the keyword function, because the parser would see it as the start of a function declaration. This means the following IIFE syntax is invalid:
jsfunction () {
  // code
}();

The grouping operator can be used to eliminate this ambiguity, since when the parser sees the left parenthesis, it knows that what follows must be an expression instead of a declaration.
js(function () {
  // code
})();

You may also use the void operator to eliminate ambiguity.
In an arrow function expression body (one that directly returns an expression without the keyword return), the grouping operator can be used to return an object literal expression, because otherwise the left curly brace would be interpreted as the start of the function body.
jsconst f = () => ({ a: 1 });

If a property is accessed on a number literal, the property accessor dot . may be ambiguous with a decimal point, unless the number already has a decimal point. You can wrap integer literals in parentheses to eliminate this ambiguity.
js(1).toString(); // "1"
Grouping operator and automatic semicolon insertionThe grouping operator can mitigate automatic semicolon insertion (ASI) pitfalls. For example, the return keyword and the returned expression cannot have a line break in between:
jsfunction sum(a, b) {
  return
    a + b;
}

This code will return undefined, because a semicolon is inserted directly after the return keyword, which causes the function to return immediately without evaluating a + b. In case the returned expression is long and you want to keep it well-formatted, you may use the grouping operator to signify that the return keyword is followed by an expression and prevent semicolon insertion:
jsfunction sum(a, b) {
  return (
    a + b
  );
}

However, grouping may also introduce ASI hazards. When a line starts with a left parenthesis and the previous line ends with an expression, the parser will not insert a semicolon before the line break, because it could be the middle of a function call. For example:
jsconst a = 1
(1).toString()

This code would be parsed as:
jsconst a = 1(1).toString();

Which throws "TypeError: 1 is not a function". If your coding style does not use semicolons, remember that when a line starts with a left parenthesis, prefix it with a semicolon. This practice is recommended by several formatters and/or style guides, including Prettier and standard.
jsconst a = 1
;(1).toString()

For more advice on working with ASI, see its reference section.SpecificationsSpecificationECMAScript Language Specification # sec-grouping-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Operator precedence
delete
typeof
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 2, 2023 by MDN contributors.
import.metaThe import.meta meta-property exposes context-specific metadata to a JavaScript module. It contains information about the module, such as the module's URL.Syntaxjsimport.meta
ValueThe import.meta object is created by the host environment, as an extensible null-prototype object where all properties are writable, configurable, and enumerable. The spec doesn't specify any properties to be defined on it, but hosts usually implement the following properties:

url

The full URL to the module, includes query parameters and/or hash (following the ? or #). In browsers, this is either the URL from which the script was obtained (for external scripts), or the URL of the containing document (for inline scripts). In Node.js, this is the file path (including the file:// protocol).

resolve

Resolves a module specifier to a URL using the current module's URL as base.

DescriptionThe import.meta syntax consists of the keyword import, a dot, and the identifier meta. Because import is a reserved word, not an identifier, this is not a property accessor, but a special expression syntax.
The import.meta meta-property is available in JavaScript modules; using import.meta outside of a module (including direct eval() within a module) is a syntax error.ExamplesPassing query parametersUsing query parameters in the import specifier allows module-specific argument passing, which may be complementary to reading parameters from the application-wide window.location (or on Node.js, through process.argv). For example, with the following HTML:
html<script type="module">
  import "./index.mjs?someURLInfo=5";
</script>

The index.mjs module is able to retrieve the someURLInfo parameter through import.meta:
js// index.mjs
new URL(import.meta.url).searchParams.get("someURLInfo"); // 5

The same applies when a module imports another:
js// index.mjs
import "./index2.mjs?someURLInfo=5";

// index2.mjs
new URL(import.meta.url).searchParams.get("someURLInfo"); // 5

The ES module implementation in Node.js supports resolving module specifiers containing query parameters (or the hash), as in the latter example. However, you cannot use queries or hashes when the module is specified through the CLI command (like node index.mjs?someURLInfo=5), because the CLI entrypoint uses a more CommonJS-like resolution mode, treating the path as a file path rather than a URL. To pass parameters to the entrypoint module, use CLI arguments and read them through process.argv instead (like node index.mjs --someURLInfo=5).Resolving a file relative to the current oneIn Node.js CommonJS modules, there's a __dirname variable that contains the absolute path to the folder containing current module, which is useful for resolving relative paths. However, ES modules cannot have contextual variables except for import.meta. Therefore, to resolve a relative file you can use import.meta.url. Note that this uses URLs rather than filesystem paths.
Before (CommonJS):
jsconst fs = require("fs/promises");
const path = require("path");

const filePath = path.join(__dirname, "someFile.txt");
fs.readFile(filePath, "utf8").then(console.log);

After (ES modules):
jsimport fs from "node:fs/promises";

const fileURL = new URL("./someFile.txt", import.meta.url);
fs.readFile(fileURL, "utf8").then(console.log);
SpecificationsSpecificationECMAScript Language Specification # prod-ImportMetaHTML Standard # hostgetimportmetapropertiesBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
import
export
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
import()The import() syntax, commonly called dynamic import, is a function-like expression that allows loading an ECMAScript module asynchronously and dynamically into a potentially non-module environment.
Unlike the declaration-style counterpart, dynamic imports are only evaluated when needed, and permit greater syntactic flexibility.Syntaxjsimport(moduleName)

The import() call is a syntax that closely resembles a function call, but import itself is a keyword, not a function. You cannot alias it like const myImport = import, which will throw a SyntaxError.Parameters
moduleName

The module to import from. The evaluation of the specifier is host-specified, but always follows the same algorithm as static import declarations.

Return valueReturns a promise which fulfills to a module namespace object: an object containing all exports from moduleName.
The evaluation of import() never synchronously throws an error. moduleName is coerced to a string, and if coercion throws, the promise is rejected with the thrown error.DescriptionThe import declaration syntax (import something from "somewhere") is static and will always result in the imported module being evaluated at load time. Dynamic imports allow one to circumvent the syntactic rigidity of import declarations and load a module conditionally or on demand. The following are some reasons why you might need to use dynamic import:

When importing statically significantly slows the loading of your code or increases your program's memory usage, and there is a low likelihood that you will need the code you are importing, or you will not need it until a later time.
When the module you are importing does not exist at load time.
When the import specifier string needs to be constructed dynamically. (Static import only supports static specifiers.)
When the module being imported has side effects, and you do not want those side effects unless some condition is true. (It is recommended not to have any side effects in a module, but you sometimes cannot control this in your module dependencies.)
When you are in a non-module environment (for example, eval or a script file).

Use dynamic import only when necessary. The static form is preferable for loading initial dependencies, and can benefit more readily from static analysis tools and tree shaking.
If your file is not run as a module (if it's referenced in an HTML file, the script tag must have type="module"), you will not be able to use static import declarations, but the asynchronous dynamic import syntax will always be available, allowing you to import modules into non-module environments.

  Dynamic module import is not permitted in all execution contexts.
  For example, import() can be used in the main thread, a shared worker, or a dedicated worker, but will throw if called within a service worker or a worklet.
Module namespace objectA module namespace object is an object that describes all exports from a module. It is a static object that is created when the module is evaluated. There are two ways to access the module namespace object of a module: through a namespace import (import * as name from moduleName), or through the fulfillment value of a dynamic import.
The module namespace object is a sealed object with null prototype. This means all string keys of the object correspond to the exports of the module and there are never extra keys. All keys are enumerable in lexicographic order (i.e. the default behavior of Array.prototype.sort()), with the default export available as a key called default. In addition, the module namespace object has a @@toStringTag property with the value "Module", used in Object.prototype.toString().
The string properties are non-configurable and writable when you use Object.getOwnPropertyDescriptors() to get their descriptors. However, they are effectively read-only, because you cannot re-assign a property to a new value. This behavior mirrors the fact that static imports create "live bindings" — the values can be re-assigned by the module exporting them, but not by the module importing them. The writability of the properties reflects the possibility of the values changing, because non-configurable and non-writable properties must be constant. For example, you can re-assign the exported value of a variable, and the new value can be observed in the module namespace object.
Each module specifier corresponds to a unique module namespace object, so the following is generally true:
jsimport * as mod from "/my-module.js";

import("/my-module.js").then((mod2) => {
  console.log(mod === mod2); // true
});

Except in one curious case: because a promise never fulfills to a thenable, if the my-module.js module exports a function called then(), that function will automatically get called when the dynamic import's promise is fulfilled, as part of the promise resolution process.
js// my-module.js
export function then(resolve) {
  console.log("then() called");
  resolve(1);
}

js// main.js
import * as mod from "/my-module.js";

import("/my-module.js").then((mod2) => {
  // Logs "then() called"
  console.log(mod === mod2); // false
});


Warning: Do not export a function called then() from a module. This will cause the module to behave differently when imported dynamically than when imported statically.
ExamplesImport a module for its side effects onlyjs(async () => {
  if (somethingIsTrue) {
    // import module for side effects
    await import("/modules/my-module.js");
  }
})();


  If your project uses packages that export ESM, you can also import them for side
  effects only. This will run the code in the package entry point file (and any files it
  imports) only.
Importing defaultsYou need to destructure and rename the "default" key from the returned object.
js(async () => {
  if (somethingIsTrue) {
    const {
      default: myDefault,
      foo,
      bar,
    } = await import("/modules/my-module.js");
  }
})();
Importing on-demand in response to user actionThis example shows how to load functionality on to a page based on a user action, in this case a button click, and then call a function within that module. This is not the only way to implement this functionality. The import() function also supports await.
jsconst main = document.querySelector("main");
for (const link of document.querySelectorAll("nav > a")) {
  link.addEventListener("click", (e) => {
    e.preventDefault();

    import("/modules/my-module.js")
      .then((module) => {
        module.loadPageInto(main);
      })
      .catch((err) => {
        main.textContent = err.message;
      });
  });
}
Importing different modules based on environmentIn processes such as server-side rendering, you may need to load different logic on server or in browser because they interact with different globals or modules (for example, browser code has access to web APIs like document and navigator, while server code has access to the server file system). You can do so through a conditional dynamic import.
jslet myModule;

if (typeof window === "undefined") {
  myModule = await import("module-used-on-server");
} else {
  myModule = await import("module-used-in-browser");
}
Importing modules with a non-literal specifierDynamic imports allow any expression as the module specifier, not necessarily string literals.
Here, we load 10 modules, /modules/module-0.js, /modules/module-1.js, etc., concurrently, and call the load functions that each one exports.
jsPromise.all(
  Array.from({ length: 10 }).map(
    (_, index) => import(`/modules/module-${index}.js`),
  ),
).then((modules) => modules.forEach((module) => module.load()));
SpecificationsSpecificationECMAScript Language Specification # sec-import-callsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
import
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 6, 2023 by MDN contributors.
inThe in operator returns true if the specified property is in the specified object or its prototype chain.
The in operator cannot be used to search for values in other collections. To test if a certain value exists in an array, use Array.prototype.includes(). For sets, use Set.prototype.has().Try itSyntaxjsprop in object
#prop in object
Parameters
prop

A string or symbol representing a property name (non-symbols will be coerced to strings). Can also be a private property identifier.

object

Object to check if it (or its prototype chain) contains the property with specified name (prop).

Exceptions
TypeError

Thrown if object is not an object (i.e. a primitive).

DescriptionThe in operator tests if a string or symbol property is present in an object or its prototype chain. If you want to check for only non-inherited properties, use Object.hasOwn() instead.
A property may be present in an object but have value undefined. Therefore, x in obj is not the same as obj.x !== undefined. To make in return false after a property is added, use the delete operator instead of setting that property's value to undefined.
You can also use the in operator to check whether a particular private class field or method has been defined in an object. The operator returns true if the property is defined, and false otherwise. This is known as a branded check, because it returns true if and only if the object was created with that class constructor, after which you can safely access other private properties as well.
This is a special syntax — the left-hand side of the in operator is a property identifier instead of an expression, but unquoted (because otherwise it's a string property, not a private property).
Because accessing private properties on objects unrelated to the current class throws a TypeError instead of returning undefined, this syntax allows you to shorten:
jsclass C {
  #x;
  static isC(obj) {
    try {
      obj.#x;
      return true;
    } catch {
      return false;
    }
  }
}

To:
jsclass C {
  #x;
  static isC(obj) {
    return #x in obj;
  }
}

It also generally avoids the need for dealing with error handling just to access a private property that may be nonexistent.
However, the in operator still requires the private property to be declared beforehand in the enclosing class — otherwise, it would throw a SyntaxError ("Private field '#x' must be declared in an enclosing class"), the same one as when you try to access an undeclared private property.
jsclass C {
  foo() {
    #x in this;
  }
}

new C().foo(); // SyntaxError: Private field '#x' must be declared in an enclosing class
ExamplesBasic usageThe following examples show some uses of the in operator.
js// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)
Symbol.iterator in trees; // returns true

// Predefined objects
"PI" in Math; // returns true

// Custom objects
const mycar = { make: "Honda", model: "Accord", year: 1998 };
"make" in mycar; // returns true
"model" in mycar; // returns true

You must specify an object on the right side of the in operator. For example, you can specify a string created with the String constructor, but you cannot specify a string literal.
jsconst color1 = new String("green");
"length" in color1; // returns true

const color2 = "coral";
// generates an error (color2 is not a String object)
"length" in color2;
Using the in operator with deleted or undefined propertiesIf you delete a property with the delete operator, the in operator returns false for that property.
jsconst mycar = { make: "Honda", model: "Accord", year: 1998 };
delete mycar.make;
"make" in mycar; // returns false

const trees = ["redwood", "bay", "cedar", "oak", "maple"];
delete trees[3];
3 in trees; // returns false

If you set a property to undefined but do not delete it, the in operator returns true for that property.
jsconst mycar = { make: "Honda", model: "Accord", year: 1998 };
mycar.make = undefined;
"make" in mycar; // returns true

jsconst trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees[3] = undefined;
3 in trees; // returns true

The in operator will return false for empty array slots, even if accessing it directly returns undefined.
jsconst empties = new Array(3);
empties[2]; // returns undefined
2 in empties; // returns false

To avoid this, make sure a new array is always filled with non-empty values or not write to indexes past the end of array.
jsconst empties = new Array(3).fill(undefined);
2 in empties; // returns true
Inherited propertiesThe in operator returns true for properties in the prototype chain. This may be undesirable if you are using objects to store arbitrary key-value pairs.
jsconst ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

hasPerson("hasOwnProperty"); // true

You can use Object.hasOwn() to check if the object has the key.
jsconst ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return Object.hasOwn(ages, name);
}

hasPerson("hasOwnProperty"); // false

Alternatively, you should consider using a null prototype object or a Map for storing ages, to avoid other bugs.
jsconst ages = new Map([
  ["alice", 18],
  ["bob", 27],
]);

function hasPerson(name) {
  return ages.has(name);
}

hasPerson("hasOwnProperty"); // false
Using the in operator to implement branded checksThe code fragment below demonstrates a static function that tells if an object was created with the Person constructor and therefore can perform other methods safely.
jsclass Person {
  #age;
  constructor(age) {
    this.#age = age;
  }
  static isPerson(o) {
    return #age in o;
  }
  ageDifference(other) {
    return this.#age - other.#age;
  }
}

const p1 = new Person(20);
const p2 = new Person(30);
console.log(p1.ageDifference(p2)); // -10
console.log(Person.isPerson(p1)); // true

if (Person.isPerson(p1) && Person.isPerson(p2)) {
  console.log(p1.ageDifference(p2)); // -10
}

It helps to prevent the following case:
jsconst p2 = {};

p1.ageDifference(p2); // TypeError: Cannot read private member #age from an object whose class did not declare it

Without the in operator, you would have to use a try...catch block to check if the object has the private property.
You can also implement this as a @@hasInstance method of the class, so that you can use the instanceof operator to perform the same check (which, by default, only checks for the existence of Person.prototype in the object's prototype chain).
jsclass Person {
  #age;
  constructor(age) {
    this.#age = age;
  }
  static [Symbol.hasInstance](o) {
    // Testing `this` to prevent false-positives when
    // calling `instanceof SubclassOfPerson`
    return this === Person && #age in o;
  }
  ageDifference(other) {
    return this.#age - other.#age;
  }
}

const p1 = new Person(20);
const p2 = new Person(30);

if (p1 instanceof Person && p2 instanceof Person) {
  console.log(p1.ageDifference(p2)); // -10
}

For more examples, see Private properties and the class guide.SpecificationsSpecificationECMAScript Language Specification # sec-relational-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
for...in
delete
Object.hasOwn()
Reflect.has()
Enumerability and ownership of properties
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 18, 2024 by MDN contributors.
Increment (++)The increment (++) operator increments (adds one to) its operand and returns the value before or after the increment, depending on where the operator is placed.Try itSyntaxjsx++
++x
DescriptionThe ++ operator is overloaded for two types of operands: number and BigInt. It first coerces the operand to a numeric value and tests the type of it. It performs BigInt increment if the operand becomes a BigInt; otherwise, it performs number increment.
If used postfix, with operator after operand (for example, x++), the increment operator increments and returns the value before incrementing.
If used prefix, with operator before operand (for example, ++x), the increment operator increments and returns the value after incrementing.
The increment operator can only be applied on operands that are references (variables and object properties; i.e. valid assignment targets). ++x itself evaluates to a value, not a reference, so you cannot chain multiple increment operators together.
js++(++x); // SyntaxError: Invalid left-hand side expression in prefix operation
ExamplesPostfix incrementjslet x = 3;
const y = x++;
// x is 4; y is 3

let x2 = 3n;
const y2 = x2++;
// x2 is 4n; y2 is 3n
Prefix incrementjslet x = 3;
const y = ++x;
// x is 4; y is 4

let x2 = 3n;
const y2 = ++x2;
// x2 is 4n; y2 is 4n
SpecificationsSpecificationECMAScript Language Specification # sec-postfix-increment-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Division (/)
Multiplication (*)
Remainder (%)
Exponentiation (**)
Decrement (--)
Unary negation (-)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Inequality (!=)
  The inequality (!=) operator checks whether its two operands are not
  equal, returning a Boolean result.
  Unlike the strict inequality operator,
  it attempts to convert and compare operands that are of different types.
Try itSyntaxjsx != y
Description
  The inequality operator checks whether its operands are not equal. It is the negation
  of the equality
  operator so the following two lines will always give the same result:

jsx != y;

!(x == y);

For details of the comparison algorithm, see the page for the equality operator.

  Like the equality operator, the inequality operator will attempt to convert and compare
  operands of different types:

js3 != "3"; // false


  To prevent this, and require that different types are considered to be different, use
  the strict inequality operator instead:

js3 !== "3"; // true
ExamplesComparison with no type conversionjs1 != 2; // true
"hello" != "hola"; // true

1 != 1; // false
"hello" != "hello"; // false
Comparison with type conversionjs"1" != 1; // false
1 != "1"; // false
0 != false; // false
0 != null; // true
0 != undefined; // true
0 != !!null; // false, look at Logical NOT operator
0 != !!undefined; // false, look at Logical NOT operator
null != undefined; // false

const number1 = new Number(3);
const number2 = new Number(3);
number1 != 3; // false
number1 != number2; // true
Comparison of objectsjsconst object1 = {
  key: "value",
};

const object2 = {
  key: "value",
};

console.log(object1 != object2); // true
console.log(object1 != object1); // false
SpecificationsSpecificationECMAScript Language Specification # sec-equality-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Equality (==)
Strict equality (===)
Strict inequality (!==)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
instanceofThe instanceof operator tests to see if the prototype property of a constructor appears anywhere in the prototype chain of an object. The return value is a boolean value. Its behavior can be customized with Symbol.hasInstance.Try itSyntaxjsobject instanceof constructor
Parameters
object

The object to test.

constructor

Constructor to test against.

Exceptions
TypeError

Thrown if constructor is not an object. If constructor doesn't have a @@hasInstance method, it must also be a function.

DescriptionThe instanceof operator tests the presence of constructor.prototype in object's prototype chain. This usually (though not always) means object was constructed with constructor.
js// defining constructors
function C() {}
function D() {}

const o = new C();

// true, because: Object.getPrototypeOf(o) === C.prototype
o instanceof C;

// false, because D.prototype is nowhere in o's prototype chain
o instanceof D;

o instanceof Object; // true, because:
C.prototype instanceof Object; // true

// Re-assign `constructor.prototype`: you should
// rarely do this in practice.
C.prototype = {};
const o2 = new C();

o2 instanceof C; // true

// false, because C.prototype is nowhere in
// o's prototype chain anymore
o instanceof C;

D.prototype = new C(); // add C to [[Prototype]] linkage of D
const o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true since C.prototype is now in o3's prototype chain

Note that the value of an instanceof test can change if constructor.prototype is re-assigned after creating the object (which is usually discouraged). It can also be changed by changing object's prototype using Object.setPrototypeOf.
Classes behave in the same way, because classes also have the prototype property.
jsclass A {}
class B extends A {}

const o1 = new A();
// true, because Object.getPrototypeOf(o1) === A.prototype
o1 instanceof A;
// false, because B.prototype is nowhere in o1's prototype chain
o1 instanceof B;

const o2 = new B();
// true, because Object.getPrototypeOf(Object.getPrototypeOf(o2)) === A.prototype
o2 instanceof A;
// true, because Object.getPrototypeOf(o2) === B.prototype
o2 instanceof B;

For bound functions, instanceof looks up for the prototype property on the target function, since bound functions don't have prototype.
jsclass Base {}
const BoundBase = Base.bind(null, 1, 2);
console.log(new Base() instanceof BoundBase); // true
instanceof and @@hasInstanceIf constructor has a Symbol.hasInstance method, the method will be called in priority, with object as its only argument and constructor as this.
js// This class allows plain objects to be disguised as this class's instance,
// as long as the object has a particular flag as its property.
class Forgeable {
  static isInstanceFlag = Symbol("isInstanceFlag");

  static [Symbol.hasInstance](obj) {
    return Forgeable.isInstanceFlag in obj;
  }
}

const obj = { [Forgeable.isInstanceFlag]: true };
console.log(obj instanceof Forgeable); // true

Because all functions inherit from Function.prototype by default, most of the time, the Function.prototype[@@hasInstance] method specifies the behavior of instanceof when the right-hand side is a function. See the Symbol.hasInstance page for the exact algorithm of instanceof.instanceof and multiple realmsJavaScript execution environments (windows, frames, etc.) are each in their own realm. This means that they have different built-ins (different global object, different constructors, etc.). This may result in unexpected results. For instance, [] instanceof window.frames[0].Array will return false, because Array.prototype !== window.frames[0].Array.prototype and arrays in the current realm inherit from the former.
This may not make sense at first, but for scripts dealing with multiple frames or windows, and passing objects from one context to another via functions, this will be a valid and strong issue. For instance, you can securely check if a given object is in fact an Array using Array.isArray(), neglecting which realm it comes from.
For example, to check if a Node is an SVGElement in a different context, you can use myNode instanceof myNode.ownerDocument.defaultView.SVGElement.ExamplesUsing instanceof with StringThe following example shows the behavior of instanceof with String objects.
jsconst literalString = "This is a literal string";
const stringObject = new String("String created with constructor");

literalString instanceof String; // false, string primitive is not a String
stringObject instanceof String; // true

literalString instanceof Object; // false, string primitive is not an Object
stringObject instanceof Object; // true

stringObject instanceof Date; // false
Using instanceof with DateThe following example shows the behavior of instanceof with Date objects.
jsconst myDate = new Date();

myDate instanceof Date; // true
myDate instanceof Object; // true
myDate instanceof String; // false
Objects created using Object.create()The following example shows the behavior of instanceof with objects created using Object.create().
jsfunction Shape() {}

function Rectangle() {
  Shape.call(this); // call super constructor.
}

Rectangle.prototype = Object.create(Shape.prototype);

Rectangle.prototype.constructor = Rectangle;

const rect = new Rectangle();

rect instanceof Object; // true
rect instanceof Shape; // true
rect instanceof Rectangle; // true
rect instanceof String; // false

const literalObject = {};
const nullObject = Object.create(null);
nullObject.name = "My object";

literalObject instanceof Object; // true, every object literal has Object.prototype as prototype
({}) instanceof Object; // true, same case as above
nullObject instanceof Object; // false, prototype is end of prototype chain (null)
Demonstrating that mycar is of type Car and type ObjectThe following code creates an object type Car and an instance of that object type, mycar. The instanceof operator demonstrates that the mycar object is of type Car and of type Object.
jsfunction Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const mycar = new Car("Honda", "Accord", 1998);
const a = mycar instanceof Car; // returns true
const b = mycar instanceof Object; // returns true
Not an instanceofTo test if an object is not an instanceof a specific constructor, you can do:
jsif (!(mycar instanceof Car)) {
  // Do something, like:
  // mycar = new Car(mycar)
}

This is really different from:
jsif (!mycar instanceof Car) {
  // unreachable code
}

This will always be false. (!mycar will be evaluated before instanceof, so you always try to know if a boolean is an instance of Car).Overriding the behavior of instanceofA common pitfall of using instanceof is believing that, if x instanceof C, then x was created using C as constructor. This is not true, because x could be directly assigned with C.prototype as its prototype. In this case, if your code reads private fields of C from x, it would still fail:
jsclass C {
  #value = "foo";
  static getValue(x) {
    return x.#value;
  }
}

const x = { __proto__: C.prototype };

if (x instanceof C) {
  console.log(C.getValue(x)); // TypeError: Cannot read private member #value from an object whose class did not declare it
}

To avoid this, you can override the behavior of instanceof by adding a Symbol.hasInstance method to C, so that it does a branded check with in:
jsclass C {
  #value = "foo";

  static [Symbol.hasInstance](x) {
    return #value in x;
  }

  static getValue(x) {
    return x.#value;
  }
}

const x = { __proto__: C.prototype };

if (x instanceof C) {
  // Doesn't run, because x is not a C
  console.log(C.getValue(x));
}

Note that you may want to limit this behavior to the current class; otherwise, it could lead to false positives for subclasses:
jsclass D extends C {}
console.log(new C() instanceof D); // true; because D inherits @@hasInstance from C

You could do this by checking that this is the current constructor:
jsclass C {
  #value = "foo";

  static [Symbol.hasInstance](x) {
    return this === C && #value in x;
  }
}

class D extends C {}
console.log(new C() instanceof D); // false
console.log(new C() instanceof C); // true
console.log({ __proto__: C.prototype } instanceof C); // false
SpecificationsSpecificationECMAScript Language Specification # sec-relational-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
typeof
Symbol.hasInstance
Object.prototype.isPrototypeOf
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 14, 2023 by MDN contributors.
Left shift (<<)The left shift (<<) operator returns a number or BigInt whose binary representation is the first operand shifted by the specified number of bits to the left. Excess bits shifted off to the left are discarded, and zero bits are shifted in from the right.Try itSyntaxjsx << y
DescriptionThe << operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt left shift if both operands become BigInts; otherwise, it converts both operands to 32-bit integers and performs number left shift. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
The operator operates on the left operand's bit representation in two's complement. For example, 9 << 2 yields 36:
     9 (base 10): 00000000000000000000000000001001 (base 2)
                  --------------------------------
9 << 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10)

Bitwise a 32-bit integer x to the left by y bits yields x * 2 ** y. So for example, 9 << 3 is equivalent to 9 * (2 ** 3) = 9 * (8) = 72.
If the left operand is a number with more than 32 bits, it will get the most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001

The right operand will be converted to an unsigned 32-bit integer and then taken modulo 32, so the actual shift offset will always be a positive integer between 0 and 31, inclusive. For example, 100 << 32 is the same as 100 << 0 (and produces 100) because 32 modulo 32 is 0.
For BigInts, there's no truncation. Conceptually, understand positive BigInts as having an infinite number of leading 0 bits, and negative BigInts having an infinite number of leading 1 bits.
Left shifting any number x by 0 returns x converted to a 32-bit integer. Do not use << 0 to truncate numbers to integers; use Math.trunc() instead.ExamplesUsing left shiftjs9 << 3; // 72

// 9 * (2 ** 3) = 9 * (8) = 72

9n << 3n; // 72n
SpecificationsSpecificationECMAScript Language Specification # sec-left-shift-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Bitwise operators in the JS guide
Left shift assignment (<<=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 18, 2023 by MDN contributors.
Left shift assignment (<<=)The left shift assignment (<<=) operator performs left shift on the two operands and assigns the result to the left operand.Try itSyntaxjsx <<= y
Descriptionx <<= y is equivalent to x = x << y, except that the expression x is only evaluated once.ExamplesUsing left shift assignmentjslet a = 5;
// 00000000000000000000000000000101

a <<= 2; // 20
// 00000000000000000000000000010100

let b = 5n;
b <<= 2n; // 20n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Left shift (<<)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Less than (<)The less than (<) operator returns true if the left operand is less than the right operand, and false otherwise.Try itSyntaxjsx < y
DescriptionThe operands are compared with multiple rounds of coercion, which can be summarized as follows:

First, objects are converted to primitives by calling its [@@toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The left operand is always coerced before the right one. Note that although [@@toPrimitive]() is called with the "number" hint (meaning there's a slight preference for the object to become a number), the return value is not converted to a number, since strings are still specially handled.
If both values are strings, they are compared as strings, based on the values of the UTF-16 code units (not Unicode code points) they contain.
Otherwise JavaScript attempts to convert non-numeric types to numeric values:
    
Boolean values true and false are converted to 1 and 0 respectively.
null is converted to 0.
undefined is converted to NaN.
Strings are converted based on the values they contain, and are converted as NaN if they do not contain numeric values.


If either value is NaN, the operator returns false.
Otherwise the values are compared as numeric values. BigInt and number values can be compared together.

Other operators, including >, >=, and <=, use the same algorithm as <. There are two cases where all four operators return false:

If one of the operands gets converted to a BigInt, while the other gets converted to a string that cannot be converted to a BigInt value (it throws a syntax error when passed to BigInt()).
If one of the operands gets converted to NaN. (For example, strings that cannot be converted to numbers, or undefined.)

For all other cases, the four operators have the following relationships:
jsx < y === !(x >= y);
x <= y === !(x > y);
x > y === y < x;
x >= y === y <= x;


Note: One observable difference between < and > is the order of coercion, especially if the coercion to primitive has side effects. All comparison operators coerce the left operand before the right operand.
ExamplesString to string comparisonjs"a" < "b"; // true
"a" < "a"; // false
"a" < "3"; // false

"\uD855\uDE51" < "\uFF3A"; // true
String to number comparisonjs"5" < 3; // false
"3" < 3; // false
"3" < 5; // true

"hello" < 5; // false
5 < "hello"; // false

"5" < 3n; // false
"3" < 5n; // true
Number to Number comparisonjs5 < 3; // false
3 < 3; // false
3 < 5; // true
Number to BigInt comparisonjs5n < 3; // false
3 < 5n; // true
Comparing Boolean, null, undefined, NaNjstrue < false; // false
false < true; // true

0 < true; // true
true < 1; // false

null < 0; // false
null < 1; // true

undefined < 3; // false
3 < undefined; // false

3 < NaN; // false
NaN < 3; // false
Comparison with side effectsComparisons always coerce their operands to primitives. This means the same object may end up having different values within one comparison expression. For example, you may have two values that are both greater than and less than the other.
jsclass Mystery {
  static #coercionCount = -1;
  valueOf() {
    Mystery.#coercionCount++;
    // The left operand is coerced first, so this will return 0
    // Then it returns 1 for the right operand
    return Mystery.#coercionCount % 2;
  }
}

const l = new Mystery();
const r = new Mystery();
console.log(l < r && r < l);
// true


Warning: This can be a source of confusion. If your objects provide custom primitive conversion logic, make sure it is idempotent: multiple coercions should return the same value.
SpecificationsSpecificationECMAScript Language Specification # sec-relational-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Greater than (>)
Greater than or equal (>=)
Less than or equal (<=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 15, 2023 by MDN contributors.
Less than or equal (<=)The less than or equal (<=) operator returns true if the left operand is less than or equal to the right operand, and false otherwise.Try itSyntaxjsx <= y
DescriptionThe operands are compared using the same algorithm as the Less than operator, with the operands swapped and the result negated. x <= y is generally equivalent to !(y < x), except for two cases where x <= y and x > y are both false:

If one of the operands gets converted to a BigInt, while the other gets converted to a string that cannot be converted to a BigInt value (it throws a syntax error when passed to BigInt()).
If one of the operands gets converted to NaN. (For example, strings that cannot be converted to numbers, or undefined.)

In addition, x <= y coerces x to a primitive before y, while y < x coerces y to a primitive before x. Because coercion may have side effects, the order of the operands may matter.
x <= y is generally equivalent to x < y || x == y, except for a few cases:

When one of x or y is null, and the other is something that's not null and becomes 0 when coerced to numeric (including 0, 0n, false, "", "0", new Date(0), etc.): x <= y is true, while x < y || x == y is false.
When one of x or y is undefined, and the other is one of null or undefined: x <= y is false, while x == y is true.
When x and y are the same object that becomes NaN after the first step of Less than (such as new Date(NaN)): x <= y is false, while x == y is true.
When x and y are different objects that become the same value after the first step of Less than: x <= y is true, while x < y || x == y is false.
ExamplesString to string comparisonjs"a" <= "b"; // true
"a" <= "a"; // true
"a" <= "3"; // false
String to number comparisonjs"5" <= 3; // false
"3" <= 3; // true
"3" <= 5; // true

"hello" <= 5; // false
5 <= "hello"; // false
Number to Number comparisonjs5 <= 3; // false
3 <= 3; // true
3 <= 5; // true
Number to BigInt comparisonjs5n <= 3; // false
3 <= 3n; // true
3 <= 5n; // true
Comparing Boolean, null, undefined, NaNjstrue <= false; // false
true <= true; // true
false <= true; // true

true <= 0; // false
true <= 1; // true

null <= 0; // true
1 <= null; // false

undefined <= 3; // false
3 <= undefined; // false

3 <= NaN; // false
NaN <= 3; // false
SpecificationsSpecificationECMAScript Language Specification # sec-relational-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Greater than (>)
Greater than or equal (>=)
Less than (<)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Logical AND (&&)The logical AND (&&) (logical conjunction) operator for a set of boolean operands will be true if and only if all the operands are true. Otherwise it will be false.
More generally, the operator returns the value of the first falsy operand encountered when evaluating from left to right, or the value of the last operand if they are all truthy.Try itSyntaxjsx && y
DescriptionLogical AND (&&) evaluates operands from left to right, returning immediately with the value of the first falsy operand it encounters; if all values are truthy, the value of the last operand is returned.
If a value can be converted to true, the value is so-called truthy. If a value can be converted to false, the value is so-called falsy.
Examples of expressions that can be converted to false are:

false;
null;
NaN;
0;
empty string ("" or '' or ``);
undefined.

The AND operator preserves non-Boolean values and returns them as they are:
jsresult = "" && "foo"; // result is assigned "" (empty string)
result = 2 && 0; // result is assigned 0
result = "foo" && 4; // result is assigned 4


  Even though the && operator can be used with non-Boolean operands, it is still considered a boolean operator since its return value can always be
  converted to a boolean primitive.
  To explicitly convert its return value (or any expression in general) to the corresponding boolean value, use a double NOT operator or the Boolean constructor.
Short-circuit evaluation
  The logical AND expression is a short-circuit operator.
  As each operand is converted to a boolean, if the result of one conversion is found to be false, the AND operator stops and returns the original value of that falsy operand; it does not evaluate any of the remaining operands.

Consider the pseudocode below.
(some falsy expression) && expr


  The expr part is never evaluated because the first operand (some falsy expression) is evaluated as falsy.
  If expr is a function, the function is never called.
  See the example below:

jsfunction A() {
  console.log("called A");
  return false;
}
function B() {
  console.log("called B");
  return true;
}

console.log(A() && B());
// Logs "called A" to the console due to the call for function A,
// && evaluates to false (function A returns false), then false is logged to the console;
// the AND operator short-circuits here and ignores function B
Operator precedenceThe AND operator has a higher precedence than the OR operator, meaning the && operator is executed before the || operator (see operator precedence).
jstrue || false && false; // true
true && (false || false); // false
(2 === 3) || (4 < 0) && (1 === 1); // false
ExamplesUsing AND
  The following code shows examples of the && (logical AND)
  operator.

jsa1 = true && true; // t && t returns true
a2 = true && false; // t && f returns false
a3 = false && true; // f && t returns false
a4 = false && 3 === 4; // f && f returns false
a5 = "Cat" && "Dog"; // t && t returns "Dog"
a6 = false && "Cat"; // f && t returns false
a7 = "Cat" && false; // t && f returns false
a8 = "" && false; // f && f returns ""
a9 = false && ""; // f && f returns false
Conversion rules for booleansConverting AND to OR
The following operation involving booleans:
jsbCondition1 && bCondition2

is always equal to:
js!(!bCondition1 || !bCondition2)

Converting OR to AND
The following operation involving booleans:
jsbCondition1 || bCondition2

is always equal to:
js!(!bCondition1 && !bCondition2)
Removing nested parenthesesAs logical expressions are evaluated left to right, it is always possible to remove parentheses from a complex expression provided that certain rules are followed.
The following composite operation involving booleans:
jsbCondition1 || (bCondition2 && bCondition3)

is always equal to:
jsbCondition1 || bCondition2 && bCondition3
SpecificationsSpecificationECMAScript Language Specification # prod-LogicalANDExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Boolean
Truthy
Falsy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Logical AND assignment (&&=)The logical AND assignment (&&=) operator only evaluates the right operand and assigns to the left if the left operand is truthy.Try itSyntaxjsx &&= y
DescriptionLogical AND assignment short-circuits, meaning that x &&= y is equivalent to x && (x = y), except that the expression x is only evaluated once.
No assignment is performed if the left-hand side is not truthy, due to short-circuiting of the logical AND operator. For example, the following does not throw an error, despite x being const:
jsconst x = 0;
x &&= 2;

Neither would the following trigger the setter:
jsconst x = {
  get value() {
    return 0;
  },
  set value(v) {
    console.log("Setter called");
  },
};

x.value &&= 2;

In fact, if x is not truthy, y is not evaluated at all.
jsconst x = 0;
x &&= console.log("y evaluated");
// Logs nothing
ExamplesUsing logical AND assignmentjslet x = 0;
let y = 1;

x &&= 0; // 0
x &&= 1; // 0
y &&= 1; // 1
y &&= 0; // 0
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Logical AND (&&)
Nullish coalescing operator (??)
Bitwise AND assignment (&=)
Truthy
Falsy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Logical NOT (!)
  The logical NOT (!) (logical complement, negation) operator takes truth to
  falsity and vice versa. It is typically used with boolean (logical)
  values. When used with non-Boolean values, it returns false if its single
  operand can be converted to true; otherwise, returns true.
Try itSyntaxjs!x
Description
  Returns false if its single operand can be converted to true;
  otherwise, returns true.


  If a value can be converted to true, the value is so-called
  truthy. If a value can be converted to false, the value is
  so-called falsy.

Examples of expressions that can be converted to false are:

null;
NaN;
0;
empty string ("" or '' or ``);
undefined.

Even though the ! operator can be used with operands that are not Boolean values, it can still be considered a boolean operator since its return value can always be converted to a boolean primitive. To explicitly convert its return value (or any expression in general) to the corresponding boolean value, use a double NOT operator (!!) or the Boolean constructor.ExamplesUsing NOTThe following code shows examples of the ! (logical NOT) operator.
js!true; // !t returns false
!false; // !f returns true
!""; // !f returns true
!"Cat"; // !t returns false
Double NOT (!!)
  It is possible to use a couple of NOT operators in series to explicitly force the
  conversion of any value to the corresponding boolean primitive.
  The conversion is based on the "truthyness" or "falsyness" of the value (see
  truthy and falsy).

The same conversion can be done through the Boolean() function.
js!!true; // !!truthy returns true
!!{}; // !!truthy returns true: any object is truthy...
!!new Boolean(false); // ...even Boolean objects with a false .valueOf()!
!!false; // !!falsy returns false
!!""; // !!falsy returns false
!!Boolean(false); // !!falsy returns false
Converting between NOTsThe following operation involving booleans:
js!!bCondition

is always equal to:
jsbCondition
SpecificationsSpecificationECMAScript Language Specification # sec-logical-not-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Boolean
Truthy
Falsy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Logical OR (||)
  The logical OR (||) (logical disjunction) operator for a set of operands
  is true if and only if one or more of its operands is true. It is typically used with
  boolean (logical) values. When it is, it returns a Boolean value. However,
  the || operator actually returns the value of one of the specified
  operands, so if this operator is used with non-Boolean values, it will return a
  non-Boolean value.
Try itSyntaxjsx || y
Description
  If x can be converted to true, returns
  x; else, returns y.


  If a value can be converted to true, the value is so-called
  truthy. If a value can be converted to false, the value is
  so-called falsy.

Examples of expressions that can be converted to false are:

null;
NaN;
0;
empty string ("" or '' or ``);
undefined.


  Even though the || operator can be used with operands that are not Boolean
  values, it can still be considered a boolean operator since its return value can always
  be converted to a boolean primitive.
  To explicitly convert its return value (or any expression in general) to the
  corresponding boolean value, use a double NOT operator or the Boolean()
  constructor.
Short-circuit evaluation
  The logical OR expression is evaluated left to right, it is tested for possible
  "short-circuit" evaluation using the following rule:


(some truthy expression) || expr is short-circuit evaluated to
  the truthy expression.


  Short circuit means that the expr part above is not
evaluated, hence any side effects of doing so do not take effect (e.g., if
  expr is a function call, the calling never takes place). This
  happens because the value of the operator is already determined after the evaluation of
  the first operand. See example:

jsfunction A() {
  console.log("called A");
  return false;
}
function B() {
  console.log("called B");
  return true;
}

console.log(B() || A());
// Logs "called B" due to the function call,
// then logs true (which is the resulting value of the operator)
Operator precedence
  The following expressions might seem equivalent, but they are not, because the
  && operator is executed before the || operator
  (see operator precedence).

jstrue || false && false; // returns true, because && is executed first
(true || false) && false; // returns false, because grouping has the highest precedence
ExamplesUsing ORThe following code shows examples of the || (logical OR) operator.
jstrue || true; // t || t returns true
false || true; // f || t returns true
true || false; // t || f returns true
false || 3 === 4; // f || f returns false
"Cat" || "Dog"; // t || t returns "Cat"
false || "Cat"; // f || t returns "Cat"
"Cat" || false; // t || f returns "Cat"
"" || false; // f || f returns false
false || ""; // f || f returns ""
false || varObject; // f || object returns varObject



Note: If you use this operator to provide a default value to some
    variable, be aware that any falsy value will not be used. If you only need to
    filter out null or undefined, consider using
    the nullish coalescing operator.
  
Conversion rules for booleansConverting AND to OR
The following operation involving booleans:
jsbCondition1 && bCondition2

is always equal to:
js!(!bCondition1 || !bCondition2)

Converting OR to AND
The following operation involving booleans:
jsbCondition1 || bCondition2

is always equal to:
js!(!bCondition1 && !bCondition2)
Removing nested parentheses
  As logical expressions are evaluated left to right, it is always possible to remove
  parentheses from a complex expression following some rules.

The following composite operation involving booleans:
jsbCondition1 && (bCondition2 || bCondition3)

is always equal to:
js!(!bCondition1 || !bCondition2 && !bCondition3)
SpecificationsSpecificationECMAScript Language Specification # prod-LogicalORExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Nullish coalescing operator (??)
Boolean
Truthy
Falsy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Logical OR assignment (||=)The logical OR assignment (||=) operator only evaluates the right operand and assigns to the left if the left operand is falsy.Try itSyntaxjsx ||= y
DescriptionLogical OR assignment short-circuits, meaning that x ||= y is equivalent to x || (x = y), except that the expression x is only evaluated once.
No assignment is performed if the left-hand side is not falsy, due to short-circuiting of the logical OR operator. For example, the following does not throw an error, despite x being const:
jsconst x = 1;
x ||= 2;

Neither would the following trigger the setter:
jsconst x = {
  get value() {
    return 1;
  },
  set value(v) {
    console.log("Setter called");
  },
};

x.value ||= 2;

In fact, if x is not falsy, y is not evaluated at all.
jsconst x = 1;
x ||= console.log("y evaluated");
// Logs nothing
ExamplesSetting default contentIf the "lyrics" element is empty, display a default value:
jsdocument.getElementById("lyrics").textContent ||= "No lyrics.";

Here the short-circuit is especially beneficial, since the element will not be updated unnecessarily and won't cause unwanted side-effects such as additional parsing or rendering work, or loss of focus, etc.

  Note: Pay attention to the value returned by the API you're checking against. If an empty string is returned (a falsy value), ||= must be used, so that "No lyrics." is displayed instead of a blank space. However, if the API returns null or
  undefined in case of blank content, ??= should be used instead.
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Logical OR (||)
Nullish coalescing operator (??)
Bitwise OR assignment (|=)
Truthy
Falsy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Multiplication (*)The multiplication (*) operator produces the product of the operands.Try itSyntaxjsx * y
DescriptionThe * operator is overloaded for two types of operands: number and BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt multiplication if both operands become BigInts; otherwise, it performs number multiplication. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.ExamplesMultiplication using numbersjs2 * 2; // 4
-2 * 2; // -4
Multiplication with InfinityjsInfinity * 0; // NaN
Infinity * Infinity; // Infinity
Multiplication with non-numbersjs"foo" * 2; // NaN
"2" * 2; // 4
Multiplication using BigIntsjs2n * 2n; // 4n
-2n * 2n; // -4n

2n * 2; // TypeError: Cannot mix BigInt and other types, use explicit conversions

// To multiply a BigInt with a non-BigInt, convert either operand
2n * BigInt(2); // 4n
Number(2n) * 2; // 4
SpecificationsSpecificationECMAScript Language Specification # sec-multiplicative-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Division (/)
Remainder (%)
Exponentiation (**)
Increment (++)
Decrement (--)
Unary negation (-)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 18, 2023 by MDN contributors.
Multiplication assignment (*=)The multiplication assignment (*=) operator performs multiplication on the two operands and assigns the result to the left operand.Try itSyntaxjsx *= y
Descriptionx *= y is equivalent to x = x * y, except that the expression x is only evaluated once.ExamplesUsing multiplication assignmentjslet bar = 5;

bar *= 2; // 10
bar *= "foo"; // NaN

let foo = 3n;
foo *= 2n; // 6n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Multiplication (*)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
newThe new operator lets developers create an instance of a user-defined object type or of one of the built-in object types that has a constructor function.Try itSyntaxjsnew constructor
new constructor()
new constructor(arg1)
new constructor(arg1, arg2)
new constructor(arg1, arg2, /* …, */ argN)
Parameters
constructor

A class or function that specifies the type of the object instance.

arg1, arg2, …, argN

A list of values that the constructor will be called with. new Foo is equivalent to new Foo(), i.e. if no argument list is specified, Foo is called without arguments.

DescriptionWhen a function is called with the new keyword, the function will be used as a constructor. new will do the following things:

Creates a blank, plain JavaScript object. For convenience, let's call it newInstance.
Points newInstance's [[Prototype]] to the constructor function's prototype property, if the prototype is an Object. Otherwise, newInstance stays as a plain object with Object.prototype as its [[Prototype]].
    
Note: Properties/objects added to the constructor function's prototype property are therefore accessible to all instances created from the constructor function.


Executes the constructor function with the given arguments, binding newInstance as the this context (i.e. all references to this in the constructor function now refer to newInstance).
If the constructor function returns a non-primitive, this return value becomes the result of the whole new expression. Otherwise, if the constructor function doesn't return anything or returns a primitive, newInstance is returned instead. (Normally constructors don't return a value, but they can choose to do so to override the normal object creation process.)

Classes can only be instantiated with the new operator — attempting to call a class without new will throw a TypeError.
Creating an object with a user-defined constructor function requires two steps:


    Define the object type by writing a function that specifies its name and properties.
    For example, a constructor function to create an object Foo might look like this:
    jsfunction Foo(bar1, bar2) {
  this.bar1 = bar1;
  this.bar2 = bar2;
}


Create an instance of the object with new.
    jsconst myFoo = new Foo("Bar 1", 2021);




Note: An object can have a property that is itself another object. See the examples below.

You can always add a property to a previously defined object instance. For example, the statement car1.color = "black" adds a property color to car1, and assigns it a value of "black".
However, this does not affect any other objects. To add the new property to all objects of the same type, you must add the property to the constructor's prototype property. This defines a property that is shared by all objects created with that function, rather than by just one instance of the object type. The following code adds a color property with value "original color" to all objects of type Car, and then overwrites that value with the string "black" only in the instance object car1. For more information, see prototype.
jsfunction Car() {}
const car1 = new Car();
const car2 = new Car();

console.log(car1.color); // undefined

Car.prototype.color = "original color";
console.log(car1.color); // 'original color'

car1.color = "black";
console.log(car1.color); // 'black'

console.log(Object.getPrototypeOf(car1).color); // 'original color'
console.log(Object.getPrototypeOf(car2).color); // 'original color'
console.log(car1.color); // 'black'
console.log(car2.color); // 'original color'



Note: While the constructor function can be invoked like any regular function (i.e. without the new operator),
    in this case a new object is not created and the value of this is also different.
  

A function can know whether it is invoked with new by checking new.target. new.target is only undefined when the function is invoked without new. For example, you can have a function that behaves differently when it's called versus when it's constructed:
jsfunction Car(color) {
  if (!new.target) {
    // Called as function.
    return `${color} car`;
  }
  // Called with new.
  this.color = color;
}

const a = Car("red"); // a is "red car"
const b = new Car("red"); // b is `Car { color: "red" }`

Prior to ES6, which introduced classes, most JavaScript built-ins are both callable and constructible, although many of them exhibit different behaviors. To name a few:

Array(), Error(), and Function() behave the same when called as a function or a constructor.
Boolean(), Number(), and String() coerce their argument to the respective primitive type when called, and return wrapper objects when constructed.
Date() returns a string representing the current date when called, equivalent to new Date().toString().

After ES6, the language is stricter about which are constructors and which are functions. For example:

Symbol() and BigInt() can only be called without new. Attempting to construct them will throw a TypeError.
Proxy and Map can only be constructed with new. Attempting to call them will throw a TypeError.
ExamplesObject type and object instance
  Suppose you want to create an object type for cars. You want this type of object to be
  called Car, and you want it to have properties for make, model, and year.
  To do this, you would write the following function:

jsfunction Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

Now you can create an object called myCar as follows:
jsconst myCar = new Car("Eagle", "Talon TSi", 1993);


  This statement creates myCar and assigns it the specified values for its
  properties. Then the value of myCar.make is the string "Eagle",
  myCar.year is the integer 1993, and so on.


  You can create any number of car objects by calls to new. For
  example:

jsconst kensCar = new Car("Nissan", "300ZX", 1992);
Object property that is itself another objectSuppose you define an object called Person as follows:
jsfunction Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}

And then instantiate two new Person objects as follows:
jsconst rand = new Person("Rand McNally", 33, "M");
const ken = new Person("Ken Jones", 39, "M");


  Then you can rewrite the definition of Car to include an
  owner property that takes a Person object, as follows:

jsfunction Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}

To instantiate the new objects, you then use the following:
jsconst car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);


  Instead of passing a literal string or integer value when creating the new objects, the
  above statements pass the objects rand and ken as the
  parameters for the owners. To find out the name of the owner of car2, you
  can access the following property:

jscar2.owner.name;
Using new with classesjsclass Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const p = new Person("Caroline");
p.greet(); // Hello, my name is Caroline
SpecificationsSpecificationECMAScript Language Specification # sec-new-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Function
Reflect.construct()
Object
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
new.targetThe new.target meta-property lets you detect whether a function or constructor was called using the new operator. In constructors and functions invoked using the new operator, new.target returns a reference to the constructor or function that new was called upon. In normal function calls, new.target is undefined.Try itSyntaxjsnew.target
Valuenew.target is guaranteed to be a constructable function value or undefined.

In class constructors, it refers to the class that new was called upon, which may be a subclass of the current constructor, because subclasses transitively call the superclass's constructor through super().
In ordinary functions, if the function is constructed directly with new, new.target refers to the function itself. If the function is called without new, new.target is undefined. Functions can be used as the base class for extends, in which case new.target may refer to the subclass.
If a constructor (class or function) is called via Reflect.construct(), then new.target refers to the value passed as newTarget (which defaults to target).
In arrow functions, new.target is inherited from the surrounding scope. If the arrow function is not defined within another class or function which has a new.target binding, then a syntax error is thrown.
In static initialization blocks, new.target is undefined.
DescriptionThe new.target syntax consists of the keyword new, a dot, and the identifier target. Because new is a reserved word, not an identifier, this is not a property accessor, but a special expression syntax.
The new.target meta-property is available in all function/class bodies; using new.target outside of functions or classes is a syntax error.Examplesnew.target in function callsIn normal function calls (as opposed to constructor function calls), new.target is undefined. This lets you detect whether a function was called with new as a constructor.
jsfunction Foo() {
  if (!new.target) {
    throw new Error("Foo() must be called with new");
  }
  console.log("Foo instantiated with new");
}

new Foo(); // Logs "Foo instantiated with new"
Foo(); // Throws "Foo() must be called with new"
new.target in constructorsIn class constructors, new.target refers to the constructor that was directly invoked by new. This is also the case if the constructor is in a parent class and was delegated from a child constructor. new.target points to the class that new was called upon. For example, when b was initialized using new B(), the name of B was printed; and similarly, in case of a, the name of class A was printed.
jsclass A {
  constructor() {
    console.log(new.target.name);
  }
}

class B extends A {
  constructor() {
    super();
  }
}

const a = new A(); // Logs "A"
const b = new B(); // Logs "B"
new.target using Reflect.construct()Before Reflect.construct() or classes, it was common to implement inheritance by passing the value of this, and letting the base constructor mutate it.
jsfunction Base() {
  this.name = "Base";
}

function Extended() {
  // Only way to make the Base() constructor work on the existing
  // `this` value instead of a new object that `new` creates.
  Base.call(this);
  this.otherProperty = "Extended";
}

Object.setPrototypeOf(Extended.prototype, Base.prototype);
Object.setPrototypeOf(Extended, Base);

console.log(new Extended()); // Extended { name: 'Base', otherProperty: 'Extended' }

However, call() and apply() actually call the function instead of constructing it, so new.target has value undefined. This means that if Base() checks whether it's constructed with new, an error will be thrown, or it may behave in other unexpected ways. For example, you can't extend Map this way, because the Map() constructor cannot be called without new.
All built-in constructors directly construct the entire prototype chain of the new instance by reading new.target.prototype. So to make sure that (1) Base is constructed with new, and (2) new.target points to the subclass instead of Base itself, we need to use Reflect.construct().
jsfunction BetterMap(entries) {
  // Call the base class constructor, but setting `new.target` to the subclass,
  // so that the instance created has the correct prototype chain.
  return Reflect.construct(Map, [entries], BetterMap);
}

BetterMap.prototype.upsert = function (key, actions) {
  if (this.has(key)) {
    this.set(key, actions.update(this.get(key)));
  } else {
    this.set(key, actions.insert());
  }
};

Object.setPrototypeOf(BetterMap.prototype, Map.prototype);
Object.setPrototypeOf(BetterMap, Map);

const map = new BetterMap([["a", 1]]);
map.upsert("a", {
  update: (value) => value + 1,
  insert: () => 1,
});
console.log(map.get("a")); // 2


Note: In fact, due to the lack of Reflect.construct(), it is not possible to properly subclass built-ins (like Error subclassing) when transpiling to pre-ES6 code.

However, if you are writing ES6 code, prefer using classes and extends instead, as it's more readable and less error-prone.
jsclass BetterMap extends Map {
  // The constructor is omitted because it's just the default one

  upsert(key, actions) {
    if (this.has(key)) {
      this.set(key, actions.update(this.get(key)));
    } else {
      this.set(key, actions.insert());
    }
  }
}

const map = new BetterMap([["a", 1]]);
map.upsert("a", {
  update: (value) => value + 1,
  insert: () => 1,
});
console.log(map.get("a")); // 2
SpecificationsSpecificationECMAScript Language Specification # sec-built-in-function-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions
Classes
new
this
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
null
  The null value represents the intentional absence of any object value. It
  is one of JavaScript's primitive values and
  is treated as falsy for boolean operations.
Try itSyntaxjsnull
Description
  The value null is written with a literal: null.
  null is not an identifier for a property of the global object, like
  undefined can be. Instead,
  null expresses a lack of identification, indicating that a variable points
  to no object. In APIs, null is often retrieved in a place where an object
  can be expected but no object is relevant.

js// foo does not exist. It is not defined and has never been initialized:
foo; //ReferenceError: foo is not defined

js// foo is known to exist now but it has no type or value:
const foo = null;
foo; //null
ExamplesDifference between null and undefined
  When checking for null or undefined, beware of the differences between equality (==) and identity (===) operators, as the former performs
  type-conversion.

jstypeof null; // "object" (not "null" for legacy reasons)
typeof undefined; // "undefined"
null === undefined; // false
null == undefined; // true
null === null; // true
null == null; // true
!null; // true
Number.isNaN(1 + null); // false
Number.isNaN(1 + undefined); // true
SpecificationsSpecificationECMAScript Language Specification # sec-null-valueBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
undefined
NaN
void
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Nullish coalescing assignment (??=)The nullish coalescing assignment (??=) operator, also known as the logical nullish assignment operator, only evaluates the right operand and assigns to the left if the left operand is nullish (null or undefined).Try itSyntaxjsx ??= y
DescriptionNullish coalescing assignment short-circuits, meaning that x ??= y is equivalent to x ?? (x = y), except that the expression x is only evaluated once.
No assignment is performed if the left-hand side is not nullish, due to short-circuiting of the nullish coalescing operator. For example, the following does not throw an error, despite x being const:
jsconst x = 1;
x ??= 2;

Neither would the following trigger the setter:
jsconst x = {
  get value() {
    return 1;
  },
  set value(v) {
    console.log("Setter called");
  },
};

x.value ??= 2;

In fact, if x is not nullish, y is not evaluated at all.
jsconst x = 1;
x ??= console.log("y evaluated");
// Logs nothing
ExamplesUsing nullish coalescing assignmentYou can use the nullish coalescing assignment operator to apply default values to object properties. Compared to using destructuring and default values, ??= also applies the default value if the property has value null.
jsfunction config(options) {
  options.duration ??= 100;
  options.speed ??= 25;
  return options;
}

config({ duration: 125 }); // { duration: 125, speed: 25 }
config({}); // { duration: 100, speed: 25 }
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Nullish coalescing operator (??)
Nullish
Truthy
Falsy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Nullish coalescing operator (??)
  The nullish coalescing (??) operator is a logical
  operator that returns its right-hand side operand when its left-hand side operand is
  null or undefined, and otherwise returns its left-hand side
  operand.
Try itSyntaxjsleftExpr ?? rightExpr
DescriptionThe nullish coalescing operator can be seen as a special case of the logical OR (||) operator. The latter returns the right-hand side operand if the left operand is any falsy value, not only null or undefined. In other words, if you use || to provide some default value to another variable foo, you may encounter unexpected behaviors if you consider some falsy values as usable (e.g., '' or 0). See below for more examples.
The nullish coalescing operator has the fifth-lowest operator precedence, directly lower than || and directly higher than the conditional (ternary) operator.
It is not possible to combine both the AND (&&) and OR operators (||) directly with ??. A syntax error will be thrown in such cases.
jsnull || undefined ?? "foo"; // raises a SyntaxError
true && undefined ?? "foo"; // raises a SyntaxError

Instead, provide parenthesis to explicitly indicate precedence:
js(null || undefined) ?? "foo"; // returns "foo"
ExamplesUsing the nullish coalescing operatorIn this example, we will provide default values but keep values other than null or undefined.
jsconst nullValue = null;
const emptyText = ""; // falsy
const someNumber = 42;

const valA = nullValue ?? "default for A";
const valB = emptyText ?? "default for B";
const valC = someNumber ?? 0;

console.log(valA); // "default for A"
console.log(valB); // "" (as the empty string is not null or undefined)
console.log(valC); // 42
Assigning a default value to a variableEarlier, when one wanted to assign a default value to a variable, a common pattern was to use the logical OR operator (||):
jslet foo;

// foo is never assigned any value so it is still undefined
const someDummyText = foo || "Hello!";

However, due to || being a boolean logical operator, the left-hand-side operand was coerced to a boolean for the evaluation and any falsy value (including 0, '', NaN, false, etc.) was not returned. This behavior may cause unexpected consequences if you consider 0, '', or NaN as valid values.
jsconst count = 0;
const text = "";

const qty = count || 42;
const message = text || "hi!";
console.log(qty); // 42 and not 0
console.log(message); // "hi!" and not ""

The nullish coalescing operator avoids this pitfall by only returning the second operand when the first one evaluates to either null or undefined (but no other falsy values):
jsconst myText = ""; // An empty string (which is also a falsy value)

const notFalsyText = myText || "Hello world";
console.log(notFalsyText); // Hello world

const preservingFalsy = myText ?? "Hi neighborhood";
console.log(preservingFalsy); // '' (as myText is neither undefined nor null)
Short-circuitingLike the OR and AND logical operators, the right-hand side expression is not evaluated if the left-hand side proves to be neither null nor undefined.
jsfunction a() {
  console.log("a was called");
  return undefined;
}
function b() {
  console.log("b was called");
  return false;
}
function c() {
  console.log("c was called");
  return "foo";
}

console.log(a() ?? c());
// Logs "a was called" then "c was called" and then "foo"
// as a() returned undefined so both expressions are evaluated

console.log(b() ?? c());
// Logs "b was called" then "false"
// as b() returned false (and not null or undefined), the right
// hand side expression was not evaluated
Relationship with the optional chaining operator (?.)The nullish coalescing operator treats undefined and null as specific values. So does the optional chaining operator (?.), which is useful to access a property of an object which may be null or undefined. Combining them, you can safely access a property of an object which may be nullish and provide a default value if it is.
jsconst foo = { someFooProp: "hi" };

console.log(foo.someFooProp?.toUpperCase() ?? "not available"); // "HI"
console.log(foo.someBarProp?.toUpperCase() ?? "not available"); // "not available"
SpecificationsSpecificationECMAScript Language Specification # prod-CoalesceExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Nullish coalescing assignment (??=)
Optional chaining (?.)
Logical OR (||)
Default parameters
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Object initializerAn object initializer is a comma-delimited list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}). Objects can also be initialized using Object.create() or by invoking a constructor function with the new operator.Try itSyntaxjso = {
  a: "foo",
  b: 42,
  c: {},
  1: "number literal property",
  "foo:bar": "string literal property",

  shorthandProperty,

  method(parameters) {
    // …
  },

  get property() {},
  set property(value) {},

  [expression]: "computed property",

  __proto__: prototype,

  ...spreadProperty,
};
DescriptionAn object initializer is an expression that describes the initialization of an Object. Objects consist of properties, which are used to describe an object. The values of object properties can either contain primitive data types or other objects.Object literal syntax vs. JSONThe object literal syntax is not the same as the JavaScript Object Notation (JSON). Although they look similar, there are differences between them:

JSON only permits property definition using the "property": value syntax. The property name must be double-quoted, and the definition cannot be a shorthand. Computed property names are not allowed either.
JSON object property values can only be strings, numbers, true, false, null, arrays, or another JSON object. This means JSON cannot express methods or non-plain objects like Date or RegExp.
In JSON, "__proto__" is a normal property key. In an object literal, it sets the object's prototype.

JSON is a strict subset of the object literal syntax, meaning that every valid JSON text can be parsed as an object literal, and would likely not cause syntax errors. The only exception is that the object literal syntax prohibits duplicate __proto__ keys, which does not apply to JSON.parse(). The latter treats __proto__ like a normal property and takes the last occurrence as the property's value. The only time when the object value they represent (a.k.a. their semantic) differ is also when the source contains the __proto__ key — for object literals, it sets the object's prototype; for JSON, it's a normal property.
jsconsole.log(JSON.parse('{ "__proto__": 0, "__proto__": 1 }')); // {__proto__: 1}
console.log({ "__proto__": 0, "__proto__": 1 }); // SyntaxError: Duplicate __proto__ fields are not allowed in object literals

console.log(JSON.parse('{ "__proto__": {} }')); // { __proto__: {} }
console.log({ "__proto__": {} }); // {} (with {} as prototype)
ExamplesCreating objectsAn empty object with no properties can be created like this:
jsconst object = {};

However, the advantage of the literal or initializer notation is, that you are able to quickly create objects with properties inside the curly braces. You notate a list of key: value pairs delimited by commas.
The following code creates an object with three properties and the keys are "foo", "age" and "baz". The values of these keys are a string "bar", the number 42, and another object.
jsconst object = {
  foo: "bar",
  age: 42,
  baz: { myProp: 12 },
};
Accessing propertiesOnce you have created an object, you might want to read or change them. Object properties can be accessed by using the dot notation or the bracket notation. (See property accessors for detailed information.)
jsobject.foo; // "bar"
object["age"]; // 42
object.baz; // {myProp: 12}
object.baz.myProp; //12
Property definitionsWe have already learned how to notate properties using the initializer syntax. Oftentimes, there are variables in your code that you would like to put into an object. You will see code like this:
jsconst a = "foo";
const b = 42;
const c = {};

const o = {
  a: a,
  b: b,
  c: c,
};

There is a shorter notation available to achieve the same:
jsconst a = "foo";
const b = 42;
const c = {};

// Shorthand property names
const o = { a, b, c };

// In other words,
console.log(o.a === { a }.a); // true

Duplicate property names
When using the same name for your properties, the second property will overwrite the first.
jsconst a = { x: 1, x: 2 };
console.log(a); // {x: 2}

After ES2015, duplicate property names are allowed everywhere, including strict mode. You can also have duplicate property names in classes. The only exception is private properties, which must be unique in the class body.Method definitionsA property of an object can also refer to a function or a getter or setter method.
jsconst o = {
  property: function (parameters) {},
  get property() {},
  set property(value) {},
};

A shorthand notation is available, so that the keyword function is no longer necessary.
js// Shorthand method names
const o = {
  property(parameters) {},
};

There is also a way to concisely define generator methods.
jsconst o = {
  *generator() {
    // …
  },
};

Which is equivalent to this ES5-like notation (but note that ECMAScript 5 has no generators):
jsconst o = {
  generator: function* () {
    // …
  },
};

For more information and examples about methods, see method definitions.Computed property namesThe object initializer syntax also supports computed property names. That allows you to put an expression in square brackets [], that will be computed and used as the property name. This is reminiscent of the bracket notation of the property accessor syntax, which you may have used to read and set properties already.
Now you can use a similar syntax in object literals, too:
js// Computed property names
let i = 0;
const a = {
  [`foo${++i}`]: i,
  [`foo${++i}`]: i,
  [`foo${++i}`]: i,
};

console.log(a.foo1); // 1
console.log(a.foo2); // 2
console.log(a.foo3); // 3

const items = ["A", "B", "C"];
const obj = {
  [items]: "Hello",
};
console.log(obj); // A,B,C: "Hello"
console.log(obj["A,B,C"]); // "Hello"

const param = "size";
const config = {
  [param]: 12,
  [`mobile${param.charAt(0).toUpperCase()}${param.slice(1)}`]: 4,
};

console.log(config); // {size: 12, mobileSize: 4}
Spread propertiesObject literals support the spread syntax. It copies own enumerable properties from a provided object onto a new object.
Shallow-cloning (excluding prototype) or merging objects is now possible using a shorter syntax than Object.assign().
jsconst obj1 = { foo: "bar", x: 42 };
const obj2 = { foo: "baz", y: 13 };

const clonedObj = { ...obj1 };
// { foo: "bar", x: 42 }

const mergedObj = { ...obj1, ...obj2 };
// { foo: "baz", x: 42, y: 13 }


Warning: Note that Object.assign() triggers setters, whereas the spread syntax doesn't!
Prototype setterA property definition of the form __proto__: value or "__proto__": value does not create a property with the name __proto__. Instead, if the provided value is an object or null, it points the [[Prototype]] of the created object to that value. (If the value is not an object or null, the object is not changed.)
Note that the __proto__ key is standardized syntax, in contrast to the non-standard and non-performant Object.prototype.__proto__ accessors. It sets the [[Prototype]] during object creation, similar to Object.create — instead of mutating the prototype chain.
jsconst obj1 = {};
console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true

const obj2 = { __proto__: null };
console.log(Object.getPrototypeOf(obj2)); // null

const protoObj = {};
const obj3 = { "__proto__": protoObj };
console.log(Object.getPrototypeOf(obj3) === protoObj); // true

const obj4 = { __proto__: "not an object or null" };
console.log(Object.getPrototypeOf(obj4) === Object.prototype); // true
console.log(Object.hasOwn(obj4, "__proto__")); // false

Only a single prototype setter is permitted in an object literal. Multiple prototype setters are a syntax error.
Property definitions that do not use "colon" notation are not prototype setters. They are property definitions that behave identically to similar definitions using any other name.
jsconst __proto__ = "variable";

const obj1 = { __proto__ };
console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true
console.log(Object.hasOwn(obj1, "__proto__")); // true
console.log(obj1.__proto__); // "variable"

const obj2 = { __proto__() { return "hello"; } };
console.log(obj2.__proto__()); // "hello"

const obj3 = { ["__proto__"]: 17 };
console.log(obj3.__proto__); // 17

// Mixing prototype setter with normal own properties with "__proto__" key
const obj4 = { ["__proto__"]: 17, __proto__: {} }; // {__proto__: 17} (with {} as prototype)
const obj5 = {
  ["__proto__"]: 17,
  __proto__: {},
  __proto__: null, // SyntaxError: Duplicate __proto__ fields are not allowed in object literals
};
const obj6 = {
  ["__proto__"]: 17,
  ["__proto__"]: "hello",
  __proto__: null,
}; // {__proto__: "hello"} (with null as prototype)
const obj7 =  {
  ["__proto__"]: 17,
  __proto__,
  __proto__: null,
}; // {__proto__: "variable"} (with null as prototype)
SpecificationsSpecificationECMAScript Language Specification # sec-object-initializerBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Property accessors
get
set
Method definitions
Lexical grammar
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Operator precedenceOperator precedence determines how operators are parsed concerning each other. Operators with higher precedence become the operands of operators with lower precedence.Try itPrecedence and associativityConsider an expression describable by the representation below, where both OP1 and OP2 are fill-in-the-blanks for OPerators.
a OP1 b OP2 c

The combination above has two possible interpretations:
(a OP1 b) OP2 c
a OP1 (b OP2 c)

Which one the language decides to adopt depends on the identity of OP1 and OP2.
If OP1 and OP2 have different precedence levels (see the table below), the operator with the higher precedence goes first and associativity does not matter. Observe how multiplication has higher precedence than addition and executed first, even though addition is written first in the code.
jsconsole.log(3 + 10 * 2); // 23
console.log(3 + (10 * 2)); // 23, because parentheses here are superfluous
console.log((3 + 10) * 2); // 26, because the parentheses change the order

Within operators of the same precedence, the language groups them by associativity. Left-associativity (left-to-right) means that it is interpreted as (a OP1 b) OP2 c, while right-associativity (right-to-left) means it is interpreted as a OP1 (b OP2 c). Assignment operators are right-associative, so you can write:
jsa = b = 5; // same as writing a = (b = 5);

with the expected result that a and b get the value 5. This is because the assignment operator returns the value that is assigned. First, b is set to 5. Then the a is also set to 5 — the return value of b = 5, a.k.a. right operand of the assignment.
As another example, the unique exponentiation operator has right-associativity, whereas other arithmetic operators have left-associativity.
jsconst a = 4 ** 3 ** 2; // Same as 4 ** (3 ** 2); evaluates to 262144
const b = 4 / 3 / 2; // Same as (4 / 3) / 2; evaluates to 0.6666...

Operators are first grouped by precedence, and then, for adjacent operators that have the same precedence, by associativity. So, when mixing division and exponentiation, the exponentiation always comes before the division. For example, 2 ** 3 / 3 ** 2 results in 0.8888888888888888 because it is the same as (2 ** 3) / (3 ** 2).
For prefix unary operators, suppose we have the following pattern:
OP1 a OP2 b

where OP1 is a prefix unary operator and OP2 is a binary operator. If OP1 has higher precedence than OP2, then it would be grouped as (OP1 a) OP2 b; otherwise, it would be OP1 (a OP2 b).
jsconst a = 1;
const b = 2;
typeof a + b; // Equivalent to (typeof a) + b; result is "number2"

If the unary operator is on the second operand:
a OP2 OP1 b

Then the binary operator OP2 must have lower precedence than the unary operator OP1 for it to be grouped as a OP2 (OP1 b). For example, the following is invalid:
jsfunction* foo() {
  a + yield 1;
}

Because + has higher precedence than yield, this would become (a + yield) 1 — but because yield is a reserved word in generator functions, this would be a syntax error. Luckily, most unary operators have higher precedence than binary operators and do not suffer from this pitfall.
If we have two prefix unary operators:
OP1 OP2 a

Then the unary operator closer to the operand, OP2, must have higher precedence than OP1 for it to be grouped as OP1 (OP2 a). It's possible to get it the other way and end up with (OP1 OP2) a:
jsasync function* foo() {
  await yield 1;
}

Because await has higher precedence than yield, this would become (await yield) 1, which is awaiting an identifier called yield, and a syntax error. Similarly, if you have new !A;, because ! has lower precedence than new, this would become (new !) A, which is obviously invalid. (This code looks nonsensical to write anyway, since !A always produces a boolean, not a constructor function.)
For postfix unary operators (namely, ++ and --), the same rules apply. Luckily, both operators have higher precedence than any binary operator, so the grouping is always what you would expect. Moreover, because ++ evaluates to a value, not a reference, you can't chain multiple increments together either, as you may do in C.
jslet a = 1;
a++++; // SyntaxError: Invalid left-hand side in postfix operation.

Operator precedence will be handled recursively. For example, consider this expression:
js1 + 2 ** 3 * 4 / 5 >> 6

First, we group operators with different precedence by decreasing levels of precedence.

The ** operator has the highest precedence, so it's grouped first.
Looking around the ** expression, it has * on the right and + on the left. * has higher precedence, so it's grouped first. * and / have the same precedence, so we group them together for now.
Looking around the *// expression grouped in 2, because + has higher precedence than >>, the former is grouped.

js   (1 + ( (2 ** 3) * 4 / 5) ) >> 6
// │    │ └─ 1. ─┘        │ │
// │    └────── 2. ───────┘ │
// └────────── 3. ──────────┘

Within the *// group, because they are both left-associative, the left operand would be grouped.
js   (1 + ( ( (2 ** 3) * 4 ) / 5) ) >> 6
// │    │ │ └─ 1. ─┘     │    │ │
// │    └─│─────── 2. ───│────┘ │
// └──────│───── 3. ─────│──────┘
//        └───── 4. ─────┘

Note that operator precedence and associativity only affect the order of evaluation of operators (the implicit grouping), but not the order of evaluation of operands. The operands are always evaluated from left-to-right. The higher-precedence expressions are always evaluated first, and their results are then composed according to the order of operator precedence.
jsfunction echo(name, num) {
  console.log(`Evaluating the ${name} side`);
  return num;
}
// Exponentiation operator (**) is right-associative,
// but all call expressions (echo()), which have higher precedence,
// will be evaluated before ** does
console.log(echo("left", 4) ** echo("middle", 3) ** echo("right", 2));
// Evaluating the left side
// Evaluating the middle side
// Evaluating the right side
// 262144

// Exponentiation operator (**) has higher precedence than division (/),
// but evaluation always starts with the left operand
console.log(echo("left", 4) / echo("middle", 3) ** echo("right", 2));
// Evaluating the left side
// Evaluating the middle side
// Evaluating the right side
// 0.4444444444444444

If you are familiar with binary trees, think about it as a post-order traversal.
                /
       ┌────────┴────────┐
echo("left", 4)         **
                ┌────────┴────────┐
        echo("middle", 3)  echo("right", 2)

After all operators have been properly grouped, the binary operators would form a binary tree. Evaluation starts from the outermost group — which is the operator with the lowest precedence (/ in this case). The left operand of this operator is first evaluated, which may be composed of higher-precedence operators (such as a call expression echo("left", 4)). After the left operand has been evaluated, the right operand is evaluated in the same fashion. Therefore, all leaf nodes — the echo() calls — would be visited left-to-right, regardless of the precedence of operators joining them.Short-circuitingIn the previous section, we said "the higher-precedence expressions are always evaluated first" — this is generally true, but it has to be amended with the acknowledgement of short-circuiting, in which case an operand may not be evaluated at all.
Short-circuiting is jargon for conditional evaluation. For example, in the expression a && (b + c), if a is falsy, then the sub-expression (b + c) will not even get evaluated, even if it is grouped and therefore has higher precedence than &&. We could say that the logical AND operator (&&) is "short-circuited". Along with logical AND, other short-circuited operators include logical OR (||), nullish coalescing (??), and optional chaining (?.).
jsa || (b * c); // evaluate `a` first, then produce `a` if `a` is "truthy"
a && (b < c); // evaluate `a` first, then produce `a` if `a` is "falsy"
a ?? (b || c); // evaluate `a` first, then produce `a` if `a` is not `null` and not `undefined`
a?.b.c; // evaluate `a` first, then produce `undefined` if `a` is `null` or `undefined`

When evaluating a short-circuited operator, the left operand is always evaluated. The right operand will only be evaluated if the left operand cannot determine the result of the operation.

Note: The behavior of short-circuiting is baked in these operators. Other operators would always evaluate both operands, regardless if that's actually useful — for example, NaN * foo() will always call foo, even when the result would never be something other than NaN.

The previous model of a post-order traversal still stands. However, after the left subtree of a short-circuiting operator has been visited, the language will decide if the right operand needs to be evaluated. If not (for example, because the left operand of || is already truthy), the result is directly returned without visiting the right subtree.
Consider this case:
jsfunction A() { console.log('called A'); return false; }
function B() { console.log('called B'); return false; }
function C() { console.log('called C'); return true; }

console.log(C() || B() && A());

// Logs:
// called C
// true

Only C() is evaluated, despite && having higher precedence. This does not mean that || has higher precedence in this case — it's exactly because (B() && A()) has higher precedence that causes it to be neglected as a whole. If it's re-arranged as:
jsconsole.log(A() && C() || B());
// Logs:
// called A
// called B
// false

Then the short-circuiting effect of && would only prevent C() from being evaluated, but because A() && C() as a whole is false, B() would still be evaluated.
However, note that short-circuiting does not change the final evaluation outcome. It only affects the evaluation of operands, not how operators are grouped — if evaluation of operands doesn't have side effects (for example, logging to the console, assigning to variables, throwing an error), short-circuiting would not be observable at all.
The assignment counterparts of these operators (&&=, ||=, ??=) are short-circuited as well. They are short-circuited in a way that the assignment does not happen at all.TableThe following table lists operators in order from highest precedence (18) to lowest precedence (1).
Several general notes about the table:

Not all syntax included here are "operators" in the strict sense. For example, spread ... and arrow => are typically not regarded as operators. However, we still included them to show how tightly they bind compared to other operators/expressions.
Some operators have certain operands that require expressions narrower than those produced by higher-precedence operators. For example, the right-hand side of member access . (precedence 17) must be an identifier instead of a grouped expression. The left-hand side of arrow => (precedence 2) must be an arguments list or a single identifier instead of some random expression.
Some operators have certain operands that accept expressions wider than those produced by higher-precedence operators. For example, the bracket-enclosed expression of bracket notation [ … ] (precedence 17) can be any expression, even comma (precedence 1) joined ones. These operators act as if that operand is "automatically grouped". In this case we will omit the associativity.




Precedence
Associativity
Individual operators
Notes


18: grouping
n/a
Grouping(x)
[1]


17: access and call
left-to-right
Member accessx.y
[2]


Optional chainingx?.y


n/a
Computed member accessx[y]
[3]


new with argument listnew x(y)
[4]


Function callx(y)


import(x)


16: new
n/a
new without argument listnew x


15: postfix operators
n/a
Postfix incrementx++
[5]


Postfix decrementx--


14: prefix operators
n/a
Prefix increment++x
[6]


Prefix decrement--x


Logical NOT!x


Bitwise NOT~x


Unary plus+x


Unary negation-x


typeof x


void x


delete x
[7]


await x


13: exponentiation
right-to-left
Exponentiationx ** y
[8]


12: multiplicative operators
left-to-right
Multiplicationx * y


Divisionx / y


Remainderx % y


11: additive operators
left-to-right
Additionx + y


Subtractionx - y


10: bitwise shift
left-to-right
Left shiftx << y


Right shiftx >> y


Unsigned right shiftx >>> y


9: relational operators
left-to-right
Less thanx < y


Less than or equalx <= y


Greater thanx > y


Greater than or equalx >= y


x in y


x instanceof y


8: equality operators
left-to-right
Equalityx == y


Inequalityx != y


Strict equalityx === y


Strict inequalityx !== y


7: bitwise AND
left-to-right
Bitwise ANDx & y


6: bitwise XOR
left-to-right
Bitwise XORx ^ y


5: bitwise OR
left-to-right
Bitwise ORx | y


4: logical AND
left-to-right
Logical ANDx && y


3: logical OR, nullish coalescing
left-to-right
Logical ORx || y


Nullish coalescing operatorx ?? y
[9]


2: assignment and miscellaneous
right-to-left
Assignmentx = y
[10]


Addition assignmentx += y


Subtraction assignmentx -= y


Exponentiation assignmentx **= y


Multiplication assignmentx *= y


Division assignmentx /= y


Remainder assignmentx %= y


Left shift assignmentx <<= y


Right shift assignmentx >>= y


Unsigned right shift assignmentx >>>= y


Bitwise AND assignmentx &= y


Bitwise XOR assignmentx ^= y


Bitwise OR assignmentx |= y


Logical AND assignmentx &&= y


Logical OR assignmentx ||= y


Nullish coalescing assignmentx ??= y


right-to-left
Conditional (ternary) operatorx ? y : z
[11]


right-to-left
Arrowx => y
[12]


n/a
yield x


yield* x


Spread...x
[13]


1: comma
left-to-right
Comma operatorx, y



Notes:

The operand can be any expression.
The "right-hand side" must be an identifier.
The "right-hand side" can be any expression.
The "right-hand side" is a comma-separated list of any expression with precedence > 1 (i.e. not comma expressions).
The operand must be a valid assignment target (identifier or property access). Its precedence means new Foo++ is (new Foo)++ (a syntax error) and not new (Foo++) (a TypeError: (Foo++) is not a constructor).
The operand must be a valid assignment target (identifier or property access).
The operand cannot be an identifier or a private property access.
The left-hand side cannot have precedence 14.
The operands cannot be a logical OR || or logical AND && operator without grouping.
The "left-hand side" must be a valid assignment target (identifier or property access).
The associativity means the two expressions after ? are implicitly grouped.
The "left-hand side" is a single identifier or a parenthesized parameter list.
Only valid inside object literals, array literals, or argument lists.
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 24, 2023 by MDN contributors.
Optional chaining (?.)The optional chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called using this operator is undefined or null, the expression short circuits and evaluates to undefined instead of throwing an error.Try itSyntaxjsobj.val?.prop
obj.val?.[expr]
obj.func?.(args)
DescriptionThe ?. operator is like the . chaining operator, except that instead of causing an error if a reference is nullish (null or undefined), the expression short-circuits with a return value of undefined. When used with function calls, it returns undefined if the given function does not exist.
This results in shorter and simpler expressions when accessing chained properties when the possibility exists that a reference may be missing. It can also be helpful while exploring the content of an object when there's no known guarantee as to which properties are required.

  For example, consider an object obj which has a nested structure. Without
  optional chaining, looking up a deeply-nested subproperty requires validating the
  references in between, such as:

jsconst nestedProp = obj.first && obj.first.second;


  The value of obj.first is confirmed to be non-null (and
  non-undefined) before accessing the value of
  obj.first.second. This prevents the error that would occur if you accessed
  obj.first.second directly without testing obj.first.

This is an idiomatic pattern in JavaScript, but it gets verbose when the chain is long, and it's not safe. For example, if obj.first is a Falsy value that's not null or undefined, such as 0, it would still short-circuit and make nestedProp become 0, which may not be desirable.

  With the optional chaining operator (?.), however, you don't have to
  explicitly test and short-circuit based on the state of obj.first before
  trying to access obj.first.second:

jsconst nestedProp = obj.first?.second;


  By using the ?. operator instead of just ., JavaScript knows
  to implicitly check to be sure obj.first is not null or
  undefined before attempting to access obj.first.second. If
  obj.first is null or undefined, the expression
  automatically short-circuits, returning undefined.


  This is equivalent to the following, except that the temporary variable is in fact not
  created:

jsconst temp = obj.first;
const nestedProp =
  temp === null || temp === undefined ? undefined : temp.second;

Optional chaining cannot be used on a non-declared root object, but can be used with a root object with value undefined.
jsundeclaredVar?.prop; // ReferenceError: undeclaredVar is not defined
Optional chaining with function calls
  You can use optional chaining when attempting to call a method which may not exist.
  This can be helpful, for example, when using an API in which a method might be
  unavailable, either due to the age of the implementation or because of a feature which
  isn't available on the user's device.


  Using optional chaining with function calls causes the expression to automatically
  return undefined instead of throwing an exception if the method isn't
  found:

jsconst result = someInterface.customMethod?.();

However, if there is a property with such a name which is not a function, using ?. will still raise a TypeError exception "someInterface.customMethod is not a function".


Note: If someInterface itself is null or
    undefined, a TypeError exception will still be
    raised ("someInterface is null"). If you expect that
    someInterface itself may be null or undefined,
    you have to use ?. at this position as
    well: someInterface?.customMethod?.().
  

eval?.() is the shortest way to enter indirect eval mode.Optional chaining with expressionsYou can also use the optional chaining operator with bracket notation, which allows passing an expression as the property name:
jsconst nestedProp = obj?.["prop" + "Name"];

This is particularly useful for arrays, since array indices must be accessed with square brackets.
jsfunction printMagicIndex(arr) {
  console.log(arr?.[42]);
}

printMagicIndex([0, 1, 2, 3, 4, 5]); // undefined
printMagicIndex(); // undefined; if not using ?., this would throw an error: "Cannot read properties of undefined (reading '42')"
Optional chaining not valid on the left-hand side of an assignmentIt is invalid to try to assign to the result of an optional chaining expression:
jsconst object = {};
object?.property = 1; // SyntaxError: Invalid left-hand side in assignment
Short-circuitingWhen using optional chaining with expressions, if the left operand is null or undefined, the expression will not be evaluated. For instance:
jsconst potentiallyNullObj = null;
let x = 0;
const prop = potentiallyNullObj?.[x++];

console.log(x); // 0 as x was not incremented

Subsequent property accesses will not be evaluated either.
jsconst potentiallyNullObj = null;
const prop = potentiallyNullObj?.a.b;
// This does not throw, because evaluation has already stopped at
// the first optional chain

This is equivalent to:
jsconst potentiallyNullObj = null;
const prop =
  potentiallyNullObj === null || potentiallyNullObj === undefined
    ? undefined
    : potentiallyNullObj.a.b;

However, this short-circuiting behavior only happens along one continuous "chain" of property accesses. If you group one part of the chain, then subsequent property accesses will still be evaluated.
jsconst potentiallyNullObj = null;
const prop = (potentiallyNullObj?.a).b;
// TypeError: Cannot read properties of undefined (reading 'b')

This is equivalent to:
jsconst potentiallyNullObj = null;
const temp = potentiallyNullObj?.a;
const prop = temp.b;

Except the temp variable isn't created.ExamplesBasic example
  This example looks for the value of the name property for the member
  bar in a map when there is no such member. The result is therefore
  undefined.

jsconst myMap = new Map();
myMap.set("foo", { name: "baz", desc: "inga" });

const nameBar = myMap.get("bar")?.name;
Dealing with optional callbacks or event handlers
  If you use callbacks or fetch methods from an object with
  a destructuring assignment, you may have non-existent values that you cannot call as
  functions unless you have tested their existence. Using ?., you can avoid this extra test:

js// Code written without optional chaining
function doSomething(onContent, onError) {
  try {
    // Do something with the data
  } catch (err) {
    // Testing if onError really exists
    if (onError) {
      onError(err.message);
    }
  }
}

js// Using optional chaining with function calls
function doSomething(onContent, onError) {
  try {
    // Do something with the data
  } catch (err) {
    onError?.(err.message); // No exception if onError is undefined
  }
}
Stacking the optional chaining operatorWith nested structures, it is possible to use optional chaining multiple times:
jsconst customer = {
  name: "Carl",
  details: {
    age: 82,
    location: "Paradise Falls", // Detailed address is unknown
  },
};
const customerCity = customer.details?.address?.city;

// This also works with optional chaining function call
const customerName = customer.name?.getName?.(); // Method does not exist, customerName is undefined
Combining with the nullish coalescing operatorThe nullish coalescing operator may be used after optional chaining in order to build a default value when none was found:
jsfunction printCustomerCity(customer) {
  const customerCity = customer?.city ?? "Unknown city";
  console.log(customerCity);
}

printCustomerCity({
  name: "Nathan",
  city: "Paris",
}); // "Paris"
printCustomerCity({
  name: "Carl",
  details: { age: 82 },
}); // "Unknown city"
SpecificationsSpecificationECMAScript Language Specification # prod-OptionalExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Nullish coalescing operator (??)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Property accessorsProperty accessors provide access to an object's properties by using the dot notation or the bracket notation.Try itSyntaxjsobject.propertyName
object[expression]
DescriptionOne can think of an object as an associative array (a.k.a. map, dictionary, hash, lookup table). The keys in this array are the names of the object's properties.
There are two ways to access properties: dot notation and bracket notation.Dot notationIn the object.propertyName syntax, the propertyName must be a valid JavaScript identifier which can also be a reserved word. For example, object.$1 is valid, while object.1 is not.
jsconst variable = object.propertyName;
object.propertyName = value;

jsconst object = {};
object.$1 = "foo";
console.log(object.$1); // 'foo'

jsconst object = {};
object.1 = 'bar'; // SyntaxError
console.log(object.1); // SyntaxError

Here, the method named createElement is retrieved from document and is called.
jsdocument.createElement("pre");

If you use a method for a numeric literal, and the numeric literal has no exponent and no decimal point, you should leave white-space(s) before the dot preceding the method call, so that the dot is not interpreted as a decimal point.
js77 .toExponential();
// or
77
.toExponential();
// or
(77).toExponential();
// or
77..toExponential();
// or
77.0.toExponential();
// because 77. === 77.0, no ambiguity
Bracket notationIn the object[expression] syntax, the expression should evaluate to a string or Symbol that represents the property's name. So, it can be any string literal, for example, including '1foo', '!bar!', or even ' ' (a space).
jsconst variable = object[propertyName];
object[propertyName] = value;

This does the exact same thing as the previous example.
jsdocument["createElement"]("pre");

A space before bracket notation is allowed.
jsdocument ["createElement"]("pre");

Passing expressions that evaluate to property name will do the same thing as directly passing the property name.
jsconst key = "name";
const getKey = () => "name";
const Obj = { name: "Michel" };

Obj["name"]; // returns "Michel"
Obj[key]; // evaluates to Obj["name"], and returns "Michel"
Obj[getKey()]; // evaluates to Obj["name"], and returns "Michel"

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks.Property namesEach property name is a string or a Symbol. Any other value, including a number, is coerced to a string. This outputs 'value', since 1 is coerced into '1'.
jsconst object = {};
object["1"] = "value";
console.log(object[1]);

This also outputs 'value', since both foo and bar are converted to the same string ("[object Object]").
jsconst foo = { uniqueProp: 1 };
const bar = { uniqueProp: 2 };
const object = {};
object[foo] = "value";
console.log(object[bar]);
Method bindingIt's typical when speaking of an object's properties to make a distinction between properties and methods. However, the property/method distinction is little more than a convention. A method is a property that can be called (for example, if it has a reference to a Function instance as its value).
A method is not bound to the object that it is a property of. Specifically, this is not fixed in a method and does not necessarily refer to the object containing the method. Instead, this is "passed" by the function call. See the reference for this.ExamplesBracket notation vs. eval()JavaScript novices often make the mistake of using eval() where the bracket notation can be used instead.
For example, the following syntax is often seen in many scripts.
jsconst x = eval(`document.forms.form_name.elements.${strFormControl}.value`);

eval() is slow and should be avoided whenever possible. Also, strFormControl would have to hold an identifier, which is not required for names and ids of form controls. It is better to use bracket notation instead:
jsconst x = document.forms.form_name.elements[strFormControl].value;
SpecificationsSpecificationECMAScript Language Specification # sec-property-accessorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Object
Object.defineProperty()
Optional chaining (?.)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Remainder (%)The remainder (%) operator returns the remainder left over when one operand is divided by a second operand. It always takes the sign of the dividend.Try itSyntaxjsx % y
DescriptionThe % operator is overloaded for two types of operands: number and BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt remainder if both operands become BigInts; otherwise, it performs number remainder. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
For the operation n % d, n is called the dividend and d is called the divisor. The operation returns NaN if one of the operands is NaN, n is ±Infinity, or if d is ±0. Otherwise, if d is ±Infinity or if n is ±0, the dividend n is returned.
When both operands are non-zero and finite, the remainder r is calculated as r := n - d * q where q is the integer such that r has the same sign as the dividend n while being as close to 0 as possible.
Note that while in most languages, '%' is a remainder operator, in some (e.g. Python, Perl) it is a modulo operator. Modulo is defined as k := n - d * q where q is the integer such that k has the same sign as the divisor d while being as close to 0 as possible. For two values of the same sign, the two are equivalent, but when the operands are of different signs, the modulo result always has the same sign as the divisor, while the remainder has the same sign as the dividend, which can make them differ by one unit of d. To obtain a modulo in JavaScript, in place of n % d, use ((n % d) + d) % d. In JavaScript, the modulo operation (which doesn't have a dedicated operator) is used to normalize the second operand of bitwise shift operators (<<, >>, etc.), making the offset always a positive value.
For BigInt division, a RangeError is thrown if the divisor y is 0n. This is because number remainder by zero returns NaN, but BigInt has no concept of NaN.ExamplesRemainder with positive dividendjs13 % 5; // 3
1 % -2; // 1
1 % 2; // 1
2 % 3; // 2
5.5 % 2; // 1.5

3n % 2n; // 1n
Remainder with negative dividendjs-13 % 5; // -3
-1 % 2; // -1
-4 % 2; // -0

-3n % 2n; // -1n
Remainder with NaNjsNaN % 2; // NaN
Remainder with InfinityjsInfinity % 2; // NaN
Infinity % 0; // NaN
Infinity % Infinity; // NaN
2 % Infinity; // 2
0 % Infinity; // 0
SpecificationsSpecificationECMAScript Language Specification # sec-multiplicative-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Division (/)
Multiplication (*)
Exponentiation (**)
Increment (++)
Decrement (--)
Unary negation (-)
Unary plus (+)
Remainder operator vs. modulo operator by Dr. Axel Rauschmayer (2019)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
Remainder assignment (%=)The remainder assignment (%=) operator performs remainder on the two operands and assigns the result to the left operand.Try itSyntaxjsx %= y
Descriptionx %= y is equivalent to x = x % y, except that the expression x is only evaluated once.ExamplesUsing remainder assignmentjslet bar = 5;

bar %= 2; // 1
bar %= "foo"; // NaN
bar %= 0; // NaN

let foo = 3n;
foo %= 2n; // 1n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Remainder (%)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Right shift (>>)The right shift (>>) operator returns a number or BigInt whose binary representation is the first operand shifted by the specified number of bits to the right. Excess bits shifted off to the right are discarded, and copies of the leftmost bit are shifted in from the left. This operation is also called "sign-propagating right shift" or "arithmetic right shift", because the sign of the resulting number is the same as the sign of the first operand.Try itSyntaxjsx >> y
DescriptionThe >> operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt right shift if both operands become BigInts; otherwise, it converts both operands to 32-bit integers and performs number right shift. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.
Since the new leftmost bit has the same value as the previous leftmost bit, the sign bit (the leftmost bit) does not change. Hence the name "sign-propagating".
The operator operates on the left operand's bit representation in two's complement. Consider the 32-bit binary representations of the decimal (base 10) numbers 9 and -9:
     9 (base 10): 00000000000000000000000000001001 (base 2)
    -9 (base 10): 11111111111111111111111111110111 (base 2)

The binary representation under two's complement of the negative decimal (base 10) number -9 is formed by inverting all the bits of its opposite number, which is 9 and 00000000000000000000000000001001 in binary, and adding 1.
In both cases, the sign of the binary number is given by its leftmost bit: for the positive decimal number 9, the leftmost bit of the binary representation is 0, and for the negative decimal number -9, the leftmost bit of the binary representation is 1.
Given those binary representations of the decimal (base 10) numbers 9, and -9:
9 >> 2 yields 2:
     9 (base 10): 00000000000000000000000000001001 (base 2)
                  --------------------------------
9 >> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)

Notice how two rightmost bits, 01, have been shifted off, and two copies of the leftmost bit, 0 have been shifted in from the left.
-9 >> 2 yields -3:
     -9 (base 10): 11111111111111111111111111110111 (base 2)
                   --------------------------------
-9 >> 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)

Notice how two rightmost bits, 11, have been shifted off. But as far as the leftmost bits: in this case, the leftmost bit is 1. So two copies of that leftmost 1 bit have been shifted in from the left — which preserves the negative sign.
The binary representation 11111111111111111111111111111101 is equal to the negative decimal (base 10) number -3, because all negative integers are stored as two's complements, and this one can be calculated by inverting all the bits of the binary representation of the positive decimal (base 10) number 3, which is 00000000000000000000000000000011, and then adding one.
If the left operand is a number with more than 32 bits, it will get the most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001

The right operand will be converted to an unsigned 32-bit integer and then taken modulo 32, so the actual shift offset will always be a positive integer between 0 and 31, inclusive. For example, 100 >> 32 is the same as 100 >> 0 (and produces 100) because 32 modulo 32 is 0.
For BigInts, there's no truncation. Conceptually, understand positive BigInts as having an infinite number of leading 0 bits, and negative BigInts having an infinite number of leading 1 bits.
Right shifting any number x by 0 returns x converted to a 32-bit integer. Do not use >> 0 to truncate numbers to integers; use Math.trunc() instead.ExamplesUsing right shiftjs9 >> 2; // 2
-9 >> 2; // -3

9n >> 2n; // 2n
SpecificationsSpecificationECMAScript Language Specification # sec-signed-right-shift-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Bitwise operators in the JS guide
Right shift assignment (>>=)
Unsigned right shift (>>>)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 18, 2023 by MDN contributors.
Right shift assignment (>>=)The right shift assignment (>>=) operator performs right shift on the two operands and assigns the result to the left operand.Try itSyntaxjsx >>= y
Descriptionx >>= y is equivalent to x = x >> y, except that the expression x is only evaluated once.ExamplesUsing right shift assignmentjslet a = 5; //   (00000000000000000000000000000101)
a >>= 2; //   1 (00000000000000000000000000000001)

let b = -5; //  (-00000000000000000000000000000101)
b >>= 2; //  -2 (-00000000000000000000000000000010)

let c = 5n;
c >>= 2n; // 1n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Right shift (>>)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
Spread syntax (...)The spread (...) syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.
Spread syntax looks exactly like rest syntax. In a way, spread syntax is the opposite of rest syntax. Spread syntax "expands" an array into its elements, while rest syntax collects multiple elements and "condenses" them into a single element. See rest parameters and rest property.Try itSyntaxjsmyFunction(a, ...iterableObj, b)
[1, ...iterableObj, '4', 'five', 6]
{ ...obj, key: 'value' }
DescriptionSpread syntax can be used when all elements from an object or array need to be included in a new array or object, or should be applied one-by-one in a function call's arguments list. There are three distinct places that accept the spread syntax:

Function arguments list (myFunction(a, ...iterableObj, b))
Array literals ([1, ...iterableObj, '4', 'five', 6])
Object literals ({ ...obj, key: 'value' })

Although the syntax looks the same, they come with slightly different semantics.
Only iterable values, like Array and String, can be spread in array literals and argument lists. Many objects are not iterable, including all plain objects that lack a Symbol.iterator method:
jsconst obj = { key1: "value1" };
const array = [...obj]; // TypeError: obj is not iterable

On the other hand, spreading in object literals enumerates the own properties of the value. For typical arrays, all indices are enumerable own properties, so arrays can be spread into objects.
jsconst array = [1, 2, 3];
const obj = { ...array }; // { 0: 1, 1: 2, 2: 3 }

All primitives can be spread in objects. Only strings have enumerable own properties, and spreading anything else doesn't create properties on the new object.
jsconst obj = { ...true, ..."test", ...10 };
// { '0': 't', '1': 'e', '2': 's', '3': 't' }

When using spread syntax for function calls, be aware of the possibility of exceeding the JavaScript engine's argument length limit. See Function.prototype.apply() for more details.ExamplesSpread in function callsReplace apply()

  It is common to use Function.prototype.apply() in cases where you want to
  use the elements of an array as arguments to a function.

jsfunction myFunction(x, y, z) {}
const args = [0, 1, 2];
myFunction.apply(null, args);

With spread syntax the above can be written as:
jsfunction myFunction(x, y, z) {}
const args = [0, 1, 2];
myFunction(...args);


  Any argument in the argument list can use spread syntax, and the spread syntax can be
  used multiple times.

jsfunction myFunction(v, w, x, y, z) {}
const args = [0, 1];
myFunction(-1, ...args, 2, ...[3]);

Apply for new operator
When calling a constructor with new, it's not possible to directly use an array and apply(), because apply() calls the target function instead of constructing it, which means, among other things, that new.target will be undefined. However, an array can be easily used with new thanks to spread syntax:
jsconst dateFields = [1970, 0, 1]; // 1 Jan 1970
const d = new Date(...dateFields);
Spread in array literalsA more powerful array literal
Without spread syntax, the array literal syntax is no longer sufficient to create a new array using an existing array as one part of it. Instead, imperative code must be used using a combination of methods, including push(), splice(), concat(), etc. With spread syntax, this becomes much more succinct:
jsconst parts = ["shoulders", "knees"];
const lyrics = ["head", ...parts, "and", "toes"];
//  ["head", "shoulders", "knees", "and", "toes"]

Just like spread for argument lists, ... can be used anywhere in the array literal, and may be used more than once.
Copying an array
You can use spread syntax to make a shallow copy of an array. Each array element retains its identity without getting copied.
jsconst arr = [1, 2, 3];
const arr2 = [...arr]; // like arr.slice()

arr2.push(4);
// arr2 becomes [1, 2, 3, 4]
// arr remains unaffected

Spread syntax effectively goes one level deep while copying an array. Therefore, it may be unsuitable for copying multidimensional arrays. The same is true with Object.assign() — no native operation in JavaScript does a deep clone. The web API method structuredClone() allows deep copying values of certain supported types. See shallow copy for more details.
jsconst a = [[1], [2], [3]];
const b = [...a];

b.shift().shift();
// 1

// Oh no! Now array 'a' is affected as well:
console.log(a);
// [[], [2], [3]]

A better way to concatenate arrays
Array.prototype.concat() is often used to concatenate an array to the end of an existing array. Without spread syntax, this is done as:
jslet arr1 = [0, 1, 2];
const arr2 = [3, 4, 5];

// Append all items from arr2 onto arr1
arr1 = arr1.concat(arr2);

With spread syntax this becomes:
jslet arr1 = [0, 1, 2];
const arr2 = [3, 4, 5];

arr1 = [...arr1, ...arr2];
// arr1 is now [0, 1, 2, 3, 4, 5]

Array.prototype.unshift() is often used to insert an array of values at the start of an existing array. Without spread syntax, this is done as:
jsconst arr1 = [0, 1, 2];
const arr2 = [3, 4, 5];

//  Prepend all items from arr2 onto arr1
Array.prototype.unshift.apply(arr1, arr2);
console.log(arr1); // [3, 4, 5, 0, 1, 2]

With spread syntax, this becomes:
jslet arr1 = [0, 1, 2];
const arr2 = [3, 4, 5];

arr1 = [...arr2, ...arr1];
console.log(arr1); // [3, 4, 5, 0, 1, 2]


Note: Unlike unshift(), this creates a new arr1, instead of modifying the original arr1 array in-place.

Conditionally adding values to an array
You can make an element present or absent in an array literal, depending on a condition, using a conditional operator.
jsconst isSummer = false;
const fruits = ["apple", "banana", ...(isSummer ? ["watermelon"] : [])];
// ['apple', 'banana']

When the condition is false, we spread an empty array, so that nothing gets added to the final array. Note that this is different from the following:
jsconst fruits = ["apple", "banana", isSummer ? "watermelon" : undefined];
// ['apple', 'banana', undefined]

In this case, an extra undefined element is added when isSummer is false, and this element will be visited by methods such as Array.prototype.map().Spread in object literalsCopying and merging objects
You can use spread syntax to merge multiple objects into one new object.
jsconst obj1 = { foo: "bar", x: 42 };
const obj2 = { bar: "baz", y: 13 };

const mergedObj = { ...obj1, ...obj2 };
// { foo: "bar", x: 42, bar: "baz", y: 13 }

A single spread creates a shallow copy of the original object (but without non-enumerable properties and without copying the prototype), similar to copying an array.
jsconst clonedObj = { ...obj1 };
// { foo: "bar", x: 42 }

Overriding properties
When one object is spread into another object, or when multiple objects are spread into one object, and properties with identical names are encountered, the property takes the last value assigned while remaining in the position it was originally set.
jsconst obj1 = { foo: "bar", x: 42 };
const obj2 = { foo: "baz", y: 13 };

const mergedObj = { x: 41, ...obj1, ...obj2, y: 9 }; // { x: 42, foo: "baz", y: 9 }

Conditionally adding properties to an object
You can make an element present or absent in an object literal, depending on a condition, using a conditional operator.
jsconst isSummer = false;
const fruits = {
  apple: 10,
  banana: 5,
  ...(isSummer ? { watermelon: 30 } : {}),
};
// { apple: 10, banana: 5 }

The case where the condition is false is an empty object, so that nothing gets spread into the final object. Note that this is different from the following:
jsconst fruits = {
  apple: 10,
  banana: 5,
  watermelon: isSummer ? 30 : undefined,
};
// { apple: 10, banana: 5, watermelon: undefined }

In this case, the watermelon property is always present and will be visited by methods such as Object.keys().
Because primitives can be spread into objects as well, and from the observation that all falsy values do not have enumerable properties, you can simply use a logical AND operator:
jsconst isSummer = false;
const fruits = {
  apple: 10,
  banana: 5,
  ...(isSummer && { watermelon: 30 }),
};

In this case, if isSummer is any falsy value, no property will be created on the fruits object.
Comparing with Object.assign()
Note that Object.assign() can be used to mutate an object, whereas spread syntax can't.
jsconst obj1 = { foo: "bar", x: 42 };
Object.assign(obj1, { x: 1337 });
console.log(obj1); // { foo: "bar", x: 1337 }

In addition, Object.assign() triggers setters on the target object, whereas spread syntax does not.
jsconst objectAssign = Object.assign(
  {
    set foo(val) {
      console.log(val);
    },
  },
  { foo: 1 },
);
// Logs "1"; objectAssign.foo is still the original setter

const spread = {
  set foo(val) {
    console.log(val);
  },
  ...{ foo: 1 },
};
// Nothing is logged; spread.foo is 1

You cannot naively re-implement the Object.assign() function through a single spreading:
jsconst obj1 = { foo: "bar", x: 42 };
const obj2 = { foo: "baz", y: 13 };
const merge = (...objects) => ({ ...objects });

const mergedObj1 = merge(obj1, obj2);
// { 0: { foo: 'bar', x: 42 }, 1: { foo: 'baz', y: 13 } }

const mergedObj2 = merge({}, obj1, obj2);
// { 0: {}, 1: { foo: 'bar', x: 42 }, 2: { foo: 'baz', y: 13 } }

In the above example, the spread syntax does not work as one might expect: it spreads an array of arguments into the object literal, due to the rest parameter. Here is an implementation of merge using the spread syntax, whose behavior is similar to Object.assign(), except that it doesn't trigger setters, nor mutates any object:
jsconst obj1 = { foo: "bar", x: 42 };
const obj2 = { foo: "baz", y: 13 };
const merge = (...objects) =>
  objects.reduce((acc, cur) => ({ ...acc, ...cur }));

const mergedObj1 = merge(obj1, obj2);
// { foo: 'baz', x: 42, y: 13 }
SpecificationsSpecificationECMAScript Language Specification # prod-SpreadElementECMAScript Language Specification # prod-ArgumentListECMAScript Language Specification # prod-PropertyDefinitionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Rest parameters
Rest property
Function.prototype.apply()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
Strict equality (===)
  The strict equality (===) operator checks whether its two operands are
  equal, returning a Boolean result. Unlike the equality operator,
  the strict equality operator always considers operands of different types to be
  different.
Try itSyntaxjsx === y
DescriptionThe strict equality operators (=== and !==) provide the IsStrictlyEqual semantic.

If the operands are of different types, return false.

    If both operands are objects, return true only if they refer to the
    same object.
  

    If both operands are null or both operands are undefined,
    return true.
  
If either operand is NaN, return false.
Otherwise, compare the two operand's values:
    

        Numbers must have the same numeric values. +0 and -0
        are considered to be the same value.
      
Strings must have the same characters in the same order.
Booleans must be both true or both false.




  The most notable difference between this operator and the equality
  (==) operator is that if the operands are of different types, the
  == operator attempts to convert them to the same type before comparing.
ExamplesComparing operands of the same typejs"hello" === "hello"; // true
"hello" === "hola"; // false

3 === 3; // true
3 === 4; // false

true === true; // true
true === false; // false

null === null; // true
Comparing operands of different typesjs"3" === 3; // false
true === 1; // false
null === undefined; // false
3 === new Number(3); // false
Comparing objectsjsconst object1 = {
  key: "value",
};

const object2 = {
  key: "value",
};

console.log(object1 === object2); // false
console.log(object1 === object1); // true
SpecificationsSpecificationECMAScript Language Specification # sec-equality-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Equality (==)
Inequality (!=)
Strict inequality (!==)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 20, 2023 by MDN contributors.
Strict inequality (!==)
  The strict inequality (!==) operator checks whether its two operands are
  not equal, returning a Boolean result. Unlike the inequality
  operator, the strict inequality operator always considers operands of different types to
  be different.
Try itSyntaxjsx !== y
Description
  The strict inequality operator checks whether its operands are not equal.
  It is the negation of the
  strict equality operator
  so the following two lines will always give the same result:

jsx !== y;

!(x === y);


  For details of the comparison algorithm, see the page for the
  strict equality operator.


  Like the strict equality operator, the strict inequality operator will always consider
  operands of different types to be different:

js3 !== "3"; // true
ExamplesComparing operands of the same typejs"hello" !== "hello"; // false
"hello" !== "hola"; // true

3 !== 3; // false
3 !== 4; // true

true !== true; // false
true !== false; // true

null !== null; // false
Comparing operands of different typesjs"3" !== 3; // true
true !== 1; // true
null !== undefined; // true
Comparing objectsjsconst object1 = {
  key: "value",
};

const object2 = {
  key: "value",
};

console.log(object1 !== object2); // true
console.log(object1 !== object1); // false
SpecificationsSpecificationECMAScript Language Specification # sec-equality-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Equality (==)
Inequality (!=)
Strict equality (===)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Subtraction (-)The subtraction (-) operator subtracts the two operands, producing their difference.Try itSyntaxjsx - y
DescriptionThe - operator is overloaded for two types of operands: number and BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt subtraction if both operands become BigInts; otherwise, it performs number subtraction. A TypeError is thrown if one operand becomes a BigInt but the other becomes a number.ExamplesSubtraction with numbersjs// Number - Number -> subtraction
5 - 3; // 2

// Number - Number -> subtraction
3 - 5; // -2
Subtraction with non-numbersjs// String - Number -> subtraction
"foo" - 3; // NaN; "foo" is converted to the number NaN

// Number - String -> subtraction
5 - "3"; // 2; "3" is converted to the number 3
Subtraction with BigIntsjs// BigInt - BigInt -> subtraction
2n - 1n; // 1n

You cannot mix BigInt and number operands in subtraction.
js2n - 1; // TypeError: Cannot mix BigInt and other types, use explicit conversions
2 - 1n; // TypeError: Cannot mix BigInt and other types, use explicit conversions
SpecificationsSpecificationECMAScript Language Specification # sec-subtraction-operator-minusBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Division (/)
Multiplication (*)
Remainder (%)
Exponentiation (**)
Increment (++)
Decrement (--)
Unary negation (-)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 18, 2023 by MDN contributors.
Subtraction assignment (-=)The subtraction assignment (-=) operator performs subtraction on the two operands and assigns the result to the left operand.Try itSyntaxjsx -= y
Descriptionx -= y is equivalent to x = x - y, except that the expression x is only evaluated once.ExamplesUsing subtraction assignmentjslet bar = 5;

bar -= 2; // 3
bar -= "foo"; // NaN

let foo = 3n;
foo -= 2n; // 1n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Subtraction (-)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
superThe super keyword is used to access properties on an object literal or class's [[Prototype]], or invoke a superclass's constructor.
The super.prop and super[expr] expressions are valid in any method definition in both classes and object literals. The super(...args) expression is valid in class constructors.Try itSyntaxjssuper([arguments]) // calls the parent constructor.
super.propertyOnParent
super[expression]
DescriptionThe super keyword can be used in two ways: as a "function call" (super(...args)), or as a "property lookup" (super.prop and super[expr]).

Note: super is a keyword and these are special syntactic constructs. super is not a variable that points to the prototype object. Attempting to read super itself is a SyntaxError.
jsconst child = {
  myParent() {
    console.log(super); // SyntaxError: 'super' keyword unexpected here
  },
};


In the constructor body of a derived class (with extends), the super keyword may appear as a "function call" (super(...args)), which must be called before the this keyword is used, and before the constructor returns. It calls the parent class's constructor and binds the parent class's public fields, after which the derived class's constructor can further access and modify this.
The "property lookup" form can be used to access methods and properties of an object literal's or class's [[Prototype]]. Within a class's body, the reference of super can be either the superclass's constructor itself, or the constructor's prototype, depending on whether the execution context is instance creation or class initialization. See the Examples section for more details.
Note that the reference of super is determined by the class or object literal super was declared in, not the object the method is called on. Therefore, unbinding or re-binding a method doesn't change the reference of super in it (although they do change the reference of this). You can see super as a variable in the class or object literal scope, which the methods create a closure over. (But also beware that it's not actually a variable, as explained above.)
When setting properties through super, the property is set on this instead.ExamplesUsing super in classesThis code snippet is taken from the classes sample (live demo). Here super() is called to avoid duplicating the constructor parts' that are common between Rectangle and Square.
jsclass Rectangle {
  constructor(height, width) {
    this.name = "Rectangle";
    this.height = height;
    this.width = width;
  }
  sayName() {
    console.log(`Hi, I am a ${this.name}.`);
  }
  get area() {
    return this.height * this.width;
  }
  set area(value) {
    this._area = value;
  }
}

class Square extends Rectangle {
  constructor(length) {
    // Here, it calls the parent class's constructor with lengths
    // provided for the Rectangle's width and height
    super(length, length);

    // Note: In derived classes, super() must be called before you
    // can use 'this'. Moving this to the top causes a ReferenceError.
    this.name = "Square";
  }
}
Super-calling static methodsYou are also able to call super on static methods.
jsclass Rectangle {
  static logNbSides() {
    return "I have 4 sides";
  }
}

class Square extends Rectangle {
  static logDescription() {
    return `${super.logNbSides()} which are all equal`;
  }
}
Square.logDescription(); // 'I have 4 sides which are all equal'
Accessing super in class field declarationsuper can also be accessed during class field initialization. The reference of super depends on whether the current field is an instance field or a static field.
jsclass Base {
  static baseStaticField = 90;
  baseMethod() {
    return 10;
  }
}

class Extended extends Base {
  extendedField = super.baseMethod(); // 10
  static extendedStaticField = super.baseStaticField; // 90
}

Note that instance fields are set on the instance instead of the constructor's prototype, so you can't use super to access the instance field of a superclass.
jsclass Base {
  baseField = 10;
}

class Extended extends Base {
  extendedField = super.baseField; // undefined
}

Here, extendedField is undefined instead of 10, because baseField is defined as an own property of the Base instance, instead of Base.prototype. super, in this context, only looks up properties on Base.prototype, because that's the [[Prototype]] of Extended.prototype.Deleting super properties will throw an errorYou cannot use the delete operator and super.prop or super[expr] to delete a parent class' property — it will throw a ReferenceError.
jsclass Base {
  foo() {}
}
class Derived extends Base {
  delete() {
    delete super.foo; // this is bad
  }
}

new Derived().delete(); // ReferenceError: invalid delete involving 'super'.
Using super.prop in object literalsSuper can also be used in the object initializer notation. In this example, two objects define a method. In the second object, super calls the first object's method. This works with the help of Object.setPrototypeOf() with which we are able to set the prototype of obj2 to obj1, so that super is able to find method1 on obj1.
jsconst obj1 = {
  method1() {
    console.log("method 1");
  },
};

const obj2 = {
  method2() {
    super.method1();
  },
};

Object.setPrototypeOf(obj2, obj1);
obj2.method2(); // Logs "method 1"
Methods that read super.prop do not behave differently when bound to other objectsAccessing super.x behaves like Reflect.get(Object.getPrototypeOf(objectLiteral), "x", this), which means the property is always seeked on the object literal/class declaration's prototype, and unbinding and re-binding a method won't change the reference of super.
jsclass Base {
  baseGetX() {
    return 1;
  }
}
class Extended extends Base {
  getX() {
    return super.baseGetX();
  }
}

const e = new Extended();
console.log(e.getX()); // 1
const { getX } = e;
console.log(getX()); // 1

The same happens in object literals.
jsconst parent1 = { prop: 1 };
const parent2 = { prop: 2 };

const child = {
  myParent() {
    console.log(super.prop);
  },
};

Object.setPrototypeOf(child, parent1);
child.myParent(); // Logs "1"

const myParent = child.myParent;
myParent(); // Still logs "1"

const anotherChild = { __proto__: parent2, myParent };
anotherChild.myParent(); // Still logs "1"

Only resetting the entire inheritance chain will change the reference of super.
jsclass Base {
  baseGetX() {
    return 1;
  }
  static staticBaseGetX() {
    return 3;
  }
}
class AnotherBase {
  baseGetX() {
    return 2;
  }
  static staticBaseGetX() {
    return 4;
  }
}
class Extended extends Base {
  getX() {
    return super.baseGetX();
  }
  static staticGetX() {
    return super.staticBaseGetX();
  }
}

const e = new Extended();
// Reset instance inheritance
Object.setPrototypeOf(Extended.prototype, AnotherBase.prototype);
console.log(e.getX()); // Logs "2" instead of "1", because the prototype chain has changed
console.log(Extended.staticGetX()); // Still logs "3", because we haven't modified the static part yet
// Reset static inheritance
Object.setPrototypeOf(Extended, AnotherBase);
console.log(Extended.staticGetX()); // Now logs "4"
Calling methods from superWhen calling super.prop as a function, the this value inside the prop function is the current this, not the object that super points to. For example, the super.getName() call logs "Extended", despite the code looking like it's equivalent to Base.getName().
jsclass Base {
  static getName() {
    console.log(this.name);
  }
}

class Extended extends Base {
  static getName() {
    super.getName();
  }
}

Extended.getName(); // Logs "Extended"

This is especially important when interacting with static private properties.Setting super.prop sets the property on this insteadSetting properties of super, such as super.x = 1, behaves like Reflect.set(Object.getPrototypeOf(objectLiteral), "x", 1, this). This is one of the cases where understanding super as simply "reference of the prototype object" falls short, because it actually sets the property on this instead.
jsclass A {}
class B extends A {
  setX() {
    super.x = 1;
  }
}

const b = new B();
b.setX();
console.log(b); // B { x: 1 }
console.log(Object.hasOwn(b, "x")); // true

super.x = 1 will look for the property descriptor of x on A.prototype (and invoke the setters defined there), but the this value will be set to this, which is b in this context. You can read Reflect.set for more details on the case when target and receiver differ.
This means that while methods that get super.prop are usually not susceptible to changes in the this context, those that set super.prop are.
js/* Reusing same declarations as above */

const b2 = new B();
b2.setX.call(null); // TypeError: Cannot assign to read only property 'x' of object 'null'

However, super.x = 1 still consults the property descriptor of the prototype object, which means you cannot rewrite non-writable properties, and setters will be invoked.
jsclass X {
  constructor() {
    // Create a non-writable property
    Object.defineProperty(this, "prop", {
      configurable: true,
      writable: false,
      value: 1,
    });
  }
}

class Y extends X {
  constructor() {
    super();
  }
  foo() {
    super.prop = 2; // Cannot overwrite the value.
  }
}

const y = new Y();
y.foo(); // TypeError: "prop" is read-only
console.log(y.prop); // 1
SpecificationsSpecificationECMAScript Language Specification # sec-super-keywordBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Classes
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
thisA function's this keyword behaves a little differently in JavaScript compared to other languages. It also has some differences between strict mode and non-strict mode.
In most cases, the value of this is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called. The Function.prototype.bind() method can set the value of a function's this regardless of how it's called, and arrow functions don't provide their own this binding (it retains the this value of the enclosing lexical context).Try itSyntaxjsthis
ValueIn non–strict mode, this is always a reference to an object. In strict mode, it can be any value. For more information on how the value is determined, see the description below.DescriptionThe value of this depends on in which context it appears: function, class, or global.Function contextInside a function, the value of this depends on how the function is called. Think about this as a hidden parameter of a function — just like the parameters declared in the function definition, this is a binding that the language creates for you when the function body is evaluated.
For a typical function, the value of this is the object that the function is accessed on. In other words, if the function call is in the form obj.f(), then this refers to obj. For example:
jsfunction getThis() {
  return this;
}

const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

obj1.getThis = getThis;
obj2.getThis = getThis;

console.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }
console.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }

Note how the function is the same, but based on how it's invoked, the value of this is different. This is analogous to how function parameters work.
The value of this is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the prototype chain.
jsconst obj3 = {
  __proto__: obj1,
  name: "obj3",
};

console.log(obj3.getThis()); // { name: 'obj3' }

The value of this always changes based on how a function is called, even when the function was defined on an object at creation:
jsconst obj4 = {
  name: "obj4",
  getThis() {
    return this;
  },
};

const obj5 = { name: "obj5" };

obj5.getThis = obj4.getThis;
console.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }

If the value that the method is accessed on is a primitive, this will be a primitive value as well — but only if the function is in strict mode.
jsfunction getThisStrict() {
  "use strict"; // Enter strict mode
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThisStrict = getThisStrict;
console.log(typeof (1).getThisStrict()); // "number"

If the function is called without being accessed on anything, this will be undefined — but only if the function is in strict mode.
jsconsole.log(typeof getThisStrict()); // "undefined"

In non-strict mode, a special process called this substitution ensures that the value of this is always an object. This means:

If a function is called with this set to undefined or null, this gets substituted with globalThis.
If the function is called with this set to a primitive value, this gets substituted with the primitive value's wrapper object.

jsfunction getThis() {
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThis = getThis;
console.log(typeof (1).getThis()); // "object"
console.log(getThis() === globalThis); // true

In typical function calls, this is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of this using the Function.prototype.call(), Function.prototype.apply(), or Reflect.apply() methods. Using Function.prototype.bind(), you can create a new function with a specific value of this that doesn't change regardless of how the function is called. When using these methods, the this substitution rules above still apply if the function is non-strict.
Callbacks
When a function is passed as a callback, the value of this depends on how the callback is called, which is determined by the implementor of the API. Callbacks are typically called with a this value of undefined (calling it directly without attaching it to any object), which means if the function is non–strict, the value of this is the global object (globalThis). This is the case for iterative array methods, the Promise() constructor, etc.
jsfunction logThis() {
  "use strict";
  console.log(this);
}

[1, 2, 3].forEach(logThis); // undefined, undefined, undefined

Some APIs allow you to set a this value for invocations of the callback. For example, all iterative array methods and related ones like Set.prototype.forEach() accept an optional thisArg parameter.
js[1, 2, 3].forEach(logThis, { name: "obj" });
// { name: 'obj' }, { name: 'obj' }, { name: 'obj' }

Occasionally, a callback is called with a this value other than undefined. For example, the reviver parameter of JSON.parse() and the replacer parameter of JSON.stringify() are both called with this set to the object that the property being parsed/serialized belongs to.
Arrow functions
In arrow functions, this retains the value of the enclosing lexical context's this. In other words, when evaluating an arrow function's body, the language does not create a new this binding.
For example, in global code, this is always globalThis regardless of strictness, because of the global context binding:
jsconst globalObject = this;
const foo = () => this;
console.log(foo() === globalObject); // true

Arrow functions create a closure over the this value of its surrounding scope, which means arrow functions behave as if they are "auto-bound" — no matter how it's invoked, this is bound to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their this remains that of the enclosing lexical context. See example below.
Furthermore, when invoking arrow functions using call(), bind(), or apply(), the thisArg parameter is ignored. You can still pass other arguments using these methods, though.
jsconst obj = { name: "obj" };

// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true

// Attempt to set this using bind
const boundFoo = foo.bind(obj);
console.log(boundFoo() === globalObject); // true

Constructors
When a function is used as a constructor (with the new keyword), its this is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of this becomes the value of the new expression unless the constructor returns another non–primitive value.
jsfunction C() {
  this.a = 37;
}

let o = new C();
console.log(o.a); // 37

function C2() {
  this.a = 37;
  return { a: 38 };
}

o = new C2();
console.log(o.a); // 38

In the second example (C2), because an object was returned during construction, the new object that this was bound to gets discarded. (This essentially makes the statement this.a = 37; dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)
super
When a function is invoked in the super.method() form, the this inside the method function is the same value as the this value around the super.method() call, and is generally not equal to the object that super refers to. This is because super.method is not an object member access like the ones above — it's a special syntax with different binding rules. For examples, see the super reference.Class contextA class can be split into two contexts: static and instance. Constructors, methods, and instance field initializers (public or private) belong to the instance context. Static methods, static field initializers, and static initialization blocks belong to the static context. The this value is different in each context.
Class constructors are always called with new, so their behavior is the same as function constructors: the this value is the new instance being created. Class methods behave like methods in object literals — the this value is the object that the method was accessed on. If the method is not transferred to another object, this is generally an instance of the class.
Static methods are not properties of this. They are properties of the class itself. Therefore, they are generally accessed on the class, and this is the value of the class (or a subclass). Static initialization blocks are also evaluated with this set to the current class.
Field initializers are also evaluated in the context of the class. Instance fields are evaluated with this set to the instance being constructed. Static fields are evaluated with this set to the current class. This is why arrow functions in field initializers are bound to the instance for instance fields and to the class for static fields.
jsclass C {
  instanceField = this;
  static staticField = this;
}

const c = new C();
console.log(c.instanceField === c); // true
console.log(C.staticField === C); // true

Derived class constructors
Unlike base class constructors, derived constructors have no initial this binding. Calling super() creates a this binding within the constructor and essentially has the effect of evaluating the following line of code, where Base is the base class:
jsthis = new Base();


Warning: Referring to this before calling super() will throw an error.

Derived classes must not return before calling super(), unless the constructor returns an object (so the this value is overridden) or the class has no constructor at all.
jsclass Base {}
class Good extends Base {}
class AlsoGood extends Base {
  constructor() {
    return { a: 5 };
  }
}
class Bad extends Base {
  constructor() {}
}

new Good();
new AlsoGood();
new Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
Global contextIn the global execution context (outside of any functions or classes; may be inside blocks or arrow functions defined in the global scope), the this value depends on what execution context the script runs in. Like callbacks, the this value is determined by the runtime environment (the caller).
At the top level of a script, this refers to globalThis whether in strict mode or not. This is generally the same as the global object — for example, if the source is put inside an HTML <script> element and executed as a script, this === window.

Note: globalThis is generally the same concept as the global object (i.e. adding properties to globalThis makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for globalThis that's unrelated to the global object.

js// In web browsers, the window object is also the global object:
console.log(this === window); // true

this.b = "MDN";
console.log(window.b); // "MDN"
console.log(b); // "MDN"

If the source is loaded as a module (for HTML, this means adding type="module" to the <script> tag), this is always undefined at the top level.
If the source is executed with eval(), this is the same as the enclosing context for direct eval, or globalThis (as if it's run in a separate global script) for indirect eval.
jsfunction test() {
  // Direct eval
  console.log(eval("this") === this);
  // Indirect eval, non-strict
  console.log(eval?.("this") === globalThis);
  // Indirect eval, strict
  console.log(eval?.("'use strict'; this") === globalThis);
}

test.call({ name: "obj" }); // Logs 3 "true"

Note that some source code, while looking like the global scope, is actually wrapped in a function when executed. For example, Node.js CommonJS modules are wrapped in a function and executed with the this value set to module.exports. Event handler attributes are executed with this set to the element they are attached to.
Object literals don't create a this scope — only functions (methods) defined within the object do. Using this in an object literal inherits the value from the surrounding scope.
jsconst obj = {
  a: this,
};

console.log(obj.a === window); // true
Examplesthis in function contextsThe value of the this parameter depends on how the function is called, not on how it's defined.
js// An object can be passed as the first argument to 'call'
// or 'apply' and 'this' will be bound to it.
const obj = { a: "Custom" };

// Variables declared with var become properties of 'globalThis'.
var a = "Global";

function whatsThis() {
  return this.a; // 'this' depends on how the function is called
}

whatsThis(); // 'Global'; the 'this' parameter defaults to 'globalThis' in non–strict mode
obj.whatsThis = whatsThis;
obj.whatsThis(); // 'Custom'; the 'this' parameter is bound to obj

Using call() and apply(), you can pass the value of this as if it's an explicit parameter.
jsfunction add(c, d) {
  return this.a + this.b + c + d;
}

const o = { a: 1, b: 3 };

// The first argument is bound to the implicit 'this' parameter; the remaining
// arguments are bound to the named parameters.
add.call(o, 5, 7); // 16

// The first argument is bound to the implicit 'this' parameter; the second
// argument is an array whose members are bound to the named parameters.
add.apply(o, [10, 20]); // 34
this and object conversionIn non–strict mode, if a function is called with a this value that's not an object, the this value is substituted with an object. null and undefined become globalThis. Primitives like 7 or 'foo' are converted to an object using the related constructor, so the primitive number 7 is converted to a Number wrapper class and the string 'foo' to a String wrapper class.
jsfunction bar() {
  console.log(Object.prototype.toString.call(this));
}

bar.call(7); // [object Number]
bar.call("foo"); // [object String]
bar.call(undefined); // [object Window]
The bind() methodCalling f.bind(someObject) creates a new function with the same body and scope as f, but the value of this is permanently bound to the first argument of bind, regardless of how the function is being called.
jsfunction f() {
  return this.a;
}

const g = f.bind({ a: "azerty" });
console.log(g()); // azerty

const h = g.bind({ a: "yoo" }); // bind only works once!
console.log(h()); // azerty

const o = { a: 37, f, g, h };
console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty
this in arrow functionsArrow functions create closures over the this value of the enclosing execution context. In the following example, we create obj with a method getThisGetter that returns a function that returns the value of this. The returned function is created as an arrow function, so its this is permanently bound to the this of its enclosing function. The value of this inside getThisGetter can be set in the call, which in turn sets the return value of the returned function. We will assume that getThisGetter is a non-strict function, which means it's contained in a non-strict script and not further nested in a class or strict function.
jsconst obj = {
  getThisGetter() {
    const getter = () => this;
    return getter;
  },
};

We can call getThisGetter as a method of obj, which binds this to obj inside its body. The returned function is assigned to a variable fn. Now, when calling fn, the value of this returned is still the one set by the call to getThisGetter, which is obj. If the returned function was not an arrow function, such calls would cause the this value to be globalThis, because getThisGetter is non-strict.
jsconst fn = obj.getThisGetter();
console.log(fn() === obj); // true

But be careful if you unbind the method of obj without calling it, because getThisGetter is still a method that has a varying this value. Calling fn2()() in the following example returns globalThis, because it follows the this from fn2(), which is globalThis since it's called without being attached to any object.
jsconst fn2 = obj.getThisGetter;
console.log(fn2()() === globalThis); // true in non-strict mode

This behavior is very useful when defining callbacks. Usually, each function expression creates its own this binding, which shadows the this value of the upper scope. Now, you can define functions as arrow functions if you don't care about the this value, and only create this bindings where you do (e.g. in class methods). See example with setTimeout().this with a getter or setterthis in getters and setters is based on which object the property is accessed on, not which object the property is defined on. A function used as getter or setter has its this bound to the object from which the property is being set or gotten.
jsfunction sum() {
  return this.a + this.b + this.c;
}

const o = {
  a: 1,
  b: 2,
  c: 3,
  get average() {
    return (this.a + this.b + this.c) / 3;
  },
};

Object.defineProperty(o, "sum", {
  get: sum,
  enumerable: true,
  configurable: true,
});

console.log(o.average, o.sum); // 2 6
this in DOM event handlersWhen a function is used as an event handler, its this parameter is bound to the DOM element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than addEventListener()).
js// When called as a listener, turns the related element blue
function bluify(e) {
  // Always true
  console.log(this === e.currentTarget);
  // true when currentTarget and target are the same object
  console.log(this === e.target);
  this.style.backgroundColor = "#A5D9F3";
}

// Get a list of every element in the document
const elements = document.getElementsByTagName("*");

// Add bluify as a click listener so when the
// element is clicked on, it turns blue
for (const element of elements) {
  element.addEventListener("click", bluify, false);
}
this in inline event handlersWhen the code is called from an inline event handler attribute, its this is bound to the DOM element on which the listener is placed:
html<button onclick="alert(this.tagName.toLowerCase());">Show this</button>

The above alert shows button. Note, however, that only the outer scope has its this bound this way:
html<button onclick="alert((function () { return this; })());">
  Show inner this
</button>

In this case, the this parameter of the inner function is bound to globalThis (i.e. the default object in non–strict mode where this isn't passed in the call).Bound methods in classesJust like with regular functions, the value of this within methods depends on how they are called. Sometimes it is useful to override this behavior so that this within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:
jsclass Car {
  constructor() {
    // Bind sayBye but not sayHi to show the difference
    this.sayBye = this.sayBye.bind(this);
  }

  sayHi() {
    console.log(`Hello from ${this.name}`);
  }

  sayBye() {
    console.log(`Bye from ${this.name}`);
  }

  get name() {
    return "Ferrari";
  }
}

class Bird {
  get name() {
    return "Tweety";
  }
}

const car = new Car();
const bird = new Bird();

// The value of 'this' in methods depends on their caller
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// For bound methods, 'this' doesn't depend on the caller
bird.sayBye = car.sayBye;
bird.sayBye(); // Bye from Ferrari


Note: Classes are always in strict mode. Calling methods with an undefined this will throw an error if the method tries to access properties on this.
jsconst carSayHi = car.sayHi;
carSayHi(); // TypeError because the 'sayHi' method tries to access 'this.name', but 'this' is undefined in strict mode.


Note, however, that auto-bound methods suffer from the same problem as using arrow functions for class properties: each instance of the class will have its own copy of the method, which increases memory usage. Only use it where absolutely necessary. You can also mimic the implementation of Intl.NumberFormat.prototype.format(): define the property as a getter that returns a bound function when accessed and saves it, so that the function is only created once and only created when necessary.this in with statementsAlthough with statements are deprecated and not available in strict mode, they still serve as an exception to the normal this binding rules. If a function is called within a with statement and that function is a property of the scope object, the this value is bound to the scope object, as if the obj1. prefix exists.
jsconst obj1 = {
  foo() {
    return this;
  },
};

with (obj1) {
  console.log(foo() === obj1); // true
}
SpecificationsSpecificationECMAScript Language Specification # sec-this-keywordBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Strict mode
globalThis
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
typeofThe typeof operator returns a string indicating the type of the operand's value.Try itSyntaxjstypeof operand
Parameters
operand

An expression representing the object or primitive whose type is to be returned.

DescriptionThe following table summarizes the possible return values of typeof. For more information about types and primitives, see also the JavaScript data structure page.



Type
Result




Undefined
"undefined"


Null
"object" (reason)


Boolean
"boolean"


Number
"number"


BigInt
"bigint"


String
"string"


Symbol
"symbol"


Function (implements [[Call]] in ECMA-262 terms; classes are functions as well)
"function"


Any other object
"object"



This list of values is exhaustive. No spec-compliant engines are reported to produce (or had historically produced) values other than those listed.ExamplesBasic usagejs// Numbers
typeof 37 === "number";
typeof 3.14 === "number";
typeof 42 === "number";
typeof Math.LN2 === "number";
typeof Infinity === "number";
typeof NaN === "number"; // Despite being "Not-A-Number"
typeof Number("1") === "number"; // Number tries to parse things into numbers
typeof Number("shoe") === "number"; // including values that cannot be type coerced to a number

typeof 42n === "bigint";

// Strings
typeof "" === "string";
typeof "bla" === "string";
typeof `template literal` === "string";
typeof "1" === "string"; // note that a number within a string is still typeof string
typeof typeof 1 === "string"; // typeof always returns a string
typeof String(1) === "string"; // String converts anything into a string, safer than toString

// Booleans
typeof true === "boolean";
typeof false === "boolean";
typeof Boolean(1) === "boolean"; // Boolean() will convert values based on if they're truthy or falsy
typeof !!1 === "boolean"; // two calls of the ! (logical NOT) operator are equivalent to Boolean()

// Symbols
typeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";

// Undefined
typeof undefined === "undefined";
typeof declaredButUndefinedVariable === "undefined";
typeof undeclaredVariable === "undefined";

// Objects
typeof { a: 1 } === "object";

// use Array.isArray or Object.prototype.toString.call
// to differentiate regular objects from arrays
typeof [1, 2, 4] === "object";

typeof new Date() === "object";
typeof /regex/ === "object";

// The following are confusing, dangerous, and wasteful. Avoid them.
typeof new Boolean(true) === "object";
typeof new Number(1) === "object";
typeof new String("abc") === "object";

// Functions
typeof function () {} === "function";
typeof class C {} === "function";
typeof Math.sin === "function";
typeof nulljs// This stands since the beginning of JavaScript
typeof null === "object";

In the first implementation of JavaScript, JavaScript values were represented as a type tag and a value. The type tag for objects was 0. null was represented as the NULL pointer (0x00 in most platforms). Consequently, null had 0 as type tag, hence the typeof return value "object". (reference)
A fix was proposed for ECMAScript (via an opt-in), but was rejected. It would have resulted in typeof null === "null".Using new operatorAll constructor functions called with new will return non-primitives ("object" or "function"). Most return objects, with the notable exception being Function, which returns a function.
jsconst str = new String("String");
const num = new Number(100);

typeof str; // "object"
typeof num; // "object"

const func = new Function();

typeof func; // "function"
Need for parentheses in syntaxThe typeof operator has higher precedence than binary operators like addition (+). Therefore, parentheses are needed to evaluate the type of an addition result.
js// Parentheses can be used for determining the data type of expressions.
const someData = 99;

typeof someData + " Wisen"; // "number Wisen"
typeof (someData + " Wisen"); // "string"
Interaction with undeclared and uninitialized variablestypeof is generally always guaranteed to return a string for any operand it is supplied with. Even with undeclared identifiers, typeof will return "undefined" instead of throwing an error.
jstypeof undeclaredVariable; // "undefined"

However, using typeof on lexical declarations (let const, and class) in the same block before the place of declaration will throw a ReferenceError. Block scoped variables are in a temporal dead zone from the start of the block until the initialization is processed, during which it will throw an error if accessed.
jstypeof newLetVariable; // ReferenceError
typeof newConstVariable; // ReferenceError
typeof newClass; // ReferenceError

let newLetVariable;
const newConstVariable = "hello";
class newClass {}
Exceptional behavior of document.allAll current browsers expose a non-standard host object document.all with type undefined.
jstypeof document.all === "undefined";

Although document.all is also falsy and loosely equal to undefined, it is not undefined. The case of document.all having type "undefined" is classified in the web standards as a "willful violation" of the original ECMAScript standard for web compatibility.Custom method that gets a more specific typetypeof is very useful, but it's not as versatile as might be required. For example, typeof [] is "object", as well as typeof new Date(), typeof /abc/, etc.
For greater specificity in checking types, here we present a custom type(value) function, which mostly mimics the behavior of typeof, but for non-primitives (i.e. objects and functions), it returns a more granular type name where possible.
jsfunction type(value) {
  if (value === null) {
    return "null";
  }
  const baseType = typeof value;
  // Primitive types
  if (!["object", "function"].includes(baseType)) {
    return baseType;
  }

  // Symbol.toStringTag often specifies the "display name" of the
  // object's class. It's used in Object.prototype.toString().
  const tag = value[Symbol.toStringTag];
  if (typeof tag === "string") {
    return tag;
  }

  // If it's a function whose source code starts with the "class" keyword
  if (
    baseType === "function" &&
    Function.prototype.toString.call(value).startsWith("class")
  ) {
    return "class";
  }

  // The name of the constructor; for example `Array`, `GeneratorFunction`,
  // `Number`, `String`, `Boolean` or `MyCustomClass`
  const className = value.constructor.name;
  if (typeof className === "string" && className !== "") {
    return className;
  }

  // At this point there's no robust way to get the type of value,
  // so we use the base implementation.
  return baseType;
}

For checking potentially non-existent variables that would otherwise throw a ReferenceError, use typeof nonExistentVar === "undefined" because this behavior cannot be mimicked with custom code.SpecificationsSpecificationECMAScript Language Specification # sec-typeof-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
instanceof
document.all willful violation of the standard
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Unary negation (-)The unary negation (-) operator precedes its operand and negates it.Try itSyntaxjs-x
DescriptionThe - operator is overloaded for two types of operands: number and BigInt. It first coerces the operand to a numeric value and tests the type of it. It performs BigInt negation if the operand becomes a BigInt; otherwise, it performs number negation.ExamplesNegating numbersjsconst x = 3;
const y = -x;
// y is -3; x is 3
Negating non-numbersThe unary negation operator can convert a non-number into a number.
jsconst x = "4";
const y = -x;

// y is -4

BigInts can be negated using the unary negation operator.
jsconst x = 4n;
const y = -x;

// y is -4n
SpecificationsSpecificationECMAScript Language Specification # sec-unary-minus-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Division (/)
Multiplication (*)
Remainder (%)
Exponentiation (**)
Increment (++)
Decrement (--)
Unary plus (+)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Unary plus (+)
  The unary plus (+) operator precedes its operand and evaluates to its
  operand but attempts to convert it into a number, if it isn't already.
Try itSyntaxjs+x
DescriptionAlthough unary negation (-) also can convert non-numbers, unary plus is the fastest and preferred way of converting something into a number, because it does not perform any other operations on the number.
Unary plus does the exact same steps as normal number coercion used by most built-in methods expecting numbers. It can convert string representations of integers and floats, as well as the non-string values true, false, and null. Integers in both decimal and hexadecimal (0x-prefixed) formats are supported. Negative numbers are supported (though not for hex). If it cannot parse a particular value, it will evaluate to NaN. Unlike other arithmetic operators, which work with both numbers and BigInts, using the + operator on BigInt values throws a TypeError.ExamplesUsage with numbersjsconst x = 1;
const y = -1;

console.log(+x);
// 1
console.log(+y);
// -1
Usage with non-numbersjs+true  // 1
+false // 0
+null  // 0
+[]    // 0
+function (val) { return val; } // NaN
+1n    // throws TypeError: Cannot convert BigInt value to number
SpecificationsSpecificationECMAScript Language Specification # sec-unary-plus-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Addition (+)
Subtraction (-)
Division (/)
Multiplication (*)
Remainder (%)
Exponentiation (**)
Increment (++)
Decrement (--)
Unary negation (-)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
Unsigned right shift (>>>)The unsigned right shift (>>>) operator returns a number whose binary representation is the first operand shifted by the specified number of bits to the right. Excess bits shifted off to the right are discarded, and zero bits are shifted in from the left. This operation is also called "zero-filling right shift", because the sign bit becomes 0, so the resulting number is always positive. Unsigned right shift does not accept BigInt values.Try itSyntaxjsx >>> y
DescriptionUnlike other arithmetic and bitwise operators, the unsigned right shift operator does not accept BigInt values. This is because it fills the leftmost bits with zeroes, but conceptually, BigInts have an infinite number of leading sign bits, so there's no "leftmost bit" to fill with zeroes.
The operator operates on the left operand's bit representation in two's complement. Consider the 32-bit binary representations of the decimal (base 10) numbers 9 and -9:
     9 (base 10): 00000000000000000000000000001001 (base 2)
    -9 (base 10): 11111111111111111111111111110111 (base 2)

The binary representation under two's complement of the negative decimal (base 10) number -9 is formed by inverting all the bits of its opposite number, which is 9 and 00000000000000000000000000001001 in binary, and adding 1.
In both cases, the sign of the binary number is given by its leftmost bit: for the positive decimal number 9, the leftmost bit of the binary representation is 0, and for the negative decimal number -9, the leftmost bit of the binary representation is 1.
Given those binary representations of the decimal (base 10) numbers 9, and -9:
For the positive number 9, zero-fill right shift and sign-propagating right shift yield the same result: 9 >>> 2 yields 2, the same as 9 >> 2:
      9 (base 10): 00000000000000000000000000001001 (base 2)
                   --------------------------------
9 >>  2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)
9 >>> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)

Notice how two rightmost bits, 01, have been shifted off, and two zeroes have been shifted in from the left.
However, notice what happens for -9: -9 >> 2 (sign-propagating right shift) yields -3, but -9 >>> 2 (zero-fill right shift) yields 1073741821:
      -9 (base 10): 11111111111111111111111111110111 (base 2)
                    --------------------------------
-9 >>  2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)
-9 >>> 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)

Notice how two rightmost bits, 11, have been shifted off. For -9 >> 2 (sign-propagating right shift), two copies of the leftmost 1 bit have been shifted in from the left, which preserves the negative sign. On the other hand, for -9 >>> 2 (zero-fill right shift), zeroes have instead been shifted in from the left, so the negative sign of the number is not preserved, and the result is instead a (large) positive number.
If the left operand is a number with more than 32 bits, it will get the most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001

The right operand will be converted to an unsigned 32-bit integer and then taken modulo 32, so the actual shift offset will always be a positive integer between 0 and 31, inclusive. For example, 100 >>> 32 is the same as 100 >>> 0 (and produces 100) because 32 modulo 32 is 0.ExamplesUsing unsigned right shiftjs9 >>> 2; // 2
-9 >>> 2; // 1073741821

Unsigned right shift doesn't work with BigInts.
js9n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
SpecificationsSpecificationECMAScript Language Specification # sec-unsigned-right-shift-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Bitwise operators in the JS guide
Unsigned right shift assignment (>>>=)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Unsigned right shift assignment (>>>=)The unsigned right shift assignment (>>>=) operator performs unsigned right shift on the two operands and assigns the result to the left operand.Try itSyntaxjsx >>>= y
Descriptionx >>>= y is equivalent to x = x >>> y, except that the expression x is only evaluated once.ExamplesUsing unsigned right shift assignmentjslet a = 5; // (00000000000000000000000000000101)
a >>>= 2; // 1 (00000000000000000000000000000001)

let b = -5; // (-00000000000000000000000000000101)
b >>>= 2; // 1073741822 (00111111111111111111111111111110)

let c = 5n;
c >>>= 2n; // 1n
SpecificationsSpecificationECMAScript Language Specification # sec-assignment-operatorsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assignment operators in the JS guide
Unsigned right shift (>>>)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 13, 2023 by MDN contributors.
void operator
  The void operator evaluates the given
  expression and then returns undefined.
Try itSyntaxjsvoid expression
Description
  This operator allows evaluating expressions that produce a value into places where an
  expression that evaluates to undefined is desired.


  The void operator is often used merely to obtain the
  undefined primitive value, usually using void(0) (which is
  equivalent to void 0). In these cases, the global variable
  undefined can be used.


  It should be noted that the precedence
  of the void operator should be taken into account and that
  parentheses can help clarify the resolution of the expression following the
  void operator:

jsvoid 2 === "2"; // (void 2) === '2', returns false
void (2 === "2"); // void (2 === '2'), returns undefined
ExamplesImmediately Invoked Function ExpressionsWhen using an immediately-invoked function expression, the function keyword cannot be at the immediate start of the statement, because that would be parsed as a function declaration, and would generate a syntax error when the parentheses representing invocation is reached — if the function is unnamed, it would immediately be a syntax error if the function is parsed as a declaration.
jsfunction iife() {
  console.log("Executed!");
}(); // SyntaxError: Unexpected token ')'

function () {
  console.log("Executed!");
}(); // SyntaxError: Function statements require a function name

In order for the function to be parsed as an expression, the function keyword has to appear at a position that only accepts expressions, not statements. This can be achieved be prefixing the keyword with a unary operator, which only accepts expressions as operands. Function invocation has higher precedence than unary operators, so it will be executed first. Its return value (which is almost always undefined) will be passed to the unary operator and then immediately discarded.
Of all the unary operators, void offers the best semantic, because it clearly signals that the return value of the function invocation should be discarded.
jsvoid function () {
  console.log("Executed!");
}();

// Logs "Executed!"

This is a bit longer than wrapping the function expression in parentheses, which has the same effect of forcing the function keyword to be parsed as the start of an expression instead of a statement.
js(function () {
  console.log("Executed!");
})();
JavaScript URIs
  When a browser follows a javascript: URI, it evaluates the code in the URI
  and then replaces the contents of the page with the returned value, unless the returned
  value is undefined. The void operator can be used to return
  undefined. For example:

html<a href="javascript:void(0);">Click here to do nothing</a>

<a href="javascript:void(document.body.style.backgroundColor='green');">
  Click here for green background
</a>



Note: javascript: pseudo protocol is discouraged over
    other alternatives, such as unobtrusive event handlers.
  
Non-leaking Arrow Functions
  Arrow functions introduce a short-hand braceless syntax that returns an expression.
  This can cause unintended side effects if the expression is a function call where the returned value changes from undefined to some other value.

For example, if doSomething() returns false in the code below, the checkbox will no longer be marked as checked or unchecked when the checkbox is clicked (setting the handler to false disables the default action).
jscheckbox.onclick = () => doSomething();


  This is unlikely to be desired behaviour!
  To be safe, when the return value of a function is not intended to be used, it can be passed to the void operator to ensure that (for example) changing APIs do not cause arrow functions' behaviors to change.

jscheckbox.onclick = () => void doSomething();
SpecificationsSpecificationECMAScript Language Specification # sec-void-operatorBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
undefined
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 13, 2023 by MDN contributors.
yieldThe yield operator is used to pause and resume a generator function.Try itSyntaxjsyield
yield expression
Parameters
expression Optional

The value to yield from the generator function via the iterator protocol. If omitted, undefined is yielded.

Return valueReturns the optional value passed to the generator's next() method to resume its execution.

Note: This means next() is asymmetric: it always sends a value to the currently suspended yield, but returns the operand of the next yield. The argument passed to the first next() call cannot be retrieved because there's no currently suspended yield.
DescriptionThe yield keyword pauses generator function execution and the value of the expression following the yield keyword is returned to the generator's caller. It can be thought of as a generator-based version of the return keyword.
yield can only be used directly within the generator function that contains it. It cannot be used within nested functions.
Calling a generator function constructs a Generator object. Each time the generator's next() method is called, the generator resumes execution, and runs until it reaches one of the following:

A yield expression. In this case, the generator pauses, and the next() method return an iterator result object with two properties: value and done. The value property is the value of the expression after the yield operator, and done is false, indicating that the generator function has not fully completed.
The end of the generator function. In this case, execution of the generator ends, and the next() method returns an iterator result object where the value is undefined and done is true.
A return statement. In this case, execution of the generator ends, and the next() method returns an iterator result object where the value is the specified return value and done is true.
A throw statement. In this case, execution of the generator halts entirely, and the next() method throws the specified exception.

Once paused on a yield expression, the generator's code execution remains paused until the generator's next() method is called again. If an optional value is passed to the generator's next() method, that value becomes the value returned by the generator's current yield operation. The first next() call does not have a corresponding suspended yield operation, so there's no way to get the argument passed to the first next() call.
If the generator's return() or throw() method is called, it acts as if a return or throw statement was executed at the paused yield expression. You can use try...catch...finally within the generator function body to handle these early completions. If the return() or throw() method is called but there's no suspended yield expression (because next() has not been called yet, or because the generator has already completed), then the early completions cannot be handled and always terminate the generator.ExamplesUsing yieldThe following code is the declaration of an example generator function.
jsfunction* countAppleSales() {
  const saleList = [3, 7, 5];
  for (let i = 0; i < saleList.length; i++) {
    yield saleList[i];
  }
}

Once a generator function is defined, it can be used by constructing an iterator as shown.
jsconst appleStore = countAppleSales(); // Generator { }
console.log(appleStore.next()); // { value: 3, done: false }
console.log(appleStore.next()); // { value: 7, done: false }
console.log(appleStore.next()); // { value: 5, done: false }
console.log(appleStore.next()); // { value: undefined, done: true }

You can also send a value with next(value) into the generator. step evaluates as a return value of the yield expression — although the value passed to the generator's next() method the first time next() is called is ignored.
jsfunction* counter(value) {
  while (true) {
    const step = yield value++;

    if (step) {
      value += step;
    }
  }
}

const generatorFunc = counter(0);
console.log(generatorFunc.next().value); // 0
console.log(generatorFunc.next().value); // 1
console.log(generatorFunc.next().value); // 2
console.log(generatorFunc.next().value); // 3
console.log(generatorFunc.next(10).value); // 14
console.log(generatorFunc.next().value); // 15
console.log(generatorFunc.next(10).value); // 26
SpecificationsSpecificationECMAScript Language Specification # prod-YieldExpressionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Iteration protocols
function*
function* expression
yield*
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
yield*The yield* operator is used to delegate to another iterable object, such as a Generator.Try itSyntaxjsyield* expression
Parameters
expression Optional

An iterable object.

Return valueReturns the value returned by that iterator when it's closed (when done is true).DescriptionThe yield* expression iterates over the operand and yields each value returned by it. It delegates iteration of the current generator to an underlying iterator — which we will refer to as "generator" and "iterator", respectively. yield* first gets the iterator from the operand by calling the latter's @@iterator method. Then, each time the next() method of the generator is called, yield* calls the iterator's next() method, passing the argument received by the generator's next() method (always undefined for the first call), and yielding the same result object as what's returned from the iterator's next() method. If the iterator result has done: true, then the yield* expression stops executing and returns the value of that result.
The yield* operator forwards the current generator's throw() and return() methods to the underlying iterator as well. If the current generator is prematurely closed through one of these methods, the underlying iterator will be notified. If the generator's throw()/return() method is called, the throw()/return() method of the underlying iterator is called with the same argument. The return value of throw()/return() is handled like the next() method's result, and if the method throws, the exception is propagated from the yield* expression.
If the underlying iterator doesn't have a throw() method, this causes yield* to throw a TypeError – but before throwing the error, the underlying iterator's return() method is called if one exists. If the underlying iterator doesn't have a return() method, the yield* expression turns into a return statement, just like calling return() on a suspended yield expression.ExamplesDelegating to another generator
  In following code, values yielded by g1() are returned from
  next() calls just like those which are yielded by g2().

jsfunction* g1() {
  yield 2;
  yield 3;
  yield 4;
}

function* g2() {
  yield 1;
  yield* g1();
  yield 5;
}

const gen = g2();

console.log(gen.next()); // {value: 1, done: false}
console.log(gen.next()); // {value: 2, done: false}
console.log(gen.next()); // {value: 3, done: false}
console.log(gen.next()); // {value: 4, done: false}
console.log(gen.next()); // {value: 5, done: false}
console.log(gen.next()); // {value: undefined, done: true}
Other Iterable objects
  Besides generator objects, yield* can also yield other kinds
  of iterables (e.g., arrays, strings, or arguments
  objects).

jsfunction* g3(...args) {
  yield* [1, 2];
  yield* "34";
  yield* args;
}

const gen = g3(5, 6);

console.log(gen.next()); // {value: 1, done: false}
console.log(gen.next()); // {value: 2, done: false}
console.log(gen.next()); // {value: "3", done: false}
console.log(gen.next()); // {value: "4", done: false}
console.log(gen.next()); // {value: 5, done: false}
console.log(gen.next()); // {value: 6, done: false}
console.log(gen.next()); // {value: undefined, done: true}
The value of yield* expression itselfyield* is an expression, not a statement, so it evaluates to a value.
jsfunction* g4() {
  yield* [1, 2, 3];
  return "foo";
}

function* g5() {
  const g4ReturnValue = yield* g4();
  console.log(g4ReturnValue); // 'foo'
  return g4ReturnValue;
}

const gen = g5();

console.log(gen.next()); // {value: 1, done: false}
console.log(gen.next()); // {value: 2, done: false}
console.log(gen.next()); // {value: 3, done: false} done is false because g5 generator isn't finished, only g4
console.log(gen.next()); // {value: 'foo', done: true}
Method forwardingThe next(), throw(), and return() methods of the current generator are all forwarded to the underlying iterator.
jsconst iterable = {
  [Symbol.iterator]() {
    let count = 0;
    return {
      next(v) {
        console.log("next called with", v);
        count++;
        return { value: count, done: false };
      },
      return(v) {
        console.log("return called with", v);
        return { value: "iterable return value", done: true };
      },
      throw(v) {
        console.log("throw called with", v);
        return { value: "iterable thrown value", done: true };
      },
    };
  },
};

function* gf() {
  yield* iterable;
  return "gf return value";
}

const gen = gf();
console.log(gen.next(10));
// next called with undefined; the argument of the first next() call is always ignored
// { value: 1, done: false }
console.log(gen.next(20));
// next called with 20
// { value: 2, done: false }
console.log(gen.return(30));
// return called with 30
// { value: 'iterable return value', done: true }
console.log(gen.next(40));
// { value: undefined, done: true }; gen is already closed

const gen2 = gf();
console.log(gen2.next(10));
// next called with undefined
// { value: 1, done: false }
console.log(gen2.throw(50));
// throw called with 50
// { value: 'gf return value', done: true }
console.log(gen.next(60));
// { value: undefined, done: true }; gen is already closed

If the return()/throw() method of the underlying iterator returns done: false, the current generator continues executing and yield* continues to delegate to the underlying iterator.
jsconst iterable = {
  [Symbol.iterator]() {
    let count = 0;
    return {
      next(v) {
        console.log("next called with", v);
        count++;
        return { value: count, done: false };
      },
      return(v) {
        console.log("return called with", v);
        return { value: "iterable return value", done: false };
      },
    };
  },
};

function* gf() {
  yield* iterable;
  return "gf return value";
}

const gen = gf();
console.log(gen.next(10));
// next called with undefined
// { value: 1, done: false }
console.log(gen.return(20));
// return called with 20
// { value: 'iterable return value', done: false }
console.log(gen.next(30));
// { value: 2, done: false }; gen is not closed

If the underlying iterator doesn't have a throw() method and the generator's throw() is called, yield* throws an error.
jsconst iterable = {
  [Symbol.iterator]() {
    let count = 0;
    return {
      next(v) {
        count++;
        return { value: count, done: false };
      },
    };
  },
};

function* gf() {
  yield* iterable;
  return "gf return value";
}

const gen = gf();
gen.next(); // First next() starts the yield* expression
gen.throw(20); // TypeError: The iterator does not provide a 'throw' method.
SpecificationsSpecificationECMAScript Language Specification # sec-generator-function-definitions-runtime-semantics-evaluationBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Iteration protocols
function*
function* expression
yield
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
Statements and declarationsJavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.Statements and declarations by categoryFor an alphabetical listing see the sidebar on the left.Control flow
return

Specifies the value to be returned by a function.

break

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

continue

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

throw

Throws a user-defined exception.

if...else

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

switch

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

try...catch

Marks a block of statements to try, and specifies a response, should an exception be thrown.

Declaring variables
var

Declares a variable, optionally initializing it to a value.

let

Declares a block scope local variable, optionally initializing it to a value.

const

Declares a read-only named constant.

Functions and classes
function

Declares a function with the specified parameters.

function*

Generator Functions enable writing iterators more easily.

async function

Declares an async function with the specified parameters.

async function*

Asynchronous Generator Functions enable writing async iterators more easily.

class

Declares a class.

Iterations
do...while

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

for

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

for...in

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

for...of

Iterates over iterable objects (including arrays, array-like objects, iterators and generators), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

for await...of

Iterates over async iterable objects, array-like objects, iterators and generators, invoking a custom iteration hook with statements to be executed for the value of each distinct property.

while

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

Others
Empty

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

Block

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

Expression statement

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

debugger

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

export

Used to export functions to make them available for imports in external modules, and other scripts.

import

Used to import functions exported from an external module, another script.

label

Provides a statement with an identifier that you can refer to using a break or continue statement.

with 
Deprecated


Extends the scope chain for a statement.

Difference between statements and declarationsIn this section, we will be mixing two kinds of constructs: statements and declarations. They are two disjoint sets of grammars. The following are declarations:

let
const
function
function*
async function
async function*
class
export (Note: it can only appear at the top-level of a module)
import (Note: it can only appear at the top-level of a module)

Everything else in the list above is a statement.
The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an if...else:
jsif (condition)
  statement1;
else
  statement2;

If you use a declaration instead of a statement, it would be a SyntaxError. For example, a let declaration is not a statement, so you can't use it in its bare form as the body of an if statement.
jsif (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context

On the other hand, var is a statement, so you can use it on its own as the if body.
jsif (condition)
  var i = 0;

You can see declarations as "binding identifiers to values", and statements as "carrying out actions". The fact that var is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing var-defined variables, and defining variables that are visible outside of its block (because var-defined variables aren't block-scoped).
As another example, labels can only be attached to statements.
jslabel: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context


Note: there's a legacy grammar that allows function declarations to have labels, but it's only standardized for compatibility with web reality.

To get around this, you can wrap the declaration in braces — this makes it part of a block statement.
jslabel: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Expressions and operators
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
async functionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2017.Learn moreSee full compatibilityReport feedbackThe async function declaration creates a binding of a new async function to a given name. The await keyword is permitted within the function body, enabling asynchronous, promise-based behavior to be written in a cleaner style and avoiding the need to explicitly configure promise chains.
You can also define async functions using the async function expression.Try itSyntaxjsasync function name(param0) {
  statements
}
async function name(param0, param1) {
  statements
}
async function name(param0, param1, /* …, */ paramN) {
  statements
}


Note: There cannot be a line terminator between async and function, otherwise a semicolon is automatically inserted, causing async to become an identifier and the rest to become a function declaration.
Parameters
name

The function's name.

param Optional

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference.

statements Optional


      The statements comprising the body of the function. The await
      mechanism may be used.
    

DescriptionAn async function declaration creates an AsyncFunction object. Each time when an async function is called, it returns a new Promise which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function.
Async functions can contain zero or more await expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of async and await enables the use of ordinary try / catch blocks around asynchronous code.

Note: The await keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a SyntaxError.
await can be used on its own with JavaScript modules.



Note: The purpose of async/await is to simplify the syntax
    necessary to consume promise-based APIs. The behavior
    of async/await is similar to combining generators and
    promises.
  


  Async functions always return a promise. If the return value of an async function is
  not explicitly a promise, it will be implicitly wrapped in a promise.

For example, consider the following code:
jsasync function foo() {
  return 1;
}

It is similar to:
jsfunction foo() {
  return Promise.resolve(1);
}


Note:
Even though the return value of an async function behaves as if it's wrapped in a Promise.resolve, they are not equivalent.
An async function will return a different reference, whereas Promise.resolve returns the same reference if the given value is a promise.
It can be a problem when you want to check the equality of a promise and a return value of an async function.
jsconst p = new Promise((res, rej) => {
  res(1);
});

async function asyncReturn() {
  return p;
}

function basicReturn() {
  return Promise.resolve(p);
}

console.log(p === basicReturn()); // true
console.log(p === asyncReturn()); // false



  The body of an async function can be thought of as being split by zero or more await
  expressions. Top-level code, up to and including the first await expression (if there is
  one), is run synchronously. In this way, an async function without an await expression
  will run synchronously. If there is an await expression inside the function body,
  however, the async function will always complete asynchronously.

For example:
jsasync function foo() {
  await 1;
}

It is also equivalent to:
jsfunction foo() {
  return Promise.resolve(1).then(() => undefined);
}


  Code after each await expression can be thought of as existing in a .then
  callback. In this way a promise chain is progressively constructed with each reentrant
  step through the function. The return value forms the final link in the chain.


  In the following example, we successively await two promises. Progress moves through
  function foo in three stages.



    The first line of the body of function foo is executed synchronously,
    with the await expression configured with the pending promise. Progress through
    foo is then suspended and control is yielded back to the function that
    called foo.
  

    Some time later, when the first promise has either been fulfilled or rejected,
    control moves back into foo. The result of the first promise fulfillment
    (if it was not rejected) is returned from the await expression. Here 1 is
    assigned to result1. Progress continues, and the second await expression
    is evaluated. Again, progress through foo is suspended and control is
    yielded.
  

    Some time later, when the second promise has either been fulfilled or rejected,
    control re-enters foo. The result of the second promise resolution is
    returned from the second await expression. Here 2 is assigned to
    result2. Control moves to the return expression (if any). The default
    return value of undefined is returned as the resolution value of the
    current promise.
  

jsasync function foo() {
  const result1 = await new Promise((resolve) =>
    setTimeout(() => resolve("1")),
  );
  const result2 = await new Promise((resolve) =>
    setTimeout(() => resolve("2")),
  );
}
foo();


  Note how the promise chain is not built-up in one go. Instead, the promise chain is
  constructed in stages as control is successively yielded from and returned to the async
  function. As a result, we must be mindful of error handling behavior when dealing with
  concurrent asynchronous operations.


  For example, in the following code an unhandled promise rejection error will be thrown,
  even if a .catch handler has been configured further along the promise
  chain. This is because p2 will not be "wired into" the promise chain until
  control returns from p1.

jsasync function foo() {
  const p1 = new Promise((resolve) => setTimeout(() => resolve("1"), 1000));
  const p2 = new Promise((_, reject) => setTimeout(() => reject("2"), 500));
  const results = [await p1, await p2]; // Do not do this! Use Promise.all or Promise.allSettled instead.
}
foo().catch(() => {}); // Attempt to swallow all errors...

async function declarations behave similar to function declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts.ExamplesAsync functions and execution orderjsfunction resolveAfter2Seconds() {
  console.log("starting slow promise");
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("slow");
      console.log("slow promise is done");
    }, 2000);
  });
}

function resolveAfter1Second() {
  console.log("starting fast promise");
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("fast");
      console.log("fast promise is done");
    }, 1000);
  });
}

async function sequentialStart() {
  console.log("== sequentialStart starts ==");

  // 1. Start a timer, log after it's done
  const slow = resolveAfter2Seconds();
  console.log(await slow);

  // 2. Start the next timer after waiting for the previous one
  const fast = resolveAfter1Second();
  console.log(await fast);

  console.log("== sequentialStart done ==");
}

async function sequentialWait() {
  console.log("== sequentialWait starts ==");

  // 1. Start two timers without waiting for each other
  const slow = resolveAfter2Seconds();
  const fast = resolveAfter1Second();

  // 2. Wait for the slow timer to complete, and then log the result
  console.log(await slow);
  // 3. Wait for the fast timer to complete, and then log the result
  console.log(await fast);

  console.log("== sequentialWait done ==");
}

async function concurrent1() {
  console.log("== concurrent1 starts ==");

  // 1. Start two timers concurrently and wait for both to complete
  const results = await Promise.all([
    resolveAfter2Seconds(),
    resolveAfter1Second(),
  ]);
  // 2. Log the results together
  console.log(results[0]);
  console.log(results[1]);

  console.log("== concurrent1 done ==");
}

async function concurrent2() {
  console.log("== concurrent2 starts ==");

  // 1. Start two timers concurrently, log immediately after each one is done
  await Promise.all([
    (async () => console.log(await resolveAfter2Seconds()))(),
    (async () => console.log(await resolveAfter1Second()))(),
  ]);
  console.log("== concurrent2 done ==");
}

sequentialStart(); // after 2 seconds, logs "slow", then after 1 more second, "fast"

// wait above to finish
setTimeout(sequentialWait, 4000); // after 2 seconds, logs "slow" and then "fast"

// wait again
setTimeout(concurrent1, 7000); // same as sequentialWait

// wait again
setTimeout(concurrent2, 10000); // after 1 second, logs "fast", then after 1 more second, "slow"

await and concurrency

  In sequentialStart, execution suspends 2 seconds for the first
  await, and then another second for the second await. The
  second timer is not created until the first has already fired, so the code finishes
  after 3 seconds.


  In sequentialWait, both timers are created and then awaited.
  The timers run concurrently, which means the code finishes in 2 rather than 3 seconds,
  i.e. the slowest timer.
  However, the await calls still run in series, which means the second
  await will wait for the first one to finish. In this case, the result of
  the fastest timer is processed after the slowest.


  If you wish to safely perform other jobs after two or more jobs run concurrently and are complete, you must await a call
  to Promise.all() or Promise.allSettled() before that job.



Warning: The functions sequentialWait and concurrent1
    are not functionally equivalent.
  

    In sequentialWait, if promise fast rejects before promise
    slow is fulfilled, then an unhandled promise rejection error will be
    raised, regardless of whether the caller has configured a catch clause.
  

    In concurrent1, Promise.all wires up the promise
    chain in one go, meaning that the operation will fail-fast regardless of the order of
    rejection of the promises, and the error will always occur within the configured
    promise chain, enabling it to be caught in the normal way.
  
Rewriting a Promise chain with an async function
  An API that returns a Promise will result in a promise chain, and it
  splits the function into many parts. Consider the following code:

jsfunction getProcessedData(url) {
  return downloadData(url) // returns a promise
    .catch((e) => downloadFallbackData(url)) // returns a promise
    .then((v) => processDataInWorker(v)); // returns a promise
}

it can be rewritten with a single async function as follows:
jsasync function getProcessedData(url) {
  let v;
  try {
    v = await downloadData(url);
  } catch (e) {
    v = await downloadFallbackData(url);
  }
  return processDataInWorker(v);
}

Alternatively, you can chain the promise with catch():
jsasync function getProcessedData(url) {
  const v = await downloadData(url).catch((e) => downloadFallbackData(url));
  return processDataInWorker(v);
}


  In the two rewritten versions, notice there is no await statement after the
  return keyword, although that would be valid too: The return value of an
  async function is implicitly wrapped in Promise.resolve - if
  it's not already a promise itself (as in the examples).
SpecificationsSpecificationECMAScript Language Specification # sec-async-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Using promises guide
Functions
AsyncFunction
async function expression
function
function*
async function*
await
Promise
Decorating async JavaScript functions on innolitics.com (2016)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 12, 2024 by MDN contributors.
async function*The async function* declaration creates a binding of a new async generator function to a given name.
You can also define async generator functions using the async function* expression.Try itSyntaxjsasync function* name(param0) {
  statements
}
async function* name(param0, param1) {
  statements
}
async function* name(param0, param1, /* …, */ paramN) {
  statements
}


Note: Async generator functions do not have arrow function counterparts.


Note: function and * are separate tokens, so they can be separated by whitespace or line terminators. However, there cannot be a line terminator between async and function, otherwise a semicolon is automatically inserted, causing async to become an identifier and the rest to become a function* declaration.
Parameters
name

The function name.

param Optional

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference.

statements Optional

The statements comprising the body of the function.

DescriptionAn async function* declaration creates an AsyncGeneratorFunction object. Each time when an async generator function is called, it returns a new AsyncGenerator object, which conforms to the async iterator protocol. Every call to next() returns a Promise that resolves to the iterator result object.
An async generator function combines the features of async functions and generator functions. You can use both the await and yield keywords within the function body. This empowers you to handle asynchronous tasks ergonomically with await, while leveraging the lazy nature of generator functions.
When a promise is yielded from an async generator, the iterator result promise's eventual state will match that of the yielded promise. For example:
jsasync function* foo() {
  yield Promise.reject(1);
}

foo()
  .next()
  .catch((e) => console.error(e));

1 will be logged, because if the yielded promise rejects, the iterator result will reject as well. The value property of an async generator's resolved result will not be another promise.
async function* declarations behave similar to function declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts.ExamplesDeclaring an async generator functionAsync generator functions always produce promises of results — even when each yield step is synchronous.
jsasync function* myGenerator(step) {
  await new Promise((resolve) => setTimeout(resolve, 10));
  yield 0;
  yield step;
  yield step * 2;
}

const gen = myGenerator(2);
gen
  .next()
  .then((res) => {
    console.log(res); // { value: 0, done: false }
    return gen.next();
  })
  .then((res) => {
    console.log(res); // { value: 2, done: false }
    return gen.next();
  })
  .then((res) => {
    console.log(res); // { value: 4, done: false }
    return gen.next();
  })
  .then((res) => {
    console.log(res); // { value: undefined, done: true }
    return gen.next();
  });
Using an async generator function to read a series of filesIn this example, we read a series of files and only access its content when requested, using Node's fs/promises module.
jsasync function* readFiles(directory) {
  const files = await fs.readdir(directory);
  for (const file of files) {
    const stats = await fs.stat(file);
    if (stats.isFile()) {
      yield {
        name: file,
        content: await fs.readFile(file, "utf8"),
      };
    }
  }
}

const files = readFiles(".");
console.log((await files.next()).value);
// Possible output: { name: 'file1.txt', content: '...' }
console.log((await files.next()).value);
// Possible output: { name: 'file2.txt', content: '...' }
SpecificationsSpecificationECMAScript Language Specification # sec-async-generator-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Iterators and generators guide
Functions
AsyncGeneratorFunction
async function* expression
function
function*
async function
Iteration protocols
yield
yield*
AsyncGenerator
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Block statementA block statement is used to group zero or more statements. The block is delimited by a pair of braces ("curly braces") and contains a list of zero or more statements and declarations.Try itSyntaxjs{
  StatementList
}


StatementList

Statements and declarations grouped within the block statement.

DescriptionThe block statement is often called the compound statement in other languages. It allows you to use multiple statements where JavaScript expects only one statement. Combining statements into blocks is a common practice in JavaScript, especially when used in association with control flow statements like if...else and for. The opposite behavior is possible using an empty statement, where you provide no statement, although one is required.
In addition, combined with block-scoped declarations like let, const, and class, blocks can prevent temporary variables from polluting the global namespace, just like IIFEs do.Block scoping rules with var or function declaration in non-strict modeVariables declared with var or created by function declarations in non-strict mode do not have block scope. Variables introduced within a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:
jsvar x = 1;
{
  var x = 2;
}
console.log(x); // 2

This logs 2 because the var x statement within the block is in the same scope as the var x statement before the block.
In non-strict code, function declarations inside blocks behave strangely. Do not use them.Block scoping rules with let, const, class, or function declaration in strict modeBy contrast, identifiers declared with let, const, and class do have block scope:
jslet x = 1;
{
  let x = 2;
}
console.log(x); // 1

The x = 2 is limited in scope to the block in which it was defined.
The same is true of const:
jsconst c = 1;
{
  const c = 2;
}
console.log(c); // 1; does not throw SyntaxError

Note that the block-scoped const c = 2 does not throw a SyntaxError: Identifier 'c' has already been declared because it can be declared uniquely within the block.
In strict mode, function declarations inside blocks are scoped to that block and are hoisted to the top of the block.
js"use strict";

{
  foo(); // Logs "foo"
  function foo() {
    console.log("foo");
  }
}

foo(); // ReferenceError: foo is not defined
ExamplesUsing a block statement as the body of a for loopA for loop accepts a single statement as its body.
jsfor (let i = 0; i < 10; i++) console.log(i);

If you want to use more than one statement in the loop body, you can group them into one block statement:
jsfor (let i = 0; i < 10; i++) {
  console.log(i);
  console.log(i ** 2);
}
Using a block statement to encapsulate datalet and const declarations are scoped to the containing block. This allows you to hide data from the global scope without wrapping it in a function.
jslet sector;
{
  // These variables are scoped to this block and are not
  // accessible after the block
  const angle = Math.PI / 3;
  const radius = 10;
  sector = {
    radius,
    angle,
    area: (angle / 2) * radius ** 2,
    perimeter: 2 * radius + angle * radius,
  };
}
console.log(sector);
// {
//   radius: 10,
//   angle: 1.0471975511965976,
//   area: 52.35987755982988,
//   perimeter: 30.471975511965976
// }
console.log(typeof radius); // "undefined"
SpecificationsSpecificationECMAScript Language Specification # sec-blockBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
while
if...else
let
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 7, 2023 by MDN contributors.
breakThe break statement terminates the current loop or switch statement and transfers program control to the statement following the terminated statement. It can also be used to jump past a labeled statement when used within that labeled statement.Try itSyntaxjsbreak;
break label;


label Optional

Identifier associated with the label of the statement to break to. If the break statement is not nested within a loop or switch, then the label identifier is required.

DescriptionWhen break; is encountered, the program breaks out of the innermost switch or looping statement and continues executing the next statement after that.
When break label; is encountered, the program breaks out of the statement labeled with label and continues executing the next statement after that. The break statement needs to be nested within the referenced label. The labeled statement can be any statement (commonly a block statement); it does not have to be another loop statement.
A break statement, with or without a following label, cannot be used at the top level of a script, module, function's body, or static initialization block, even when the function or class is further contained within a loop.Examplesbreak in while loopThe following function has a break statement that terminates the while loop when i is 3, and then returns the value 3 * x.
jsfunction testBreak(x) {
  let i = 0;

  while (i < 6) {
    if (i === 3) {
      break;
    }
    i += 1;
  }

  return i * x;
}
break in switch statementsThe following code has a break statement that terminates the switch statement when a case is matched and the corresponding code has run.
jsconst food = "sushi";

switch (food) {
  case "sushi":
    console.log("Sushi is originally from Japan.");
    break;
  case "pizza":
    console.log("Pizza is originally from Italy.");
    break;
  default:
    console.log("I have never heard of that dish.");
    break;
}
break in labeled blocksThe following code uses break statements with labeled blocks. By using break outerBlock, control is transferred to the end of the block statement marked as outerBlock.
jsouterBlock: {
  innerBlock: {
    console.log("1");
    break outerBlock; // breaks out of both innerBlock and outerBlock
    console.log(":-("); // skipped
  }
  console.log("2"); // skipped
}
Unsyntactic break statementsA break statement must be nested within any label it references. The following code also uses break statements with labeled blocks, but generates a syntax error because its break statement references block2 but it's not nested within block2.
jsblock1: {
  console.log("1");
  break block2; // SyntaxError: label not found
}

block2: {
  console.log("2");
}

Syntax errors are also generated in the following code examples which use break statements within functions that are nested within a loop, or labeled block that the break statements are intended to break out of.
jsfunction testBreak(x) {
  let i = 0;

  while (i < 6) {
    if (i === 3) {
      (() => {
        break;
      })();
    }
    i += 1;
  }

  return i * x;
}

testBreak(1); // SyntaxError: Illegal break statement

jsblock1: {
  console.log("1");
  (() => {
    break block1; // SyntaxError: Undefined label 'block1'
  })();
}
SpecificationsSpecificationECMAScript Language Specification # sec-break-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
continue
label
switch
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 11, 2023 by MDN contributors.
classBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackThe class declaration creates a binding of a new class to a given name.
You can also define classes using the class expression.Try itSyntaxjsclass name {
  // class body
}
class name extends otherName {
  // class body
}
DescriptionThe class body of a class declaration is executed in strict mode. The class declaration is very similar to let:

class declarations are scoped to blocks as well as functions.
class declarations can only be accessed after the place of declaration is reached (see temporal dead zone). For this reason, class declarations are commonly regarded as non-hoisted (unlike function declarations).
class declarations do not create properties on globalThis when declared at the top level of a script (unlike function declarations).
class declarations cannot be redeclared by any other declaration in the same scope.

Outside the class body, class declarations can be re-assigned like let, but you should avoid doing so. Within the class body, the binding is constant like const.
jsclass Foo {
  static {
    Foo = 1; // TypeError: Assignment to constant variable.
  }
}

class Foo2 {
  bar = (Foo2 = 1); // TypeError: Assignment to constant variable.
}

class Foo3 {}
Foo3 = 1;
console.log(Foo3); // 1
ExamplesA simple class declarationIn the following example, we first define a class named Rectangle, then extend it to create a class named FilledRectangle.
Note that super(), used in the constructor, can only be used in constructors, and must be called before the this keyword can be used.
jsclass Rectangle {
  constructor(height, width) {
    this.name = "Rectangle";
    this.height = height;
    this.width = width;
  }
}

class FilledRectangle extends Rectangle {
  constructor(height, width, color) {
    super(height, width);
    this.name = "Filled rectangle";
    this.color = color;
  }
}
SpecificationsSpecificationECMAScript Language Specification # sec-class-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
function
class expression
Classes
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
constThe const declaration declares block-scoped local variables. The value of a constant can't be changed through reassignment using the assignment operator, but if a constant is an object, its properties can be added, updated, or removed.Try itSyntaxjsconst name1 = value1;
const name1 = value1, name2 = value2;
const name1 = value1, name2 = value2, /* …, */ nameN = valueN;


nameN

The name of the variable to declare. Each must be a legal JavaScript identifier or a destructuring binding pattern.

valueN

Initial value of the variable. It can be any legal expression.

DescriptionThe const declaration is very similar to let:

const declarations are scoped to blocks as well as functions.
const declarations can only be accessed after the place of declaration is reached (see temporal dead zone). For this reason, const declarations are commonly regarded as non-hoisted.
const declarations do not create properties on globalThis when declared at the top level of a script.
const declarations cannot be redeclared by any other declaration in the same scope.
const begins declarations, not statements. That means you cannot use a lone const declaration as the body of a block (which makes sense, since there's no way to access the variable).
    jsif (true) const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context



An initializer for a constant is required. You must specify its value in the same declaration. (This makes sense, given that it can't be changed later.)
jsconst FOO; // SyntaxError: Missing initializer in const declaration

The const declaration creates an immutable reference to a value. It does not mean the value it holds is immutable — just that the variable identifier cannot be reassigned. For instance, in the case where the content is an object, this means the object's contents (e.g., its properties) can be altered. You should understand const declarations as "create a variable whose identity remains constant", not "whose value remains constant" — or, "create immutable bindings", not "immutable values".
Many style guides (including MDN's) recommend using const over let whenever a variable is not reassigned in its scope. This makes the intent clear that a variable's type (or value, in the case of a primitive) can never change. Others may prefer let for non-primitives that are mutated.
The list that follows the const keyword is called a binding list and is separated by commas, where the commas are not comma operators and the = signs are not assignment operators. Initializers of later variables can refer to earlier variables in the list.ExamplesBasic const usageConstants can be declared with uppercase or lowercase, but a common convention is to use all-uppercase letters, especially for primitives because they are truly immutable.
js// define MY_FAV as a constant and give it the value 7
const MY_FAV = 7;

console.log("my favorite number is: " + MY_FAV);

js// Re-assigning to a constant variable throws an error
MY_FAV = 20; // TypeError: Assignment to constant variable

// Redeclaring a constant throws an error
const MY_FAV = 20; // SyntaxError: Identifier 'MY_FAV' has already been declared
var MY_FAV = 20; // SyntaxError: Identifier 'MY_FAV' has already been declared
let MY_FAV = 20; // SyntaxError: Identifier 'MY_FAV' has already been declared
Block scopingIt's important to note the nature of block scoping.
jsconst MY_FAV = 7;

if (MY_FAV === 7) {
  // This is fine because it's in a new block scope
  const MY_FAV = 20;
  console.log(MY_FAV); // 20

  // var declarations are not scoped to blocks so this throws an error
  var MY_FAV = 20; // SyntaxError: Identifier 'MY_FAV' has already been declared
}

console.log(MY_FAV); // 7
const in objects and arraysconst also works on objects and arrays. Attempting to overwrite the object throws an error "Assignment to constant variable".
jsconst MY_OBJECT = { key: "value" };
MY_OBJECT = { OTHER_KEY: "value" };

However, object keys are not protected, so the following statement is executed without problem.
jsMY_OBJECT.key = "otherValue";

You would need to use Object.freeze() to make an object immutable.
The same applies to arrays. Assigning a new array to the variable throws an error "Assignment to constant variable".
jsconst MY_ARRAY = [];
MY_ARRAY = ["B"];

Still, it's possible to push items into the array and thus mutate it.
jsMY_ARRAY.push("A"); // ["A"]
Declaration with destructuringThe left-hand side of each = can also be a binding pattern. This allows creating multiple variables at once.
jsconst result = /(a+)(b+)(c+)/.exec("aaabcc");
const [, a, b, c] = result;
console.log(a, b, c); // "aaa" "b" "cc"

For more information, see Destructuring assignment.SpecificationsSpecificationECMAScript Language Specification # sec-let-and-const-declarationsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
var
let
Constants in the JavaScript Guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
continueThe continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.Try itSyntaxjscontinue;
continue label;


label Optional

Identifier associated with the label of the statement.

DescriptionIn contrast to the break statement, continue does not terminate the execution of the loop entirely, but instead:

In a while or do...while loop, it jumps back to the condition.
In a for loop, it jumps to the update expression.
In a for...in, for...of, or for await...of loop, it jumps to the next iteration.

The continue statement can include an optional label that allows the program to jump to the next iteration of a labeled loop statement instead of the innermost loop. In this case, the continue statement needs to be nested within this labeled statement.
A continue statement, with or without a following label, cannot be used at the top level of a script, module, function's body, or static initialization block, even when the function or class is further contained within a loop.ExamplesUsing continue with whileThe following example shows a while loop that has a continue statement that executes when the value of i is 3. Thus, n takes on the values 1, 3, 7, and 12.
jslet i = 0;
let n = 0;

while (i < 5) {
  i++;

  if (i === 3) {
    continue;
  }

  n += i;
}
Using continue with a labelIn the following example, a statement labeled checkIAndJ contains a statement labeled checkJ. If continue is encountered, the program continues at the top of the checkJ statement. Each time continue is encountered, checkJ reiterates until its condition returns false. When false is returned, the remainder of the checkIAndJ statement is completed.
If continue had a label of checkIAndJ, the program would continue at the top of the checkIAndJ statement.
jslet i = 0;
let j = 8;

checkIAndJ: while (i < 4) {
  console.log(`i: ${i}`);
  i += 1;

  checkJ: while (j > 4) {
    console.log(`j: ${j}`);
    j -= 1;

    if (j % 2 === 0) continue checkJ;
    console.log(`${j} is odd.`);
  }
  console.log(`i = ${i}`);
  console.log(`j = ${j}`);
}

Output:
i: 0

// start checkj
j: 8
7 is odd.
j: 7
j: 6
5 is odd.
j: 5
// end checkj

i = 1
j = 4

i: 1
i = 2
j = 4

i: 2
i = 3
j = 4

i: 3
i = 4
j = 4
Unsyntactic continue statementscontinue cannot be used within loops across function boundaries.
jsfor (let i = 0; i < 10; i++) {
  (() => {
    continue; // SyntaxError: Illegal continue statement: no surrounding iteration statement
  })();
}

When referencing a label, the labeled statement must contain the continue statement.
jslabel: for (let i = 0; i < 10; i++) {
  console.log(i);
}

for (let i = 0; i < 10; i++) {
  continue label; // SyntaxError: Undefined label 'label'
}

The labeled statement must be a loop.
jslabel: {
  for (let i = 0; i < 10; i++) {
    continue label; // SyntaxError: Illegal continue statement: 'label' does not denote an iteration statement
  }
}
SpecificationsSpecificationECMAScript Language Specification # sec-continue-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
break
label
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 11, 2023 by MDN contributors.
debugger
  The debugger statement invokes any available debugging
  functionality, such as setting a breakpoint. If no debugging functionality is available,
  this statement has no effect.
Syntaxjsdebugger;
ExamplesUsing the debugger statement
  The following example shows code where a debugger statement has been
  inserted, to invoke a debugger (if one exists) when the function is called.

jsfunction potentiallyBuggyCode() {
  debugger;
  // do potentially buggy stuff to examine, step through, etc.
}


  When the debugger is invoked, execution is paused at the debugger
  statement. It is like a breakpoint in the script source.



SpecificationsSpecificationECMAScript Language Specification # sec-debugger-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
The Firefox JavaScript Debugger¶ in the Firefox source docs
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
do...while
  The do...while statement creates a loop that executes a
  specified statement until the test condition evaluates to false. The condition is
  evaluated after executing the statement, resulting in the specified statement executing
  at least once.
Try itSyntaxjsdo
  statement
while (condition);


statement


      A statement that is executed at least once and is re-executed each time the
      condition evaluates to true. To execute multiple statements within the loop, use a
      block statement ({ /* ... */ }) to
      group those statements.
    

condition


      An expression evaluated after each pass through the loop. If condition
evaluates to true, the statement is re-executed. When
      condition evaluates to false, control passes to the statement following
      the do...while.
    

      Note: Use the break statement to stop a loop before condition evaluates
      to false.
    

ExamplesUsing do...while
  In the following example, the do...while loop iterates at least once and
  reiterates until i is no longer less than 5.

jslet result = "";
let i = 0;
do {
  i += 1;
  result += `${i} `;
} while (i > 0 && i < 5);
// Despite i === 0 this will still loop as it starts off without the test

console.log(result);
Using an assignment as a conditionIn some cases, it can make sense to use an assignment as a condition, such as this:
jsdo {
  // …
} while ((match = regexp.exec(str)));

But when you do, there are readability tradeoffs. The while documentation has a Using an assignment as a condition section with our recommendations.SpecificationsSpecificationECMAScript Language Specification # sec-do-while-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
while
for
break
continue
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 9, 2023 by MDN contributors.
Empty statement
  An empty statement is used to provide no statement, although the
  JavaScript syntax would expect one.
Try itSyntaxjs;
Description
  The empty statement is a semicolon (;) indicating that no statement will
  be executed, even if JavaScript syntax requires one.


  The opposite behavior, where you want multiple statements, but JavaScript only allows a
  single one, is possible using a block statement,
  which combines several statements into a single one.
ExamplesEmpty loop body
  The empty statement is sometimes used with loop statements. See the following example
  with an empty loop body:

jsconst arr = [1, 2, 3];

// Assign all array values to 0
for (let i = 0; i < arr.length; arr[i++] = 0) /* empty statement */ ;

console.log(arr);
// [0, 0, 0]
Unintentional usage
  It is a good idea to comment intentional use of the empty statement, as it is
  not really obvious to distinguish from a normal semicolon.

In the following example, the usage is probably not intentional:
jsif (condition);      // Caution, this "if" does nothing!
  killTheUniverse(); // So this always gets executed!!!
SpecificationsSpecificationECMAScript Language Specification # sec-empty-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Block statement
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
exportThe export declaration is used to export values from a JavaScript module. Exported values can then be imported into other programs with the import declaration or dynamic import. The value of an imported binding is subject to change in the module that exports it — when a module updates the value of a binding that it exports, the update will be visible in its imported value.
In order to use the export declaration in a source file, the file must be interpreted by the runtime as a module. In HTML, this is done by adding type="module" to the <script> tag, or by being imported by another module. Modules are automatically interpreted in strict mode.Syntaxjs// Exporting declarations
export let name1, name2/*, … */; // also var
export const name1 = 1, name2 = 2/*, … */; // also var, let
export function functionName() { /* … */ }
export class ClassName { /* … */ }
export function* generatorFunctionName() { /* … */ }
export const { name1, name2: bar } = o;
export const [ name1, name2 ] = array;

// Export list
export { name1, /* …, */ nameN };
export { variable1 as name1, variable2 as name2, /* …, */ nameN };
export { variable1 as "string name" };
export { name1 as default /*, … */ };

// Default exports
export default expression;
export default function functionName() { /* … */ }
export default class ClassName { /* … */ }
export default function* generatorFunctionName() { /* … */ }
export default function () { /* … */ }
export default class { /* … */ }
export default function* () { /* … */ }

// Aggregating modules
export * from "module-name";
export * as name1 from "module-name";
export { name1, /* …, */ nameN } from "module-name";
export { import1 as name1, import2 as name2, /* …, */ nameN } from "module-name";
export { default, /* …, */ } from "module-name";
export { default as name1 } from "module-name";


nameN

Identifier to be exported (so that it can be imported via import in another script). If you use an alias with as, the actual exported name can be specified as a string literal, which may not be a valid identifier.

DescriptionEvery module can have two different types of export, named export and default export. You can have multiple named exports per module but only one default export. Each type corresponds to one of the above syntax.
Named exports:
js// export features declared elsewhere
export { myFunction2, myVariable2 };

// export individual features (can export var, let,
// const, function, class)
export let myVariable = Math.sqrt(2);
export function myFunction() {
  // …
}

After the export keyword, you can use let, const, and var declarations, as well as function or class declarations. You can also use the export { name1, name2 } syntax to export a list of names declared elsewhere. Note that export {} does not export an empty object — it's a no-op declaration that exports nothing (an empty name list).
Export declarations are not subject to temporal dead zone rules. You can declare that the module exports X before the name X itself is declared.
jsexport { x };
const x = 1;
// This works, because `export` is only a declaration, but doesn't
// utilize the value of `x`.

Default exports:
js// export feature declared elsewhere as default
export { myFunction as default };
// This is equivalent to:
export default myFunction;

// export individual features as default
export default function () { /* … */ }
export default class { /* … */ }


Note: Names for export declarations must be distinct from each other. Having exports with duplicate names or using more than one default export will result in a SyntaxError and prevent the module from being evaluated.

The export default syntax allows any expression.
jsexport default 1 + 1;

As a special case, functions and classes are exported as declarations, not expressions, and these declarations can be anonymous. This means functions will be hoisted.
js// Works because `foo` is a function declaration,
// not a function expression
foo();

export default function foo() {
  console.log("Hi");
}

// It's still technically a declaration, but it's allowed
// to be anonymous
export default function () {
  console.log("Hi");
}

Named exports are useful when you need to export several values. When importing this module, named exports must be referred to by the exact same name (optionally renaming it with as), but the default export can be imported with any name. For example:
js// file test.js
const k = 12;
export default k;

js// some other file
import m from "./test"; // note that we have the freedom to use import m instead of import k, because k was default export
console.log(m); // 12

You can also rename named exports to avoid naming conflicts:
jsexport { myFunction as function1, myVariable as variable };

You can rename a name to something that's not a valid identifier by using a string literal. For example:
jsexport { myFunction as "my-function" };
Re-exporting / AggregatingA module can also "relay" values exported from other modules without the hassle of writing two separate import/export statements. This is often useful when creating a single module concentrating various exports from various modules (usually called a "barrel module").
This can be achieved with the "export from" syntax:
jsexport { default as function1, function2 } from "bar.js";

Which is comparable to a combination of import and export, except that function1 and function2 do not become available inside the current module:
jsimport { default as function1, function2 } from "bar.js";
export { function1, function2 };

Most of the "import from" syntaxes have "export from" counterparts.
jsexport { x } from "mod";
export { x as v } from "mod";
export * as ns from "mod";

There is also export * from "mod", although there's no import * from "mod". This re-exports all named exports from mod as the named exports of the current module, but the default export of mod is not re-exported. If there are two wildcard exports statements that implicitly re-export the same name, neither one is re-exported.
js// -- mod1.js --
export const a = 1;

// -- mod2.js --
export const a = 3;

// -- barrel.js --
export * from "./mod1.js";
export * from "./mod2.js";

// -- main.js --
import * as ns from "./barrel.js";
console.log(ns.a); // undefined

Attempting to import the duplicate name directly will throw an error.
jsimport { a } from "./barrel.js";
// SyntaxError: The requested module './barrel.js' contains conflicting star exports for name 'a'

The following is syntactically invalid despite its import equivalent:
jsexport DefaultExport from "bar.js"; // Invalid

The correct way of doing this is to rename the export:
jsexport { default as DefaultExport } from "bar.js";

The "export from" syntax allows the as token to be omitted, which makes the default export still re-exported as default export.
jsexport { default, function2 } from "bar.js";
ExamplesUsing named exportsIn a module my-module.js, we could include the following code:
js// module "my-module.js"
function cube(x) {
  return x * x * x;
}

const foo = Math.PI + Math.SQRT2;

const graph = {
  options: {
    color: "white",
    thickness: "2px",
  },
  draw() {
    console.log("From graph draw function");
  },
};

export { cube, foo, graph };

Then in the top-level module included in your HTML page, we could have:
jsimport { cube, foo, graph } from "./my-module.js";

graph.options = {
  color: "blue",
  thickness: "3px",
};

graph.draw(); // Logs "From graph draw function"
console.log(cube(3)); // 27
console.log(foo); // 4.555806215962888

It is important to note the following:

You need to include this script in your HTML with a <script> element of type="module", so that it gets recognized as a module and dealt with appropriately.
You can't run JS modules via a file:// URL — you'll get CORS errors. You need to run it via an HTTP server.
Using the default exportIf we want to export a single value or to have a fallback value for your module, you could use a default export:
js// module "my-module.js"

export default function cube(x) {
  return x * x * x;
}

Then, in another script, it is straightforward to import the default export:
jsimport cube from "./my-module.js";
console.log(cube(3)); // 27
Using export fromLet's take an example where we have the following hierarchy:

childModule1.js: exporting myFunction and myVariable
childModule2.js: exporting MyClass
parentModule.js: acting as an aggregator (and doing nothing else)
top level module: consuming the exports of parentModule.js

This is what it would look like using code snippets:
js// In childModule1.js
function myFunction() {
  console.log("Hello!");
}
const myVariable = 1;
export { myFunction, myVariable };

js// In childModule2.js
class MyClass {
  constructor(x) {
    this.x = x;
  }
}

export { MyClass };

js// In parentModule.js
// Only aggregating the exports from childModule1 and childModule2
// to re-export them
export { myFunction, myVariable } from "childModule1.js";
export { MyClass } from "childModule2.js";

js// In top-level module
// We can consume the exports from a single module since parentModule
// "collected"/"bundled" them in a single source
import { myFunction, myVariable, MyClass } from "parentModule.js";
SpecificationsSpecificationECMAScript Language Specification # sec-exportsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
import
JavaScript modules guide
ES6 in Depth: Modules on hacks.mozilla.org (2015)
ES modules: A cartoon deep-dive on hacks.mozilla.org (2018)
Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 2, 2024 by MDN contributors.
Expression statementAn expression statement is an expression used in a place where a statement is expected. The expression is evaluated and its result is discarded — therefore, it makes sense only for expressions that have side effects, such as executing a function or updating a variable.Syntaxjsexpression;


expression

An arbitrary expression to be evaluated. There are certain expressions that may be ambiguous with other statements and are thus forbidden.

DescriptionApart from the dedicated statement syntaxes, you can also use almost any expression as a statement on its own. The expression statement syntax requires a semicolon at the end, but the automatic semicolon insertion process may insert one for you if the lack of a semicolon results in invalid syntax.
Because the expression is evaluated and then discarded, the result of the expression is not available. Therefore, the expression must have some side effect for it to be useful. Expression statements are commonly:

Function calls (console.log("Hello");, [1, 2, 3].forEach((i) => console.log(i));)
Tagged template literals
Assignment expressions, including compound assignments
Increment and decrement operators
delete
import()
yield and yield*

Others may also have side effects if they invoke getters or trigger type coercions.Forbidden expressionsIn order for an expression to be used as a statement, it must not be ambiguous with other statement syntaxes. Therefore, the expression must not start with any of the following tokens:

function: which would be a function declaration or function* declaration, not a function expression or function* expression
async function: which would be an async function declaration or async function* declaration, not an async function expression or async function* expression
class: which would be a class declaration, not a class expression
let[: which would be a let declaration with array destructuring, not a property accessor on a variable called let (let can only be an identifier in non-strict mode)
{: which would be a block statement, not an object literal

Therefore, all of the following are invalid:
jsfunction foo() {
  console.log("foo");
}(); // SyntaxError: Unexpected token '('

// For some reason, you have a variable called `let`
var let = [1, 2, 3];
let[0] = 4; // SyntaxError: Invalid destructuring assignment target

{
  foo: 1,
  bar: 2, // SyntaxError: Unexpected token ':'
};

More dangerously, sometimes the code happens to be valid syntax, but is not what you intend.
js// For some reason, you have a variable called `let`
var let = [1, 2, 3];

function setIndex(index, value) {
  if (index >= 0) {
    // Intend to assign to the array `let`, but instead creates an extra variable!
    let[index] = value;
  }
}

setIndex(0, [1, 2]);
console.log(let); // [1, 2, 3]

// This is not an object literal, but a block statement,
// where `foo` is a label and `1` is an expression statement.
// This often happens in the console
{ foo: 1 };

To avoid these problems, you can use parentheses, so that the statement is unambiguously an expression statement.
js(function foo() {
  console.log("foo");
})();
ExamplesAvoiding control flow statementsYou can avoid almost all use of control flow statements using expression statements. For example, if...else can be replaced with ternary operators and logical operators. Iterative statements like for or for...of can be replaced with array methods.
js// Using control flow statements
function range(start, end) {
  if (start > end) {
    [start, end] = [end, start];
  }
  const result = [];
  for (let i = start; i < end; i++) {
    result.push(i);
  }
  return result;
}

// Using expression statements
function range2(start, end) {
  start > end && ([start, end] = [end, start]);
  return Array.from({ length: end - start }, (_, i) => start + i);
}


Warning: This only demonstrates a capability of the language. Excessive use of expression statements as a substitute for control-flow statements can make code much less readable.
SpecificationsSpecificationECMAScript Language Specification # sec-expression-statementSee also
Statements and declarations
Expressions and operators
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 11, 2023 by MDN contributors.
forThe for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement) to be executed in the loop.Try itSyntaxjsfor (initialization; condition; afterthought)
  statement


initialization Optional

An expression (including assignment expressions) or variable declaration evaluated once before the loop begins. Typically used to initialize a counter variable. This expression may optionally declare new variables with var or let keywords. Variables declared with var are not local to the loop, i.e. they are in the same scope the for loop is in. Variables declared with let are local to the statement.
The result of this expression is discarded.

condition Optional

An expression to be evaluated before each loop iteration. If this expression evaluates to true, statement is executed. If the expression evaluates to false, execution exits the loop and goes to the first statement after the for construct.
This conditional test is optional. If omitted, the condition always evaluates to true.

afterthought Optional

An expression to be evaluated at the end of each loop iteration. This occurs before the next evaluation of condition. Generally used to update or increment the counter variable.

statement

A statement that is executed as long as the condition evaluates to true. You can use a block statement to execute multiple statements. To execute no statement within the loop, use an empty statement (;).

ExamplesUsing forThe following for statement starts by declaring the variable i and initializing it to 0. It checks that i is less than nine, performs the two succeeding statements, and increments i by 1 after each pass through the loop.
jsfor (let i = 0; i < 9; i++) {
  console.log(i);
  // more statements
}
Initialization block syntaxThe initialization block accepts both expressions and variable declarations. However, expressions cannot use the in operator unparenthesized, because that is ambiguous with a for...in loop.
jsfor (let i = "start" in window ? window.start : 0; i < 9; i++) {
  console.log(i);
}
// SyntaxError: 'for-in' loop variable declaration may not have an initializer.

js// Parenthesize the whole initializer
for (let i = ("start" in window ? window.start : 0); i < 9; i++) {
  console.log(i);
}

// Parenthesize the `in` expression
for (let i = ("start" in window) ? window.start : 0; i < 9; i++) {
  console.log(i);
}
Optional for expressionsAll three expressions in the head of the for loop are optional. For example, it is not required to use the initialization block to initialize variables:
jslet i = 0;
for (; i < 9; i++) {
  console.log(i);
  // more statements
}

Like the initialization block, the condition part is also optional. If you are omitting this expression, you must make sure to break the loop in the body in order to not create an infinite loop.
jsfor (let i = 0; ; i++) {
  console.log(i);
  if (i > 3) break;
  // more statements
}

You can also omit all three expressions. Again, make sure to use a break statement to end the loop and also modify (increase) a variable, so that the condition for the break statement is true at some point.
jslet i = 0;

for (;;) {
  if (i > 3) break;
  console.log(i);
  i++;
}

However, in the case where you are not fully using all three expression positions — especially if you are not declaring variables with the first expression but mutating something in the upper scope — consider using a while loop instead, which makes the intention clearer.
jslet i = 0;

while (i <= 3) {
  console.log(i);
  i++;
}
Lexical declarations in the initialization blockDeclaring a variable within the initialization block has important differences from declaring it in the upper scope, especially when creating a closure within the loop body. For example, for the code below:
jsfor (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}

It logs 0, 1, and 2, as expected. However, if the variable is defined in the upper scope:
jslet i = 0;
for (; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}

It logs 3, 3, and 3. The reason is that each setTimeout creates a new closure that closes over the i variable, but if the i is not scoped to the loop body, all closures will reference the same variable when they eventually get called — and due to the asynchronous nature of setTimeout, it will happen after the loop has already exited, causing the value of i in all queued callbacks' bodies to have the value of 3.
This also happens if you use a var statement as the initialization, because variables declared with var are only function-scoped, but not lexically scoped (i.e. they can't be scoped to the loop body).
jsfor (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
// Logs 3, 3, 3

The scoping effect of the initialization block can be understood as if the declaration happens within the loop body, but just happens to be accessible within the condition and afterthought parts. More precisely, let declarations are special-cased by for loops — if initialization is a let declaration, then every time, after the loop body is evaluated, the following happens:

A new lexical scope is created with new let-declared variables.
The binding values from the last iteration are used to re-initialize the new variables.
afterthought is evaluated in the new scope.

So re-assigning the new variables within afterthought does not affect the bindings from the previous iteration.
A new lexical scope is also created after initialization, just before condition is evaluated for the first time. These details can be observed by creating closures, which allow to get hold of a binding at any particular point. For example, in this code a closure created within the initialization section does not get updated by re-assignments of i in the afterthought:
jsfor (let i = 0, getI = () => i; i < 3; i++) {
  console.log(getI());
}
// Logs 0, 0, 0

This does not log "0, 1, 2", like what would happen if getI is declared in the loop body. This is because getI is not re-evaluated on each iteration — rather, the function is created once and closes over the i variable, which refers to the variable declared when the loop was first initialized. Subsequent updates to the value of i actually create new variables called i, which getI does not see. A way to fix this is to re-compute getI every time i updates:
jsfor (let i = 0, getI = () => i; i < 3; i++, getI = () => i) {
  console.log(getI());
}
// Logs 0, 1, 2

The i variable inside the initialization is distinct from the i variable inside every iteration, including the first. So, in this example, getI returns 0, even though the value of i inside the iteration is incremented beforehand:
jsfor (let i = 0, getI = () => i; i < 3; ) {
  i++;
  console.log(getI());
}
// Logs 0, 0, 0

In fact, you can capture this initial binding of the i variable and re-assign it later, and this updated value will not be visible to the loop body, which sees the next new binding of i.
jsfor (
  let i = 0, getI = () => i, incrementI = () => i++;
  getI() < 3;
  incrementI()
) {
  console.log(i);
}
// Logs 0, 0, 0

This logs "0, 0, 0", because the i variable in each loop evaluation is actually a separate variable, but getI and incrementI both read and write the initial binding of i, not what was subsequently declared.Using for without a bodyThe following for cycle calculates the offset position of a node in the afterthought section, and therefore it does not require the use of a statement section, a semicolon is used instead.
jsfunction showOffsetPos(id) {
  let left = 0;
  let top = 0;
  for (
    let itNode = document.getElementById(id); // initialization
    itNode; // condition
    left += itNode.offsetLeft,
      top += itNode.offsetTop,
      itNode = itNode.offsetParent // afterthought
  ); // semicolon

  console.log(
    `Offset position of "${id}" element:
left: ${left}px;
top: ${top}px;`,
  );
}

showOffsetPos("content");

// Logs:
// Offset position of "content" element:
// left: 0px;
// top: 153px;

Note that the semicolon after the for statement is mandatory, because it stands as an empty statement. Otherwise, the for statement acquires the following console.log line as its statement section, which makes the log execute multiple times.Using for with two iterating variablesYou can create two counters that are updated simultaneously in a for loop using the comma operator. Multiple let and var declarations can also be joined with commas.
jsconst arr = [1, 2, 3, 4, 5, 6];
for (let l = 0, r = arr.length - 1; l < r; l++, r--) {
  console.log(arr[l], arr[r]);
}
// 1 6
// 2 5
// 3 4
SpecificationsSpecificationECMAScript Language Specification # sec-for-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Empty statement
break
continue
while
do...while
for...in
for...of
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
for await...ofThe for await...of statement creates a loop iterating over async iterable objects as well as sync iterables. This statement can only be used in contexts where await can be used, which includes inside an async function body and in a module.Try itSyntaxjsfor await (variable of iterable)
  statement


variable

Receives a value from the sequence on each iteration. May be either a declaration with const, let, or var, or an assignment target (e.g. a previously declared variable, an object property, or a destructuring assignment pattern). Variables declared with var are not local to the loop, i.e. they are in the same scope the for await...of loop is in.

iterable

An async iterable or sync iterable. The source of the sequence of values on which the loop operates.

statement

A statement to be executed on every iteration. May reference variable. You can use a block statement to execute multiple statements.

DescriptionWhen a for await...of loop iterates over an iterable, it first gets the iterable's [@@asyncIterator]() method and calls it, which returns an async iterator. If the @asyncIterator method does not exist, it then looks for an [@@iterator]() method, which returns a sync iterator. The sync iterator returned is then wrapped into an async iterator by wrapping every object returned from the next(), return(), and throw() methods into a resolved or rejected promise, with the value property resolved if it's also a promise. The loop then repeatedly calls the final async iterator's next() method and awaits the returned promise, producing the sequence of values to be assigned to variable.
If the for await...of loop exited early (e.g. a break statement is encountered or an error is thrown), the return() method of the iterator is called to perform any cleanup. The returned promise is awaited before the loop exits.
for await...of generally functions the same as the for...of loop and shares many of the same syntax and semantics. There are a few differences:

for await...of works on both sync and async iterables, while for...of only works on sync iterables.
for await...of can only be used in contexts where await can be used, which includes inside an async function body and in a module. Even when the iterable is sync, the loop still awaits the return value for every iteration, leading to slower execution due to repeated promise unwrapping.
If the iterable is a sync iterable that yields promises, for await...of would produce a sequence of resolved values, while for...of would produce a sequence of promises. (However, beware of error handling and cleanup — see Iterating over sync iterables and generators)
For for await...of, the variable can be the identifier async (e.g. for await (async of foo)); for...of forbids this case.
ExamplesIterating over async iterablesYou can also iterate over an object that explicitly implements async iterable protocol:
jsconst LIMIT = 3;

const asyncIterable = {
  [Symbol.asyncIterator]() {
    let i = 0;
    return {
      next() {
        const done = i === LIMIT;
        const value = done ? undefined : i++;
        return Promise.resolve({ value, done });
      },
      return() {
        // This will be reached if the consumer called 'break' or 'return' early in the loop.
        return { done: true };
      },
    };
  },
};

(async () => {
  for await (const num of asyncIterable) {
    console.log(num);
  }
})();
// 0
// 1
// 2
Iterating over async generators
  Since the return values of async generator functions conform to the async iterable protocol,
  they can be looped using for await...of.

jsasync function* asyncGenerator() {
  let i = 0;
  while (i < 3) {
    yield i++;
  }
}

(async () => {
  for await (const num of asyncGenerator()) {
    console.log(num);
  }
})();
// 0
// 1
// 2

For a more concrete example of iterating over an async generator using for await...of, consider iterating over data from an API.
This example first creates an async iterable for a stream of data, then uses it to find the size of the response from the API.
jsasync function* streamAsyncIterable(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) return;
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}

// Fetches data from URL and calculates response size using the async generator.
async function getResponseSize(url) {
  const response = await fetch(url);
  // Will hold the size of the response, in bytes.
  let responseSize = 0;
  // The for-await-of loop. Async iterates over each portion of the response.
  for await (const chunk of streamAsyncIterable(response.body)) {
    // Incrementing the total response length.
    responseSize += chunk.length;
  }

  console.log(`Response Size: ${responseSize} bytes`); // "Response Size: 1071472"
  return responseSize;
}
getResponseSize("https://jsonplaceholder.typicode.com/photos");
Iterating over sync iterables and generatorsfor await...of loop also consumes sync iterables and generators. In that case it internally awaits emitted values before assign them to the loop control variable.
jsfunction* generator() {
  yield 0;
  yield 1;
  yield Promise.resolve(2);
  yield Promise.resolve(3);
  yield 4;
}

(async () => {
  for await (const num of generator()) {
    console.log(num);
  }
})();
// 0
// 1
// 2
// 3
// 4

// compare with for-of loop:

for (const numOrPromise of generator()) {
  console.log(numOrPromise);
}
// 0
// 1
// Promise { 2 }
// Promise { 3 }
// 4


Note: Be aware of yielding rejected promises from a sync generator. In such case, for await...of throws when consuming the rejected promise and DOESN'T CALL finally blocks within that generator. This can be undesirable if you need to free some allocated resources with try/finally.

jsfunction* generatorWithRejectedPromises() {
  try {
    yield 0;
    yield 1;
    yield Promise.resolve(2);
    yield Promise.reject(3);
    yield 4;
    throw 5;
  } finally {
    console.log("called finally");
  }
}

(async () => {
  try {
    for await (const num of generatorWithRejectedPromises()) {
      console.log(num);
    }
  } catch (e) {
    console.log("caught", e);
  }
})();
// 0
// 1
// 2
// caught 3

// compare with for-of loop:

try {
  for (const numOrPromise of generatorWithRejectedPromises()) {
    console.log(numOrPromise);
  }
} catch (e) {
  console.log("caught", e);
}
// 0
// 1
// Promise { 2 }
// Promise { <rejected> 3 }
// 4
// caught 5
// called finally

To make finally blocks of a sync generator always called, use the appropriate form of the loop — for await...of for the async generator and for...of for the sync one — and await yielded promises explicitly inside the loop.
js(async () => {
  try {
    for (const numOrPromise of generatorWithRejectedPromises()) {
      console.log(await numOrPromise);
    }
  } catch (e) {
    console.log("caught", e);
  }
})();
// 0
// 1
// 2
// caught 3
// called finally
SpecificationsSpecificationECMAScript Language Specification # sec-for-in-and-for-of-statementsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Symbol.asyncIterator
for...of
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
for...inThe for...in statement iterates over all enumerable string properties of an object (ignoring properties keyed by symbols), including inherited enumerable properties.Try itSyntaxjsfor (variable in object)
  statement
Parameters
variable

Receives a string property name on each iteration. May be either a declaration with const, let, or var, or an assignment target (e.g. a previously declared variable, an object property, or a destructuring assignment pattern). Variables declared with var are not local to the loop, i.e. they are in the same scope the for...in loop is in.

object

Object whose non-symbol enumerable properties are iterated over.

statement

A statement to be executed on every iteration. May reference variable. You can use a block statement to execute multiple statements.

DescriptionThe loop will iterate over all enumerable properties of the object itself and those the object inherits from its prototype chain (properties of nearer prototypes take precedence over those of prototypes further away from the object in its prototype chain).
A for...in loop only iterates over enumerable, non-symbol properties. Objects created from built–in constructors like Array and Object have inherited non–enumerable properties from Array.prototype and Object.prototype, such as Array's indexOf() method or Object's toString() method, which will not be visited in the for...in loop.
The traversal order, as of modern ECMAScript specification, is well-defined and consistent across implementations. Within each component of the prototype chain, all non-negative integer keys (those that can be array indices) will be traversed first in ascending order by value, then other string keys in ascending chronological order of property creation.
The variable part of for...in accepts anything that can come before the = operator. You can use const to declare the variable as long as it's not reassigned within the loop body (it can change between iterations, because those are two separate variables). Otherwise, you can use let. You can use destructuring to assign multiple local variables, or use a property accessor like for (x.y in iterable) to assign the value to an object property.
A legacy syntax allows var declarations of the loop variable to have an initializer. This throws a syntax error in strict mode and is ignored in non–strict mode.Deleted, added, or modified propertiesfor...in visits property keys in the following fashion:

It first gets all own string keys of the current object, in a fashion very similar to Object.getOwnPropertyNames().
For each key, if no string with the same value has ever been visited, the property descriptor is retrieved and the property is only visited if it is enumerable. However, this property string will be marked as visited even if it's not enumerable.
Then, the current object is replaced with its prototype, and the process is repeated.

This means:

Any property added to the currently visited object during iteration will not be visited, because all own properties of the current object have already been saved beforehand.
If multiple objects in the prototype chain have a property with the same name, only the first one will be considered, and it is only visited if it's enumerable. If it is non-enumerable, no other properties with the same name further up the prototype chain will be visited, even if they are enumerable.

In general, it is best not to add, modify, or remove properties from the object during iteration, other than the property currently being visited. The spec explicitly allows the implementation to not follow the algorithm above in one of the following cases:

The object's prototype chain is modified during iteration.
A property is deleted from the object or its prototype chain during iteration.
A property is added to the object's prototype chain during iteration.
A property's enumerability is changed during iteration.

In these cases, implementations may behave differently from what you may expect, or even from each other.Array iteration and for...inArray indexes are just enumerable properties with integer names and are otherwise identical to general object properties. The for...in loop will traverse all integer keys before traversing other keys, and in strictly increasing order, making the behavior of for...in close to normal array iteration. However, the for...in loop will return all enumerable properties, including those with non–integer names and those that are inherited. Unlike for...of, for...in uses property enumeration instead of the array's iterator. In sparse arrays, for...of will visit the empty slots, but for...in will not.
It is better to use a for loop with a numeric index, Array.prototype.forEach(), or the for...of loop, because they will return the index as a number instead of a string, and also avoid non-index properties.Iterating over own properties onlyIf you only want to consider properties attached to the object itself, and not its prototypes, you can use one of the following techniques:

Object.keys()
Object.getOwnPropertyNames()

Object.keys will return a list of enumerable own string properties, while Object.getOwnPropertyNames will also contain non-enumerable ones.
Many JavaScript style guides and linters recommend against the use of for...in, because it iterates over the entire prototype chain which is rarely what one wants, and may be a confusion with the more widely-used for...of loop. for...in is most practically used for debugging purposes, being an easy way to check the properties of an object (by outputting to the console or otherwise). In situations where objects are used as ad hoc key-value pairs, for...in allows you check if any of those keys hold a particular value.ExamplesUsing for...inThe for...in loop below iterates over all of the object's enumerable, non-symbol properties and logs a string of the property names and their values.
jsconst obj = { a: 1, b: 2, c: 3 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}

// Logs:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
Iterating own propertiesThe following function illustrates the use of Object.hasOwn(): the inherited properties are not displayed.
jsconst triangle = { a: 1, b: 2, c: 3 };

function ColoredTriangle() {
  this.color = "red";
}

ColoredTriangle.prototype = triangle;

const obj = new ColoredTriangle();

for (const prop in obj) {
  if (Object.hasOwn(obj, prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}

// Logs:
// "obj.color = red"
Concurrent modification
Warning: You should not write code like this yourself. It is only included here to illustrate the behavior of for...in in some corner cases.

Properties added to the current object during iteration are never visited:
jsconst obj = { a: 1, b: 2 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
  obj.c = 3;
}

// Logs:
// obj.a = 1
// obj.b = 2

Shadowed properties are only visited once:
jsconst proto = { a: 1 };
const obj = { __proto__: proto, a: 2 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}

// Logs:
// obj.a = 2

Object.defineProperty(obj, "a", { enumerable: false });

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}
// Logs nothing, because the first "a" property visited is non-enumerable.

In addition, consider the following cases, where the behavior is unspecified, and implementations tend to diverge from the specified algorithm:
Changing the prototype during iteration:
jsconst obj = { a: 1, b: 2 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
  Object.setPrototypeOf(obj, { c: 3 });
}

Deleting a property during iteration:
jsconst obj = { a: 1, b: 2, c: 3 };

// Deleting a property before it is visited
for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
  delete obj.c;
}

const obj2 = { a: 1, b: 2, c: 3 };

// Deleting a property after it is visited
for (const prop in obj2) {
  console.log(`obj2.${prop} = ${obj2[prop]}`);
  delete obj2.a;
}

Enumerable properties added to the prototype during iteration:
jsconst proto = {};
const obj = { __proto__: proto, a: 1, b: 2 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
  proto.c = 3;
}

Changing the enumerability of a property during iteration:
jsconst obj = { a: 1, b: 2, c: 3 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
  Object.defineProperty(obj, "c", { enumerable: false });
}
SpecificationsSpecificationECMAScript Language Specification # sec-for-in-and-for-of-statementsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
for...of
for
Enumerability and ownership of properties
Object.getOwnPropertyNames()
Object.hasOwn()
Array.prototype.forEach()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
for...ofThe for...of statement executes a loop that operates on a sequence of values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), as well as the arguments object, generators produced by generator functions, and user-defined iterables.Try itSyntaxjsfor (variable of iterable)
  statement


variable

Receives a value from the sequence on each iteration. May be either a declaration with const, let, or var, or an assignment target (e.g. a previously declared variable, an object property, or a destructuring assignment pattern). Variables declared with var are not local to the loop, i.e. they are in the same scope the for...of loop is in.

iterable

An iterable object. The source of the sequence of values on which the loop operates.

statement

A statement to be executed on every iteration. May reference variable. You can use a block statement to execute multiple statements.

DescriptionA for...of loop operates on the values sourced from an iterable one by one in sequential order. Each operation of the loop on a value is called an iteration, and the loop is said to iterate over the iterable. Each iteration executes statements that may refer to the current sequence value.
When a for...of loop iterates over an iterable, it first calls the iterable's [@@iterator]() method, which returns an iterator, and then repeatedly calls the resulting iterator's next() method to produce the sequence of values to be assigned to variable.
A for...of loop exits when the iterator has completed (the iterator's next() method returns an object containing done: true). You may also use control flow statements to change the normal control flow. break exits the loop and goes to the first statement after the loop body, while continue skips the rest of the statements of the current iteration and proceeds to the next iteration.
If the for...of loop exited early (e.g. a break statement is encountered or an error is thrown), the return() method of the iterator is called to perform any cleanup.
The variable part of for...of accepts anything that can come before the = operator. You can use const to declare the variable as long as it's not reassigned within the loop body (it can change between iterations, because those are two separate variables). Otherwise, you can use let.
jsconst iterable = [10, 20, 30];

for (let value of iterable) {
  value += 1;
  console.log(value);
}
// 11
// 21
// 31


Note: Each iteration creates a new variable. Reassigning the variable inside the loop body does not affect the original value in the iterable (an array, in this case).

You can use destructuring to assign multiple local variables, or use a property accessor like for (x.y of iterable) to assign the value to an object property.
However, a special rule forbids using async as the variable name. This is invalid syntax:
jslet async;
for (async of [1, 2, 3]); // SyntaxError: The left-hand side of a for-of loop may not be 'async'.

This is to avoid syntax ambiguity with the valid code for (async of => {};;), which is a for loop.ExamplesIterating over an Arrayjsconst iterable = [10, 20, 30];

for (const value of iterable) {
  console.log(value);
}
// 10
// 20
// 30
Iterating over a stringStrings are iterated by Unicode code points.
jsconst iterable = "boo";

for (const value of iterable) {
  console.log(value);
}
// "b"
// "o"
// "o"
Iterating over a TypedArrayjsconst iterable = new Uint8Array([0x00, 0xff]);

for (const value of iterable) {
  console.log(value);
}
// 0
// 255
Iterating over a Mapjsconst iterable = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);

for (const entry of iterable) {
  console.log(entry);
}
// ['a', 1]
// ['b', 2]
// ['c', 3]

for (const [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a Setjsconst iterable = new Set([1, 1, 2, 2, 3, 3]);

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over the arguments objectYou can iterate over the arguments object to examine all parameters passed into a function.
jsfunction foo() {
  for (const value of arguments) {
    console.log(value);
  }
}

foo(1, 2, 3);
// 1
// 2
// 3
Iterating over a NodeListThe following example adds a read class to paragraphs that are direct descendants of the <article> element by iterating over a NodeList DOM collection.
jsconst articleParagraphs = document.querySelectorAll("article > p");
for (const paragraph of articleParagraphs) {
  paragraph.classList.add("read");
}
Iterating over a user-defined iterableIterating over an object with an @@iterator method that returns a custom iterator:
jsconst iterable = {
  [Symbol.iterator]() {
    let i = 1;
    return {
      next() {
        if (i <= 3) {
          return { value: i++, done: false };
        }
        return { value: undefined, done: true };
      },
    };
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterating over an object with an @@iterator generator method:
jsconst iterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterable iterators (iterators with a [@@iterator]() method that returns this) are a fairly common technique to make iterators usable in syntaxes expecting iterables, such as for...of.
jslet i = 1;

const iterator = {
  next() {
    if (i <= 3) {
      return { value: i++, done: false };
    }
    return { value: undefined, done: true };
  },
  [Symbol.iterator]() {
    return this;
  },
};

for (const value of iterator) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a generatorjsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
}
// 1
// 2
// 3
Early exitingExecution of the break statement in the first loop causes it to exit early. The iterator is not finished yet, so the second loop will continue from where the first one stopped at.
jsconst source = [1, 2, 3];

const iterator = source[Symbol.iterator]();

for (const value of iterator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// Another loop using the same iterator
// picks up where the last loop left off.
for (const value of iterator) {
  console.log(value);
}
// 2
// 3

// The iterator is used up.
// This loop will execute no iterations.
for (const value of iterator) {
  console.log(value);
}
// [No output]

Generators implement the return() method, which causes the generator function to early return when the loop exits. This makes generators not reusable between loops.
jsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// The generator is used up.
// This loop will execute no iterations.
for (const value of generator) {
  console.log(value);
}
// [No output]
Difference between for...of and for...inBoth for...in and for...of statements iterate over something. The main difference between them is in what they iterate over.
The for...in statement iterates over the enumerable string properties of an object, while the for...of statement iterates over values that the iterable object defines to be iterated over.
The following example shows the difference between a for...of loop and a for...in loop when used with an Array.
jsObject.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

const iterable = [3, 5, 7];
iterable.foo = "hello";

for (const i in iterable) {
  console.log(i);
}
// "0", "1", "2", "foo", "arrCustom", "objCustom"

for (const i in iterable) {
  if (Object.hasOwn(iterable, i)) {
    console.log(i);
  }
}
// "0" "1" "2" "foo"

for (const i of iterable) {
  console.log(i);
}
// 3 5 7

The object iterable inherits the properties objCustom and arrCustom because it contains both Object.prototype and Array.prototype in its prototype chain.
The for...in loop logs only enumerable properties of the iterable object. It doesn't log array elements 3, 5, 7 or "hello" because those are not properties — they are values. It logs array indexes as well as arrCustom and objCustom, which are actual properties. If you're not sure why these properties are iterated over, there's a more thorough explanation of how array iteration and for...in work.
The second loop is similar to the first one, but it uses Object.hasOwn() to check if the found enumerable property is the object's own, i.e. not inherited. If it is, the property is logged. Properties 0, 1, 2 and foo are logged because they are own properties. Properties arrCustom and objCustom are not logged because they are inherited.
The for...of loop iterates and logs values that iterable, as an array (which is iterable), defines to be iterated over. The object's elements 3, 5, 7 are shown, but none of the object's properties are.SpecificationsSpecificationECMAScript Language Specification # sec-for-in-and-for-of-statementsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Array.prototype.forEach()
Map.prototype.forEach()
Object.entries()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
functionThe function declaration creates a binding of a new function to a given name.
You can also define functions using the function expression.Try itSyntaxjsfunction name(param0) {
  statements
}
function name(param0, param1) {
  statements
}
function name(param0, param1, /* …, */ paramN) {
  statements
}
Parameters
name

The function name.

param Optional

The name of a formal parameter for the function. Maximum number of arguments varies in different engines. For the parameters' syntax, see the Functions reference.

statements Optional

The statements which comprise the body of the function.

DescriptionA function declaration creates a Function object. Each time when a function is called, it returns the value specified by the last executed return statement, or undefined if the end of the function body is reached. See functions for detailed information on functions.
function declarations behave like a mix of var and let:

Like let, in strict mode, function declarations are scoped to the most closely containing block.
Like let, function declarations at the top level of a module or within blocks in strict mode cannot be redeclared by any other declaration.
Like var, function declarations at the top level of a script (strict or non-strict) become properties on globalThis. Function declarations at the top level of a script or function body (strict or non-strict) can be redeclared by another function or var.
Like both, function declarations can be re-assigned, but you should avoid doing so.
Unlike either, function declarations are hoisted together with its value and can be called anywhere in its scope.
Block-level function declaration
Warning: In non-strict mode, function declarations inside blocks behave strangely. Only declare functions in blocks if you are in strict mode.

Functions can be conditionally declared — that is, a function statement can be nested within an if statement. However, in non-strict mode, the results are inconsistent across implementations.
jsconsole.log(
  `'foo' name ${
    "foo" in globalThis ? "is" : "is not"
  } global. typeof foo is ${typeof foo}`,
);
if (false) {
  function foo() {
    return 1;
  }
}

// In Chrome:
// 'foo' name is global. typeof foo is undefined
//
// In Firefox:
// 'foo' name is global. typeof foo is undefined
//
// In Safari:
// 'foo' name is global. typeof foo is function

The scoping and hoisting effect won't change regardless of whether the if body is actually executed.
jsconsole.log(
  `'foo' name ${
    "foo" in globalThis ? "is" : "is not"
  } global. typeof foo is ${typeof foo}`,
);
if (true) {
  function foo() {
    return 1;
  }
}

// In Chrome:
// 'foo' name is global. typeof foo is undefined
//
// In Firefox:
// 'foo' name is global. typeof foo is undefined
//
// In Safari:
// 'foo' name is global. typeof foo is function

In strict mode, block-level function declarations are scoped to that block and are hoisted to the top of the block.
js"use strict";

{
  foo(); // Logs "foo"
  function foo() {
    console.log("foo");
  }
}

console.log(
  `'foo' name ${
    "foo" in globalThis ? "is" : "is not"
  } global. typeof foo is ${typeof foo}`,
);
// 'foo' name is not global. typeof foo is undefined
HoistingFunction declarations in JavaScript are hoisted to the top of the enclosing function or global scope. You can use the function before you declared it:
jshoisted(); // Logs "foo"

function hoisted() {
  console.log("foo");
}

Note that function expressions are not hoisted:
jsnotHoisted(); // TypeError: notHoisted is not a function

var notHoisted = function () {
  console.log("bar");
};
RedeclarationsWhether function declarations can be redeclared in the same scope depends on what scope it's contained in.
At the top level of a script, function declarations behave like var and can be redeclared by another function or var but not by let, const, or class.
jsfunction a(b) {}
function a(b, c) {}
console.log(a.length); // 2
let a = 2; // SyntaxError: Identifier 'a' has already been declared

When function declarations are redeclared by var, the var declaration's initializer always overrides the function's value, regardless of their relative position. This is because function declarations are hoisted before any initializer gets evaluated, so the initializer comes later and overrides the value.
jsvar a = 1;
function a() {}
console.log(a); // 1

At the top level of a function's body, function also behaves like var and can be redeclared or have the same name as a parameter.
jsfunction foo(a) {
  function a() {}
  console.log(typeof a);
}

foo(2); // Logs "function"

At the top level of a module or a block in strict mode, function declarations behave like let and cannot be redeclared by any other declaration.
js// Assuming current source is a module
function foo() {}
function foo() {} // SyntaxError: Identifier 'foo' has already been declared

js"use strict";
{
  function foo() {}
  function foo() {} // SyntaxError: Identifier 'foo' has already been declared
}

A function declaration within a catch block cannot have the same name as the catch-bound identifier, even in non-strict mode.
jstry {
} catch (e) {
  function e() {} // SyntaxError: Identifier 'e' has already been declared
}
ExamplesUsing functionThe following code declares a function that returns the total amount of sales, when given the number of units sold of three products.
jsfunction calcSales(unitsA, unitsB, unitsC) {
  return unitsA * 79 + unitsB * 129 + unitsC * 699;
}
SpecificationsSpecificationECMAScript Language Specification # sec-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
Function
function expression
function*
async function
async function*
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
function*The function* declaration creates a binding of a new generator function to a given name. A generator function can be exited and later re-entered, with its context (variable bindings) saved across re-entrances.
You can also define generator functions using the function* expression.Try itSyntaxjsfunction* name(param0) {
  statements
}
function* name(param0, param1) {
  statements
}
function* name(param0, param1, /* …, */ paramN) {
  statements
}


Note: Generator functions do not have arrow function counterparts.


Note: function and * are separate tokens, so they can be separated by whitespace or line terminators.
Parameters
name

The function name.

param Optional

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference.

statements Optional

The statements comprising the body of the function.

Description
  A function* declaration creates a GeneratorFunction object. Each time when a generator function is called, it returns a new Generator object, which conforms to the iterator protocol. When the iterator's next()
  method is called, the generator function's body is executed until the first
  yield expression, which specifies the value to be
  returned from the iterator or, with yield*, delegates
  to another generator function. The next() method returns an object with a
  value property containing the yielded value and a done
  property which indicates whether the generator has yielded its last value, as a boolean.
  Calling the next() method with an argument will resume the generator
  function execution, replacing the yield expression where an execution was
  paused with the argument from next().


  Generators in JavaScript — especially when combined with Promises — are a very
  powerful tool for asynchronous programming as they mitigate — if not entirely eliminate
  -- the problems with callbacks, such as Callback Hell and
  Inversion of Control.
  However, an even simpler solution to these problems can be achieved
  with async functions.


  A return statement in a generator, when executed, will make the generator
  finish (i.e. the done property of the object returned by it will be set to
  true). If a value is returned, it will be set as the value
  property of the object returned by the generator.
  Much like a return statement, an error thrown inside the generator will
  make the generator finished — unless caught within the generator's body.
  When a generator is finished, subsequent next() calls will not execute any
  of that generator's code, they will just return an object of this form:
  {value: undefined, done: true}.

function* declarations behave similar to function declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts.ExamplesSimple examplejsfunction* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
// …
Example with yield*jsfunction* anotherGenerator(i) {
  yield i + 1;
  yield i + 2;
  yield i + 3;
}

function* generator(i) {
  yield i;
  yield* anotherGenerator(i);
  yield i + 10;
}

const gen = generator(10);

console.log(gen.next().value); // 10
console.log(gen.next().value); // 11
console.log(gen.next().value); // 12
console.log(gen.next().value); // 13
console.log(gen.next().value); // 20
Passing arguments into Generatorsjsfunction* logGenerator() {
  console.log(0);
  console.log(1, yield);
  console.log(2, yield);
  console.log(3, yield);
}

const gen = logGenerator();

// the first call of next executes from the start of the function
// until the first yield statement
gen.next(); // 0
gen.next("pretzel"); // 1 pretzel
gen.next("california"); // 2 california
gen.next("mayonnaise"); // 3 mayonnaise
Return statement in a generatorjsfunction* yieldAndReturn() {
  yield "Y";
  return "R";
  yield "unreachable";
}

const gen = yieldAndReturn();
console.log(gen.next()); // { value: "Y", done: false }
console.log(gen.next()); // { value: "R", done: true }
console.log(gen.next()); // { value: undefined, done: true }
Generator as an object propertyjsconst someObj = {
  *generator() {
    yield "a";
    yield "b";
  },
};

const gen = someObj.generator();

console.log(gen.next()); // { value: 'a', done: false }
console.log(gen.next()); // { value: 'b', done: false }
console.log(gen.next()); // { value: undefined, done: true }
Generator as an object methodjsclass Foo {
  *generator() {
    yield 1;
    yield 2;
    yield 3;
  }
}

const f = new Foo();
const gen = f.generator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
Generator as a computed propertyjsclass Foo {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
  }
}

const SomeObj = {
  *[Symbol.iterator]() {
    yield "a";
    yield "b";
  },
};

console.log(Array.from(new Foo())); // [ 1, 2 ]
console.log(Array.from(SomeObj)); // [ 'a', 'b' ]
Generators are not constructablejsfunction* f() {}
const obj = new f(); // throws "TypeError: f is not a constructor
Generator defined in an expressionjsconst foo = function* () {
  yield 10;
  yield 20;
};

const bar = foo();
console.log(bar.next()); // {value: 10, done: false}
Generator examplejsfunction* powers(n) {
  //endless loop to generate
  for (let current = n; ; current *= n) {
    yield current;
  }
}

for (const power of powers(2)) {
  // controlling generator
  if (power > 32) {
    break;
  }
  console.log(power);
  // 2
  // 4
  // 8
  // 16
  // 32
}
SpecificationsSpecificationECMAScript Language Specification # sec-generator-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Iterators and generators guide
Functions
GeneratorFunction
function* expression
function
async function
async function*
Iteration protocols
yield
yield*
Generator
Regenerator on GitHub
Promises and Generators: control flow utopia presentation by Forbes Lindesay at JSConf (2013)
Task.js on GitHub
You Don't Know JS: Async & Performance, Ch.4: Generators by Kyle Simpson
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
if...elseThe if...else statement executes a statement if a specified condition is truthy. If the condition is falsy, another statement in the optional else clause will be executed.Try itSyntaxjsif (condition)
  statement1

// With an else clause
if (condition)
  statement1
else
  statement2


condition

An expression that is considered to be either truthy or falsy.

statement1

Statement that is executed if condition is truthy. Can be any statement, including further nested if statements. To execute multiple statements, use a block statement ({ /* ... */ }) to group those statements. To execute no statements, use an empty statement.

statement2

Statement that is executed if condition is falsy and the else clause exists. Can be any statement, including block statements and further nested if statements.

DescriptionMultiple if...else statements can be nested to create an else if clause. Note that there is no elseif (in one word) keyword in JavaScript.
jsif (condition1)
  statement1
else if (condition2)
  statement2
else if (condition3)
  statement3
// …
else
  statementN

To see how this works, this is how it would look if the nesting were properly indented:
jsif (condition1)
  statement1
else
  if (condition2)
    statement2
  else
    if (condition3)
      statement3
// …

To execute multiple statements within a clause, use a block statement ({ /* ... */ }) to group those statements.
jsif (condition) {
  statements1
} else {
  statements2
}

Not using blocks may lead to confusing behavior, especially if the code is hand-formatted. For example:
jsfunction checkValue(a, b) {
  if (a === 1)
    if (b === 2)
      console.log("a is 1 and b is 2");
  else
    console.log("a is not 1");
}

This code looks innocent — however, executing checkValue(1, 3) will log "a is not 1". This is because in the case of dangling else, the else clause will be connected to the closest if clause. Therefore, the code above, with proper indentation, would look like:
jsfunction checkValue(a, b) {
  if (a === 1)
    if (b === 2)
      console.log("a is 1 and b is 2");
    else
      console.log("a is not 1");
}

In general, it is a good practice to always use block statements, especially in code involving nested if statements.
jsfunction checkValue(a, b) {
  if (a === 1) {
    if (b === 2) {
      console.log("a is 1 and b is 2");
    }
  } else {
    console.log("a is not 1");
  }
}

Do not confuse the primitive Boolean values true and false with truthiness or falsiness of the Boolean object. Any value that is not false, undefined, null, 0, -0, NaN, or the empty string (""), and any object, including a Boolean object whose value is false, is considered truthy when used as the condition. For example:
jsconst b = new Boolean(false);
if (b) {
  console.log("b is truthy"); // "b is truthy"
}
ExamplesUsing if...elsejsif (cipherChar === fromChar) {
  result += toChar;
  x++;
} else {
  result += clearChar;
}
Using else ifNote that there is no elseif syntax in JavaScript. However, you can write it with a space between else and if:
jsif (x > 50) {
  /* do something */
} else if (x > 5) {
  /* do something */
} else {
  /* do something */
}
Using an assignment as a conditionYou should almost never have an if...else with an assignment like x = y as a condition:
jsif ((x = y)) {
  // …
}

Because unlike while loops, the condition is only evaluated once, so the assignment is only performed once. The code above is equivalent to:
jsx = y;
if (x) {
  // …
}

Which is much clearer. However, in the rare case you find yourself wanting to do something like that, the while documentation has a Using an assignment as a condition section with our recommendations.SpecificationsSpecificationECMAScript Language Specification # sec-if-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
block
switch
Conditional (ternary) operator
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
importThe static import declaration is used to import read-only live bindings which are exported by another module. The imported bindings are called live bindings because they are updated by the module that exported the binding, but cannot be re-assigned by the importing module.
In order to use the import declaration in a source file, the file must be interpreted by the runtime as a module. In HTML, this is done by adding type="module" to the <script> tag. Modules are automatically interpreted in strict mode.
There is also a function-like dynamic import(), which does not require scripts of type="module".Syntaxjsimport defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { default as alias } from "module-name";
import { export1, export2 } from "module-name";
import { export1, export2 as alias2, /* … */ } from "module-name";
import { "string name" as alias } from "module-name";
import defaultExport, { export1, /* … */ } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";


defaultExport

Name that will refer to the default export from the module. Must be a valid JavaScript identifier.

module-name

The module to import from. The evaluation of the specifier is host-specified. This is often a relative or absolute URL to the .js file containing the module. In Node, extension-less imports often refer to packages in node_modules. Certain bundlers may permit importing files without extensions; check your environment. Only single quoted and double quoted Strings are allowed.

name

Name of the module object that will be used as a kind of namespace when referring to the imports. Must be a valid JavaScript identifier.

exportN

Name of the exports to be imported. The name can be either an identifier or a string literal, depending on what module-name declares to export. If it is a string literal, it must be aliased to a valid identifier.

aliasN

Names that will refer to the named imports. Must be a valid JavaScript identifier.

Descriptionimport declarations can only be present in modules, and only at the top-level (i.e. not inside blocks, functions, etc.). If an import declaration is encountered in non-module contexts (for example, <script> tags without type="module", eval, new Function, which all have "script" or "function body" as parsing goals), a SyntaxError is thrown. To load modules in non-module contexts, use the dynamic import syntax instead.
All imported bindings cannot be in the same scope as any other declaration, including let, const, class, function, var, and import declaration.
import declarations are designed to be syntactically rigid (for example, only string literal specifiers, only permitted at the top-level, all bindings must be identifiers), which allows modules to be statically analyzed and linked before getting evaluated. This is the key to making modules asynchronous by nature, powering features like top-level await.Forms of import declarationsThere are four forms of import declarations:

Named import: import { export1, export2 } from "module-name";
Default import: import defaultExport from "module-name";
Namespace import: import * as name from "module-name";
Side effect import: import "module-name";

Below are examples to clarify the syntax.
Named import
Given a value named myExport which has been exported from the module my-module either implicitly as export * from "another.js" or explicitly using the export statement, this inserts myExport into the current scope.
jsimport { myExport } from "/modules/my-module.js";

You can import multiple names from the same module.
jsimport { foo, bar } from "/modules/my-module.js";

You can rename an export when importing it. For example, this inserts shortName into the current scope.
jsimport { reallyReallyLongModuleExportName as shortName } from "/modules/my-module.js";

A module may also export a member as a string literal which is not a valid identifier, in which case you must alias it in order to use it in the current module.
js// /modules/my-module.js
const a = 1;
export { a as "a-b" };

jsimport { "a-b" as a } from "/modules/my-module.js";


Note: import { x, y } from "mod" is not equivalent to import defaultExport from "mod" and then destructuring x and y from defaultExport. Named and default imports are distinct syntaxes in JavaScript modules.

Default import
Default exports need to be imported with the corresponding default import syntax. The simplest version directly imports the default:
jsimport myDefault from "/modules/my-module.js";

Since the default export doesn't explicitly specify a name, you can give the identifier any name you like.
It is also possible to specify a default import with namespace imports or named imports. In such cases, the default import will have to be declared first. For instance:
jsimport myDefault, * as myModule from "/modules/my-module.js";
// myModule.default and myDefault point to the same binding

or
jsimport myDefault, { foo, bar } from "/modules/my-module.js";

Importing a name called default has the same effect as a default import. It is necessary to alias the name because default is a reserved word.
jsimport { default as myDefault } from "/modules/my-module.js";

Namespace import
The following code inserts myModule into the current scope, containing all the exports from the module located at /modules/my-module.js.
jsimport * as myModule from "/modules/my-module.js";

Here, myModule represents a namespace object which contains all exports as properties. For example, if the module imported above includes an export doAllTheAmazingThings(), you would call it like this:
jsmyModule.doAllTheAmazingThings();

myModule is a sealed object with null prototype. The default export available as a key called default. For more information, see module namespace object.

Note: JavaScript does not have wildcard imports like import * from "module-name", because of the high possibility of name conflicts.

Import a module for its side effects only

  Import an entire module for side effects only, without importing anything. This runs
  the module's global code, but doesn't actually import any values.

jsimport "/modules/my-module.js";

This is often used for polyfills, which mutate the global variables.HoistingImport declarations are hoisted. In this case, that means that the identifiers the imports introduce are available in the entire module scope, and their side effects are produced before the rest of the module's code runs.
jsmyModule.doAllTheAmazingThings(); // myModule.doAllTheAmazingThings is imported by the next line

import * as myModule from "/modules/my-module.js";
ExamplesStandard ImportIn this example, we create a re-usable module that exports a function to get all primes within a given range.
js// getPrimes.js
/**
 * Returns a list of prime numbers that are smaller than `max`.
 */
export function getPrimes(max) {
  const isPrime = Array.from({ length: max }, () => true);
  isPrime[0] = isPrime[1] = false;
  isPrime[2] = true;
  for (let i = 2; i * i < max; i++) {
    if (isPrime[i]) {
      for (let j = i ** 2; j < max; j += i) {
        isPrime[j] = false;
      }
    }
  }
  return [...isPrime.entries()]
    .filter(([, isPrime]) => isPrime)
    .map(([number]) => number);
}

jsimport { getPrimes } from "/modules/getPrimes.js";

console.log(getPrimes(10)); // [2, 3, 5, 7]
Imported values can only be modified by the exporterThe identifier being imported is a live binding, because the module exporting it may re-assign it and the imported value would change. However, the module importing it cannot re-assign it. Still, any module holding an exported object can mutate the object, and the mutated value can be observed by all other modules importing the same value.
You can also observe the new value through the module namespace object.
js// my-module.js
export let myValue = 1;
setTimeout(() => {
  myValue = 2;
}, 500);

js// main.js
import { myValue } from "/modules/my-module.js";
import * as myModule from "/modules/my-module.js";

console.log(myValue); // 1
console.log(myModule.myValue); // 1
setTimeout(() => {
  console.log(myValue); // 2; my-module has updated its value
  console.log(myModule.myValue); // 2
  myValue = 3; // TypeError: Assignment to constant variable.
  // The importing module can only read the value but can't re-assign it.
}, 1000);
SpecificationsSpecificationECMAScript Language Specification # sec-importsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
export
import()
import.meta
Previewing ES6 Modules and more from ES2015, ES2016 and beyond on blogs.windows.com (2016)
ES6 in Depth: Modules on hacks.mozilla.org (2015)
ES modules: A cartoon deep-dive on hacks.mozilla.org (2018)
Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer
Export and Import on javascript.info
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Labeled statementA labeled statement is any statement that is prefixed with an identifier. You can jump to this label using a break or continue statement nested within the labeled statement.Try itSyntaxjslabel:
  statement


label

Any JavaScript identifier that is not a reserved word.

statement

A JavaScript statement. break can be used within any labeled statement, and continue can be used within labeled looping statements.

DescriptionYou can use a label to identify a statement, and later refer to it using a break or continue statement. Note that JavaScript has no goto statement; you can only use labels with break or continue.
Any break or continue that references label must be contained within the statement that's labeled by label. Think about label as a variable that's only available in the scope of statement.
If a break label; statement is encountered when executing statement, execution of statement terminates, and execution continues at the statement immediately following the labeled statement.
continue label; can only be used if statement is one of the looping statements. If a continue label; statement is encountered when executing statement, execution of statement continues at the next iteration of the loop. continue; without a label can only continue the innermost loop, while continue label; allows continuing any given loop even when the statement is nested within other loops.
A statement can have multiple labels. In this case, the labels are all functionally equivalent.ExamplesUsing a labeled continue with for loopsjs// The first for statement is labeled "loop1"
loop1: for (let i = 0; i < 3; i++) {
  // The second for statement is labeled "loop2"
  loop2: for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      continue loop1;
    }
    console.log(`i = ${i}, j = ${j}`);
  }
}

// Logs:
// i = 0, j = 0
// i = 0, j = 1
// i = 0, j = 2
// i = 1, j = 0
// i = 2, j = 0
// i = 2, j = 1
// i = 2, j = 2

Notice how it skips both "i = 1, j = 1" and "i = 1, j = 2".Using a labeled break with for loopsjslet i, j;

// The first for statement is labeled "loop1"
loop1: for (i = 0; i < 3; i++) {
  // The second for statement is labeled "loop2"
  loop2: for (j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break loop1;
    }
    console.log(`i = ${i}, j = ${j}`);
  }
}

// Logs:
// i = 0, j = 0
// i = 0, j = 1
// i = 0, j = 2
// i = 1, j = 0

Notice the difference with the previous continue example: when break loop1 is encountered, the execution of the outer loop is terminated, so there are no further logs beyond "i = 1, j = 0"; when continue loop1 is encountered, the execution of the outer loop continues at the next iteration, so only "i = 1, j = 1" and "i = 1, j = 2" are skipped.Using a labeled continue statementGiven an array of items and an array of tests, this example counts the number of items that pass all the tests.
js// Numbers from 1 to 100
const items = Array.from({ length: 100 }, (_, i) => i + 1);
const tests = [
  { pass: (item) => item % 2 === 0 },
  { pass: (item) => item % 3 === 0 },
  { pass: (item) => item % 5 === 0 },
];
let itemsPassed = 0;

itemIteration: for (const item of items) {
  for (const test of tests) {
    if (!test.pass(item)) {
      continue itemIteration;
    }
  }

  itemsPassed++;
}

Note how the continue itemIteration; statement skips the rest of the tests for the current item as well as the statement that updates the itemsPassed counter, and continues with the next item. If you don't use a label, you would need to use a boolean flag instead.
js// Numbers from 1 to 100
const items = Array.from({ length: 100 }, (_, i) => i + 1);
const tests = [
  { pass: (item) => item % 2 === 0 },
  { pass: (item) => item % 3 === 0 },
  { pass: (item) => item % 5 === 0 },
];
let itemsPassed = 0;

for (const item of items) {
  let passed = true;
  for (const test of tests) {
    if (!test.pass(item)) {
      passed = false;
      break;
    }
  }
  if (passed) {
    itemsPassed++;
  }
}
Using a labeled break statementGiven an array of items and an array of tests, this example determines whether all items pass all tests.
js// Numbers from 1 to 100
const items = Array.from({ length: 100 }, (_, i) => i + 1);
const tests = [
  { pass: (item) => item % 2 === 0 },
  { pass: (item) => item % 3 === 0 },
  { pass: (item) => item % 5 === 0 },
];
let allPass = true;

itemIteration: for (const item of items) {
  for (const test of tests) {
    if (!test.pass(item)) {
      allPass = false;
      break itemIteration;
    }
  }
}

Again, if you don't use a label, you would need to use a boolean flag instead.
js// Numbers from 1 to 100
const items = Array.from({ length: 100 }, (_, i) => i + 1);
const tests = [
  { pass: (item) => item % 2 === 0 },
  { pass: (item) => item % 3 === 0 },
  { pass: (item) => item % 5 === 0 },
];
let allPass = true;

for (const item of items) {
  let passed = true;
  for (const test of tests) {
    if (!test.pass(item)) {
      passed = false;
      break;
    }
  }
  if (!passed) {
    allPass = false;
    break;
  }
}
Using a labeled block with breakYou can label statements other than loops, such as simple blocks, but only break statements can reference non-loop labels.
jsfoo: {
  console.log("face");
  break foo;
  console.log("this will not be executed");
}
console.log("swap");

// Logs:
// "face"
// "swap"
Labeled function declarationsLabels can only be applied to statements, not declarations. There is a legacy grammar that allows function declarations to be labeled in non-strict code:
jsL: function F() {}

In strict mode code, however, this will throw a SyntaxError:
js"use strict";
L: function F() {}
// SyntaxError: functions cannot be labelled

Non-plain functions, such as generator functions and async functions can neither be labeled in strict code, nor in non-strict code:
jsL: function* F() {}
// SyntaxError: generator functions cannot be labelled

The labeled function declaration syntax is deprecated and you should not use it, even in non-strict code. You cannot actually jump to this label within the function body.SpecificationsSpecificationECMAScript Language Specification # sec-labelled-statementsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
break
continue
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
letThe let declaration declares re-assignable, block-scoped local variables, optionally initializing each to a value.Try itSyntaxjslet name1;
let name1 = value1;
let name1 = value1, name2 = value2;
let name1, name2 = value2;
let name1 = value1, name2, /* …, */ nameN = valueN;
Parameters
nameN

The name of the variable to declare. Each must be a legal JavaScript identifier or a destructuring binding pattern.

valueN Optional

Initial value of the variable. It can be any legal expression. Default value is undefined.

DescriptionThe scope of a variable declared with let is one of the following curly-brace-enclosed syntaxes that most closely contains the let declaration:

Block statement
switch statement
try...catch statement
Body of one of the for statements, if the let is in the header of the statement
Function body
Static initialization block

Or if none of the above applies:

The current module, for code running in module mode
The global scope, for code running in script mode.

Compared with var, let declarations have the following differences:

let declarations are scoped to blocks as well as functions.
let declarations can only be accessed after the place of declaration is reached (see temporal dead zone). For this reason, let declarations are commonly regarded as non-hoisted.
let declarations do not create properties on globalThis when declared at the top level of a script.
let declarations cannot be redeclared by any other declaration in the same scope.
let begins declarations, not statements. That means you cannot use a lone let declaration as the body of a block (which makes sense, since there's no way to access the variable).
    jsif (true) let a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context



Note that let is allowed as an identifier name when declared with var or function in non-strict mode, but you should avoid using let as an identifier name to prevent unexpected syntax ambiguities.
Many style guides (including MDN's) recommend using const over let whenever a variable is not reassigned in its scope. This makes the intent clear that a variable's type (or value, in the case of a primitive) can never change. Others may prefer let for non-primitives that are mutated.
The list that follows the let keyword is called a binding list and is separated by commas, where the commas are not comma operators and the = signs are not assignment operators. Initializers of later variables can refer to earlier variables in the list.Temporal dead zone (TDZ)A variable declared with let, const, or class is said to be in a "temporal dead zone" (TDZ) from the start of the block until code execution reaches the place where the variable is declared and initialized.
While inside the TDZ, the variable has not been initialized with a value, and any attempt to access it will result in a ReferenceError. The variable is initialized with a value when execution reaches the place in the code where it was declared. If no initial value was specified with the variable declaration, it will be initialized with a value of undefined.
This differs from var variables, which will return a value of undefined if they are accessed before they are declared. The code below demonstrates the different result when let and var are accessed in code before the place where they are declared.
js{
  // TDZ starts at beginning of scope
  console.log(bar); // "undefined"
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  var bar = 1;
  let foo = 2; // End of TDZ (for foo)
}

The term "temporal" is used because the zone depends on the order of execution (time) rather than the order in which the code is written (position). For example, the code below works because, even though the function that uses the let variable appears before the variable is declared, the function is called outside the TDZ.
js{
  // TDZ starts at beginning of scope
  const func = () => console.log(letVar); // OK

  // Within the TDZ letVar access throws `ReferenceError`

  let letVar = 3; // End of TDZ (for letVar)
  func(); // Called outside TDZ!
}

Using the typeof operator for a let variable in its TDZ will throw a ReferenceError:
jstypeof i; // ReferenceError: Cannot access 'i' before initialization
let i = 10;

This differs from using typeof for undeclared variables, and variables that hold a value of undefined:
jsconsole.log(typeof undeclaredVariable); // "undefined"


Note: let and const declarations are only processed when the current script gets processed. If you have two <script> elements running in script mode within one HTML, the first script is not subject to the TDZ restrictions for top-level let or const variables declared in the second script, although if you declare a let or const variable in the first script, declaring it again in the second script will cause a redeclaration error.
Redeclarationslet declarations cannot be in the same scope as any other declaration, including let, const, class, function, var, and import declaration.
js{
  let foo;
  let foo; // SyntaxError: Identifier 'foo' has already been declared
}

A let declaration within a function's body cannot have the same name as a parameter. A let declaration within a catch block cannot have the same name as the catch-bound identifier.
jsfunction foo(a) {
  let a = 1; // SyntaxError: Identifier 'a' has already been declared
}
try {
} catch (e) {
  let e; // SyntaxError: Identifier 'e' has already been declared
}

If you're experimenting in a REPL, such as the Firefox web console (Tools > Web Developer > Web Console), and you run two let declarations with the same name in two separate inputs, you may get the same re-declaration error. See further discussion of this issue in Firefox bug 1580891. The Chrome console allows let re-declarations between different REPL inputs.
You may encounter errors in switch statements because there is only one block.
jslet x = 1;

switch (x) {
  case 0:
    let foo;
    break;
  case 1:
    let foo; // SyntaxError: Identifier 'foo' has already been declared
    break;
}

To avoid the error, wrap each case in a new block statement.
jslet x = 1;

switch (x) {
  case 0: {
    let foo;
    break;
  }
  case 1: {
    let foo;
    break;
  }
}
ExamplesScoping rulesVariables declared by let have their scope in the block for which they are declared, as well as in any contained sub-blocks. In this way, let works very much like var. The main difference is that the scope of a var variable is the entire enclosing function:
jsfunction varTest() {
  var x = 1;
  {
    var x = 2; // same variable!
    console.log(x); // 2
  }
  console.log(x); // 2
}

function letTest() {
  let x = 1;
  {
    let x = 2; // different variable
    console.log(x); // 2
  }
  console.log(x); // 1
}

At the top level of programs and functions, let, unlike var, does not create a property on the global object. For example:
jsvar x = "global";
let y = "global";
console.log(this.x); // "global"
console.log(this.y); // undefined
TDZ combined with lexical scopingThe following code results in a ReferenceError at the line shown:
jsfunction test() {
  var foo = 33;
  if (foo) {
    let foo = foo + 55; // ReferenceError
  }
}
test();

The if block is evaluated because the outer var foo has a value. However due to lexical scoping this value is not available inside the block: the identifier foo inside the if block is the let foo. The expression foo + 55 throws a ReferenceError because initialization of let foo has not completed — it is still in the temporal dead zone.
This phenomenon can be confusing in a situation like the following. The instruction let n of n.a is already inside the scope of the for...of loop's block. So, the identifier n.a is resolved to the property a of the n object located in the first part of the instruction itself (let n). This is still in the temporal dead zone as its declaration statement has not been reached and terminated.
jsfunction go(n) {
  // n here is defined!
  console.log(n); // { a: [1, 2, 3] }

  for (let n of n.a) {
    //          ^ ReferenceError
    console.log(n);
  }
}

go({ a: [1, 2, 3] });
Other situationsWhen used inside a block, let limits the variable's scope to that block. Note the difference between var, whose scope is inside the function where it is declared.
jsvar a = 1;
var b = 2;

{
  var a = 11; // the scope is global
  let b = 22; // the scope is inside the block

  console.log(a); // 11
  console.log(b); // 22
}

console.log(a); // 11
console.log(b); // 2

However, this combination of var and let declarations below is a SyntaxError because var not being block-scoped, leading to them being in the same scope. This results in an implicit re-declaration of the variable.
jslet x = 1;

{
  var x = 2; // SyntaxError for re-declaration
}
Declaration with destructuringThe left-hand side of each = can also be a binding pattern. This allows creating multiple variables at once.
jsconst result = /(a+)(b+)(c+)/.exec("aaabcc");
let [, a, b, c] = result;
console.log(a, b, c); // "aaa" "b" "cc"

For more information, see Destructuring assignment.SpecificationsSpecificationECMAScript Language Specification # sec-let-and-const-declarationsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
var
const
Hoisting
ES6 In Depth: let and const on hacks.mozilla.org (2015)
Breaking changes in let and const in Firefox 44 on blog.mozilla.org (2015)
You Don't Know JS: Scope & Closures, Ch.3: Function vs. Block Scope by Kyle Simpson
What is the Temporal Dead Zone? on Stack Overflow
What is the difference between using let and var? on Stack Overflow
Why was the name 'let' chosen for block-scoped variable declarations in JavaScript? on Stack Overflow
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 20, 2023 by MDN contributors.
returnThe return statement ends function execution and specifies a value to be returned to the function caller.Try itSyntaxjsreturn;
return expression;


expression Optional

The expression whose value is to be returned. If omitted, undefined is returned.

DescriptionThe return statement can only be used within function bodies. When a return statement is used in a function body, the execution of the function is stopped. The return statement has different effects when placed in different functions:

In a plain function, the call to that function evaluates to the return value.
In an async function, the produced promise is resolved with the returned value.
In a generator function, the produced generator object's next() method returns { done: true, value: returnedValue }.
In an async generator function, the produced async generator object's next() method returns a promise fulfilled with { done: true, value: returnedValue }.

If a return statement is executed within a try block, its finally block, if present, is first executed, before the value is actually returned.Automatic semicolon insertionThe syntax forbids line terminators between the return keyword and the expression to be returned.
jsreturn
a + b;

The code above is transformed by automatic semicolon insertion (ASI) into:
jsreturn;
a + b;

This makes the function return undefined and the a + b expression is never evaluated. This may generate a warning in the console.
To avoid this problem (to prevent ASI), you could use parentheses:
jsreturn (
  a + b
);
ExamplesInterrupt a functionA function immediately stops at the point where return is called.
jsfunction counter() {
  // Infinite loop
  for (let count = 1; ; count++) {
    console.log(`${count}A`); // Until 5
    if (count === 5) {
      return;
    }
    console.log(`${count}B`); // Until 4
  }
  console.log(`${count}C`); // Never appears
}

counter();

// Logs:
// 1A
// 1B
// 2A
// 2B
// 3A
// 3B
// 4A
// 4B
// 5A
Returning a functionSee also the article about Closures.
jsfunction magic() {
  return function calc(x) {
    return x * 42;
  };
}

const answer = magic();
answer(1337); // 56154
SpecificationsSpecificationECMAScript Language Specification # sec-return-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions
Closures
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 11, 2023 by MDN contributors.
switchThe switch statement evaluates an expression, matching the expression's value against a series of case clauses, and executes statements after the first case clause with a matching value, until a break statement is encountered. The default clause of a switch statement will be jumped to if no case matches the expression's value.Try itSyntaxjsswitch (expression) {
  case caseExpression1:
    statements
  case caseExpression2:
    statements
  // …
  case caseExpressionN:
    statements
  default:
    statements
}


expression

An expression whose result is matched against each case clause.

case caseExpressionN Optional

A case clause used to match against expression. If the value of expression matches the value of any caseExpressionN, execution starts from the first statement after that case clause until either the end of the switch statement or the first encountered break.

default Optional

A default clause; if provided, this clause is executed if the value of expression doesn't match any of the case clauses. A switch statement can only have one default clause.

DescriptionA switch statement first evaluates its expression. It then looks for the first case clause whose expression evaluates to the same value as the result of the input expression (using the strict equality comparison) and transfers control to that clause, executing all statements following that clause.
The clause expressions are only evaluated when necessary — if a match is already found, subsequent case clause expressions will not be evaluated, even when they will be visited by fall-through.
jsswitch (undefined) {
  case console.log(1):
  case console.log(2):
}
// Only logs 1

If no matching case clause is found, the program looks for the optional default clause, and if found, transfers control to that clause, executing statements following that clause. If no default clause is found, the program continues execution at the statement following the end of switch. By convention, the default clause is the last clause, but it does not need to be so. A switch statement may only have one default clause; multiple default clauses will result in a SyntaxError.Breaking and fall-throughYou can use the break statement within a switch statement's body to break out early, often when all statements between two case clauses have been executed. Execution will continue at the first statement following switch.
If break is omitted, execution will proceed to the next case clause, even to the default clause, regardless of whether the value of that clause's expression matches. This behavior is called "fall-through".
jsconst foo = 0;
switch (foo) {
  case -1:
    console.log("negative 1");
    break;
  case 0: // Value of foo matches this criteria; execution starts from here
    console.log(0);
  // Forgotten break! Execution falls through
  case 1: // no break statement in 'case 0:' so this case will run as well
    console.log(1);
    break; // Break encountered; will not continue into 'case 2:'
  case 2:
    console.log(2);
    break;
  default:
    console.log("default");
}
// Logs 0 and 1

In the appropriate context, other control-flow statements also have the effect of breaking out of the switch statement. For example, if the switch statement is contained in a function, then a return statement terminates the execution of the function body and therefore the switch statement. If the switch statement is contained in a loop, then a continue statement stops the switch statement and jumps to the next iteration of the loop.Lexical scopingThe case and default clauses are like labels: they indicate possible places that control flow may jump to. However, they don't create lexical scopes themselves (neither do they automatically break out — as demonstrated above). For example:
jsconst action = "say_hello";
switch (action) {
  case "say_hello":
    const message = "hello";
    console.log(message);
    break;
  case "say_hi":
    const message = "hi";
    console.log(message);
    break;
  default:
    console.log("Empty action received.");
}

This example will output the error "Uncaught SyntaxError: Identifier 'message' has already been declared", because the first const message = 'hello'; conflicts with the second const message = 'hi'; declaration, even when they're within their own separate case clauses. Ultimately, this is due to both const declarations being within the same block scope created by the switch body.
To fix this, whenever you need to use let or const declarations in a case clause, wrap it in a block.
jsconst action = "say_hello";
switch (action) {
  case "say_hello": {
    const message = "hello";
    console.log(message);
    break;
  }
  case "say_hi": {
    const message = "hi";
    console.log(message);
    break;
  }
  default: {
    console.log("Empty action received.");
  }
}

This code will now output hello in the console as it should, without any errors.ExamplesUsing switchIn the following example, if expr evaluates to Bananas, the program matches the value with case case 'Bananas' and executes the associated statement. When break is encountered, the program breaks out of switch and executes the statement following switch. If break were omitted, the statement for the case 'Cherries' would also be executed.
jsswitch (expr) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
  case "Papayas":
    console.log("Mangoes and papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${expr}.`);
}

console.log("Is there anything else you'd like?");
Putting the default clause between two case clausesIf no match is found, execution will start from the default clause, and execute all statements after that.
jsconst foo = 5;
switch (foo) {
  case 2:
    console.log(2);
    break; // it encounters this break so will not continue into 'default:'
  default:
    console.log("default");
  // fall-through
  case 1:
    console.log("1");
}

It also works when you put default before all other case clauses.Taking advantage of fall-throughThis method takes advantage of the fact that if there is no break below a case clause, execution will continue to the next case clause regardless if that case meets the criteria.
The following is an example of a single operation sequential case statement, where four different values perform exactly the same.
jsconst Animal = "Giraffe";
switch (Animal) {
  case "Cow":
  case "Giraffe":
  case "Dog":
  case "Pig":
    console.log("This animal is not extinct.");
    break;
  case "Dinosaur":
  default:
    console.log("This animal is extinct.");
}

The following is an example of a multiple-operation sequential case clause, where, depending on the provided integer, you can receive different output. This shows you that it will traverse in the order that you put the case clauses, and it does not have to be numerically sequential. In JavaScript, you can even mix in definitions of strings into these case statements as well.
jsconst foo = 1;
let output = "Output: ";
switch (foo) {
  case 0:
    output += "So ";
  case 1:
    output += "What ";
    output += "Is ";
  case 2:
    output += "Your ";
  case 3:
    output += "Name";
  case 4:
    output += "?";
    console.log(output);
    break;
  case 5:
    output += "!";
    console.log(output);
    break;
  default:
    console.log("Please pick a number from 0 to 5!");
}

The output from this example:



Value
Log text




foo is NaN or not 1, 2, 3, 4, 5, or 0
Please pick a number from 0 to 5!


0
Output: So What Is Your Name?


1
Output: What Is Your Name?


2
Output: Your Name?


3
Output: Name?


4
Output: ?


5
Output: !


An alternative to if...else chainsYou may often find yourself doing a series of if...else matches.
jsif ("fetch" in globalThis) {
  // Fetch a resource with fetch
} else if ("XMLHttpRequest" in globalThis) {
  // Fetch a resource with XMLHttpRequest
} else {
  // Fetch a resource with some custom AJAX logic
}

This pattern is not doing a sequence of === comparisons, but you can still convert it to a switch construct.
jsswitch (true) {
  case "fetch" in globalThis:
    // Fetch a resource with fetch
    break;
  case "XMLHttpRequest" in globalThis:
    // Fetch a resource with XMLHttpRequest
    break;
  default:
    // Fetch a resource with some custom AJAX logic
    break;
}

The switch (true) pattern as an alternative to if...else is especially useful if you want to utilize the fall-through behavior.
jsswitch (true) {
  case isSquare(shape):
    console.log("This shape is a square.");
  // Fall-through, since a square is a rectangle as well!
  case isRectangle(shape):
    console.log("This shape is a rectangle.");
  case isQuadrilateral(shape):
    console.log("This shape is a quadrilateral.");
    break;
  case isCircle(shape):
    console.log("This shape is a circle.");
    break;
}
SpecificationsSpecificationECMAScript Language Specification # sec-switch-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
if...else
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 12, 2023 by MDN contributors.
throwThe throw statement throws a user-defined exception. Execution of the current function will stop (the statements after throw won't be executed), and control will be passed to the first catch block in the call stack. If no catch block exists among caller functions, the program will terminate.Try itSyntaxjsthrow expression;


expression

The expression to throw.

DescriptionThe throw statement is valid in all contexts where statements can be used. Its execution generates an exception that penetrates through the call stack. For more information on error bubbling and handling, see Control flow and error handling.
The throw keyword can be followed by any kind of expression, for example:
jsthrow error; // Throws a previously defined value (e.g. within a catch block)
throw new Error("Required"); // Throws a new Error object

In practice, the exception you throw should always be an Error object or an instance of an Error subclass, such as RangeError. This is because code that catches the error may expect certain properties, such as message, to be present on the caught value. For example, web APIs typically throw DOMException instances, which inherit from Error.prototype.Automatic semicolon insertionThe syntax forbids line terminators between the throw keyword and the expression to be thrown.
jsthrow
new Error();

The code above is transformed by automatic semicolon insertion (ASI) into:
jsthrow;
new Error();

This is invalid code, because unlike return, throw must be followed by an expression.
To avoid this problem (to prevent ASI), you could use parentheses:
jsthrow (
  new Error()
);
ExamplesThrowing a user-defined errorThis example defines a function that throws a TypeError if the input is not of the expected type.
jsfunction isNumeric(x) {
  return ["number", "bigint"].includes(typeof x);
}

function sum(...values) {
  if (!values.every(isNumeric)) {
    throw new TypeError("Can only add numbers");
  }
  return values.reduce((a, b) => a + b);
}

console.log(sum(1, 2, 3)); // 6
try {
  sum("1", "2");
} catch (e) {
  console.error(e); // TypeError: Can only add numbers
}
Throwing an existing objectThis example calls a callback-based async function, and throws an error if the callback receives an error.
jsreadFile("foo.txt", (err, data) => {
  if (err) {
    throw err;
  }
  console.log(data);
});

Errors thrown this way are not catchable by the caller and will cause the program to crash unless (a) the readFile function itself catches the error, or (b) the program is running in a context that catches top-level errors. You can handle errors more naturally by using the Promise() constructor.
jsfunction readFilePromise(path) {
  return new Promise((resolve, reject) => {
    readFile(path, (err, data) => {
      if (err) {
        reject(err);
      }
      resolve(data);
    });
  });
}

try {
  const data = await readFilePromise("foo.txt");
  console.log(data);
} catch (err) {
  console.error(err);
}
SpecificationsSpecificationECMAScript Language Specification # sec-throw-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
try...catch
Error
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 11, 2023 by MDN contributors.
try...catchThe try...catch statement is comprised of a try block and either a catch block, a finally block, or both. The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. The code in the finally block will always be executed before control flow exits the entire construct.Try itSyntaxjstry {
  tryStatements
} catch (exceptionVar) {
  catchStatements
} finally {
  finallyStatements
}


tryStatements

The statements to be executed.

catchStatements

Statement that is executed if an exception is thrown in the try block.

exceptionVar Optional

An optional identifier or pattern to hold the caught exception for the associated catch block. If the catch block does not use the exception's value, you can omit the exceptionVar and its surrounding parentheses.

finallyStatements

Statements that are executed before control flow exits the try...catch...finally construct. These statements execute regardless of whether an exception was thrown or caught.

DescriptionThe try statement always starts with a try block. Then, a catch block or a finally block must be present. It's also possible to have both catch and finally blocks. This gives us three forms for the try statement:

try...catch
try...finally
try...catch...finally

Unlike other constructs such as if or for, the try, catch, and finally blocks must be blocks, instead of single statements.
jstry doSomething(); // SyntaxError
catch (e) console.log(e);

A catch block contains statements that specify what to do if an exception is thrown in the try block. If any statement within the try block (or in a function called from within the try block) throws an exception, control is immediately shifted to the catch block. If no exception is thrown in the try block, the catch block is skipped.
The finally block will always execute before control flow exits the try...catch...finally construct. It always executes, regardless of whether an exception was thrown or caught.
You can nest one or more try statements. If an inner try statement does not have a catch block, the enclosing try statement's catch block is used instead.
You can also use the try statement to handle JavaScript exceptions. See the JavaScript Guide for more information on JavaScript exceptions.Catch bindingWhen an exception is thrown in the try block, exceptionVar (i.e., the e in catch (e)) holds the exception value. You can use this binding to get information about the exception that was thrown. This binding is only available in the catch block's scope.
It doesn't need to be a single identifier. You can use a destructuring pattern to assign multiple identifiers at once.
jstry {
  throw new TypeError("oops");
} catch ({ name, message }) {
  console.log(name); // "TypeError"
  console.log(message); // "oops"
}

The bindings created by the catch clause live in the same scope as the catch block, so any variables declared in the catch block cannot have the same name as the bindings created by the catch clause. (There's one exception to this rule, but it's a deprecated syntax.)
jstry {
  throw new TypeError("oops");
} catch ({ name, message }) {
  var name; // SyntaxError: Identifier 'name' has already been declared
  let message; // SyntaxError: Identifier 'message' has already been declared
}

The exception binding is writable. For example, you may want to normalize the exception value to make sure it's an Error object.
jstry {
  throw "Oops; this is not an Error object";
} catch (e) {
  if (!(e instanceof Error)) {
    e = new Error(e);
  }
  console.error(e.message);
}

If you don't need the exception value, you can omit it along with the enclosing parentheses.
jsfunction isValidJSON(text) {
  try {
    JSON.parse(text);
    return true;
  } catch {
    return false;
  }
}
The finally blockThe finally block contains statements to execute after the try block and catch block(s) execute, but before the statements following the try...catch...finally block. Control flow will always enter the finally block, which can proceed in one of the following ways:

Immediately after the try block finishes execution normally (and no exceptions were thrown);
Immediately after the catch block finishes execution normally;
Immediately before a control-flow statement (return, throw, break, continue) is executed in the try block or catch block.

If an exception is thrown from the try block, even when there's no catch block to handle the exception, the finally block still executes, in which case the exception is still thrown immediately after the finally block finishes executing.
The following example shows one use case for the finally block. The code opens a file and then executes statements that use the file; the finally block makes sure the file always closes after it is used even if an exception was thrown.
jsopenMyFile();
try {
  // tie up a resource
  writeMyFile(theData);
} finally {
  closeMyFile(); // always close the resource
}

Control flow statements (return, throw, break, continue) in the finally block will "mask" any completion value of the try block or catch block. In this example, the try block tries to return 1, but before returning, the control flow is yielded to the finally block first, so the finally block's return value is returned instead.
jsfunction doIt() {
  try {
    return 1;
  } finally {
    return 2;
  }
}

doIt(); // returns 2

It is generally a bad idea to have control flow statements in the finally block. Only use it for cleanup code.ExamplesUnconditional catch blockWhen a catch block is used, the catch block is executed when any exception is thrown from within the try block. For example, when the exception occurs in the following code, control transfers to the catch block.
jstry {
  throw "myException"; // generates an exception
} catch (e) {
  // statements to handle any exceptions
  logMyErrors(e); // pass exception object to error handler
}

The catch block specifies an identifier (e in the example above) that holds the value of the exception; this value is only available in the scope of the catch block.Conditional catch blocksYou can create "Conditional catch blocks" by combining try...catch blocks with if...else if...else structures, like this:
jstry {
  myroutine(); // may throw three types of exceptions
} catch (e) {
  if (e instanceof TypeError) {
    // statements to handle TypeError exceptions
  } else if (e instanceof RangeError) {
    // statements to handle RangeError exceptions
  } else if (e instanceof EvalError) {
    // statements to handle EvalError exceptions
  } else {
    // statements to handle any unspecified exceptions
    logMyErrors(e); // pass exception object to error handler
  }
}

A common use case for this is to only catch (and silence) a small subset of expected errors, and then re-throw the error in other cases:
jstry {
  myRoutine();
} catch (e) {
  if (e instanceof RangeError) {
    // statements to handle this very common expected error
  } else {
    throw e; // re-throw the error unchanged
  }
}

This may mimic the syntax from other languages, like Java:
javatry {
  myRoutine();
} catch (RangeError e) {
  // statements to handle this very common expected error
}
// Other errors are implicitly re-thrown
Nested try blocksFirst, let's see what happens with this:
jstry {
  try {
    throw new Error("oops");
  } finally {
    console.log("finally");
  }
} catch (ex) {
  console.error("outer", ex.message);
}

// Logs:
// "finally"
// "outer" "oops"

Now, if we already caught the exception in the inner try block by adding a catch block:
jstry {
  try {
    throw new Error("oops");
  } catch (ex) {
    console.error("inner", ex.message);
  } finally {
    console.log("finally");
  }
} catch (ex) {
  console.error("outer", ex.message);
}

// Logs:
// "inner" "oops"
// "finally"

And now, let's rethrow the error.
jstry {
  try {
    throw new Error("oops");
  } catch (ex) {
    console.error("inner", ex.message);
    throw ex;
  } finally {
    console.log("finally");
  }
} catch (ex) {
  console.error("outer", ex.message);
}

// Logs:
// "inner" "oops"
// "finally"
// "outer" "oops"

Any given exception will be caught only once by the nearest enclosing catch block unless it is rethrown. Of course, any new exceptions raised in the "inner" block (because the code in catch block may do something that throws), will be caught by the "outer" block.Returning from a finally blockIf the finally block returns a value, this value becomes the return value of the entire try-catch-finally statement, regardless of any return statements in the try and catch blocks. This includes exceptions thrown inside of the catch block:
js(() => {
  try {
    try {
      throw new Error("oops");
    } catch (ex) {
      console.error("inner", ex.message);
      throw ex;
    } finally {
      console.log("finally");
      return;
    }
  } catch (ex) {
    console.error("outer", ex.message);
  }
})();

// Logs:
// "inner" "oops"
// "finally"

The outer "oops" is not thrown because of the return in the finally block. The same would apply to any value returned from the catch block.SpecificationsSpecificationECMAScript Language Specification # sec-try-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Error
throw
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 31, 2024 by MDN contributors.
varThe var statement declares function-scoped or globally-scoped variables, optionally initializing each to a value.Try itSyntaxjsvar name1;
var name1 = value1;
var name1 = value1, name2 = value2;
var name1, name2 = value2;
var name1 = value1, name2, /* …, */ nameN = valueN;


nameN

The name of the variable to declare. Each must be a legal JavaScript identifier or a destructuring binding pattern.

valueN Optional

Initial value of the variable. It can be any legal expression. Default value is undefined.

DescriptionThe scope of a variable declared with var is one of the following curly-brace-enclosed syntaxes that most closely contains the var statement:

Function body
Static initialization block

Or if none of the above applies:

The current module, for code running in module mode
The global scope, for code running in script mode.

jsfunction foo() {
  var x = 1;
  function bar() {
    var y = 2;
    console.log(x); // 1 (function `bar` closes over `x`)
    console.log(y); // 2 (`y` is in scope)
  }
  bar();
  console.log(x); // 1 (`x` is in scope)
  console.log(y); // ReferenceError, `y` is scoped to `bar`
}

foo();

Importantly, other block constructs, including block statements, try...catch, switch, headers of one of the for statements, do not create scopes for var, and variables declared with var inside such a block can continue to be referenced outside the block.
jsfor (var a of [1, 2, 3]);
console.log(a); // 3

In a script, a variable declared using var is added as a non-configurable property of the global object. This means its property descriptor cannot be changed and it cannot be deleted using delete. JavaScript has automatic memory management, and it would make no sense to be able to use the delete operator on a global variable.
js"use strict";
var x = 1;
Object.hasOwn(globalThis, "x"); // true
delete globalThis.x; // TypeError in strict mode. Fails silently otherwise.
delete x; // SyntaxError in strict mode. Fails silently otherwise.

In both NodeJS CommonJS modules and native ECMAScript modules, top-level variable declarations are scoped to the module, and are not added as properties to the global object.
The list that follows the var keyword is called a binding list and is separated by commas, where the commas are not comma operators and the = signs are not assignment operators. Initializers of later variables can refer to earlier variables in the list and get the initialized value.Hoistingvar declarations, wherever they occur in a script, are processed before any code within the script is executed. Declaring a variable anywhere in the code is equivalent to declaring it at the top. This also means that a variable can appear to be used before it's declared. This behavior is called hoisting, as it appears that the variable declaration is moved to the top of the function, static initialization block, or script source in which it occurs.

Note: var declarations are only hoisted to the top of the current script. If you have two <script> elements within one HTML, the first script cannot access variables declared by the second before the second script has been processed and executed.

jsbla = 2;
var bla;

This is implicitly understood as:
jsvar bla;
bla = 2;

For that reason, it is recommended to always declare variables at the top of their scope (the top of global code and the top of function code) so it's clear which variables are scoped to the current function.
Only a variable's declaration is hoisted, not its initialization. The initialization happens only when the assignment statement is reached. Until then the variable remains undefined (but declared):
jsfunction doSomething() {
  console.log(bar); // undefined
  var bar = 111;
  console.log(bar); // 111
}

This is implicitly understood as:
jsfunction doSomething() {
  var bar;
  console.log(bar); // undefined
  bar = 111;
  console.log(bar); // 111
}
RedeclarationsDuplicate variable declarations using var will not trigger an error, even in strict mode, and the variable will not lose its value, unless the declaration has an initializer.
jsvar a = 1;
var a = 2;
console.log(a); // 2
var a;
console.log(a); // 2; not undefined

var declarations can also be in the same scope as a function declaration. In this case, the var declaration's initializer always overrides the function's value, regardless of their relative position. This is because function declarations are hoisted before any initializer gets evaluated, so the initializer comes later and overrides the value.
jsvar a = 1;
function a() {}
console.log(a); // 1

var declarations cannot be in the same scope as a let, const, class, or import declaration.
jsvar a = 1;
let a = 2; // SyntaxError: Identifier 'a' has already been declared

Because var declarations are not scoped to blocks, this also applies to the following case:
jslet a = 1;
{
  var a = 1; // SyntaxError: Identifier 'a' has already been declared
}

It does not apply to the following case, where let is in a child scope of var, not the same scope:
jsvar a = 1;
{
  let a = 2;
}

A var declaration within a function's body can have the same name as a parameter.
jsfunction foo(a) {
  var a = 1;
  console.log(a);
}

foo(2); // Logs 1

A var declaration within a catch block can have the same name as the catch-bound identifier, but only if the catch binding is a simple identifier, not a destructuring pattern. This is a deprecated syntax and you should not rely on it. In this case, the declaration is hoisted to outside the catch block, but any value assigned within the catch block is not visible outside.
jstry {
  throw 1;
} catch (e) {
  var e = 2; // Works
}
console.log(e); // undefined
ExamplesDeclaring and initializing two variablesjsvar a = 0,
  b = 0;
Assigning two variables with single string valuejsvar a = "A";
var b = a;

This is equivalent to:
jsvar a, b = a = "A";

Be mindful of the order:
jsvar x = y,
  y = "A";
console.log(x, y); // undefined A

Here, x and y are declared before any code is executed, but the assignments occur later. At the time x = y is evaluated, y exists so no ReferenceError is thrown and its value is undefined. So, x is assigned the undefined value. Then, y is assigned the value "A".Initialization of several variablesBe careful of the var x = y = 1 syntax — y is not actually declared as a variable, so y = 1 is an unqualified identifier assignment, which creates a global variable in non-strict mode.
jsvar x = 0;
function f() {
  var x = y = 1; // Declares x locally; declares y globally.
}
f();

console.log(x, y); // 0 1

// In non-strict mode:
// x is the global one as expected;
// y is leaked outside of the function, though!

The same example as above but with a strict mode:
js"use strict";

var x = 0;
function f() {
  var x = y = 1; // ReferenceError: y is not defined
}
f();

console.log(x, y);
Implicit globals and outer function scopeVariables that appear to be implicit globals may be references to variables in an outer function scope:
jsvar x = 0; // Declares x within file scope, then assigns it a value of 0.

console.log(typeof z); // "undefined", since z doesn't exist yet

function a() {
  var y = 2; // Declares y within scope of function a, then assigns it a value of 2.

  console.log(x, y); // 0 2

  function b() {
    x = 3; // Assigns 3 to existing file scoped x.
    y = 4; // Assigns 4 to existing outer y.
    z = 5; // Creates a new global variable z, and assigns it a value of 5.
    // (Throws a ReferenceError in strict mode.)
  }

  b(); // Creates z as a global variable.
  console.log(x, y, z); // 3 4 5
}

a(); // Also calls b.
console.log(x, z); // 3 5
console.log(typeof y); // "undefined", as y is local to function a
Declaration with destructuringThe left-hand side of each = can also be a binding pattern. This allows creating multiple variables at once.
jsconst result = /(a+)(b+)(c+)/.exec("aaabcc");
var [, a, b, c] = result;
console.log(a, b, c); // "aaa" "b" "cc"

For more information, see Destructuring assignment.SpecificationsSpecificationECMAScript Language Specification # sec-variable-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
let
const
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
while
  The while statement creates a loop that executes a specified statement
  as long as the test condition evaluates to true. The condition is evaluated before
  executing the statement.
Try itSyntaxjswhile (condition)
  statement


condition


      An expression evaluated before each pass through the loop. If this condition
      evaluates to true, statement is executed. When condition
      evaluates to false, execution continues with the statement after the
      while loop.
    

statement


      An optional statement that is executed as long as the condition evaluates to true.
      To execute multiple statements within the loop, use a block statement
      ({ /* ... */ }) to group those statements.
    

      Note: Use the break statement to stop a loop before condition evaluates
      to true.
    

ExamplesUsing while
  The following while loop iterates as long as n is less than
  three.

jslet n = 0;
let x = 0;

while (n < 3) {
  n++;
  x += n;
}


  Each iteration, the loop increments n and adds it to x.
  Therefore, x and n take on the following values:


After the first pass: n = 1 and x = 1
After the second pass: n = 2 and x = 3
After the third pass: n = 3 and x = 6


  After completing the third pass, the condition n < 3 is no longer true,
  so the loop terminates.
Using an assignment as a conditionIn some cases, it can make sense to use an assignment as a condition. This comes with readability tradeoffs, so there are certain stylistic recommendations that would make the pattern more obvious for everyone.
Consider the following example, which iterates over a document's comments, logging them to the console.
jsconst iterator = document.createNodeIterator(document, NodeFilter.SHOW_COMMENT);
let currentNode;
while (currentNode = iterator.nextNode()) {
  console.log(currentNode.textContent.trim());
}

That's not completely a good-practice example, due to the following line specifically:
jswhile (currentNode = iterator.nextNode()) {

The effect of that line is fine — in that, each time a comment node is found:

iterator.nextNode() returns that comment node, which gets assigned to currentNode.
The value of currentNode = iterator.nextNode() is therefore truthy.
So the console.log() call executes and the loop continues.

…and then, when there are no more comment nodes in the document:

iterator.nextNode() returns null.
The value of currentNode = iterator.nextNode() is therefore also null, which is falsy.
So the loop ends.

The problem with this line is: conditions typically use comparison operators such as ===, but the = in that line isn't a comparison operator — instead, it's an assignment operator. So that = looks like it's a typo for === — even though it's not actually a typo.
Therefore, in cases like that one, some code-linting tools such as ESLint's no-cond-assign rule — in order to help you catch a possible typo so that you can fix it — will report a warning such as the following:

Expected a conditional expression and instead saw an assignment.

Many style guides recommend more explicitly indicating the intention for the condition to be an assignment. You can do that minimally by putting additional parentheses as a grouping operator around the assignment:
jsconst iterator = document.createNodeIterator(document, NodeFilter.SHOW_COMMENT);
let currentNode;
while ((currentNode = iterator.nextNode())) {
  console.log(currentNode.textContent.trim());
}

In fact, this is the style enforced by ESLint's no-cond-assign's default configuration, as well as Prettier, so you'll likely see this pattern a lot in the wild.
Some people may further recommend adding a comparison operator to turn the condition into an explicit comparison:
jswhile ((currentNode = iterator.nextNode()) !== null) {

There are other ways to write this pattern, such as:
jswhile ((currentNode = iterator.nextNode()) && currentNode) {

Or, forgoing the idea of using a while loop altogether:
jsconst iterator = document.createNodeIterator(document, NodeFilter.SHOW_COMMENT);
for (
  let currentNode = iterator.nextNode();
  currentNode;
  currentNode = iterator.nextNode()
) {
  console.log(currentNode.textContent.trim());
}

If the reader is sufficiently familiar with the assignment as condition pattern, all these variations should have equivalent readability. Otherwise, the last form is probably the most readable, albeit the most verbose.SpecificationsSpecificationECMAScript Language Specification # sec-while-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
do...while
for
break
continue
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 10, 2023 by MDN contributors.
withDeprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note: Use of the with statement is not recommended, as it may be the source of confusing bugs and compatibility issues, makes optimization impossible, and is forbidden in strict mode. The recommended alternative is to assign the object whose properties you want to access to a temporary variable.

The with statement extends the scope chain for a statement.Syntaxjswith (expression)
  statement


expression

Adds the given expression to the scope chain used when evaluating the statement. The parentheses around the expression are required.

statement

Any statement. To execute multiple statements, use a block statement ({ ... }) to group those statements.

DescriptionThere are two types of identifiers: a qualified identifier and an unqualified identifier. An unqualified identifier is one that does not indicate where it comes from.
jsfoo; // unqualified identifier
foo.bar; // bar is a qualified identifier

Normally, an unqualified identifier is resolved by searching the scope chain for a variable with that name, while a qualified identifier is resolved by searching the prototype chain of an object for a property with that name.
jsconst foo = { bar: 1 };
console.log(foo.bar);
// foo is found in the scope chain as a variable;
// bar is found in foo as a property

One exception to this is the global object, which sits on top of the scope chain, and whose properties automatically become global variables that can be referred to without qualifiers.
jsconsole.log(globalThis.Math === Math); // true

The with statement adds the given object to the head of this scope chain during the evaluation of its statement body. Every unqualified name would first be searched within the object (through a in check) before searching in the upper scope chain.
Note that if the unqualified reference refers to a method of the object, the method is called with the object as its this value.
jswith ([1, 2, 3]) {
  console.log(toString()); // 1,2,3
}

The object may have an @@unscopables property, which defines a list of properties that should not be added to the scope chain (for backward compatibility). See the Symbol.unscopables documentation for more information.
The reasons to use a with statement include saving one temporary variable and reducing file size by avoiding repeating a lengthy object reference. However, there are far more reasons why with statements are not desirable:

Performance: The with statement forces the specified object to be searched first for all name lookups. Therefore, all identifiers that aren't members of the specified object will be found more slowly in a with block. Moreover, the optimizer cannot make any assumptions about what each unqualified identifier refers to, so it must repeat the same property lookup every time the identifier is used.
Readability: The with statement makes it hard for a human reader or JavaScript compiler to decide whether an unqualified name will be found along the scope chain, and if so, in which object. For example:
    jsfunction f(x, o) {
  with (o) {
    console.log(x);
  }
}
If you look just at the definition of f, it's impossible to tell what the x in the with body refers to. Only when f is called can x be determined to be o.x or f's first formal parameter. If you forget to define x in the object you pass as the second parameter, you won't get an error — instead you'll just get unexpected results. It's also unclear what the actual intent of such code would be.
  

    Forward compatibility: Code using with may not be forward compatible, especially when used with something other than a plain object, which may gain more properties in the future. Consider this example:
    jsfunction f(foo, values) {
  with (foo) {
    console.log(values);
  }
}
If you call f([1, 2, 3], obj) in an ECMAScript 5 environment, the values reference inside the with statement will resolve to obj. However, ECMAScript 2015 introduces a values property on Array.prototype (so it will be available on every array). So, after upgrading the environment, the values reference inside the with statement resolves to [1, 2, 3].values instead, and is likely to cause bugs.
    In this particular example, values is defined as unscopable through Array.prototype[@@unscopables], so it still correctly resolves to the values parameter. If it were not defined as unscopable, one can see how this would be a difficult issue to debug.
  
ExamplesUsing the with statementThe following with statement specifies that the Math object is the default object. The statements following the with statement refer to the PI property and the cos and sin methods, without specifying an object. JavaScript assumes the Math object for these references.
jslet a, x, y;
const r = 10;

with (Math) {
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
Avoiding the with statement by destructuring properties into the current scopeYou can usually avoid using with through property destructuring. Here we create an extra block to mimic the behavior of with creating an extra scope — but in actual usage, this block can usually be omitted.
jslet a, x, y;
const r = 10;

{
  const { PI, cos, sin } = Math;
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
Avoiding the with statement by using an IIFEIf you're producing an expression that must reuse a long-named reference multiple times, and your goal is to eliminate that lengthy name within your expression, you can wrap the expression in an IIFE and provide the long name as an argument.
jsconst objectHavingAnEspeciallyLengthyName = { foo: true, bar: false };

if (((o) => o.foo && !o.bar)(objectHavingAnEspeciallyLengthyName)) {
  // This branch runs.
}
Creating dynamic namespaces using the with statement and a proxywith will transform every variable lookup to a property lookup, while Proxies allow trapping every property lookup call. You can create a dynamic namespace by combining them.
jsconst namespace = new Proxy(
  {},
  {
    has(target, key) {
      // Avoid trapping global properties like `console`
      if (key in globalThis) {
        return false;
      }
      // Trap all property lookups
      return true;
    },
    get(target, key) {
      return key;
    },
  },
);

with (namespace) {
  console.log(a, b, c); // "a" "b" "c"
}
SpecificationsSpecificationECMAScript Language Specification # sec-with-statementBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
block
Strict mode
Symbol.unscopables
Array.prototype[@@unscopables]
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
FunctionsGenerally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body. Values can be passed to a function as parameters, and the function will return a value.
In JavaScript, functions are first-class objects, because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.
For more examples and explanations, see the JavaScript guide about functions.DescriptionFunction values are typically instances of Function. See Function for information on properties and methods of Function objects. Callable values cause typeof to return "function" instead of "object".

Note: Not all callable values are instanceof Function. For example, the Function.prototype object is callable but not an instance of Function. You can also manually set the prototype chain of your function so it no longer inherits from Function.prototype. However, such cases are extremely rare.
Return valueBy default, if a function's execution doesn't end at a return statement, or if the return keyword doesn't have an expression after it, then the return value is undefined. The return statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

Note: Constructors called with new have a different set of logic to determine their return values.
Passing argumentsParameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:
jsfunction formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);

In this example, the num variable is called the function's parameter: it's declared in the parenthesis-enclosed list of the function's definition. The function expects the num parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the formatNumber(2) call, the number 2 is the function's argument: it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the arguments object.
Arguments are always passed by value and never passed by reference. This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing, which means if the object's properties are mutated, the change will impact the outside of the function. For example:
jsfunction updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota

The this keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.Defining functionsBroadly speaking, JavaScript has four kinds of functions:

Regular function: can return anything; always runs to completion after invocation
Generator function: returns a Generator object; can be paused and resumed with the yield operator
Async function: returns a Promise; can be paused and resumed with the await operator
Async generator function: returns an AsyncGenerator object; both the await and yield operators can be used

For every kind of function, there are three ways to define it:

Declaration

function, function*, async function, async function*

Expression

function, function*, async function, async function*

Constructor

Function(), GeneratorFunction(), AsyncFunction(), AsyncGeneratorFunction()


In addition, there are special syntaxes for defining arrow functions and methods, which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without new), but they also inherit from Function.prototype and have typeof MyClass === "function".
js// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

The Function() constructor, function expression, and function declaration syntaxes create full-fledged function objects, which can be constructed with new. However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.
The function declaration creates functions that are hoisted. Other syntaxes do not hoist the function and the function value is only visible after the definition.
The arrow function and Function() constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.
The arrow function syntax does not have access to arguments or this.
The Function() constructor cannot access any local variables — it only has access to the global scope.
The Function() constructor causes runtime compilation and is often slower than other syntaxes.

For function expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:
jsconst y = function x() {};
console.log(x); // ReferenceError: x is not defined

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.
A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.
A function defined by new Function will dynamically have its source assembled, which is observable when you serialize it. For example, console.log(new Function().toString()) gives:
jsfunction anonymous(
) {

}

This is the actual source used to compile the function. However, although the Function() constructor will create the function with name anonymous, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:
jsnew Function("alert(anonymous);")();

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a Function constructor does not inherit any scope other than the global scope (which all functions inherit).
js// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the Function constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than new Function(...). Therefore the Function constructor should generally be avoided whenever possible.
A function declaration may be unintentionally turned into a function expression when it appears in an expression context.
js// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the function or async function keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).
jsfunction () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'

Instead, start the expression statement with something else, so that the function keyword unambiguously starts a function expression. Common options include grouping and using void.
js(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
Function parametersEach function parameter is a simple identifier that you can access in the local scope.
jsfunction myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}

There are three special parameter syntaxes:

Default parameters allow formal parameters to be initialized with default values if no value or undefined is passed.
The rest parameter allows representing an indefinite number of arguments as an array.
Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

jsfunction myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}

There are some consequences if one of the above non-simple parameter syntaxes is used:

You cannot apply "use strict" to the function body — this causes a syntax error.
Even if the function is not in strict mode, the arguments object stops syncing with the named parameters, and arguments.callee throws an error when accessed.
The arguments objectYou can refer to a function's arguments within the function by using the arguments object.

arguments

An array-like object containing the arguments passed to the currently executing function.

arguments.callee

The currently executing function.

arguments.length

The number of arguments passed to the function.

Getter and setter functionsYou can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes, you can use special syntaxes to define the getter and setter of an accessor property.

get

Binds an object property to a function that will be called when that property is looked up.

set

Binds an object property to a function to be called when there is an attempt to set that property.


Note that these syntaxes create an object property, not a method. The getter and setter functions themselves can only be accessed using reflective APIs such as Object.getOwnPropertyDescriptor().Block-level functionsIn strict mode, functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.
js"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
Block-level functions in non-strict codeIn a word: Don't.
In non-strict code, function declarations inside blocks behave strangely. For example:
jsif (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}

The semantics of this in strict mode are well-specified — zero only ever exists within that scope of the if block. If shouldDefineZero is false, then zero should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the function declaration reference.
A safer way to define functions conditionally is to assign a function expression to a variable:
js// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
ExamplesReturning a formatted numberThe following function returns a string containing the formatted representation of a number padded with leading zeros.
js// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}

The following statements call the padZeros function.
jslet result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
Determining whether a function existsYou can determine whether a function exists by using the typeof operator. In the following example, a test is performed to determine if the window object has a property called noFunc that is a function. If so, it is used; otherwise, some other action is taken.
jsif (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}

Note that in the if test, a reference to noFunc is used — there are no parentheses () after the function name so the actual function is not called.SpecificationsSpecificationECMAScript Language Specification # sec-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Classes
function
function expression
Function
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
Arrow function expressionsAn arrow function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage:

Arrow functions don't have their own bindings to this, arguments, or super, and should not be used as methods.
Arrow functions cannot be used as constructors. Calling them with new throws a TypeError. They also don't have access to the new.target keyword.
Arrow functions cannot use yield within their body and cannot be created as generator functions.
Try itSyntaxjs() => expression

param => expression

(param) => expression

(param1, paramN) => expression

() => {
  statements
}

param => {
  statements
}

(param1, paramN) => {
  statements
}

Rest parameters, default parameters, and destructuring within params are supported, and always require parentheses:
js(a, b, ...r) => expression
(a = 400, b = 20, c) => expression
([a, b] = [10, 20]) => expression
({ a, b } = { a: 10, b: 20 }) => expression

Arrow functions can be async by prefixing the expression with the async keyword.
jsasync param => expression
async (param1, param2, ...paramN) => {
  statements
}
DescriptionLet's decompose a traditional anonymous function down to the simplest arrow function step-by-step. Each step along the way is a valid arrow function.

Note: Traditional function expressions and arrow functions have more differences than their syntax. We will introduce their behavior differences in more detail in the next few subsections.

js// Traditional anonymous function
(function (a) {
  return a + 100;
});

// 1. Remove the word "function" and place arrow between the argument and opening body brace
(a) => {
  return a + 100;
};

// 2. Remove the body braces and word "return" — the return is implied.
(a) => a + 100;

// 3. Remove the parameter parentheses
a => a + 100;

In the example above, both the parentheses around the parameter and the braces around the function body may be omitted. However, they can only be omitted in certain cases.
The parentheses can only be omitted if the function has a single simple parameter. If it has multiple parameters, no parameters, or default, destructured, or rest parameters, the parentheses around the parameter list are required.
js// Traditional anonymous function
(function (a, b) {
  return a + b + 100;
});

// Arrow function
(a, b) => a + b + 100;

const a = 4;
const b = 2;

// Traditional anonymous function (no parameters)
(function () {
  return a + b + 100;
});

// Arrow function (no parameters)
() => a + b + 100;

The braces can only be omitted if the function directly returns an expression. If the body has additional lines of processing, the braces are required — and so is the return keyword. Arrow functions cannot guess what or when you want to return.
js// Traditional anonymous function
(function (a, b) {
  const chuck = 42;
  return a + b + chuck;
});

// Arrow function
(a, b) => {
  const chuck = 42;
  return a + b + chuck;
};

Arrow functions are always unnamed. If the arrow function needs to call itself, use a named function expression instead. You can also assign the arrow function to a variable so it has a name.
js// Traditional Function
function bob(a) {
  return a + 100;
}

// Arrow Function
const bob2 = (a) => a + 100;
Function bodyArrow functions can have either an expression body or the usual block body.
In an expression body, only a single expression is specified, which becomes the implicit return value. In a block body, you must use an explicit return statement.
jsconst func = (x) => x * x;
// expression body syntax, implied "return"

const func2 = (x, y) => {
  return x + y;
};
// with block body, explicit "return" needed

Returning object literals using the expression body syntax (params) => { object: literal } does not work as expected.
jsconst func = () => { foo: 1 };
// Calling func() returns undefined!

const func2 = () => { foo: function () {} };
// SyntaxError: function statement requires a name

const func3 = () => { foo() {} };
// SyntaxError: Unexpected token '{'

This is because JavaScript only sees the arrow function as having an expression body if the token following the arrow is not a left brace, so the code inside braces ({}) is parsed as a sequence of statements, where foo is a label, not a key in an object literal.
To fix this, wrap the object literal in parentheses:
jsconst func = () => ({ foo: 1 });
Cannot be used as methodsArrow function expressions should only be used for non-method functions because they do not have their own this. Let's see what happens when we try to use them as methods:
js"use strict";

const obj = {
  i: 10,
  b: () => console.log(this.i, this),
  c() {
    console.log(this.i, this);
  },
};

obj.b(); // logs undefined, Window { /* … */ } (or the global object)
obj.c(); // logs 10, Object { /* … */ }

Another example involving Object.defineProperty():
js"use strict";

const obj = {
  a: 10,
};

Object.defineProperty(obj, "b", {
  get: () => {
    console.log(this.a, typeof this.a, this); // undefined 'undefined' Window { /* … */ } (or the global object)
    return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'
  },
});

Because a class's body has a this context, arrow functions as class fields close over the class's this context, and the this inside the arrow function's body will correctly point to the instance (or the class itself, for static fields). However, because it is a closure, not the function's own binding, the value of this will not change based on the execution context.
jsclass C {
  a = 1;
  autoBoundMethod = () => {
    console.log(this.a);
  };
}

const c = new C();
c.autoBoundMethod(); // 1
const { autoBoundMethod } = c;
autoBoundMethod(); // 1
// If it were a normal method, it should be undefined in this case

Arrow function properties are often said to be "auto-bound methods", because the equivalent with normal methods is:
jsclass C {
  a = 1;
  constructor() {
    this.method = this.method.bind(this);
  }
  method() {
    console.log(this.a);
  }
}


Note: Class fields are defined on the instance, not on the prototype, so every instance creation would create a new function reference and allocate a new closure, potentially leading to more memory usage than a normal unbound method.

For similar reasons, the call(), apply(), and bind() methods are not useful when called on arrow functions, because arrow functions establish this based on the scope the arrow function is defined within, and the this value does not change based on how the function is invoked.No binding of argumentsArrow functions do not have their own arguments object. Thus, in this example, arguments is a reference to the arguments of the enclosing scope:
jsfunction foo(n) {
  const f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n
  return f();
}

foo(3); // 3 + 3 = 6


Note: You cannot declare a variable called arguments in strict mode, so the code above would be a syntax error. This makes the scoping effect of arguments much easier to comprehend.


  In most cases, using rest parameters
  is a good alternative to using an arguments object.

jsfunction foo(n) {
  const f = (...args) => args[0] + n;
  return f(10);
}

foo(1); // 11
Cannot be used as constructorsArrow functions cannot be used as constructors and will throw an error when called with new. They also do not have a prototype property.
jsconst Foo = () => {};
const foo = new Foo(); // TypeError: Foo is not a constructor
console.log("prototype" in Foo); // false
Cannot be used as generatorsThe yield keyword cannot be used in an arrow function's body (except when used within generator functions further nested within the arrow function). As a consequence, arrow functions cannot be used as generators.Line break before arrowAn arrow function cannot contain a line break between its parameters and its arrow.
jsconst func = (a, b, c)
  => 1;
// SyntaxError: Unexpected token '=>'

For the purpose of formatting, you may put the line break after the arrow or use parentheses/braces around the function body, as shown below. You can also put line breaks between parameters.
jsconst func = (a, b, c) =>
  1;

const func2 = (a, b, c) => (
  1
);

const func3 = (a, b, c) => {
  return 1;
};

const func4 = (
  a,
  b,
  c,
) => 1;
Precedence of arrowAlthough the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with operator precedence compared to regular functions.
jslet callback;

callback = callback || () => {};
// SyntaxError: invalid arrow-function arguments

Because => has a lower precedence than most operators, parentheses are necessary to avoid callback || () being parsed as the arguments list of the arrow function.
jscallback = callback || (() => {});
ExamplesUsing arrow functionsjs// An empty arrow function returns undefined
const empty = () => {};

(() => "foobar")();
// Returns "foobar"
// (this is an Immediately Invoked Function Expression)

const simple = (a) => (a > 15 ? 15 : a);
simple(16); // 15
simple(10); // 10

const max = (a, b) => (a > b ? a : b);

// Easy array filtering, mapping, etc.
const arr = [5, 6, 13, 0, 1, 18, 23];

const sum = arr.reduce((a, b) => a + b);
// 66

const even = arr.filter((v) => v % 2 === 0);
// [6, 0, 18]

const double = arr.map((v) => v * 2);
// [10, 12, 26, 0, 2, 36, 46]

// More concise promise chains
promise
  .then((a) => {
    // …
  })
  .then((b) => {
    // …
  });

// Parameterless arrow functions that are visually easier to parse
setTimeout(() => {
  console.log("I happen sooner");
  setTimeout(() => {
    // deeper code
    console.log("I happen later");
  }, 1);
}, 1);
Using call, bind, and applyThe call(), apply(), and bind() methods work as expected with traditional functions, because we establish the scope for each of the methods:
jsconst obj = {
  num: 100,
};

// Setting "num" on globalThis to show how it is NOT used.
globalThis.num = 42;

// A simple traditional function to operate on "this"
const add = function (a, b, c) {
  return this.num + a + b + c;
};

console.log(add.call(obj, 1, 2, 3)); // 106
console.log(add.apply(obj, [1, 2, 3])); // 106
const boundAdd = add.bind(obj);
console.log(boundAdd(1, 2, 3)); // 106

With arrow functions, since our add function is essentially created on the globalThis (global) scope, it will assume this is the globalThis.
jsconst obj = {
  num: 100,
};

// Setting "num" on globalThis to show how it gets picked up.
globalThis.num = 42;

// Arrow function
const add = (a, b, c) => this.num + a + b + c;

console.log(add.call(obj, 1, 2, 3)); // 48
console.log(add.apply(obj, [1, 2, 3])); // 48
const boundAdd = add.bind(obj);
console.log(boundAdd(1, 2, 3)); // 48

Perhaps the greatest benefit of using arrow functions is with methods like setTimeout() and EventTarget.prototype.addEventListener() that usually require some kind of closure, call(), apply(), or bind() to ensure that the function is executed in the proper scope.
With traditional function expressions, code like this does not work as expected:
jsconst obj = {
  count: 10,
  doSomethingLater() {
    setTimeout(function () {
      // the function executes on the window scope
      this.count++;
      console.log(this.count);
    }, 300);
  },
};

obj.doSomethingLater(); // logs "NaN", because the property "count" is not in the window scope.

With arrow functions, the this scope is more easily preserved:
jsconst obj = {
  count: 10,
  doSomethingLater() {
    // The method syntax binds "this" to the "obj" context.
    setTimeout(() => {
      // Since the arrow function doesn't have its own binding and
      // setTimeout (as a function call) doesn't create a binding
      // itself, the "obj" context of the outer method is used.
      this.count++;
      console.log(this.count);
    }, 300);
  },
};

obj.doSomethingLater(); // logs 11
SpecificationsSpecificationECMAScript Language Specification # sec-arrow-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
function
function expression
ES6 In Depth: Arrow functions on hacks.mozilla.org (2015)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
Default parametersDefault function parameters allow named parameters to be initialized with default values if no value or undefined is passed.Try itSyntaxjsfunction fnName(param1 = defaultValue1, /* …, */ paramN = defaultValueN) {
  // …
}
DescriptionIn JavaScript, function parameters default to undefined. However, it's often useful to set a different default value. This is where default parameters can help.
In the following example, if no value is provided for b when multiply is called, b's value would be undefined when evaluating a * b and multiply would return NaN.
jsfunction multiply(a, b) {
  return a * b;
}

multiply(5, 2); // 10
multiply(5); // NaN !

In the past, the general strategy for setting defaults was to test parameter values in the function body and assign a value if they are undefined. In the following example, b is set to 1 if multiply is called with only one argument:
jsfunction multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

multiply(5, 2); // 10
multiply(5); // 5

With default parameters, checks in the function body are no longer necessary. Now, you can assign 1 as the default value for b in the function head:
jsfunction multiply(a, b = 1) {
  return a * b;
}

multiply(5, 2); // 10
multiply(5); // 5
multiply(5, undefined); // 5

Parameters are still set left-to-right, overwriting default parameters even if there are later parameters without defaults.
jsfunction f(x = 1, y) {
  return [x, y];
}

f(); // [1, undefined]
f(2); // [2, undefined]


Note: The first default parameter and all parameters after it will not contribute to the function's length.

The default parameter initializers live in their own scope, which is a parent of the scope created for the function body.
This means that earlier parameters can be referred to in the initializers of later parameters. However, functions and variables declared in the function body cannot be referred to from default value parameter initializers; attempting to do so throws a run-time ReferenceError. This also includes var-declared variables in the function body.
For example, the following function will throw a ReferenceError when invoked, because the default parameter value does not have access to the child scope of the function body:
jsfunction f(a = go()) {
  function go() {
    return ":P";
  }
}

f(); // ReferenceError: go is not defined

This function will print the value of the parameter a, because the variable var a is hoisted only to the top of the scope created for the function body, not the parent scope created for the parameter list, so its value is not visible to b.
jsfunction f(a, b = () => console.log(a)) {
  var a = 1;
  b();
}

f(); // undefined
f(5); // 5
ExamplesPassing undefined vs. other falsy valuesIn the second call in this example, even if the first argument is set explicitly to undefined (though not null or other falsy values), the value of the num argument is still the default.
jsfunction test(num = 1) {
  console.log(typeof num);
}

test(); // 'number' (num is set to 1)
test(undefined); // 'number' (num is set to 1 too)

// test with other falsy values:
test(""); // 'string' (num is set to '')
test(null); // 'object' (num is set to null)
Evaluated at call timeThe default argument is evaluated at call time. Unlike with Python (for example), a new object is created each time the function is called.
jsfunction append(value, array = []) {
  array.push(value);
  return array;
}

append(1); // [1]
append(2); // [2], not [1, 2]

This even applies to functions and variables:
jsfunction callSomething(thing = something()) {
  return thing;
}

let numberOfTimesCalled = 0;
function something() {
  numberOfTimesCalled += 1;
  return numberOfTimesCalled;
}

callSomething(); // 1
callSomething(); // 2
Earlier parameters are available to later default parametersParameters defined earlier (to the left) are available to later default parameters:
jsfunction greet(name, greeting, message = `${greeting} ${name}`) {
  return [name, greeting, message];
}

greet("David", "Hi"); // ["David", "Hi", "Hi David"]
greet("David", "Hi", "Happy Birthday!"); // ["David", "Hi", "Happy Birthday!"]

This functionality can be approximated like this, which demonstrates how many edge cases are handled:
jsfunction go() {
  return ":P";
}

function withDefaults(
  a,
  b = 5,
  c = b,
  d = go(),
  e = this,
  f = arguments,
  g = this.value,
) {
  return [a, b, c, d, e, f, g];
}

function withoutDefaults(a, b, c, d, e, f, g) {
  switch (arguments.length) {
    case 0:
    case 1:
      b = 5;
    case 2:
      c = b;
    case 3:
      d = go();
    case 4:
      e = this;
    case 5:
      f = arguments;
    case 6:
      g = this.value;
  }
  return [a, b, c, d, e, f, g];
}

withDefaults.call({ value: "=^_^=" });
// [undefined, 5, 5, ":P", {value:"=^_^="}, arguments, "=^_^="]

withoutDefaults.call({ value: "=^_^=" });
// [undefined, 5, 5, ":P", {value:"=^_^="}, arguments, "=^_^="]
Destructured parameter with default value assignmentYou can use default value assignment with the destructuring assignment syntax.
A common way of doing that is to set an empty object/array as the default value for the destructured parameter; for example: [x = 1, y = 2] = []. This makes it possible to pass nothing to the function and still have those values prefilled:
jsfunction preFilledArray([x = 1, y = 2] = []) {
  return x + y;
}

preFilledArray(); // 3
preFilledArray([]); // 3
preFilledArray([2]); // 4
preFilledArray([2, 3]); // 5

// Works the same for objects:
function preFilledObject({ z = 3 } = {}) {
  return z;
}

preFilledObject(); // 3
preFilledObject({}); // 3
preFilledObject({ z: 2 }); // 2
SpecificationsSpecificationECMAScript Language Specification # sec-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
Rest parameters
Nullish coalescing operator (??)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
getThe get syntax binds an object property to a function that will be called when that property is looked up. It can also be used in classes.Try itSyntaxjs{ get prop() { /* … */ } }
{ get [expression]() { /* … */ } }

There are some additional syntax restrictions:

A getter must have exactly zero parameters.
Parameters
prop

The name of the property to bind to the given function. In the same way as other properties in object initializers, it can be a string literal, a number literal, or an identifier.

expression

You can also use expressions for a computed property name to bind to the given function.

DescriptionSometimes it is desirable to allow access to a property that returns a dynamically computed value, or you may want to reflect the status of an internal variable without requiring the use of explicit method calls. In JavaScript, this can be accomplished with the use of a getter.
An object property is either a data property or an accessor property, but it cannot simultaneously be both. Read Object.defineProperty() for more information. The getter syntax allows you to specify the getter function in an object initializer.
jsconst obj = {
  get prop() {
    // getter, the code executed when reading obj.prop
    return someValue;
  },
};

Properties defined using this syntax are own properties of the created object, and they are configurable and enumerable.ExamplesDefining a getter on new objects in object initializers
  This will create a pseudo-property latest for object obj,
  which will return the last array item in log.

jsconst obj = {
  log: ["example", "test"],
  get latest() {
    if (this.log.length === 0) return undefined;
    return this.log[this.log.length - 1];
  },
};
console.log(obj.latest); // "test"

Note that attempting to assign a value to latest will not change it.Using getters in classesYou can use the exact same syntax to define public instance getters that are available on class instances. In classes, you don't need the comma separator between methods.
jsclass ClassWithGetSet {
  #msg = "hello world";
  get msg() {
    return this.#msg;
  }
  set msg(x) {
    this.#msg = `hello ${x}`;
  }
}

const instance = new ClassWithGetSet();
console.log(instance.msg); // "hello world"

instance.msg = "cake";
console.log(instance.msg); // "hello cake"

Getter properties are defined on the prototype property of the class and are thus shared by all instances of the class. Unlike getter properties in object literals, getter properties in classes are not enumerable.
Static getters and private getters use similar syntaxes, which are described in the static and private properties pages.Deleting a getter using the delete operator
  If you want to remove the getter, you can just delete
  it:

jsdelete obj.latest;
Defining a getter on existing objects using defineProperty
  To append a getter to an existing object later at any time, use
  Object.defineProperty().

jsconst o = { a: 0 };

Object.defineProperty(o, "b", {
  get() {
    return this.a + 1;
  },
});

console.log(o.b); // Runs the getter, which yields a + 1 (which is 1)
Using a computed property namejsconst expr = "foo";

const obj = {
  get [expr]() {
    return "bar";
  },
};

console.log(obj.foo); // "bar"
Defining static gettersjsclass MyConstants {
  static get foo() {
    return "foo";
  }
}

console.log(MyConstants.foo); // 'foo'
MyConstants.foo = "bar";
console.log(MyConstants.foo); // 'foo', a static getter's value cannot be changed
Smart / self-overwriting / lazy getters
  Getters give you a way to define a property of an object, but they do not
  calculate the property's value until it is accessed. A getter defers the cost
  of calculating the value until the value is needed. If it is never needed, you never pay
  the cost.


  An additional optimization technique to lazify or delay the calculation of a property
  value and cache it for later access are smart (or memoized) getters.
  The value is calculated the first time the getter is called, and is then cached so
  subsequent accesses return the cached value without recalculating it. This is useful in
  the following situations:



    If the calculation of a property value is expensive (takes much RAM or CPU time,
    spawns worker threads, retrieves remote file, etc.).
  

    If the value isn't needed just now. It will be used later, or in some case it's not
    used at all.
  

    If it's used, it will be accessed several times, and there is no need to
    re-calculate that value will never be changed or shouldn't be re-calculated.
  



Note: This means that you shouldn't write a lazy getter for a property whose value you
    expect to change, because if the getter is lazy then it will not recalculate the
    value.
  

    Note that getters are not "lazy" or "memoized" by nature; you must implement this
    technique if you desire this behavior.
  


  In the following example, the object has a getter as its own property. On getting the
  property, the property is removed from the object and re-added, but implicitly as a data
  property this time. Finally, the value gets returned.

jsconst obj = {
  get notifier() {
    delete this.notifier;
    this.notifier = document.getElementById("bookmarked-notification-anchor");
    return this.notifier;
  },
};
get vs. defineProperty
  While using the get keyword and Object.defineProperty() have
  similar results, there is a subtle difference between the two when used on
  classes.


  When using get the property will be defined on the instance's prototype,
  while using Object.defineProperty() the property will be defined on the
  instance it is applied to.

jsclass Example {
  get hello() {
    return "world";
  }
}

const obj = new Example();
console.log(obj.hello);
// "world"

console.log(Object.getOwnPropertyDescriptor(obj, "hello"));
// undefined

console.log(
  Object.getOwnPropertyDescriptor(Object.getPrototypeOf(obj), "hello"),
);
// { configurable: true, enumerable: false, get: function get hello() { return 'world'; }, set: undefined }
SpecificationsSpecificationECMAScript Language Specification # sec-method-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Working with objects guide
Functions
set
Object.defineProperty()
Object initializer
class
Property accessors
Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments by Jeff Walden (2010)
More SpiderMonkey changes: ancient, esoteric, very rarely used syntax for creating getters and setters is being removed by Jeff Walden (2010)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 15, 2024 by MDN contributors.
Method definitionsMethod definition is a shorter syntax for defining a function property in an object initializer. It can also be used in classes.Try itSyntaxjs({
  property(parameters) {},
  *generator(parameters) {},
  async property(parameters) {},
  async *generator(parameters) {},

  // with computed keys
  [expression](parameters) {},
  *[expression](parameters) {},
  async [expression](parameters) {},
  async *[expression](parameters) {},
})
DescriptionThe shorthand syntax is similar to the getter and setter syntax.
Given the following code:
jsconst obj = {
  foo: function () {
    // …
  },
  bar: function () {
    // …
  },
};

You are now able to shorten this to:
jsconst obj = {
  foo() {
    // …
  },
  bar() {
    // …
  },
};

Properties defined using this syntax are own properties of the created object, and they are configurable, enumerable, and writable, just like normal properties.
function*, async function, and async function* properties all have their respective method syntaxes; see examples below.
However, note that the method syntax is not equivalent to a normal property with a function as its value — there are semantic differences. This makes methods defined in object literals more consistent with methods in classes.Method definitions are not constructableMethods cannot be constructors! They will throw a TypeError if you try to instantiate them. On the other hand, a property created as a function can be used as a constructor.
jsconst obj = {
  method() {},
};
new obj.method(); // TypeError: obj.method is not a constructor
Using super in method definitionsOnly functions defined as methods have access to the super keyword. super.prop looks up the property on the prototype of the object that the method was initialized on.
jsconst obj = {
  __proto__: {
    prop: "foo",
  },
  notAMethod: function () {
    console.log(super.prop); // SyntaxError: 'super' keyword unexpected here
  },
};
ExamplesUsing method definitionsjsconst obj = {
  a: "foo",
  b() {
    return this.a;
  },
};
console.log(obj.b()); // "foo"
Method definitions in classesYou can use the exact same syntax to define public instance methods that are available on class instances. In classes, you don't need the comma separator between methods.
jsclass ClassWithPublicInstanceMethod {
  publicMethod() {
    return "hello world";
  }
  secondPublicMethod() {
    return "goodbye world";
  }
}

const instance = new ClassWithPublicInstanceMethod();
console.log(instance.publicMethod()); // "hello world"

Public instance methods are defined on the prototype property of the class and are thus shared by all instances of the class. They are writable, non-enumerable, and configurable.
Inside instance methods, this and super work like in normal methods. Usually, this refers to the instance itself. In subclasses, super lets you access the prototype of the object that the method is attached to, allowing you to call methods from the superclass.
jsclass BaseClass {
  msg = "hello world";
  basePublicMethod() {
    return this.msg;
  }
}

class SubClass extends BaseClass {
  subPublicMethod() {
    return super.basePublicMethod();
  }
}

const instance = new SubClass();
console.log(instance.subPublicMethod()); // "hello world"

Static methods and private methods use similar syntaxes, which are described in the static and private properties pages.Computed property namesThe method syntax also supports computed property names.
jsconst bar = {
  foo0: function () {
    return 0;
  },
  foo1() {
    return 1;
  },
  ["foo" + 2]() {
    return 2;
  },
};

console.log(bar.foo0()); // 0
console.log(bar.foo1()); // 1
console.log(bar.foo2()); // 2
Generator methodsNote that the asterisk (*) in the generator method syntax must be before the generator property name. (That is, * g(){} will work, but g *(){} will not.)
js// Using a named property
const obj = {
  g: function* () {
    let index = 0;
    while (true) {
      yield index++;
    }
  },
};

// The same object using shorthand syntax
const obj2 = {
  *g() {
    let index = 0;
    while (true) {
      yield index++;
    }
  },
};

const it = obj2.g();
console.log(it.next().value); // 0
console.log(it.next().value); // 1
Async methodsjs// Using a named property
const obj = {
  f: async function () {
    await somePromise;
  },
};

// The same object using shorthand syntax
const obj2 = {
  async f() {
    await somePromise;
  },
};
Async generator methodsjsconst obj = {
  f: async function* () {
    yield 1;
    yield 2;
    yield 3;
  },
};

// The same object using shorthand syntax
const obj2 = {
  async *f() {
    yield 1;
    yield 2;
    yield 3;
  },
};
SpecificationsSpecificationECMAScript Language Specification # sec-method-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Working with objects guide
Functions
get
set
Object initializer
class
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 15, 2024 by MDN contributors.
Rest parametersThe rest parameter syntax allows a function to accept an indefinite number of arguments as an array, providing a way to represent variadic functions in JavaScript.Try itSyntaxjsfunction f(a, b, ...theArgs) {
  // …
}
DescriptionA function definition's last parameter can be prefixed with ... (three U+002E FULL STOP characters), which will cause all remaining (user supplied) parameters to be placed within an Array object.
jsfunction myFun(a, b, ...manyMoreArgs) {
  console.log("a", a);
  console.log("b", b);
  console.log("manyMoreArgs", manyMoreArgs);
}

myFun("one", "two", "three", "four", "five", "six");

// Console Output:
// a, one
// b, two
// manyMoreArgs, ["three", "four", "five", "six"]

A function definition can only have one rest parameter, and the rest parameter must be the last parameter in the function definition.
jsfunction wrong1(...one, ...wrong) {}
function wrong2(...wrong, arg2, arg3) {}

The rest parameter is not counted towards the function's length property.The difference between rest parameters and the arguments objectThere are three main differences between rest parameters and the arguments object:

The arguments object is not a real array, while rest parameters are Array instances, meaning methods like sort(), map(), forEach() or pop() can be applied on it directly.
The arguments object has the additional (deprecated) callee property.
In a non-strict function with simple parameters, the arguments object syncs its indices with the values of parameters. The rest parameter array never updates its value when the named parameters are re-assigned.
The rest parameter bundles all the extra parameters into a single array, but does not contain any named argument defined before the ...restParam. The arguments object contains all of the parameters — including the parameters in the ...restParam array — bundled into one array-like object.
ExamplesUsing rest parametersIn this example, the first argument is mapped to a and the second to b, so these named arguments are used as normal.
However, the third argument, manyMoreArgs, will be an array that contains the third, fourth, fifth, sixth, …, nth — as many arguments as the user specifies.
jsfunction myFun(a, b, ...manyMoreArgs) {
  console.log("a", a);
  console.log("b", b);
  console.log("manyMoreArgs", manyMoreArgs);
}

myFun("one", "two", "three", "four", "five", "six");

// a, "one"
// b, "two"
// manyMoreArgs, ["three", "four", "five", "six"] <-- an array

Below, even though there is just one value, the last argument still gets put into an array.
js// Using the same function definition from example above

myFun("one", "two", "three");

// a, "one"
// b, "two"
// manyMoreArgs, ["three"] <-- an array with just one value

Below, the third argument isn't provided, but manyMoreArgs is still an array (albeit an empty one).
js// Using the same function definition from example above

myFun("one", "two");

// a, "one"
// b, "two"
// manyMoreArgs, [] <-- still an array

Below, only one argument is provided, so b gets the default value undefined, but manyMoreArgs is still an empty array.
js// Using the same function definition from example above

myFun("one");

// a, "one"
// b, undefined
// manyMoreArgs, [] <-- still an array
Argument lengthSince theArgs is an array, a count of its elements is given by the length property. If the function's only parameter is a rest parameter, restParams.length will be equal to arguments.length.
jsfunction fun1(...theArgs) {
  console.log(theArgs.length);
}

fun1(); // 0
fun1(5); // 1
fun1(5, 6, 7); // 3
Using rest parameters in combination with ordinary parametersIn the next example, a rest parameter is used to collect all parameters after the first parameter into an array. Each one of the parameter values collected into the array is then multiplied by the first parameter, and the array is returned:
jsfunction multiply(multiplier, ...theArgs) {
  return theArgs.map((element) => multiplier * element);
}

const arr = multiply(2, 15, 25, 42);
console.log(arr); // [30, 50, 84]
From arguments to an arrayArray methods can be used on rest parameters, but not on the arguments object:
jsfunction sortRestArgs(...theArgs) {
  const sortedArgs = theArgs.sort();
  return sortedArgs;
}

console.log(sortRestArgs(5, 3, 7, 1)); // 1, 3, 5, 7

function sortArguments() {
  const sortedArgs = arguments.sort();
  return sortedArgs; // this will never happen
}

console.log(sortArguments(5, 3, 7, 1));
// throws a TypeError (arguments.sort is not a function)

Rest parameters were introduced to reduce the boilerplate code that was commonly used for converting a set of arguments to an array.
Before rest parameters, arguments need to be converted to a normal array before calling array methods on them:
jsfunction fn(a, b) {
  const normalArray = Array.prototype.slice.call(arguments);
  // — or —
  const normalArray2 = [].slice.call(arguments);
  // — or —
  const normalArrayFrom = Array.from(arguments);

  const first = normalArray.shift(); // OK, gives the first argument
  const firstBad = arguments.shift(); // ERROR (arguments is not a normal array)
}

Now, you can easily gain access to a normal array using a rest parameter:
jsfunction fn(...args) {
  const normalArray = args;
  const first = normalArray.shift(); // OK, gives the first argument
}
SpecificationsSpecificationECMAScript Language Specification # sec-function-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
Spread syntax (...)
Default parameters
arguments
Array
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
setThe set syntax binds an object property to a function to be called when there is an attempt to set that property. It can also be used in classes.Try itSyntaxjs{ set prop(val) { /* … */ } }
{ set [expression](val) { /* … */ } }

There are some additional syntax restrictions:

A setter must have exactly one parameter.
Parameters
prop

The name of the property to bind to the given function. In the same way as other properties in object initializers, it can be a string literal, a number literal, or an identifier.

val


      An alias for the variable that holds the value attempted to be assigned to
      prop.
    

expression

You can also use expressions for a computed property name to bind to the given function.

DescriptionIn JavaScript, a setter can be used to execute a function whenever an attempt is made to change a property's value. Setters are most often used in conjunction with getters.
An object property is either a data property or an accessor property, but it cannot simultaneously be both. Read Object.defineProperty() for more information. The setter syntax allows you to specify the setter function in an object initializer.
jsconst obj = {
  set prop() {
    // setter, the code executed when setting obj.prop
  },
}

Properties defined using this syntax are own properties of the created object, and they are configurable and enumerable.ExamplesDefining a setter on new objects in object initializers
  The following example defines a pseudo-property current of object
  language. When current is assigned a value, it updates
  log with that value:

jsconst language = {
  set current(name) {
    this.log.push(name);
  },
  log: [],
};

language.current = "EN";
console.log(language.log); // ['EN']

language.current = "FA";
console.log(language.log); // ['EN', 'FA']


  Note that current is not defined, and any attempts to access it will
  result in undefined.
Using setters in classesYou can use the exact same syntax to define public instance setters that are available on class instances. In classes, you don't need the comma separator between methods.
jsclass ClassWithGetSet {
  #msg = "hello world";
  get msg() {
    return this.#msg;
  }
  set msg(x) {
    this.#msg = `hello ${x}`;
  }
}

const instance = new ClassWithGetSet();
console.log(instance.msg); // "hello world"

instance.msg = "cake";
console.log(instance.msg); // "hello cake"

Setter properties are defined on the prototype property of the class and are thus shared by all instances of the class. Unlike setter properties in object literals, setter properties in classes are not enumerable.
Static setters and private setters use similar syntaxes, which are described in the static and private properties pages.Removing a setter with the delete operator
  If you want to remove the setter, you can just delete
  it:

jsdelete language.current;
Defining a setter on existing objects using defineProperty
  To append a setter to an existing object, use
  Object.defineProperty().

jsconst o = { a: 0 };

Object.defineProperty(o, "b", {
  set(x) {
    this.a = x / 2;
  },
});

o.b = 10;
// Runs the setter, which assigns 10 / 2 (5) to the 'a' property

console.log(o.a); // 5
Using a computed property namejsconst expr = "foo";

const obj = {
  baz: "bar",
  set [expr](v) {
    this.baz = v;
  },
};

console.log(obj.baz); // "bar"

obj.foo = "baz";
// Run the setter

console.log(obj.baz); // "baz"
SpecificationsSpecificationECMAScript Language Specification # sec-method-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Working with objects guide
Functions
get
Object.defineProperty()
Object initializer
class
Property accessors
Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments by Jeff Walden (2010)
More SpiderMonkey changes: ancient, esoteric, very rarely used syntax for creating getters and setters is being removed by Jeff Walden (2010)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 15, 2024 by MDN contributors.
The arguments objectarguments is an array-like object accessible inside functions that contains the values of the arguments passed to that function.Try itDescription
Note: In modern code, rest parameters should be preferred.

The arguments object is a local variable available within all non-arrow functions. You can refer to a function's arguments inside that function by using its arguments object. It has entries for each argument the function was called with, with the first entry's index at 0.
For example, if a function is passed 3 arguments, you can access them as follows:
jsarguments[0]; // first argument
arguments[1]; // second argument
arguments[2]; // third argument

The arguments object is useful for functions called with more arguments than they are formally declared to accept, called variadic functions, such as Math.min(). This example function accepts any number of string arguments and returns the longest one:
jsfunction longestString() {
  let longest = "";
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i].length > longest.length) {
      longest = arguments[i];
    }
  }
  return longest;
}

You can use arguments.length to count how many arguments the function was called with. If you instead want to count how many parameters a function is declared to accept, inspect that function's length property.Assigning to indicesEach argument index can also be set or reassigned:
jsarguments[1] = "new value";

Non-strict functions that only have simple parameters (that is, no rest, default, or destructured parameters) will sync the new value of parameters with the arguments object, and vice versa:
jsfunction func(a) {
  arguments[0] = 99; // updating arguments[0] also updates a
  console.log(a);
}
func(10); // 99

function func2(a) {
  a = 99; // updating a also updates arguments[0]
  console.log(arguments[0]);
}
func2(10); // 99

Non-strict functions that are passed rest, default, or destructured parameters will not sync new values assigned to parameters in the function body with the arguments object. Instead, the arguments object in non-strict functions with complex parameters will always reflect the values passed to the function when the function was called.
jsfunction funcWithDefault(a = 55) {
  arguments[0] = 99; // updating arguments[0] does not also update a
  console.log(a);
}
funcWithDefault(10); // 10

function funcWithDefault2(a = 55) {
  a = 99; // updating a does not also update arguments[0]
  console.log(arguments[0]);
}
funcWithDefault2(10); // 10

// An untracked default parameter
function funcWithDefault3(a = 55) {
  console.log(arguments[0]);
  console.log(arguments.length);
}
funcWithDefault3(); // undefined; 0

This is the same behavior exhibited by all strict-mode functions, regardless of the type of parameters they are passed. That is, assigning new values to parameters in the body of the function never affects the arguments object, nor will assigning new values to the arguments indices affect the value of parameters, even when the function only has simple parameters.

Note: You cannot write a "use strict"; directive in the body of a function definition that accepts rest, default, or destructured parameters. Doing so will throw a syntax error.
arguments is an array-like objectarguments is an array-like object, which means that arguments has a length property and properties indexed from zero, but it doesn't have Array's built-in methods like forEach() or map(). However, it can be converted to a real Array, using one of slice(), Array.from(), or spread syntax.
jsconst args = Array.prototype.slice.call(arguments);
// or
const args = Array.from(arguments);
// or
const args = [...arguments];

For common use cases, using it as an array-like object is sufficient, since it both is iterable and has length and number indices. For example, Function.prototype.apply() accepts array-like objects.
jsfunction midpoint() {
  return (
    (Math.min.apply(null, arguments) + Math.max.apply(null, arguments)) / 2
  );
}

console.log(midpoint(3, 1, 4, 1, 5)); // 3
Properties
arguments.callee 
Deprecated


Reference to the currently executing function that the arguments belong to. Forbidden in strict mode.

arguments.length

The number of arguments that were passed to the function.

arguments[@@iterator]

Returns a new Array iterator object that contains the values for each index in arguments.

ExamplesDefining a function that concatenates several stringsThis example defines a function that concatenates several strings. The function's only formal argument is a string containing the characters that separate the items to concatenate.
jsfunction myConcat(separator) {
  const args = Array.prototype.slice.call(arguments, 1);
  return args.join(separator);
}

You can pass as many arguments as you like to this function. It returns a string list using each argument in the list:
jsmyConcat(", ", "red", "orange", "blue");
// "red, orange, blue"

myConcat("; ", "elephant", "giraffe", "lion", "cheetah");
// "elephant; giraffe; lion; cheetah"

myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley");
// "sage. basil. oregano. pepper. parsley"
Defining a function that creates HTML listsThis example defines a function that creates a string containing HTML for a list. The only formal argument for the function is a string that is "u" if the list is to be unordered (bulleted), or "o" if the list is to be ordered (numbered). The function is defined as follows:
jsfunction list(type) {
  let html = `<${type}l><li>`;
  const args = Array.prototype.slice.call(arguments, 1);
  html += args.join("</li><li>");
  html += `</li></${type}l>`; // end list
  return html;
}

You can pass any number of arguments to this function, and it adds each argument as a list item to a list of the type indicated. For example:
jslist("u", "One", "Two", "Three");
// "<ul><li>One</li><li>Two</li><li>Three</li></ul>"
Using typeof with argumentsThe typeof operator returns 'object' when used with arguments
jsconsole.log(typeof arguments); // 'object'

The type of individual arguments can be determined by indexing arguments:
jsconsole.log(typeof arguments[0]); // returns the type of the first argument
SpecificationsSpecificationECMAScript Language Specification # sec-arguments-exotic-objectsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Functions guide
Functions
Rest parameters
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 4, 2023 by MDN contributors.
ClassesBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackClasses are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes.
For more examples and explanations, see the Using classes guide.DescriptionDefining classesClasses are in fact "special functions", and just as you can define function expressions and function declarations, a class can be defined in two ways: a class expression or a class declaration.
js// Declaration
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

// Expression; the class is anonymous but assigned to a variable
const Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};

// Expression; the class has its own name
const Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};

Like function expressions, class expressions may be anonymous, or have a name that's different from the variable that it's assigned to. However, unlike function declarations, class declarations have the same temporal dead zone restrictions as let or const and behave as if they are not hoisted.Class bodyThe body of a class is the part that is in curly braces {}. This is where you define class members, such as methods or constructor.
The body of a class is executed in strict mode even without the "use strict" directive.
A class element can be characterized by three aspects:

Kind: Getter, setter, method, or field
Location: Static or instance
Visibility: Public or private

Together, they add up to 16 possible combinations. To divide the reference more logically and avoid overlapping content, the different elements are introduced in detail in different pages:

Method definitions

Public instance method

getter

Public instance getter

setter

Public instance setter

Public class fields

Public instance field

static

Public static method, getter, setter, and field

Private properties

Everything that's private



Note: Private features have the restriction that all property names declared in the same class must be unique. All other public properties do not have this restriction — you can have multiple public properties with the same name, and the last one overwrites the others. This is the same behavior as in object initializers.

In addition, there are two special class element syntaxes: constructor and static initialization blocks, with their own references.
Constructor
The constructor method is a special method for creating and initializing an object created with a class. There can only be one special method with the name "constructor" in a class — a SyntaxError is thrown if the class contains more than one occurrence of a constructor method.
A constructor can use the super keyword to call the constructor of the super class.
You can create instance properties inside the constructor:
jsclass Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

Alternatively, if your instance properties' values do not depend on the constructor's arguments, you can define them as class fields.
Static initialization blocks
Static initialization blocks allow flexible initialization of static properties, including the evaluation of statements during initialization, while granting access to the private scope.
Multiple static blocks can be declared, and these can be interleaved with the declaration of static fields and methods (all static items are evaluated in declaration order).
Methods
Methods are defined on the prototype of each class instance and are shared by all instances. Methods can be plain functions, async functions, generator functions, or async generator functions. For more information, see method definitions.
jsclass Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  // Getter
  get area() {
    return this.calcArea();
  }
  // Method
  calcArea() {
    return this.height * this.width;
  }
  *getSides() {
    yield this.height;
    yield this.width;
    yield this.height;
    yield this.width;
  }
}

const square = new Rectangle(10, 10);

console.log(square.area); // 100
console.log([...square.getSides()]); // [10, 10, 10, 10]

Static methods and fields
The static keyword defines a static method or field for a class. Static properties (fields and methods) are defined on the class itself instead of each instance. Static methods are often used to create utility functions for an application, whereas static fields are useful for caches, fixed-configuration, or any other data that doesn't need to be replicated across instances.
jsclass Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static displayName = "Point";
  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    return Math.hypot(dx, dy);
  }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);
p1.displayName; // undefined
p1.distance; // undefined
p2.displayName; // undefined
p2.distance; // undefined

console.log(Point.displayName); // "Point"
console.log(Point.distance(p1, p2)); // 7.0710678118654755

Field declarations
With the class field declaration syntax, the constructor example can be written as:
jsclass Rectangle {
  height = 0;
  width;
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

Class fields are similar to object properties, not variables, so we don't use keywords such as const to declare them. In JavaScript, private features use a special identifier syntax, so modifier keywords like public and private should not be used either.
As seen above, the fields can be declared with or without a default value. Fields without default values default to undefined. By declaring fields up-front, class definitions become more self-documenting, and the fields are always present, which help with optimizations.
See public class fields for more information.
Private properties
Using private fields, the definition can be refined as below.
jsclass Rectangle {
  #height = 0;
  #width;
  constructor(height, width) {
    this.#height = height;
    this.#width = width;
  }
}


  It's an error to reference private fields from outside of the class; they can only be read or written within the class body.
  By defining things that are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change from version to version.

Private fields can only be declared up-front in a field declaration. They cannot be created later through assigning to them, the way that normal properties can.
For more information, see private properties.InheritanceThe extends keyword is used in class declarations or class expressions to create a class as a child of another constructor (either a class or a function).
jsclass Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }

  speak() {
    console.log(`${this.name} barks.`);
  }
}

const d = new Dog("Mitzie");
d.speak(); // Mitzie barks.

If there is a constructor present in the subclass, it needs to first call super() before using this. The super keyword can also be used to call corresponding methods of super class.
jsclass Cat {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Lion extends Cat {
  speak() {
    super.speak();
    console.log(`${this.name} roars.`);
  }
}

const l = new Lion("Fuzzy");
l.speak();
// Fuzzy makes a noise.
// Fuzzy roars.
Evaluation orderWhen a class declaration or class expression is evaluated, its various components are evaluated in the following order:

The extends clause, if present, is first evaluated. It must evaluate to a valid constructor function or null, or a TypeError is thrown.
The constructor method is extracted, substituted with a default implementation if constructor is not present. However, because the constructor definition is only a method definition, this step is not observable.
The class elements' property keys are evaluated in the order of declaration. If the property key is computed, the computed expression is evaluated, with the this value set to the this value surrounding the class (not the class itself). None of the property values are evaluated yet.
Methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the prototype property of the current class, and static methods and accessors are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later. This step is not observable.
The class is now initialized with the prototype specified by extends and implementation specified by constructor. For all steps above, if an evaluated expression tries to access the name of the class, a ReferenceError is thrown because the class is not initialized yet.
The class elements' values are evaluated in the order of declaration:
    
For each instance field (public or private), its initializer expression is saved. The initializer is evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the super() call returns (for derived classes).
For each static field (public or private), its initializer is evaluated with this set to the class itself, and the property is created on the class.
Static initialization blocks are evaluated with this set to the class itself.


The class is now fully initialized and can be used as a constructor function.

For how instances are created, see the constructor reference.ExamplesBinding this with instance and static methodsWhen a static or instance method is called without a value for this, such as by assigning the method to a variable and then calling it, the this value will be undefined inside the method. This behavior is the same even if the "use strict" directive isn't present, because code within the class body is always executed in strict mode.
jsclass Animal {
  speak() {
    return this;
  }
  static eat() {
    return this;
  }
}

const obj = new Animal();
obj.speak(); // the Animal object
const speak = obj.speak;
speak(); // undefined

Animal.eat(); // class Animal
const eat = Animal.eat;
eat(); // undefined

If we rewrite the above using traditional function-based syntax in non–strict mode, then this method calls are automatically bound to globalThis. In strict mode, the value of this remains as undefined.
jsfunction Animal() {}

Animal.prototype.speak = function () {
  return this;
};

Animal.eat = function () {
  return this;
};

const obj = new Animal();
const speak = obj.speak;
speak(); // global object (in non–strict mode)

const eat = Animal.eat;
eat(); // global object (in non-strict mode)
SpecificationsSpecificationECMAScript Language Specification # sec-class-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Using classes guide
class
class expression
Functions
ES6 In Depth: Classes on hacks.mozilla.org (2015)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 10, 2024 by MDN contributors.
constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackThe constructor method is a special method of a class for creating and initializing an object instance of that class.

Note: This page introduces the constructor syntax. For the constructor property present on all objects, see Object.prototype.constructor.
Try itSyntaxjsconstructor() { /* … */ }
constructor(argument0) { /* … */ }
constructor(argument0, argument1) { /* … */ }
constructor(argument0, argument1, /* …, */ argumentN) { /* … */ }

There are some additional syntax restrictions:

A class method called constructor cannot be a getter, setter, async, or generator.
A class cannot have more than one constructor method.
DescriptionA constructor enables you to provide any custom initialization that must be done before any other methods can be called on an instantiated object.
jsclass Person {
  constructor(name) {
    this.name = name;
  }

  introduce() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const otto = new Person("Otto");

otto.introduce(); // Hello, my name is Otto


  If you don't provide your own constructor, then a default constructor will be supplied for you.
  If your class is a base class, the default constructor is empty:

jsconstructor() {}

If your class is a derived class, the default constructor calls the parent constructor, passing along any arguments that were provided:
jsconstructor(...args) {
  super(...args);
}


Note: The difference between an explicit constructor like the one above and the default constructor is that the latter doesn't actually invoke the array iterator through argument spreading.

That enables code like this to work:
jsclass ValidationError extends Error {
  printCustomerMessage() {
    return `Validation failed :-( (details: ${this.message})`;
  }
}

try {
  throw new ValidationError("Not a valid phone number");
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(error.name); // This is Error instead of ValidationError!
    console.log(error.printCustomerMessage());
  } else {
    console.log("Unknown error", error);
    throw error;
  }
}


  The ValidationError class doesn't need an explicit constructor, because it doesn't need to do any custom initialization.
  The default constructor then takes care of initializing the parent Error from the argument it is given.


  However, if you provide your own constructor, and your class derives from some parent class, then you must explicitly call the parent class constructor using super().
  For example:

jsclass ValidationError extends Error {
  constructor(message) {
    super(message); // call parent class constructor
    this.name = "ValidationError";
    this.code = "42";
  }

  printCustomerMessage() {
    return `Validation failed :-( (details: ${this.message}, code: ${this.code})`;
  }
}

try {
  throw new ValidationError("Not a valid phone number");
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(error.name); // Now this is ValidationError!
    console.log(error.printCustomerMessage());
  } else {
    console.log("Unknown error", error);
    throw error;
  }
}

Using new on a class goes through the following steps:

(If it's a derived class) The constructor body before the super() call is evaluated. This part should not access this because it's not yet initialized.
(If it's a derived class) The super() call is evaluated, which initializes the parent class through the same process.
The current class's fields are initialized.
The constructor body after the super() call (or the entire body, if it's a base class) is evaluated.

Within the constructor body, you can access the object being created through this and access the class that is called with new through new.target. Note that methods (including getters and setters) and the prototype chain are already initialized on this before the constructor is executed, so you can even access methods of the subclass from the constructor of the superclass. However, if those methods use this, the this will not have been fully initialized yet. This means reading public fields of the derived class will result in undefined, while reading private fields will result in a TypeError.
jsnew (class C extends class B {
  constructor() {
    console.log(this.foo());
  }
} {
  #a = 1;
  foo() {
    return this.#a; // TypeError: Cannot read private member #a from an object whose class did not declare it
    // It's not really because the class didn't declare it,
    // but because the private field isn't initialized yet
    // when the superclass constructor is running
  }
})();

The constructor method may have a return value. While the base class may return anything from its constructor, the derived class must return an object or undefined, or a TypeError will be thrown.
jsclass ParentClass {
  constructor() {
    return 1;
  }
}

console.log(new ParentClass()); // ParentClass {}
// The return value is ignored because it's not an object
// This is consistent with function constructors

class ChildClass extends ParentClass {
  constructor() {
    return 1;
  }
}

console.log(new ChildClass()); // TypeError: Derived constructors may only return object or undefined

If the parent class constructor returns an object, that object will be used as the this value on which class fields of the derived class will be defined. This trick is called "return overriding", which allows a derived class's fields (including private ones) to be defined on unrelated objects.
The constructor follows normal method syntax, so parameter default values, rest parameters, etc. can all be used.
jsclass Person {
  constructor(name = "Anonymous") {
    this.name = name;
  }
  introduce() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const person = new Person();
person.introduce(); // Hello, my name is Anonymous

The constructor must be a literal name. Computed properties cannot become constructors.
jsclass Foo {
  // This is a computed property. It will not be picked up as a constructor.
  ["constructor"]() {
    console.log("called");
    this.a = 1;
  }
}

const foo = new Foo(); // No log
console.log(foo); // Foo {}
foo.constructor(); // Logs "called"
console.log(foo); // Foo { a: 1 }

Async methods, generator methods, accessors, and class fields are forbidden from being called constructor. Private names cannot be called #constructor. Any member named constructor must be a plain method.ExamplesUsing the constructorThis code snippet is taken from the classes sample (live demo).
jsclass Square extends Polygon {
  constructor(length) {
    // Here, it calls the parent class' constructor with lengths
    // provided for the Polygon's width and height
    super(length, length);
    // NOTE: In derived classes, `super()` must be called before you
    // can use `this`. Leaving this out will cause a ReferenceError.
    this.name = "Square";
  }

  get area() {
    return this.height * this.width;
  }

  set area(value) {
    this.height = value ** 0.5;
    this.width = value ** 0.5;
  }
}
Calling super in a constructor bound to a different prototypesuper() calls the constructor that's the prototype of the current class. If you change the prototype of the current class itself, super() will call the constructor that's the new prototype. Changing the prototype of the current class's prototype property doesn't affect which constructor super() calls.
jsclass Polygon {
  constructor() {
    this.name = "Polygon";
  }
}

class Rectangle {
  constructor() {
    this.name = "Rectangle";
  }
}

class Square extends Polygon {
  constructor() {
    super();
  }
}

// Make Square extend Rectangle (which is a base class) instead of Polygon
Object.setPrototypeOf(Square, Rectangle);

const newInstance = new Square();

// newInstance is still an instance of Polygon, because we didn't
// change the prototype of Square.prototype, so the prototype chain
// of newInstance is still
//   newInstance --> Square.prototype --> Polygon.prototype
console.log(newInstance instanceof Polygon); // true
console.log(newInstance instanceof Rectangle); // false

// However, because super() calls Rectangle as constructor, the name property
// of newInstance is initialized with the logic in Rectangle
console.log(newInstance.name); // Rectangle
SpecificationsSpecificationECMAScript Language Specification # sec-static-semantics-constructormethodBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Using classes guide
Classes
Static initialization blocks
class
super()
Object.prototype.constructor
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
extendsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackThe extends keyword is used in class declarations or class expressions to create a class that is a child of another class.Try itSyntaxjsclass ChildClass extends ParentClass { /* … */ }


ParentClass

An expression that evaluates to a constructor function (including a class) or null.

DescriptionThe extends keyword can be used to subclass custom classes as well as built-in objects.
Any constructor that can be called with new and has the prototype property can be the candidate for the parent class. The two conditions must both hold — for example, bound functions and Proxy can be constructed, but they don't have a prototype property, so they cannot be subclassed.
jsfunction OldStyleClass() {
  this.someProperty = 1;
}
OldStyleClass.prototype.someMethod = function () {};

class ChildClass extends OldStyleClass {}

class ModernClass {
  someProperty = 1;
  someMethod() {}
}

class AnotherChildClass extends ModernClass {}

The prototype property of the ParentClass must be an Object or null, but you would rarely worry about this in practice, because a non-object prototype doesn't behave as it should anyway. (It's ignored by the new operator.)
jsfunction ParentClass() {}
ParentClass.prototype = 3;

class ChildClass extends ParentClass {}
// Uncaught TypeError: Class extends value does not have valid prototype property 3

console.log(Object.getPrototypeOf(new ParentClass()));
// [Object: null prototype] {}
// Not actually a number!

extends sets the prototype for both ChildClass and ChildClass.prototype.




Prototype of ChildClass
Prototype of ChildClass.prototype




extends clause absent
Function.prototype
Object.prototype


extends null
Function.prototype
null


extends ParentClass
ParentClass
ParentClass.prototype



jsclass ParentClass {}
class ChildClass extends ParentClass {}

// Allows inheritance of static properties
Object.getPrototypeOf(ChildClass) === ParentClass;
// Allows inheritance of instance properties
Object.getPrototypeOf(ChildClass.prototype) === ParentClass.prototype;

The right-hand side of extends does not have to be an identifier. You can use any expression that evaluates to a constructor. This is often useful to create mixins. The this value in the extends expression is the this surrounding the class definition, and referring to the class's name is a ReferenceError because the class is not initialized yet. await and yield work as expected in this expression.
jsclass SomeClass extends class {
  constructor() {
    console.log("Base class");
  }
} {
  constructor() {
    super();
    console.log("Derived class");
  }
}

new SomeClass();
// Base class
// Derived class

While the base class may return anything from its constructor, the derived class must return an object or undefined, or a TypeError will be thrown.
jsclass ParentClass {
  constructor() {
    return 1;
  }
}

console.log(new ParentClass()); // ParentClass {}
// The return value is ignored because it's not an object
// This is consistent with function constructors

class ChildClass extends ParentClass {
  constructor() {
    super();
    return 1;
  }
}

console.log(new ChildClass()); // TypeError: Derived constructors may only return object or undefined

If the parent class constructor returns an object, that object will be used as the this value for the derived class when further initializing class fields. This trick is called "return overriding", which allows a derived class's fields (including private ones) to be defined on unrelated objects.Subclassing built-ins
Warning: The standard committee now holds the position that the built-in subclassing mechanism in previous spec versions is over-engineered and causes non-negligible performance and security impacts. New built-in methods consider less about subclasses, and engine implementers are investigating whether to remove certain subclassing mechanisms. Consider using composition instead of inheritance when enhancing built-ins.

Here are some things you may expect when extending a class:

When calling a static factory method (like Promise.resolve() or Array.from()) on a subclass, the returned instance is always an instance of the subclass.
When calling an instance method that returns a new instance (like Promise.prototype.then() or Array.prototype.map()) on a subclass, the returned instance is always an instance of the subclass.
Instance methods try to delegate to a minimal set of primitive methods where possible. For example, for a subclass of Promise, overriding then() automatically causes the behavior of catch() to change; or for a subclass of Map, overriding set() automatically causes the behavior of the Map() constructor to change.

However, the above expectations take non-trivial efforts to implement properly.

The first one requires the static method to read the value of this to get the constructor for constructing the returned instance. This means [p1, p2, p3].map(Promise.resolve) throws an error because the this inside Promise.resolve is undefined. A way to fix this is to fall back to the base class if this is not a constructor, like Array.from() does, but that still means the base class is special-cased.
The second one requires the instance method to read this.constructor to get the constructor function. However, new this.constructor() may break legacy code, because the constructor property is both writable and configurable and is not protected in any way. Therefore, many copying built-in methods use the constructor's @@species property instead (which by default just returns this, the constructor itself). However, @@species allows running arbitrary code and creating instances of arbitrary type, which poses a security concern and greatly complicates subclassing semantics.
The third one leads to visible invocations of custom code, which makes a lot of optimizations harder to implement. For example, if the Map() constructor is called with an iterable of x elements, then it must visibly invoke the set() method x times, instead of just copying the elements into the internal storage.

These problems are not unique to built-in classes. For your own classes, you will likely have to make the same decisions. However, for built-in classes, optimizability and security are a much bigger concern. New built-in methods always construct the base class and call as few custom methods as possible. If you want to subclass built-ins while achieving the above expectations, you need to override all methods that have the default behavior baked into them. Any addition of new methods on the base class may also break the semantics of your subclass because they are inherited by default. Therefore, a better way to extend built-ins is to use composition.Extending nullextends null was designed to allow easy creation of objects that do not inherit from Object.prototype. However, due to unsettled decisions about whether super() should be called within the constructor, it's not possible to construct such a class in practice using any constructor implementation that doesn't return an object. The TC39 committee is working on re-enabling this feature.
jsnew (class extends null {})();
// TypeError: Super constructor null of anonymous class is not a constructor

new (class extends null {
  constructor() {}
})();
// ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor

new (class extends null {
  constructor() {
    super();
  }
})();
// TypeError: Super constructor null of anonymous class is not a constructor

Instead, you need to explicitly return an instance from the constructor.
jsclass NullClass extends null {
  constructor() {
    // Using new.target allows derived classes to
    // have the correct prototype chain
    return Object.create(new.target.prototype);
  }
}

const proto = Object.getPrototypeOf;
console.log(proto(proto(new NullClass()))); // null
ExamplesUsing extendsThe first example creates a class called Square from a class called Polygon. This example is extracted from this live demo (source).
jsclass Square extends Polygon {
  constructor(length) {
    // Here, it calls the parent class' constructor with lengths
    // provided for the Polygon's width and height
    super(length, length);
    // Note: In derived classes, super() must be called before you
    // can use 'this'. Leaving this out will cause a reference error.
    this.name = "Square";
  }

  get area() {
    return this.height * this.width;
  }
}
Extending plain objectsClasses cannot extend regular (non-constructible) objects. If you want to inherit from a regular object by making all properties of this object available on inherited instances, you can instead use Object.setPrototypeOf():
jsconst Animal = {
  speak() {
    console.log(`${this.name} makes a noise.`);
  },
};

class Dog {
  constructor(name) {
    this.name = name;
  }
}

Object.setPrototypeOf(Dog.prototype, Animal);

const d = new Dog("Mitzie");
d.speak(); // Mitzie makes a noise.
Extending built-in objectsThis example extends the built-in Date object. This example is extracted from this live demo (source).
jsclass MyDate extends Date {
  getFormattedDate() {
    const months = [
      "Jan", "Feb", "Mar", "Apr", "May", "Jun",
      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    ];
    return `${this.getDate()}-${months[this.getMonth()]}-${this.getFullYear()}`;
  }
}
Extending ObjectAll JavaScript objects inherit from Object.prototype by default, so writing extends Object at first glance seems redundant. The only difference from not writing extends at all is that the constructor itself inherits static methods from Object, such as Object.keys(). However, because no Object static method uses the this value, there's still no value in inheriting these static methods.
The Object() constructor special-cases the subclassing scenario. If it's implicitly called via super(), it always initializes a new object with new.target.prototype as its prototype. Any value passed to super() is ignored.
jsclass C extends Object {
  constructor(v) {
    super(v);
  }
}

console.log(new C(1) instanceof Number); // false
console.log(C.keys({ a: 1, b: 2 })); // [ 'a', 'b' ]

Compare this behavior with a custom wrapper that does not special-case subclassing:
jsfunction MyObject(v) {
  return new Object(v);
}
class D extends MyObject {
  constructor(v) {
    super(v);
  }
}
console.log(new D(1) instanceof Number); // true
SpeciesYou might want to return Array objects in your derived array class MyArray. The species pattern lets you override default constructors.
For example, when using methods such as Array.prototype.map() that return the default constructor, you want these methods to return a parent Array object, instead of the MyArray object. The Symbol.species symbol lets you do this:
jsclass MyArray extends Array {
  // Overwrite species to the parent Array constructor
  static get [Symbol.species]() {
    return Array;
  }
}

const a = new MyArray(1, 2, 3);
const mapped = a.map((x) => x * x);

console.log(mapped instanceof MyArray); // false
console.log(mapped instanceof Array); // true

This behavior is implemented by many built-in copying methods. For caveats of this feature, see the subclassing built-ins discussion.Mix-insAbstract subclasses or mix-ins are templates for classes. A class can only have a single superclass, so multiple inheritance from tooling classes, for example, is not possible. The functionality must be provided by the superclass.
A function with a superclass as input and a subclass extending that superclass as output can be used to implement mix-ins:
jsconst calculatorMixin = (Base) =>
  class extends Base {
    calc() {}
  };

const randomizerMixin = (Base) =>
  class extends Base {
    randomize() {}
  };

A class that uses these mix-ins can then be written like this:
jsclass Foo {}
class Bar extends calculatorMixin(randomizerMixin(Foo)) {}
Avoiding inheritanceInheritance is a very strong coupling relationship in object-oriented programming. It means all behaviors of the base class are inherited by the subclass by default, which may not always be what you want. For example, consider the implementation of a ReadOnlyMap:
jsclass ReadOnlyMap extends Map {
  set() {
    throw new TypeError("A read-only map must be set at construction time.");
  }
}

It turns out that ReadOnlyMap is not constructible, because the Map() constructor calls the instance's set() method.
jsconst m = new ReadOnlyMap([["a", 1]]); // TypeError: A read-only map must be set at construction time.

We may get around this by using a private flag to indicate whether the instance is being constructed. However, a more significant problem with this design is that it breaks the Liskov substitution principle, which states that a subclass should be substitutable for its superclass. If a function expects a Map object, it should be able to use a ReadOnlyMap object as well, which will break here.
Inheritance often leads to the circle-ellipse problem, because neither type perfectly entails the behavior of the other, although they share a lot of common traits. In general, unless there's a very good reason to use inheritance, it's better to use composition instead. Composition means that a class has a reference to an object of another class, and only uses that object as an implementation detail.
jsclass ReadOnlyMap {
  #data;
  constructor(values) {
    this.#data = new Map(values);
  }
  get(key) {
    return this.#data.get(key);
  }
  has(key) {
    return this.#data.has(key);
  }
  get size() {
    return this.#data.size;
  }
  *keys() {
    yield* this.#data.keys();
  }
  *values() {
    yield* this.#data.values();
  }
  *entries() {
    yield* this.#data.entries();
  }
  *[Symbol.iterator]() {
    yield* this.#data[Symbol.iterator]();
  }
}

In this case, the ReadOnlyMap class is not a subclass of Map, but it still implements most of the same methods. This means more code duplication, but it also means that the ReadOnlyMap class is not strongly coupled to the Map class, and does not easily break if the Map class is changed, avoiding the semantic issues of built-in subclassing. For example, if the Map class adds an emplace() method that does not call set(), it would cause the ReadOnlyMap class to no longer be read-only unless the latter is updated accordingly to override emplace() as well. Moreover, ReadOnlyMap objects do not have the set method at all, which is more accurate than throwing an error at runtime.SpecificationsSpecificationECMAScript Language Specification # sec-class-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Using classes guide
Classes
constructor
class
super
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Private propertiesPrivate properties are counterparts of the regular class properties which are public, including class fields, class methods, etc. Private properties get created by using a hash # prefix and cannot be legally referenced outside of the class. The privacy encapsulation of these class properties is enforced by JavaScript itself.
Private properties were not native to the language before this syntax existed. In prototypal inheritance, its behavior may be emulated with WeakMap objects or closures, but they can't compare to the # syntax in terms of ergonomics.Syntaxjsclass ClassWithPrivate {
  #privateField;
  #privateFieldWithInitializer = 42;

  #privateMethod() {
    // …
  }

  static #privateStaticField;
  static #privateStaticFieldWithInitializer = 42;

  static #privateStaticMethod() {
    // …
  }
}

There are some additional syntax restrictions:

All private identifiers declared within a class must be unique. The namespace is shared between static and instance properties. The only exception is when the two declarations define a getter-setter pair.
The private identifier cannot be #constructor.
DescriptionMost class properties have their private counterparts:

Private fields
Private methods
Private static fields
Private static methods
Private getters
Private setters
Private static getters
Private static setters

These features are collectively called private properties. However, constructors cannot be private in JavaScript. To prevent classes from being constructed outside of the class, you have to use a private flag.
Private properties are declared with # names (pronounced "hash names"), which are identifiers prefixed with #. The hash prefix is an inherent part of the property name — you can draw relationship with the old underscore prefix convention _privateField — but it's not an ordinary string property, so you can't dynamically access it with the bracket notation.
It is a syntax error to refer to # names from outside of the class. It is also a syntax error to refer to private properties that were not declared in the class body, or to attempt to remove declared properties with delete.
jsclass ClassWithPrivateField {
  #privateField;

  constructor() {;
    delete this.#privateField; // Syntax error
    this.#undeclaredField = 42; // Syntax error
  }
}

const instance = new ClassWithPrivateField();
instance.#privateField; // Syntax error

JavaScript, being a dynamic language, is able to perform this compile-time check because of the special hash identifier syntax, making it different from normal properties on the syntax level.

Note: Code run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

If you access a private property from an object that doesn't have the property, a TypeError is thrown, instead of returning undefined as normal properties do.
jsclass C {
  #x;

  static getX(obj) {
    return obj.#x;
  }
}

console.log(C.getX(new C())); // undefined
console.log(C.getX({})); // TypeError: Cannot read private member #x from an object whose class did not declare it

This example also illustrates that you can access private properties within static functions too, and on externally defined instances of the class.
You can use the in operator to check whether an externally defined object possesses a private property. This will return true if the private field or method exists, and false otherwise.
jsclass C {
  #x;
  constructor(x) {
    this.#x = x;
  }
  static getX(obj) {
    if (#x in obj) return obj.#x;

    return "obj must be an instance of C";
  }
}
console.log(C.getX(new C("foo"))); // "foo"
console.log(C.getX(new C(0.196))); // 0.196
console.log(C.getX(new C(new Date()))); // the current date and time
console.log(C.getX({})); // "obj must be an instance of C"

Note a corollary of private names being always pre-declared and non-deletable: if you found that an object possesses one private property of the current class (either from a try...catch or an in check), it must possess all other private properties. An object possessing the private properties of a class generally means it was constructed by that class (although not always).
Private properties are not part of the prototypical inheritance model since they can only be accessed within the current class's body and aren't inherited by subclasses. Private properties with the same name within different classes are entirely different and do not interoperate with each other. See them as external metadata attached to each instance, managed by the class. For this reason, Object.freeze() and Object.seal() have no effect on private properties.
For more information on how and when private fields are initialized, see public class fields.ExamplesPrivate fieldsPrivate fields include private instance fields and private static fields. Private fields are only accessible from inside the class declaration.
Private instance fields
Like their public counterparts, private instance fields:

are added before the constructor runs in a base class, or immediately after super() is invoked in a subclass, and
are only available on instances of the class.

jsclass ClassWithPrivateField {
  #privateField;

  constructor() {
    this.#privateField = 42;
  }
}

class Subclass extends ClassWithPrivateField {
  #subPrivateField;

  constructor() {
    super();
    this.#subPrivateField = 23;
  }
}

new Subclass(); // In some dev tools, it shows Subclass {#privateField: 42, #subPrivateField: 23}


Note: #privateField from the ClassWithPrivateField base class is private to ClassWithPrivateField and is not accessible from the derived Subclass.

Returning overriding object
A class's constructor can return a different object, which will be used as the new this for the derived class constructor. The derived class may then define private fields on that returned object — meaning it is possible to "stamp" private fields onto unrelated objects.
jsclass Stamper extends class {
  // A base class whose constructor returns the object it's given
  constructor(obj) {
    return obj;
  }
} {
  // This declaration will "stamp" the private field onto the object
  // returned by the base class constructor
  #stamp = 42;
  static getStamp(obj) {
    return obj.#stamp;
  }
}

const obj = {};
new Stamper(obj);
// `Stamper` calls `Base`, which returns `obj`, so `obj` is
// now the `this` value. `Stamper` then defines `#stamp` on `obj`

console.log(obj); // In some dev tools, it shows {#stamp: 42}
console.log(Stamper.getStamp(obj)); // 42
console.log(obj instanceof Stamper); // false

// You cannot stamp private properties twice
new Stamper(obj); // Error: Initializing an object twice is an error with private fields


Warning: This is a potentially very confusing thing to do. You are generally advised to avoid returning anything from the constructor — especially something unrelated to this.

Private static fields
Like their public counterparts, private static fields:

are added to the class constructor at class evaluation time, and
are only available on the class itself.

jsclass ClassWithPrivateStaticField {
  static #privateStaticField = 42;

  static publicStaticMethod() {
    return ClassWithPrivateStaticField.#privateStaticField;
  }
}

console.log(ClassWithPrivateStaticField.publicStaticMethod()); // 42

There is a restriction on private static fields: only the class which defines the private static field can access the field. This can lead to unexpected behavior when using this. In the following example, this refers to the Subclass class (not the ClassWithPrivateStaticField class) when we try to call Subclass.publicStaticMethod(), and so causes a TypeError.
jsclass ClassWithPrivateStaticField {
  static #privateStaticField = 42;

  static publicStaticMethod() {
    return this.#privateStaticField;
  }
}

class Subclass extends ClassWithPrivateStaticField {}

Subclass.publicStaticMethod(); // TypeError: Cannot read private member #privateStaticField from an object whose class did not declare it

This is the same if you call the method with super, because super methods are not called with the super class as this.
jsclass ClassWithPrivateStaticField {
  static #privateStaticField = 42;

  static publicStaticMethod() {
    // When invoked through super, `this` still refers to Subclass
    return this.#privateStaticField;
  }
}

class Subclass extends ClassWithPrivateStaticField {
  static callSuperMethod() {
    return super.publicStaticMethod();
  }
}

Subclass.callSuperMethod(); // TypeError: Cannot read private member #privateStaticField from an object whose class did not declare it

You are advised to always access private static fields through the class name, not through this, so inheritance doesn't break the method.Private methodsPrivate methods include private instance methods and private static methods. Private methods are only accessible from inside the class declaration.
Private instance methods
Unlike their public counterparts, private instance methods:

are installed immediately before the instance fields are installed, and
are only available on instances of the class, not on its .prototype property.

jsclass ClassWithPrivateMethod {
  #privateMethod() {
    return 42;
  }

  publicMethod() {
    return this.#privateMethod();
  }
}

const instance = new ClassWithPrivateMethod();
console.log(instance.publicMethod()); // 42

Private instance methods may be generator, async, or async generator functions. Private getters and setters are also possible, and follow the same syntax requirements as their public getter and setter counterparts.
jsclass ClassWithPrivateAccessor {
  #message;

  get #decoratedMessage() {
    return `🎬${this.#message}🛑`;
  }
  set #decoratedMessage(msg) {
    this.#message = msg;
  }

  constructor() {
    this.#decoratedMessage = "hello world";
    console.log(this.#decoratedMessage);
  }
}

new ClassWithPrivateAccessor(); // 🎬hello world🛑

Unlike public methods, private methods are not accessible on the .prototype property of their class.
jsclass C {
  #method() {}

  static getMethod(x) {
    return x.#method;
  }
}

console.log(C.getMethod(new C())); // [Function: #method]
console.log(C.getMethod(C.prototype)); // TypeError: Receiver must be an instance of class C

Private static methods
Like their public counterparts, private static methods:

are added to the class constructor at class evaluation time, and
are only available on the class itself.

jsclass ClassWithPrivateStaticMethod {
  static #privateStaticMethod() {
    return 42;
  }

  static publicStaticMethod() {
    return ClassWithPrivateStaticMethod.#privateStaticMethod();
  }
}

console.log(ClassWithPrivateStaticMethod.publicStaticMethod()); // 42

Private static methods may be generator, async, and async generator functions.
The same restriction previously mentioned for private static fields holds for private static methods, and similarly can lead to unexpected behavior when using this. In the following example, when we try to call Subclass.publicStaticMethod(), this refers to the Subclass class (not the ClassWithPrivateStaticMethod class) and so causes a TypeError.
jsclass ClassWithPrivateStaticMethod {
  static #privateStaticMethod() {
    return 42;
  }

  static publicStaticMethod() {
    return this.#privateStaticMethod();
  }
}

class Subclass extends ClassWithPrivateStaticMethod {}

console.log(Subclass.publicStaticMethod()); // TypeError: Cannot read private member #privateStaticMethod from an object whose class did not declare it
Simulating private constructorsMany other languages include the capability to mark a constructor as private, which prevents the class from being instantiated outside of the class itself — you can only use static factory methods that create instances, or not be able to create instances at all. JavaScript does not have a native way to do this, but it can be accomplished by using a private static flag.
jsclass PrivateConstructor {
  static #isInternalConstructing = false;

  constructor() {
    if (!PrivateConstructor.#isInternalConstructing) {
      throw new TypeError("PrivateConstructor is not constructable");
    }
    PrivateConstructor.#isInternalConstructing = false;
    // More initialization logic
  }

  static create() {
    PrivateConstructor.#isInternalConstructing = true;
    const instance = new PrivateConstructor();
    return instance;
  }
}

new PrivateConstructor(); // TypeError: PrivateConstructor is not constructable
PrivateConstructor.create(); // PrivateConstructor {}
SpecificationsSpecificationECMAScript Language Specification # prod-PrivateIdentifierECMAScript Language Specification # prod-00OK517SBrowser compatibilityjavascript.classes.private_class_fieldsBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.javascript.classes.private_class_fields_inBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.javascript.classes.private_class_methodsBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Using classes guide
Classes
Public class fields
class
Private Syntax FAQ in the TC39 class-fields proposal
The semantics of all JS class elements by Shu-yu Guo (2018)
Public and private class fields on v8.dev (2018)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 7, 2023 by MDN contributors.
Public class fieldsPublic fields are writable, enumerable, and configurable properties. As such, unlike their private counterparts, they participate in prototype inheritance.Syntaxjsclass ClassWithField {
  instanceField;
  instanceFieldWithInitializer = "instance field";
  static staticField;
  static staticFieldWithInitializer = "static field";
}

There are some additional syntax restrictions:

The name of a static property (field or method) cannot be prototype.
The name of a class field (static or instance) cannot be constructor.
DescriptionThis page introduces public instance fields in detail.

For public static fields, see static.
For private fields, see private properties.
For public methods, see method definitions.
For public accessors, see getter and setter.

Public instance fields exist on every created instance of a class. By declaring a public field, you can ensure the field is always present, and the class definition is more self-documenting.
Public instance fields are added to the instance either at construction time in the base class (before the constructor body runs), or just after super() returns in a subclass. Fields without initializers are initialized to undefined. Like properties, field names may be computed.
jsconst PREFIX = "prefix";

class ClassWithField {
  field;
  fieldWithInitializer = "instance field";
  [`${PREFIX}Field`] = "prefixed field";
}

const instance = new ClassWithField();
console.log(Object.hasOwn(instance, "field")); // true
console.log(instance.field); // undefined
console.log(instance.fieldWithInitializer); // "instance field"
console.log(instance.prefixField); // "prefixed field"

Computed field names are only evaluated once, at class definition time. This means that each class always has a fixed set of field names, and two instances cannot have different field names via computed names. The this value in the computed expression is the this surrounding the class definition, and referring to the class's name is a ReferenceError because the class is not initialized yet. await and yield work as expected in this expression.
jsclass C {
  [Math.random()] = 1;
}

console.log(new C());
console.log(new C());
// Both instances have the same field name

In the field initializer, this refers to the class instance under construction, and super refers to the prototype property of the base class, which contains the base class's instance methods, but not its instance fields.
jsclass Base {
  baseField = "base field";
  anotherBaseField = this.baseField;
  baseMethod() {
    return "base method output";
  }
}

class Derived extends Base {
  subField = super.baseMethod();
}

const base = new Base();
const sub = new Derived();

console.log(base.anotherBaseField); // "base field"

console.log(sub.subField); // "base method output"

The field initializer expression is evaluated each time a new instance is created. (Because the this value is different for each instance, the initializer expression can access instance-specific properties.)
jsclass C {
  obj = {};
}

const instance1 = new C();
const instance2 = new C();
console.log(instance1.obj === instance2.obj); // false

The expression is evaluated synchronously. You cannot use await or yield in the initializer expression. (Think of the initializer expression as being implicitly wrapped in a function.)
Because instance fields of a class are added before the respective constructor runs, you can access the fields' values within the constructor. However, because instance fields of a derived class are defined after super() returns, the base class's constructor does not have access to the derived class's fields.
jsclass Base {
  constructor() {
    console.log("Base constructor:", this.field);
  }
}

class Derived extends Base {
  field = 1;
  constructor() {
    super();
    console.log("Derived constructor:", this.field);
    this.field = 2;
  }
}

const instance = new Derived();
// Base constructor: undefined
// Derived constructor: 1
console.log(instance.field); // 2

Fields are added one-by-one. Field initializers can refer to field values above it, but not below it. All instance and static methods are added beforehand and can be accessed, although calling them may not behave as expected if they refer to fields below the one being initialized.
jsclass C {
  a = 1;
  b = this.c;
  c = this.a + 1;
  d = this.c + 1;
}

const instance = new C();
console.log(instance.d); // 3
console.log(instance.b); // undefined


Note: This is more important with private fields, because accessing a non-initialized private field throws a TypeError, even if the private field is declared below. (If the private field is not declared, it would be an early SyntaxError.)

Because class fields are added using the [[DefineOwnProperty]] semantic (which is essentially Object.defineProperty()), field declarations in derived classes do not invoke setters in the base class. This behavior differs from using this.field = … in the constructor.
jsclass Base {
  set field(val) {
    console.log(val);
  }
}

class DerivedWithField extends Base {
  field = 1;
}

const instance = new DerivedWithField(); // No log

class DerivedWithConstructor extends Base {
  constructor() {
    super();
    this.field = 1;
  }
}

const instance2 = new DerivedWithConstructor(); // Logs 1


Note: Before the class fields specification was finalized with the [[DefineOwnProperty]] semantic, most transpilers, including Babel and tsc, transformed class fields to the DerivedWithConstructor form, which has caused subtle bugs after class fields were standardized.
ExamplesUsing class fieldsClass fields cannot depend on arguments of the constructor, so field initializers usually evaluate to the same value for each instance (unless the same expression can evaluate to different values each time, such as Date.now() or object initializers).
jsclass Person {
  name = nameArg; // nameArg is out of scope of the constructor
  constructor(nameArg) {}
}

jsclass Person {
  // All instances of Person will have the same name
  name = "Dragomir";
}

However, even declaring an empty class field is beneficial, because it indicates the existence of the field, which allows type checkers as well as human readers to statically analyze the shape of the class.
jsclass Person {
  name;
  age;
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

The code above seems repetitive, but consider the case where this is dynamically mutated: the explicit field declaration makes it clear which fields will definitely be present on the instance.
jsclass Person {
  name;
  age;
  constructor(properties) {
    Object.assign(this, properties);
  }
}

Because initializers are evaluated after the base class has executed, you can access properties created by the base class constructor.
jsclass Person {
  name;
  age;
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

class Professor extends Person {
  name = `Professor ${this.name}`;
}

console.log(new Professor("Radev", 54).name); // "Professor Radev"
SpecificationsSpecificationECMAScript Language Specification # prod-FieldDefinitionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Using classes guide
Classes
Private properties
class
The semantics of all JS class elements by Shu-yu Guo (2018)
Public and private class fields on v8.dev (2018)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
staticBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackThe static keyword defines a static method or field for a class, or a static initialization block (see the link for more information about this usage). Static properties cannot be directly accessed on instances of the class. Instead, they're accessed on the class itself.
Static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.

Note: In the context of classes, MDN Web Docs content uses the terms properties and fields interchangeably.
Try itSyntaxjsclass ClassWithStatic {
  static staticField;
  static staticFieldWithInitializer = value;
  static staticMethod() {
    // …
  }
}

There are some additional syntax restrictions:

The name of a static property (field or method) cannot be prototype.
The name of a class field (static or instance) cannot be constructor.
DescriptionThis page introduces public static properties of classes, which include static methods, static accessors, and static fields.

For private static features, see private properties.
For instance features, see methods definitions, getter, setter, and public class fields.

Public static features are declared using the static keyword. They are added to the class constructor at the time of class evaluation using the [[DefineOwnProperty]] semantic (which is essentially Object.defineProperty()). They are accessed again from the class constructor.
Static methods are often utility functions, such as functions to create or clone instances. Public static fields are useful when you want a field to exist only once per class, not on every class instance you create. This is useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.
Static field names can be computed. The this value in the computed expression is the this surrounding the class definition, and referring to the class's name is a ReferenceError because the class is not initialized yet. await and yield work as expected in this expression.
Static fields can have an initializer. Static fields without initializers are initialized to undefined. Public static fields are not reinitialized on subclasses, but can be accessed via the prototype chain.
jsclass ClassWithStaticField {
  static staticField;
  static staticFieldWithInitializer = "static field";
}

class SubclassWithStaticField extends ClassWithStaticField {
  static subStaticField = "subclass field";
}

console.log(Object.hasOwn(ClassWithStaticField, "staticField")); // true
console.log(ClassWithStaticField.staticField); // undefined
console.log(ClassWithStaticField.staticFieldWithInitializer); // "static field"
console.log(SubclassWithStaticField.staticFieldWithInitializer); // "static field"
console.log(SubclassWithStaticField.subStaticField); // "subclass field"

In the field initializer, this refers to the current class (which you can also access through its name), and super refers to the base class constructor.
jsclass ClassWithStaticField {
  static baseStaticField = "base static field";
  static anotherBaseStaticField = this.baseStaticField;

  static baseStaticMethod() {
    return "base static method output";
  }
}

class SubClassWithStaticField extends ClassWithStaticField {
  static subStaticField = super.baseStaticMethod();
}

console.log(ClassWithStaticField.anotherBaseStaticField); // "base static field"
console.log(SubClassWithStaticField.subStaticField); // "base static method output"

The expression is evaluated synchronously. You cannot use await or yield in the initializer expression. (Think of the initializer expression as being implicitly wrapped in a function.)
Static field initializers and static initialization blocks are evaluated one-by-one. Field initializers can refer to field values above it, but not below it. All static methods are added beforehand and can be accessed, although calling them may not behave as expected if they refer to fields below the one being initialized.

Note: This is more important with private static fields, because accessing a non-initialized private field throws a TypeError, even if the private field is declared below. (If the private field is not declared, it would be an early SyntaxError.)
ExamplesUsing static members in classesThe following example demonstrates several things:

How a static member (method or property) is defined on a class.
That a class with a static member can be sub-classed.
How a static member can and cannot be called.

jsclass Triple {
  static customName = "Tripler";
  static description = "I triple any number you provide";
  static calculate(n = 1) {
    return n * 3;
  }
}

class SquaredTriple extends Triple {
  static longDescription;
  static description = "I square the triple of any number you provide";
  static calculate(n) {
    return super.calculate(n) * super.calculate(n);
  }
}

console.log(Triple.description); // 'I triple any number you provide'
console.log(Triple.calculate()); // 3
console.log(Triple.calculate(6)); // 18

const tp = new Triple();

console.log(SquaredTriple.calculate(3)); // 81 (not affected by parent's instantiation)
console.log(SquaredTriple.description); // 'I square the triple of any number you provide'
console.log(SquaredTriple.longDescription); // undefined
console.log(SquaredTriple.customName); // 'Tripler'

// This throws because calculate() is a static member, not an instance member.
console.log(tp.calculate()); // 'tp.calculate is not a function'
Calling static members from another static methodIn order to call a static method or property within another static method of the same class, you can use the this keyword.
jsclass StaticMethodCall {
  static staticProperty = "static property";
  static staticMethod() {
    return `Static method and ${this.staticProperty} has been called`;
  }
  static anotherStaticMethod() {
    return `${this.staticMethod()} from another static method`;
  }
}
StaticMethodCall.staticMethod();
// 'Static method and static property has been called'

StaticMethodCall.anotherStaticMethod();
// 'Static method and static property has been called from another static method'
Calling static members from a class constructor and other methods
  Static members are not directly accessible using the this keyword from
  non-static methods. You need to call them using the class name:
  CLASSNAME.STATIC_METHOD_NAME() /
  CLASSNAME.STATIC_PROPERTY_NAME or by calling the method as a property of
  the constructor: this.constructor.STATIC_METHOD_NAME() /
  this.constructor.STATIC_PROPERTY_NAME

jsclass StaticMethodCall {
  constructor() {
    console.log(StaticMethodCall.staticProperty); // 'static property'
    console.log(this.constructor.staticProperty); // 'static property'
    console.log(StaticMethodCall.staticMethod()); // 'static method has been called.'
    console.log(this.constructor.staticMethod()); // 'static method has been called.'
  }

  static staticProperty = "static property";
  static staticMethod() {
    return "static method has been called.";
  }
}
SpecificationsSpecificationECMAScript Language Specification # sec-class-definitionsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Using classes guide
Classes
Static initialization blocks
class
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Static initialization blocksStatic initialization blocks are declared within a class. It contains statements to be evaluated during class initialization. This permits more flexible initialization logic than static properties, such as using try...catch or setting multiple fields from a single value. Initialization is performed in the context of the current class declaration, with access to private state, which allows the class to share information of its private properties with other classes or functions declared in the same scope (analogous to "friend" classes in C++).Try itSyntaxjsclass ClassWithSIB {
  static {
    // …
  }
}
DescriptionWithout static initialization blocks, complex static initialization might be achieved by calling a static method after the class declaration:
jsclass MyClass {
  static init() {
    // Access to private static fields is allowed here
  }
}

MyClass.init();

However, this approach exposes an implementation detail (the init() method) to the user of the class. On the other hand, any initialization logic declared outside the class does not have access to private static fields. Static initialization blocks allow arbitrary initialization logic to be declared within the class and executed during class evaluation.

  A class can have any number of static {} initialization blocks in its class body.
  These are evaluated, along with any interleaved static field initializers, in the order they are declared.
  Any static initialization of a super class is performed first, before that of its sub classes.

The scope of the variables declared inside the static block is local to the block. This includes var, function, const, and let declarations. var declarations in the block are not hoisted.
jsvar y = "Outer y";

class A {
  static field = "Inner y";
  static {
    var y = this.field;
  }
}

// var defined in static block is not hoisted
console.log(y); // 'Outer y'


  The this inside a static block refers to the constructor object of the class.
  super.property can be used to access static properties of the super class.
  Note however that it is a syntax error to call super() in a class static initialization block, or to use the arguments object.

The statements are evaluated synchronously. You cannot use await or yield in this block. (Think of the initialization statements as being implicitly wrapped in a function.)
The scope of the static block is nested within the lexical scope of the class body, and can access private names declared within the class without causing a syntax error.
Static field initializers and static initialization blocks are evaluated one-by-one. The initialization block can refer to field values above it, but not below it. All static methods are added beforehand and can be accessed, although calling them may not behave as expected if they refer to fields below the current block.

Note: This is more important with private static fields, because accessing a non-initialized private field throws a TypeError, even if the private field is declared below. (If the private field is not declared, it would be an early SyntaxError.)

A static initialization block may not have decorators (the class itself may).ExamplesMultiple blocks
  The code below demonstrates a class with static initialization blocks and interleaved static field initializers.
  The output shows that the blocks and fields are evaluated in execution order.

jsclass MyClass {
  static field1 = console.log("static field1");
  static {
    console.log("static block1");
  }
  static field2 = console.log("static field2");
  static {
    console.log("static block2");
  }
}
// 'static field1'
// 'static block1'
// 'static field2'
// 'static block2'

Note that any static initialization of a super class is performed first, before that of its sub classes.Using this and super
  The this inside a static block refers to the constructor object of the class.
  This code shows how to access a public static field.

jsclass A {
  static field = "static field";
  static {
    console.log(this.field);
  }
}
// 'static field'

The super.property syntax can be used inside a static block to reference static properties of a super class.
jsclass A {
  static field = "static field";
}

class B extends A {
  static {
    console.log(super.field);
  }
}
// 'static field'
Access to private propertiesThis example below shows how access can be granted to a private instance field of a class from an object outside the class (example from the v8.dev blog):
jslet getDPrivateField;

class D {
  #privateField;
  constructor(v) {
    this.#privateField = v;
  }
  static {
    getDPrivateField = (d) => d.#privateField;
  }
}

console.log(getDPrivateField(new D("private"))); // 'private'
SpecificationsSpecificationECMAScript Language Specification # prod-ClassStaticBlockBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Using classes guide
Classes
static
class
Class static initialization blocks on v8.dev (2021)
ES2022 feature: class static initialization blocks by Dr. Axel Rauschmayer (2021)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Regular expressionsA regular expression (regex for short) allow developers to match strings against a pattern, extract submatch information, or simply test if the string conforms to that pattern. Regular expressions are used in many programming languages, and JavaScript's syntax is inspired by Perl.
You are encouraged to read the regular expressions guide to get an overview of the available regex syntaxes and how they work.DescriptionRegular expressions are a important concept in formal language theory. They are a way to describe a possibly infinite set of character strings (called a language). A regular expression, at its core, needs the following features:

A set of characters that can be used in the language, called the alphabet.
Concatenation: ab means "the character a followed by the character b".
Union: a|b means "either a or b".
Kleene star: a* means "zero or more a characters".

Assuming a finite alphabet (such as the 26 letters of the English alphabet, or the entire Unicode character set), all regular languages can be generated by the features above. Of course, many patterns are very tedious to express this way (such as "10 digits" or "a character that's not a space"), so JavaScript regular expressions include many shorthands, introduced below.

Note: JavaScript regular expressions are in fact not regular, due to the existence of backreferences (regular expressions must have finite states). However, they are still a very useful feature.
Creating regular expressionsA regular expression is typically created as a literal by enclosing a pattern in forward slashes (/):
jsconst regex1 = /ab+c/g;

Regular expressions can also be created with the RegExp() constructor:
jsconst regex2 = new RegExp("ab+c", "g");

They have no runtime differences, although they may have implications on performance, static analyzability, and authoring ergonomic issues with escaping characters. For more information, see the RegExp reference.Regex flagsFlags are special parameters that can change the way a regular expression is interpreted or the way it interacts with the input text. Each flag corresponds to one accessor property on the RegExp object.



Flag
Description
Corresponding property




d
Generate indices for substring matches.
hasIndices


g
Global search.
global


i
Case-insensitive search.
ignoreCase


m
Allows ^ and $ to match next to newline characters.
multiline


s
Allows . to match newline characters.
dotAll


u
"Unicode"; treat a pattern as a sequence of Unicode code points.
unicode


v
An upgrade to the u mode with more Unicode features.
unicodeSets


y
Perform a "sticky" search that matches starting at the current position in the target string.
sticky



The sections below list all available regex syntaxes, grouped by their syntactic nature.AssertionsAssertions are constructs that test whether the string meets a certain condition at the specified position, but not consume characters. Assertions cannot be quantified.

Input boundary assertion: ^, $

Asserts that the current position is the start or end of input, or start or end of a line if the m flag is set.

Lookahead assertion: (?=...), (?!...)

Asserts that the current position is followed or not followed by a certain pattern.

Lookbehind assertion: (?<=...), (?<!...)

Asserts that the current position is preceded or not preceded by a certain pattern.

Word boundary assertion: \b, \B

Asserts that the current position is a word boundary.

AtomsAtoms are the most basic units of a regular expression. Each atom consumes one or more characters in the string, and either fails the match or allows the pattern to continue matching with the next atom.

Backreference: \1, \2

Matches a previously matched subpattern captured with a capturing group.

Capturing group: (...)

Matches a subpattern and remembers information about the match.

Character class: [...], [^...]

Matches any character in or not in a set of characters. When the v flag is enabled, it can also be used to match finite-length strings.

Character class escape: \d, \D, \w, \W, \s, \S

Matches any character in or not in a predefined set of characters.

Character escape: \n, \u{...}

Matches a character that may not be able to be conveniently represented in its literal form.

Literal character: a, b

Matches a specific character.

Named backreference: \k<name>

Matches a previously matched subpattern captured with a named capturing group.

Named capturing group: (?<name>...)

Matches a subpattern and remembers information about the match. The group can later be identified by a custom name instead of by its index in the pattern.

Non-capturing group: (?:...)

Matches a subpattern without remembering information about the match.

Unicode character class escape: \p{...}, \P{...}

Matches a set of characters specified by a Unicode property. When the v flag is enabled, it can also be used to match finite-length strings.

Wildcard: .

Matches any character except line terminators, unless the s flag is set.

Other featuresThese features do not specify any pattern themselves, but are used to compose patterns.

Disjunction: |

Matches any of a set of alternatives separated by the | character.

Quantifier: *, +, ?, {n}, {n,}, {n,m}

Matches an atom a certain number of times.

Escape sequencesEscape sequences in regexes refer to any kind of syntax formed by \ followed by one or more characters. They may serve very different purposes depending on what follow \. Below is a list of all valid "escape sequences":



Escape sequence
Followed by
Meaning




\B
None
Non-word-boundary assertion


\D
None
Character class escape representing non-digit characters


\P
{, a Unicode property and/or value, then }
Unicode character class escape representing characters without the specified Unicode property


\S
None
Character class escape representing non-white-space characters


\W
None
Character class escape representing non-word characters


\b
None
Word boundary assertion; inside character classes, represents U+0008 (BACKSPACE)


\c
A letter from A to Z or a to z
A character escape representing the control character with value equal to the letter's character value modulo 32


\d
None
Character class escape representing digit characters (0 to 9)


\f
None
Character escape representing U+000C (FORM FEED)


\k
<, an identifier, then >
A named backreference


\n
None
Character escape representing U+000A (LINE FEED)


\p
{, a Unicode property and/or value, then }
Unicode character class escape representing characters with the specified Unicode property


\q
{, a string, then a }
Only valid inside v-mode character classes; represents the string to be matched literally


\r
None
Character escape representing U+000D (CARRIAGE RETURN)


\s
None
Character class escape representing whitespace characters


\t
None
Character escape representing U+0009 (CHARACTER TABULATION)


\u
4 hexadecimal digits; or {, 1 to 6 hexadecimal digits, then }
Character escape representing the character with the given code point


\v
None
Character escape representing U+000B (LINE TABULATION)


\w
None
Character class escape representing word characters (A to Z, a to z, 0 to 9, _)


\x
2 hexadecimal digits
Character escape representing the character with the given value


\0
None
Character escape representing U+0000 (NULL)



\ followed by any other digit character becomes a legacy octal escape sequence, which is forbidden in Unicode-aware mode.
In addition, \ can be followed by some non-letter-or-digit characters, in which case the escape sequence is always a character escape representing the escaped character itself:

\$, \(, \), \*, \+, \., \/, \?, \[, \\, \], \^, {, \|, }: valid everywhere
\-: only valid inside character classes
\!, \#, \%, \&, \,, \:, \;, \<, \=, \>, \@, \`, \~: only valid inside v-mode character classes

The other ASCII characters, namely space character, ", ', _, and any letter character not mentioned above, are not valid escape sequences. In Unicode-unaware mode, escape sequences that are not one of the above become identity escapes: they represent the character that follows the backslash. For example, \a represents the character a. This behavior limits the ability to introduce new escape sequences without causing backward compatibility issues, and is therefore forbidden in Unicode-aware mode.SpecificationsSpecificationECMAScript Language Specification # prod-DecimalEscapeECMAScript Language Specification # prod-AtomECMAScript Language Specification # prod-CharacterClassECMAScript Language Specification # prod-CharacterClassEscapeECMAScript Language Specification # prod-CharacterEscapeECMAScript Language Specification # prod-DisjunctionECMAScript Language Specification # prod-AssertionECMAScript Language Specification # prod-PatternCharacterECMAScript Language Specification # prod-AtomEscapeECMAScript Language Specification # prod-QuantifierBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Regular expressions guide
RegExp
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 2, 2024 by MDN contributors.
Backreference: \1, \2A backreference refers to the submatch of a previous capturing group and matches the same text as that group. For named capturing groups, you may prefer to use the named backreference syntax.Syntaxregex\N


Note: N is not a literal character.
Parameters
N

A positive integer referring to the number of a capturing group.

DescriptionA backreference is a way to match the same text as previously matched by a capturing group. Capturing groups count from 1, so the first capturing group's result can be referenced with \1, the second with \2, and so on. \0 is a character escape for the NUL character.
In case-insensitive matching, the backreference may match text with different casing from the original text.
js/(b)\1/i.test("bB"); // true

The backreference must refer to an existent capturing group. If the number it specifies is greater than the total number of capturing groups, a syntax error is thrown.
js/(a)\2/u; // SyntaxError: Invalid regular expression: Invalid escape

In Unicode-unaware mode, invalid backreferences become a legacy octal escape sequence. This is a deprecated syntax for web compatibility, and you should not rely on it.
js/(a)\2/.test("a\x02"); // true

If the referenced capturing group is unmatched (for example, because it belongs to an unmatched alternative in a disjunction), or the group hasn't matched yet (for example, because it lies to the right of the backreference), the backreference always succeeds (as if it matches the empty string).
js/(?:a|(b))\1c/.test("ac"); // true
/\1(a)/.test("a"); // true
ExamplesPairing quotesThe following function matches the title='xxx' and title="xxx" patterns in a string. To ensure the quotes match, we use a backreference to refer to the first quote. Accessing the second capturing group ([2]) returns the string between the matching quote characters:
jsfunction parseTitle(metastring) {
  return metastring.match(/title=(["'])(.*?)\1/)[2];
}

parseTitle('title="foo"'); // 'foo'
parseTitle("title='foo' lang='en'"); // 'foo'
parseTitle('title="Named capturing groups\' advantages"'); // "Named capturing groups' advantages"
Matching duplicate wordsThe following function finds duplicate words in a string (which are usually typos). Note that it uses the \w character class escape, which only matches English letters but not any accented letters or other alphabets. If you want more generic matching, you may want to split the string by whitespace and iterate over the resulting array.
jsfunction findDuplicates(text) {
  return text.match(/\b(\w+)\s+\1\b/i)?.[1];
}

findDuplicates("foo foo bar"); // 'foo'
findDuplicates("foo bar foo"); // undefined
findDuplicates("Hello hello"); // 'Hello'
findDuplicates("Hello hellos"); // undefined
SpecificationsSpecificationECMAScript Language Specification # prod-DecimalEscapeBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Groups and backreferences guide
Regular expressions
Capturing group: (...)
Named capturing group: (?<name>...)
Named backreference: \k<name>
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Capturing group: (...)A capturing group groups a subpattern, allowing you to apply a quantifier to the entire group or use disjunctions within it. It memorizes information about the subpattern match, so that you can refer back to it later with a backreference, or access the information through the match results.
If you don't need the result of the subpattern match, use a non-capturing group instead, which improves performance and avoids refactoring hazards.Syntaxregex(pattern)
Parameters
pattern

A pattern consisting of anything you may use in a regex literal, including a disjunction.

DescriptionA capturing group acts like the grouping operator in JavaScript expressions, allowing you to use a subpattern as a single atom.
Capturing groups are numbered by the order of their opening parentheses. The first capturing group is numbered 1, the second 2, and so on. Named capturing groups are also capturing groups and are numbered together with other (unnamed) capturing groups. The information of the capturing group's match can be accessed through:

The return value (which is an array) of RegExp.prototype.exec(), String.prototype.match(), and String.prototype.matchAll()
The pN parameters of the String.prototype.replace() and String.prototype.replaceAll() methods' replacement callback function
Backreferences within the same pattern


Note: Even in exec()'s result array, capturing groups are accessed by numbers 1, 2, etc., because the 0 element is the entire match. \0 is not a backreference, but a character escape for the NUL character.

Capturing groups in the regex source code correspond to their results one-to-one. If a capturing group is not matched (for example, it belongs to an unmatched alternative in a disjunction), the corresponding result is undefined.
js/(ab)|(cd)/.exec("cd"); // ['cd', undefined, 'cd']

Capturing groups can be quantified. In this case, the match information corresponding to this group is the last match of the group.
js/([ab])+/.exec("abc"); // ['ab', 'b']; because "b" comes after "a", this result overwrites the previous one

Capturing groups can be used in lookahead and lookbehind assertions. Because lookbehind assertions match their atoms backwards, the final match corresponding to this group is the one that appears to the left end of the string. However, the indices of the match groups still correspond to their relative locations in the regex source.
js/c(?=(ab))/.exec("cab"); // ['c', 'ab']
/(?<=(a)(b))c/.exec("abc"); // ['c', 'a', 'b']
/(?<=([ab])+)c/.exec("abc"); // ['c', 'a']; because "a" is seen by the lookbehind after the lookbehind has seen "b"

Capturing groups can be nested, in which case the outer group is numbered first, then the inner group, because they are ordered by their opening parentheses. If a nested group is repeated by a quantifier, then each time the group matches, the subgroups' results are all overwritten, sometimes with undefined.
js/((a+)?(b+)?(c))*/.exec("aacbbbcac"); // ['aacbbbcac', 'ac', 'a', undefined, 'c']

In the example above, the outer group is matched three times:

Matches "aac", with subgroups "aa", undefined, and "c".
Matches "bbbc", with subgroups undefined, "bbb", and "c".
Matches "ac", with subgroups "a", undefined, and "c".

The "bbb" result from the second match is not preserved, because the third match overwrites it with undefined.
You can get the start and end indices of each capturing group in the input string by using the d flag. This creates an extra indices property on the array returned by exec().
You can optionally specify a name to a capturing group, which helps avoid pitfalls related to group positions and indexing. See Named capturing groups for more information.
Parentheses have other purposes in different regex syntaxes. For example, they also enclose lookahead and lookbehind assertions. Because these syntaxes all start with ?, and ? is a quantifier which normally cannot occur directly after (, this does not lead to ambiguities.ExamplesMatching dateThe following example matches a date in the format YYYY-MM-DD:
jsfunction parseDate(input) {
  const parts = /^(\d{4})-(\d{2})-(\d{2})$/.exec(input);
  if (!parts) {
    return null;
  }
  return parts.slice(1).map((p) => parseInt(p, 10));
}

parseDate("2019-01-01"); // [2019, 1, 1]
parseDate("2019-06-19"); // [2019, 6, 19]
Pairing quotesThe following function matches the title='xxx' and title="xxx" patterns in a string. To ensure the quotes match, we use a backreference to refer to the first quote. Accessing the second capturing group ([2]) returns the string between the matching quote characters:
jsfunction parseTitle(metastring) {
  return metastring.match(/title=(["'])(.*?)\1/)[2];
}

parseTitle('title="foo"'); // 'foo'
parseTitle("title='foo' lang='en'"); // 'foo'
parseTitle('title="Named capturing groups\' advantages"'); // "Named capturing groups' advantages"
SpecificationsSpecificationECMAScript Language Specification # prod-AtomBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Groups and backreferences guide
Regular expressions
Non-capturing group: (?:...)
Named capturing group: (?<name>...)
Backreference: \1, \2
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Character class escape: \d, \D, \w, \W, \s, \SA character class escape is an escape sequence that represents a set of characters.Syntaxregex\d, \D
\s, \S
\w, \W


Note: , is not part of the syntax.
DescriptionUnlike character escapes, character class escapes represent a predefined set of characters, much like a character class. The following character classes are supported:

\d

Matches any digit character. Equivalent to [0-9].

\w

Matches any word character, where a word character includes letters (A–Z, a–z), numbers (0–9), and underscore (_). If the regex is Unicode-aware and the i flag is set, it also matches other Unicode characters that get canonicalized to one of the characters above through case folding.

\s

Matches any whitespace or line terminator character.


The uppercase forms \D, \W, and \S create complement character classes for \d, \w, and \s, respectively. They match any character that is not in the set of characters matched by the lowercase form.
Unicode character class escapes start with \p and \P, but they are only supported in Unicode-aware mode. In Unicode-unaware mode, they are identity escapes for the p or P character.
Character class escapes can be used in character classes. However, they cannot be used as boundaries of character ranges, which is only allowed as a deprecated syntax for web compatibility, and you should not rely on it.ExamplesSplitting by whitespaceThe following example splits a string into an array of words, supporting all kinds of whitespace separators:
jsfunction splitWords(str) {
  return str.split(/\s+/);
}

splitWords(`Look at the stars
Look  how they\tshine for you`);
// ['Look', 'at', 'the', 'stars', 'Look', 'how', 'they', 'shine', 'for', 'you']
SpecificationsSpecificationECMAScript Language Specification # prod-CharacterClassEscapeBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Character classes guide
Regular expressions
Character class: [...], [^...]
Unicode character class escape: \p{...}, \P{...}
Character escape: \n, \u{...}
Disjunction: |
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Character class: [...], [^...]A character class matches any character in or not in a custom set of characters. When the v flag is enabled, it can also be used to match finite-length strings.Syntaxregex[]
[abc]
[A-Z]

[^]
[^abc]
[^A-Z]

// `v` mode only
[operand1&&operand2]
[operand1--operand2]
[\q{substring}]
Parameters
operand1, operand2

Can be a single character, another square-bracket-enclosed character class, a character class escape, a Unicode character class escape, or a string using the \q syntax.

substring

A literal string.

DescriptionA character class specifies a list of characters between square brackets and matches any character in the list. The v flag drastically changes how character classes are parsed and interpreted. The following syntaxes are available in both v mode and non-v mode:

A single character: matches the character itself.
A range of characters: matches any character in the inclusive range. The range is specified by two characters separated by a dash (-). The first character must be smaller in character value than the second character. The character value is the Unicode code point of the character. Because Unicode code points are usually assigned to alphabets in order, [a-z] specifies all lowercase Latin characters, while [α-ω] specifies all lowercase Greek characters. In Unicode-unaware mode, regexes are interpreted as a sequence of BMP characters. Therefore, surrogate pairs in character classes represent two characters instead of one; see below for details.
Escape sequences: \b, \-, character class escapes, Unicode character class escapes, and other character escapes.

These syntaxes can occur any number of times, and the character sets they represent are unioned. For example, /[a-zA-Z0-9]/ matches any letter or digit.
The ^ prefix in a character class creates a complement class. For example, [^abc] matches any character except a, b, or c. The ^ character is a literal character when it appears in the middle of a character class — for example, [a^b] matches the characters a, ^, and b.
The lexical grammar does a very rough parse of regex literals, so that it does not end the regex literal at a / character which appears within a character class. This means /[/]/ is valid without needing to escape the /.
The boundaries of a character range must not specify more than one character, which happens if you use a character class escape. For example:
js/[\s-9]/u; // SyntaxError: Invalid regular expression: Invalid character class

In Unicode-unaware mode, character ranges where one boundary is a character class makes the - become a literal character. This is a deprecated syntax for web compatibility, and you should not rely on it.
js/[\s-9]/.test("-"); // true

In Unicode-unaware mode, regexes are interpreted as a sequence of BMP characters. Therefore, surrogate pairs in character classes represent two characters instead of one.
js/[😄]/.test("\ud83d"); // true
/[😄]/u.test("\ud83d"); // false

/[😄-😛]/.test("😑"); // SyntaxError: Invalid regular expression: /[😄-😛]/: Range out of order in character class
/[😄-😛]/u.test("😑"); // true

Even if the pattern ignores case, the case of the two ends of a range is significant in determining which characters belong to the range. For example, the pattern /[E-F]/i only matches E, F, e, and f, while the pattern /[E-f]/i matches all uppercase and lowercase ASCII letters (because it spans over E–Z and a–f), as well as [, \, ], ^, _, and `.Non-v-mode character classNon-v-mode character classes interpret most character literally and have less restrictions about the characters they can contain. For example, . is the literal dot character, not the wildcard. The only characters that cannot appear literally are \, ], and -.

In character classes, most escape sequences are supported, except \b, \B, and backreferences. \b indicates a backspace character instead of a word boundary, while the other two cause syntax errors. To use \ literally, escape it as \\.
The ] character indicates the end of the character class. To use it literally, escape it as \].
The dash (-) character, when used between two characters, indicates a range. When it appears at the start or end of a character class, it is a literal character. It's also a literal character when it's used in the boundary of a range. For example, [a-] matches the characters a and -, [!--] matches the characters ! to -, and [--9] matches the characters - to 9. You can also escape it as \- if you want to use it literally anywhere.
v-mode character classThe basic idea of character classes in v mode remains the same: you can still use most characters literally, use - to denote character ranges, and use escape sequences. One of the most important features of the v flag is set notation within character classes. As previously mentioned, normal character classes can express unions by concatenating two ranges, such as using [A-Z0-9] to mean "the union of the set [A-Z] and the set [0-9]". However, there's no easy way to represent other operations with character sets, such as intersection and difference.
With the v flag, intersection is expressed with &&, and subtraction with --. The absence of both implies union. The two operands of && or -- can be a character, character escape, character class escape, or even another character class. For example, to express "a word character that's not an underscore", you can use [\w--_]. You cannot mix operators on the same level. For example, [\w&&[A-z]--_] is a syntax error. However, because you can nest character classes, you can be explicit by writing [\w&&[[A-z]--_]] or [[\w&&[A-z]]--_] (which both mean [A-Za-z]). Similarly, [AB--C] is invalid and you need to write [A[B--C]] (which just means [AB]).
In v mode, the Unicode character class escape \p can match finite-length strings, such as emojis. For symmetry, regular character classes can also match more than one character. To write a "string literal" in a character class, you wrap the string in \q{...}. The only regex syntax supported here is disjunction — apart from this, \q must completely enclose literals (including escaped characters). This ensures that character classes can only match finite-length strings with finitely many possibilities.
Because the character class syntax is now more sophisticated, more characters are reserved and forbidden from appearing literally.

In addition to ] and \, the following characters must be escaped in character classes if they represent literal characters: (, ), [, {, }, /, -, |. This list is somewhat similar to the list of syntax characters, except that ^, $, *, +, and ? are not reserved inside character classes, while / and - are not reserved outside character classes (although / may delimit a regex literal and therefore still needs to be escaped). All these characters may also be optionally escaped in u-mode character classes.
The following "double punctuator" sequences must be escaped as well (but they don't make much sense without the v flag anyway): &&, !!, ##, $$, %%, **, ++, ,,, .., ::, ;;, <<, ==, >>, ??, @@, ^^, ``, ~~. In u mode, some of these characters can only appear literally within character classes and cause a syntax error when escaped. In v mode, they must be escaped when appearing in pairs, but can be optionally escaped when appearing alone. For example, /[\!]/u is invalid because it's an identity escape, but both /[\!]/v and /[!]/v are valid, while /[!!]/v is invalid. The literal character reference has a detailed table of which characters can appear escaped or unescaped.

Complement character classes [^...] cannot possibly be able to match strings longer than one character. For example, [\q{ab|c}] is valid and matches the string "ab", but [^\q{ab|c}] is invalid because it's unclear how many characters should be consumed. The check is done by checking if all \q contain single characters and all \p specify character properties — for unions, all operands must be purely characters; for intersections, at least one operand must be purely characters; for subtraction, the leftmost operand must be purely characters. The check is syntactic without looking at the actual character set being specified, which means although /[^\q{ab|c}--\q{ab}]/v is equivalent to /[^c]/v, it's still rejected.Complement classes and case-insensitive matchingIn non-v-mode, complement character classes [^...] are implemented by simply inverting the match result — that is, [^...] matches whenever [...] doesn't match, and vice versa. However, the other complement classes, such as \P{...} and \W, work by eagerly constructing the set consisting of all characters without the specified property. They seem to produce the same behavior, but are made more complex when combined with case-insensitive matching.
Consider the following two regexes:
jsconst r1 = /\p{Lowercase_Letter}/iu;
const r2 = /[^\P{Lowercase_Letter}]/iu;

The r2 is a double negation and seems to be equivalent with r1. But in fact, r1 matches all lower- and upper-case ASCII letters, while r2 matches none. To illustrate how it works, pretend that we are only dealing with ASCII characters, not the entire Unicode character set, and r1 and r2 are specified as below:
jsconst r1 = /[a-z]/iu;
const r2 = /[^A-Z]/iu;

Recall that case-insensitive matching happens by folding both the pattern and the input to the same case (see ignoreCase for more details). For r1, the character class a-z stays the same after case folding, while both upper- and lower-case ASCII string inputs are folded to lower-case, so r1 is able to match both "A" and "a". For r2, the character class A-Z is folded to a-z; however, ^ negates the match result, so that [^A-Z] in effect only matches upper-case strings. However, both upper- and lower-case ASCII string inputs are still folded to lower-case, causing r2 to match nothing.
In v mode, this behavior is fixed — [^...] also eagerly constructs the complement class instead of negating the match result. This makes [^\P{Lowercase_Letter}] and \p{Lowercase_Letter} are strictly equivalent.ExamplesMatching hexadecimal digitsThe following function determines whether a string contains a valid hexadecimal number:
jsfunction isHexadecimal(str) {
  return /^[0-9A-F]+$/i.test(str);
}

isHexadecimal("2F3"); // true
isHexadecimal("beef"); // true
isHexadecimal("undefined"); // false
Using intersectionThe following function matches Greek letters.
jsfunction greekLetters(str) {
  return str.match(/[\p{Script_Extensions=Greek}&&\p{Letter}]/gv);
}

// 𐆊 is U+1018A GREEK ZERO SIGN
greekLetters("π𐆊P0零αAΣ"); // [ 'π', 'α', 'Σ' ]
Using subtractionThe following function matches all non-ASCII numbers.
jsfunction nonASCIINumbers(str) {
  return str.match(/[\p{Decimal_Number}--[0-9]]/gv);
}

// 𑜹 is U+11739 AHOM DIGIT NINE
nonASCIINumbers("𐆊0零1𝟜𑜹a"); // [ '𝟜', '𑜹' ]
Matching stringsThe following function matches all line terminator sequences, including the line terminator characters and the sequence \r\n (CRLF).
jsfunction getLineTerminators(str) {
  return str.match(/[\r\n\u2028\u2029\q{\r\n}]/gv);
}

getLineTerminators(`
A poem\r
Is split\r\n
Into many
Stanzas
`); // [ '\r', '\r\n', '\n' ]

This example is exactly equivalent to /(?:\r|\n|\u2028|\u2029|\r\n)/gu or /(?:[\r\n\u2028\u2029]|\r\n)/gu, except shorter.
The most useful case of \q{} is when doing subtraction and intersection. Previously, this was possible with multiple lookaheads. The following function matches flags that are not one of the American, Chinese, Russian, British, and French flags.
jsfunction notUNSCPermanentMember(flag) {
  return /^[\p{RGI_Emoji_Flag_Sequence}--\q{🇺🇸|🇨🇳|🇷🇺|🇬🇧|🇫🇷}]$/v.test(flag);
}

notUNSCPermanentMember("🇺🇸"); // false
notUNSCPermanentMember("🇩🇪"); // true

This example is mostly equivalent to /^(?!🇺🇸|🇨🇳|🇷🇺|🇬🇧|🇫🇷)\p{RGI_Emoji_Flag_Sequence}$/v, except perhaps more performant.SpecificationsSpecificationECMAScript Language Specification # prod-CharacterClassBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Character classes guide
Regular expressions
Character class escape: \d, \D, \w, \W, \s, \S
Unicode character class escape: \p{...}, \P{...}
Literal character: a, b
Character escape: \n, \u{...}
Disjunction: |
RegExp v flag with set notation and properties of strings on v8.dev (2022)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Character escape: \n, \u{...}A character escape represents a character that may not be able to be conveniently represented in its literal form.Syntaxregex\f, \n, \r, \t, \v
\cA, \cB, …, \cz
\0
\^, \$, \\, \., \*, \+, \?, \(, \), \[, \], {, }, \|, \/

\xHH
\uHHHH
\u{HHH}


Note: , is not part of the syntax.
Parameters
HHH

A hexadecimal number representing the Unicode code point of the character. The \xHH form must have two hexadecimal digits; the \uHHHH form must have four; the \u{HHH} form may have 1 to 6 hexadecimal digits.

DescriptionThe following character escapes are recognized in regular expressions:

\f, \n, \r, \t, \v

Same as those in string literals, except \b, which represents a word boundary in regexes unless in a character class.

\c followed by a letter from A to Z or a to z

Represents the control character with value equal to the letter's character value modulo 32. For example, \cJ represents line break (\n), because the code point of J is 74, and 74 modulo 32 is 10, which is the code point of line break. Because an uppercase letter and its lowercase form differ by 32, \cJ and \cj are equivalent. You can represent control characters from 1 to 26 in this form.

\0

Represents the U+0000 NUL character. Cannot be followed by a digit (which makes it a legacy octal escape sequence).

\^, \$, \\, \. \*, \+, \?, \(, \), \[, \], {, }, \|, \/

Represents the character itself. For example, \\ represents a backslash, and \( represents a left parenthesis. These are syntax characters in regexes (/ is the delimiter of a regex literal), so they require escaping unless in a character class.

\xHH

Represents the character with the given hexadecimal Unicode code point. The hexadecimal number must be exactly two digits long.

\uHHHH

Represents the character with the given hexadecimal Unicode code point. The hexadecimal number must be exactly four digits long. Two such escape sequences can be used to represent a surrogate pair in Unicode-aware mode. (In Unicode-unaware mode, they are always two separate characters.)

\u{HHH}

(Unicode-aware mode only) Represents the character with the given hexadecimal Unicode code point. The hexadecimal number can be from 1 to 6 digits long.


In Unicode-unaware mode, escape sequences that are not one of the above become identity escapes: they represent the character that follows the backslash. For example, \a represents the character a. This behavior limits the ability to introduce new escape sequences without causing backward compatibility issues, and is therefore forbidden in Unicode-aware mode.
In Unicode-unaware mode, ], {, and } may appear literally if it's not possible to parse them as the end of a character class or quantifier delimiters. This is a deprecated syntax for web compatibility, and you should not rely on it.
In Unicode-unaware mode, escape sequences within character classes of the form \cX where X is a number or _ are decoded in the same way as those with ASCII letters: \c0 is the same as \cP when taken modulo 32. In addition, if the form \cX is encountered anywhere where X is not one of the recognized characters, then the backslash is treated as a literal character. These syntaxes are also deprecated.
js/[\c0]/.test("\x10"); // true
/[\c_]/.test("\x1f"); // true
/[\c*]/.test("\\"); // true
/\c/.test("\\c"); // true
/\c0/.test("\\c0"); // true (the \c0 syntax is only supported in character classes)
ExamplesUsing character escapesCharacter escapes are useful when you want to match a character that is not easily represented in its literal form. For example, you cannot use a line break literally in a regex literal, so you must use a character escape:
jsconst pattern = /a\nb/;
const string = `a
b`;
console.log(pattern.test(string)); // true
SpecificationsSpecificationECMAScript Language Specification # prod-CharacterEscapeBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Character classes guide
Regular expressions
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W, \s, \S
Literal character: a, b
Unicode character class escape: \p{...}, \P{...}
Backreference: \1, \2
Named backreference: \k<name>
Word boundary assertion: \b, \B
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Disjunction: |A disjunction specifies multiple alternatives. Any alternative matching the input causes the entire disjunction to be matched.Syntaxregexalternative1|alternative2
alternative1|alternative2|alternative3|…
Parameters
alternativeN

One alternative pattern, composed of a sequence of atoms and assertions. Successfully matching one alternative causes the entire disjunction to be matched.

DescriptionThe | regular expression operator separates two or more alternatives. The pattern first tries to match the first alternative; if it fails, it tries to match the second one, and so on. For example, the following matches "a" instead of "ab", because the first alternative already matches successfully:
js/a|ab/.exec("abc"); // ['a']

The | operator has the lowest precedence in a regular expression. If you want to use a disjunction as a part of a bigger pattern, you must group it.
When a grouped disjunction has more expressions after it, the matching begins by selecting the first alternative and attempting to match the rest of the regular expression. If the rest of the regular expression fails to match, the matcher tries the next alternative instead. For example,
js/(?:(a)|(ab))(?:(c)|(bc))/.exec("abc"); // ['abc', 'a', undefined, undefined, 'bc']
// Not ['abc', undefined, 'ab', 'c', undefined]

This is because by selecting a in the first alternative, it's possible to select bc in the second alternative and result in a successful match. This process is called backtracking, because the matcher first goes beyond the disjunction and then comes back to it when subsequent matching fails.
Note also that any capturing parentheses inside an alternative that's not matched produce undefined in the resulting array.
An alternative can be empty, in which case it matches the empty string (in other words, always matches).
Alternatives are always attempted left-to-right, regardless of the direction of matching (which is reversed in a lookbehind).ExamplesMatching file extensionsThe following example matches file extensions, using the same code as the input boundary assertion article:
jsfunction isImage(filename) {
  return /\.(?:png|jpe?g|webp|avif|gif)$/i.test(filename);
}

isImage("image.png"); // true
isImage("image.jpg"); // true
isImage("image.pdf"); // false
SpecificationsSpecificationECMAScript Language Specification # prod-DisjunctionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Character classes guide
Regular expressions
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Character class: [...], [^...]
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Input boundary assertion: ^, $An input boundary assertion checks if the current position in the string is an input boundary. An input boundary is the start or end of the string; or, if the m flag is set, the start or end of a line.Syntaxregex^
$
Description^ asserts that the current position is the start of input. $ asserts that the current position is the end of input. Both are assertions, so they don't consume any characters.
More precisely, ^ asserts that the character to the left is out of bounds of the string; $ asserts that the character to the right is out of bounds of the string. If the m flag is set, ^ also matches if the character to the left is a line terminator character, and $ also matches if the character to the right is a line terminator.
Unless the m flag is set, the ^ and $ assertions only make sense when placed at the boundaries of the pattern, because any other characters to the left or right of them would necessarily cause the assertion to fail.
The y flag doesn't change the meaning of these assertions — see also anchored sticky flag.ExamplesRemoving trailing slashesThe following example removes trailing slashes from a URL string:
jsfunction removeTrailingSlash(url) {
  return url.replace(/\/$/, "");
}

removeTrailingSlash("https://example.com/"); // "https://example.com"
removeTrailingSlash("https://example.com/docs/"); // "https://example.com/docs"
Matching file extensionsThe following example checks file types by matching the file extension, which always comes at the end of the string:
jsfunction isImage(filename) {
  return /\.(?:png|jpe?g|webp|avif|gif)$/i.test(filename);
}

isImage("image.png"); // true
isImage("image.jpg"); // true
isImage("image.pdf"); // false
Matching entire inputSometimes you want to make sure that your regex matches the entire input, not just a substring of the input. For example, if you are determining if a string is a valid identifier, you can add input boundary assertions to both ends of the pattern:
jsfunction isValidIdentifier(str) {
  return /^[$_\p{ID_Start}][$_\p{ID_Continue}]*$/u.test(str);
}

isValidIdentifier("foo"); // true
isValidIdentifier("$1"); // true
isValidIdentifier("1foo"); // false
isValidIdentifier("  foo  "); // false

This function is useful when doing codegen (generating code using code), because you can use valid identifiers differently from other string properties, such as dot notation instead of bracket notation:
jsconst variables = ["foo", "foo:bar", "  foo  "];

function toAssignment(key) {
  if (isValidIdentifier(key)) {
    return `globalThis.${key} = undefined;`;
  }
  // JSON.stringify() escapes quotes and other special characters
  return `globalThis[${JSON.stringify(key)}] = undefined;`;
}

const statements = variables.map(toAssignment).join("\n");

console.log(statements);
// globalThis.foo = undefined;
// globalThis["foo:bar"] = undefined;
// globalThis["  foo  "] = undefined;
SpecificationsSpecificationECMAScript Language Specification # prod-AssertionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assertions guide
Regular expressions
Word boundary assertion: \b, \B
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Literal character: a, bA literal character specifies exactly itself to be matched in the input text.Syntaxregexc
Parameters
c

A single character that is not one of the syntax characters described below.

DescriptionIn regular expressions, most characters can appear literally. They are usually the most basic building blocks of patterns. For example, here is a pattern from the Removing HTML tags example:
jsconst pattern = /<.+?>/g;

In this example, ., +, and ? are called syntax characters. They have special meanings in regular expressions. The rest of the characters in the pattern (< and >) are literal characters. They match themselves in the input text: the left and right angle brackets.
The following characters are syntax characters in regular expressions, and they cannot appear as literal characters:

^, $
\
*, +, ?, {, }
(, )
[, ]
|

Within character classes, more characters can appear literally. For more information, see the Character class page. For example \. and [.] both match a literal .. In v-mode character classes, however, there are a different set of characters reserved as syntax characters. To be most comprehensive, below is a table of ASCII characters and whether they may appear escaped or unescaped in different contexts, where "✅" means the character represents itself, "❌" means it throws a syntax error, and "⚠️" means the character is valid but means something other than itself.



Characters
Outside character classes in u or v mode
In u-mode character classes
In v-mode character classes


Unescaped
Escaped
Unescaped
Escaped
Unescaped
Escaped




123456789 "'ACEFGHIJKLMNOPQRTUVXYZ_aceghijklmopquxyz
✅
❌
✅
❌
✅
❌


!#%&,:;<=>@`~
✅
❌
✅
❌
✅
✅


]
❌
✅
❌
✅
❌
✅


()[{}
❌
✅
✅
✅
❌
✅


*+?
❌
✅
✅
✅
✅
✅


/
✅
✅
✅
✅
❌
✅


0DSWbdfnrstvw
✅
⚠️
✅
⚠️
✅
⚠️


B
✅
⚠️
✅
❌
✅
❌


$.
⚠️
✅
✅
✅
✅
✅


|
⚠️
✅
✅
✅
❌
✅


-
✅
❌
✅⚠️
✅
❌⚠️
✅


^
⚠️
✅
✅⚠️
✅
✅⚠️
✅


\
❌⚠️
✅
❌⚠️
✅
❌⚠️
✅




Note: The characters that can both be escaped and unescaped in v-mode character classes are exactly those forbidden as "double punctuators". See v-mode character classes for more information.

Whenever you want to match a syntax character literally, you need to escape it with a backslash (\). For example, to match a literal * in a pattern, you need to write \* in the pattern. Using syntax characters as literal characters either leads to unexpected results or causes syntax errors — for example, /*/ is not a valid regular expression because the quantifier is not preceded by a pattern. In Unicode-unaware mode, ], {, and } may appear literally if it's not possible to parse them as the end of a character class or quantifier delimiters. This is a deprecated syntax for web compatibility, and you should not rely on it.
Regular expression literals cannot be specified with certain non-syntax literal characters. / cannot appear as a literal character in a regular expression literal, because / is used as the delimiter of the literal itself. You need to escape it as \/ if you want to match a literal /. Line terminators cannot appear as literal characters in a regular expression literal either, because a literal cannot span multiple lines. You need to use a character escape like \n instead. There are no such restrictions when using the RegExp() constructor, although string literals have their own escaping rules (for example, "\\" actually denotes a single backslash character, so new RegExp("\\*") and /\*/ are equivalent).
In Unicode-unaware mode, the pattern is interpreted as a sequence of UTF-16 code units. This means surrogate pairs actually represent two literal characters. This causes unexpected behaviors when paired with other features:
js/^[😄]$/.test("😄"); // false, because the pattern is interpreted as /^[\ud83d\udc04]$/
/^😄+$/.test("😄😄"); // false, because the pattern is interpreted as /^\ud83d\udc04+$/

In Unicode-aware mode, the pattern is interpreted as a sequence of Unicode code points, and surrogate pairs do not get split. Therefore, you should always prefer to use the u flag.ExamplesUsing literal charactersThe following example is copied from Character escape. The a and b characters are literal characters in the pattern, and \n is an escaped character because it cannot appear literally in a regular expression literal.
jsconst pattern = /a\nb/;
const string = `a
b`;
console.log(pattern.test(string)); // true
SpecificationsSpecificationECMAScript Language Specification # prod-PatternCharacterBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Character classes guide
Regular expressions
Character escape: \n, \u{...}
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Lookahead assertion: (?=...), (?!...)A lookahead assertion "looks ahead": it attempts to match the subsequent input with the given pattern, but it does not consume any of the input — if the match is successful, the current position in the input stays the same.Syntaxregex(?=pattern)
(?!pattern)
Parameters
pattern

A pattern consisting of anything you may use in a regex literal, including a disjunction.

DescriptionA regular expression generally matches from left to right. This is why lookahead and lookbehind assertions are called as such — lookahead asserts what's on the right, and lookbehind asserts what's on the left.
In order for a (?=pattern) assertion to succeed, the pattern must match the text after the current position, but the current position is not changed. The (?!pattern) form negates the assertion — it succeeds if the pattern does not match at the current position.
The pattern can contain capturing groups. See the capturing groups page for more information on the behavior in this case.
Unlike other regular expression operators, there's no backtracking into a lookahead — this behavior is inherited from Perl. This only matters when the pattern contains capturing groups and the pattern following the lookahead contains backreferences to those captures. For example:
js/(?=(a+))a*b\1/.exec("baabac"); // ['aba', 'a']
// Not ['aaba', 'a']

The matching of the pattern above happens as follows:

The lookahead (a+) succeeds before the first "a" in "baabac", and "aa" is captured because the quantifier is greedy.
a*b matches the "aab" in "baabac" because lookaheads don't consume their matched strings.
\1 does not match the following string, because that requires 2 "a"s, but only 1 is available. So the matcher backtracks, but it doesn't go into the lookahead, so the capturing group cannot be reduced to 1 "a", and the entire match fails at this point.
exec() re-attempts matching at the next position — before the second "a". This time, the lookahead matches "a", and a*b matches "ab". The backreference \1 matches the captured "a", and the match succeeds.

If the regex is able to backtrack into the lookahead and revise the choice made in there, then the match would succeed at step 3 by (a+) matching the first "a" (instead of the first two "a"s) and a*b matching "aab", without even re-attempting the next input position.
Negative lookaheads can contain capturing groups as well, but backreferences only make sense within the pattern, because if matching continues, pattern would necessarily be unmatched (otherwise the assertion fails). This means outside of the pattern, backreferences to those capturing groups in negative lookaheads always succeed. For example:
js/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac"); // ['baaabaac', 'ba', undefined, 'abaac']

The matching of the pattern above happens as follows:

The (.*?) pattern is non-greedy, so it starts by matching nothing. However, the next character is a, which fails to match "b" in the input.
The (.*?) pattern matches "b" so that the a in the pattern matches the first "a" in "baaabaac".
At this position, the lookahead succeeds to match, because if (a+) matches "aa", then (a+)b\2c matches "aabaac". This causes the assertion to fail, so the matcher backtracks.
The (.*?) pattern matches the "ba" so that the a in the pattern matches the second "a" in "baaabaac".
At this position, the lookahead fails to match, because the remaining input does not follow the pattern "any number of "a"s, a "b", the same number of "a"s, a c". This causes the assertion to succeed.
However, because nothing was matched within the assertion, the \2 backreference has no value, so it matches the empty string. This causes the rest of the input to be consumed by the (.*) at the end.

Normally, assertions cannot be quantified. However, in Unicode-unaware mode, lookahead assertions can be quantified. This is a deprecated syntax for web compatibility, and you should not rely on it.
js/(?=a)?b/.test("b"); // true; the lookahead is matched 0 time
ExamplesMatching strings without consuming themSometimes it's useful to validate that the matched string is followed by something without returning that as the result. The following example matches a string that is followed by a comma/period, but the punctuation is not included in the result:
jsfunction getFirstSubsentence(str) {
  return /^.*?(?=[,.])/.exec(str)?.[0];
}

getFirstSubsentence("Hello, world!"); // "Hello"
getFirstSubsentence("Thank you."); // "Thank you"

A similar effect can be achieved by capturing the submatch you are interested in.Pattern subtraction and intersectionUsing lookahead, you can match a string multiple times with different patterns, which allows you to express complex relationships like subtraction (is X but not Y) and intersection (is both X and Y).
The following example matches any identifier that's not a reserved word (only showing three reserved words here for brevity; more reserved words can be added to this disjunction). The [$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]* syntax describes exactly the set of identifier strings in the language spec; you can read more about identifiers in lexical grammar and the \p escape in Unicode character class escape.
jsfunction isValidIdentifierName(str) {
  const re =
    /^(?!(?:break|case|catch)$)[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*$/u;
  return re.test(str);
}

isValidIdentifierName("break"); // false
isValidIdentifierName("foo"); // true
isValidIdentifierName("cases"); // true

The following example matches a string that's both ASCII and can be used as an identifier part:
jsfunction isASCIIIDPart(char) {
  return /^(?=\p{ASCII}$)\p{ID_Start}$/u.test(char);
}

isASCIIIDPart("a"); // true
isASCIIIDPart("α"); // false
isASCIIIDPart(":"); // false

If you are doing intersection and subtraction with finitely many characters, you may want to use the character set intersection syntax enabled with the v flag.SpecificationsSpecificationECMAScript Language Specification # prod-AssertionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assertions guide
Regular expressions
Input boundary assertion: ^, $
Word boundary assertion: \b, \B
Lookbehind assertion: (?<=...), (?<!...)
Capturing group: (...)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 1, 2023 by MDN contributors.
Lookbehind assertion: (?<=...), (?<!...)A lookbehind assertion "looks behind": it attempts to match the previous input with the given pattern, but it does not consume any of the input — if the match is successful, the current position in the input stays the same. It matches each atom in its pattern in the reverse order.Syntaxregex(?<=pattern)
(?<!pattern)
Parameters
pattern

A pattern consisting of anything you may use in a regex literal, including a disjunction.

DescriptionA regular expression generally matches from left to right. This is why lookahead and lookbehind assertions are called as such — lookahead asserts what's on the right, and lookbehind asserts what's on the left.
In order for a (?<=pattern) assertion to succeed, the pattern must match the input immediately to the left of the current position, but the current position is not changed before matching the subsequent input. The (?<!pattern) form negates the assertion — it succeeds if the pattern does not match the input immediately to the left of the current position.
Lookbehind generally has the same semantics as lookahead — however, within a lookbehind assertion, the regular expression matches backwards. For example,
js/(?<=([ab]+)([bc]+))$/.exec("abc"); // ['', 'a', 'bc']
// Not ['', 'ab', 'c']

If the lookbehind matches from left to right, it should first greedily match [ab]+, which makes the first group capture "ab", and the remaining "c" is captured by [bc]+. However, because [bc]+ is matched first, it greedily grabs "bc", leaving only "a" for [ab]+.
This behavior is reasonable — the matcher does not know where to start the match (because the lookbehind may not be fixed-length), but it does know where to end (at the current position). Therefore, it starts from the current position and works backwards. (Regexes in some other languages forbid non-fixed-length lookbehind to avoid this issue.)
For quantified capturing groups inside the lookbehind, the match furthest to the left of the input string — instead of the one on the right — is captured because of backward matching. See the capturing groups page for more information. Backreferences inside the lookbehind must appear on the left of the group it's referring to, also due to backward matching. However, disjunctions are still attempted left-to-right.ExamplesMatching strings without consuming themSimilar to lookaheads, lookbehinds can be used to match strings without consuming them so that only useful information is extracted. For example, the following regex matches the number in a price label:
jsfunction getPrice(label) {
  return /(?<=\$)\d+(?:\.\d*)?/.exec(label)?.[0];
}

getPrice("$10.53"); // "10.53"
getPrice("10.53"); // undefined

A similar effect can be achieved by capturing the submatch you are interested in.SpecificationsSpecificationECMAScript Language Specification # prod-AssertionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assertions guide
Regular expressions
Input boundary assertion: ^, $
Word boundary assertion: \b, \B
Lookahead assertion: (?=...), (?!...)
Capturing group: (...)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Named backreference: \k<name>A named backreference refers to the submatch of a previous named capturing group and matches the same text as that group. For unnamed capturing groups, you need to use the normal backreference syntax.Syntaxregex\k<name>
Parameters
name

The name of the group. Must be a valid identifier and refer to an existent named capturing group.

DescriptionNamed backreferences are very similar to normal backreferences: it refers to the text matched by a capturing group and matches the same text. The difference is that you refer to the capturing group by name instead of by number. This makes the regular expression more readable and easier to refactor and maintain.
In Unicode-unaware mode, the sequence \k only starts a named backreference if the regex contains at least one named capturing group. Otherwise, it is an identity escape and is the same as the literal character k. This is a deprecated syntax for web compatibility, and you should not rely on it.
js/\k/.test("k"); // true
ExamplesPairing quotesThe following function matches the title='xxx' and title="xxx" patterns in a string. To ensure the quotes match, we use a backreference to refer to the first quote. Accessing the second capturing group ([2]) returns the string between the matching quote characters:
jsfunction parseTitle(metastring) {
  return metastring.match(/title=(?<quote>["'])(.*?)\k<quote>/)[2];
}

parseTitle('title="foo"'); // 'foo'
parseTitle("title='foo' lang='en'"); // 'foo'
parseTitle('title="Named capturing groups\' advantages"'); // "Named capturing groups' advantages"
SpecificationsSpecificationECMAScript Language Specification # prod-AtomEscapeBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Groups and backreferences guide
Regular expressions
Capturing group: (...)
Named capturing group: (?<name>...)
Backreference: \1, \2
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Named capturing group: (?<name>...)A named capturing group is a particular kind of capturing group that allows to give a name to the group. The group's matching result can later be identified by this name instead of by its index in the pattern.Syntaxregex(?<name>pattern)
Parameters
pattern

A pattern consisting of anything you may use in a regex literal, including a disjunction.

name

The name of the group. Must be a valid identifier.

DescriptionNamed capturing groups can be used just like capturing groups — they also have their match index in the result array, and they can be referenced through \1, \2, etc. The only difference is that they can be additionally referenced by their name. The information of the capturing group's match can be accessed through:

The groups property of the return value of RegExp.prototype.exec(), String.prototype.match(), and String.prototype.matchAll()
The groups parameter of the String.prototype.replace() and String.prototype.replaceAll() methods' replacement callback function
Named backreferences within the same pattern

All names must be unique within the same pattern. Multiple named capturing groups with the same name result in a syntax error.
js/(?<name>)(?<name>)/; // SyntaxError: Invalid regular expression: Duplicate capture group name

This restriction is relaxed if the duplicate named capturing groups are not in the same disjunction alternative, so for any string input, only one named capturing group can actually be matched. This is a much newer feature, so check browser compatibility before using it.
js/(?<year>\d{4})-\d{2}|\d{2}-(?<year>\d{4})/;
// Works; "year" can either come before or after the hyphen

Named capturing groups will all be present in the result. If a named capturing group is not matched (for example, it belongs to an unmatched alternative in a disjunction), the corresponding property on the groups object has value undefined.
js/(?<ab>ab)|(?<cd>cd)/.exec("cd").groups; // [Object: null prototype] { ab: undefined, cd: 'cd' }

You can get the start and end indices of each named capturing group in the input string by using the d flag. In addition to accessing them on the indices property on the array returned by exec(), you can also access them by their names on indices.groups.
Compared to unnamed capturing groups, named capturing groups have the following advantages:

They allow you to provide a descriptive name for each submatch result.
They allow you to access submatch results without having to remember the order in which they appear in the pattern.
When refactoring code, you can change the order of capturing groups without worrying about breaking other references.
ExamplesUsing named capturing groupsThe following example parses a timestamp and an author name from a Git log entry (output with git log --format=%ct,%an -- filename):
jsfunction parseLog(entry) {
  const { author, timestamp } = /^(?<timestamp>\d+),(?<author>.+)$/.exec(
    entry,
  ).groups;
  return `${author} committed on ${new Date(
    parseInt(timestamp) * 1000,
  ).toLocaleString()}`;
}

parseLog("1560979912,Caroline"); // "Caroline committed on 6/19/2019, 5:31:52 PM"
SpecificationsSpecificationECMAScript Language Specification # prod-AtomBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Polyfill of named capturing groups in core-js
Groups and backreferences guide
Regular expressions
Capturing group: (...)
Non-capturing group: (?:...)
Named backreference: \k<name>
ESLint rule: prefer-named-capture-group
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Non-capturing group: (?:...)A non-capturing group groups a subpattern, allowing you to apply a quantifier to the entire group or use disjunctions within it. It acts like the grouping operator in JavaScript expressions, and unlike capturing groups, it does not memorize the matched text, allowing for better performance and avoiding confusion when the pattern also contains useful capturing groups.Syntaxregex(?:pattern)
Parameters
pattern

A pattern consisting of anything you may use in a regex literal, including a disjunction.

ExamplesGrouping a subpattern and applying a quantifierIn the following example, we test if a file path ends with styles.css or styles.[a hex hash].css. Because the entire \.[\da-f]+ part is optional, in order to apply the ? quantifier to it, we need to group it into a new atom. Using a non-capturing group improves performance by not creating the extra match information that we don't need.
jsfunction isStylesheet(path) {
  return /styles(?:\.[\da-f]+)?\.css$/.test(path);
}

isStylesheet("styles.css"); // true
isStylesheet("styles.1234.css"); // true
isStylesheet("styles.cafe.css"); // true
isStylesheet("styles.1234.min.css"); // false
Grouping a disjunctionA disjunction has the lowest precedence in a regular expression. If you want to use a disjunction as a part of a bigger pattern, you must group it. You are advised to use a non-capturing group unless you rely on the matched text of the disjunction. The following example matches file extensions, using the same code as the input boundary assertion article:
jsfunction isImage(filename) {
  return /\.(?:png|jpe?g|webp|avif|gif)$/i.test(filename);
}

isImage("image.png"); // true
isImage("image.jpg"); // true
isImage("image.pdf"); // false
Avoiding refactoring hazardsCapturing groups are accessed by their position in the pattern. If you add or remove a capturing group, you must also update the positions of the other capturing groups, if you are accessing them through match results or backreferences. This can be a source of bugs, especially if most groups are purely for syntactic purposes (to apply quantifiers or to group disjunctions). Using non-capturing groups avoids this problem, and allows the indices of actual capturing groups to be easily tracked.
For example, suppose we have a function that matches the title='xxx' pattern in a string (example taken from capturing group). To ensure the quotes match, we use a backreference to refer to the first quote.
jsfunction parseTitle(metastring) {
  return metastring.match(/title=(["'])(.*?)\1/)[2];
}

parseTitle('title="foo"'); // 'foo'

If we later decided to add name='xxx' as an alias for title=, we will need to group the disjunction in another group:
jsfunction parseTitle(metastring) {
  // Oops — the backreference and index access are now off by one!
  return metastring.match(/(title|name)=(["'])(.*?)\1/)[2];
}

parseTitle('name="foo"'); // Cannot read properties of null (reading '2')
// Because \1 now refers to the "name" string, which isn't found at the end.

Instead of locating all places where we are referring to the capturing groups' indices and updating them one-by-one, it's better to avoid using a capturing group:
jsfunction parseTitle(metastring) {
  // Do not capture the title|name disjunction
  // because we don't use its value
  return metastring.match(/(?:title|name)=(["'])(.*?)\1/)[2];
}

parseTitle('name="foo"'); // 'foo'

Named capturing groups are another way to avoid refactoring hazards. It allows capturing groups to accessed by a custom name, which is unaffected when other capturing groups are added or removed.SpecificationsSpecificationECMAScript Language Specification # prod-AtomBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Groups and backreferences guide
Regular expressions
Capturing group: (...)
Named capturing group: (?<name>...)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Quantifier: *, +, ?, {n}, {n,}, {n,m}A quantifier repeats an atom a certain number of times. The quantifier is placed after the atom it applies to.Syntaxregex// Greedy
atom?
atom*
atom+
atom{count}
atom{min,}
atom{min,max}

// Non-greedy
atom??
atom*?
atom+?
atom{count}?
atom{min,}?
atom{min,max}?
Parameters
atom

A single atom.

count

A non-negative integer. The number of times the atom should be repeated.

min

A non-negative integer. The minimum number of times the atom can be repeated.

max Optional

A non-negative integer. The maximum number of times the atom can be repeated. If omitted, the atom can be repeated as many times as needed.

DescriptionA quantifier is placed after an atom to repeat it a certain number of times. It cannot appear on its own. Each quantifier is able to specify a minimum and maximum number that a pattern must be repeated for.



Quantifier
Minimum
Maximum




?
0
1


*
0
Infinity


+
1
Infinity


{count}
count
count


{min,}
min
Infinity


{min,max}
min
max



For the {count}, {min,}, and {min,max} syntaxes, there cannot be white spaces around the numbers — otherwise, it becomes a literal pattern.
jsconst re = /a{1, 3}/;
re.test("aa"); // false
re.test("a{1, 3}"); // true

This behavior is fixed in Unicode-aware mode, where braces cannot appear literally without escaping. The ability to use { and } literally without escaping is a deprecated syntax for web compatibility, and you should not rely on it.
js/a{1, 3}/u; // SyntaxError: Invalid regular expression: Incomplete quantifier

It is a syntax error if the minimum is greater than the maximum.
js/a{3,2}/; // SyntaxError: Invalid regular expression: numbers out of order in {} quantifier

Quantifiers can cause capturing groups to match multiple times. See the capturing groups page for more information on the behavior in this case.
Each repeated match doesn't have to be the same string.
js/[ab]*/.exec("aba"); // ['aba']

Quantifiers are greedy by default, which means they try to match as many times as possible until the maximum is reached, or until it's not possible to match further. You can make a quantifier non-greedy by adding a ? after it. In this case, the quantifier will try to match as few times as possible, only matching more times if it's impossible to match the rest of the pattern with this many repetitions.
js/a*/.exec("aaa"); // ['aaa']; the entire input is consumed
/a*?/.exec("aaa"); // ['']; it's possible to consume no characters and still match successfully
/^a*?$/.exec("aaa"); // ['aaa']; it's not possible to consume fewer characters and still match successfully

However, as soon as the regex successfully matches the string at some index, it will not try subsequent indices, although that may result in fewer characters being consumed.
js/a*?$/.exec("aaa"); // ['aaa']; the match already succeeds at the first character, so the regex never attempts to start matching at the second character

Greedy quantifiers may try fewer repetitions if it's otherwise impossible to match the rest of the pattern.
js/[ab]+[abc]c/.exec("abbc"); // ['abbc']

In this example, [ab]+ first greedily matches "abb", but [abc]c is not able to match the rest of the pattern ("c"), so the quantifier is reduced to match only "ab".
Greedy quantifiers avoid matching infinitely many empty strings. If the minimum number of matches is reached and no more characters are being consumed by the atom at this position, the quantifier stops matching. This is why /(a*)*/.exec("b") does not result in an infinite loop.
Greedy quantifiers try to match as many times as possible; it does not maximize the length of the match. For example, /(aa|aabaac|ba)*/.exec("aabaac") matches "aa" and then "ba" instead of "aabaac".
Quantifiers apply to a single atom. If you want to quantify a longer pattern or a disjunction, you must group it. Quantifiers cannot be applied to assertions.
js/^*/; // SyntaxError: Invalid regular expression: nothing to repeat

In Unicode-aware mode, lookahead assertions can be quantified. This is a deprecated syntax for web compatibility, and you should not rely on it.
js/(?=a)?b/.test("b"); // true; the lookahead is matched 0 time
ExamplesRemoving HTML tagsThe following example removes HTML tags enclosed in angle brackets. Note the use of ? to avoid consuming too many characters at once.
jsfunction stripTags(str) {
  return str.replace(/<.+?>/g, "");
}

stripTags("<p><em>lorem</em> <strong>ipsum</strong></p>"); // 'lorem ipsum'

The same effect can be achieved with a greedy match, but not allowing the repeated pattern to match >.
jsfunction stripTags(str) {
  return str.replace(/<[^>]+>/g, "");
}

stripTags("<p><em>lorem</em> <strong>ipsum</strong></p>"); // 'lorem ipsum'


Warning: This is for demonstration only — it doesn't handle > in attribute values. Use a proper HTML sanitizer like the HTML sanitizer API instead.
Locating Markdown paragraphsIn Markdown, paragraphs are separated by one or more blank lines. The following example counts all paragraphs in a string by matching two or more line breaks.
jsfunction countParagraphs(str) {
  return str.match(/(?:\r?\n){2,}/g).length + 1;
}

countParagraphs(`
Paragraph 1

Paragraph 2
Containing some line breaks, but still the same paragraph

Another paragraph
`); // 3


Warning: This is for demonstration only — it doesn't handle line breaks in code blocks or other Markdown block elements like headings. Use a proper Markdown parser instead.
SpecificationsSpecificationECMAScript Language Specification # prod-QuantifierBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Quantifiers guide
Regular expressions
Disjunction: |
Character class: [...], [^...]
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Unicode character class escape: \p{...}, \P{...}A unicode character class escape is a kind of character class escape that matches a set of characters specified by a Unicode property. It's only supported in Unicode-aware mode. When the v flag is enabled, it can also be used to match finite-length strings.Try itSyntaxregex\p{loneProperty}
\P{loneProperty}

\p{property=value}
\P{property=value}
Parameters
loneProperty

A lone Unicode property name or value, following the same syntax as value. It specifies the value for the General_Category property, or a binary property name. In v mode, it can also be a binary Unicode property of strings.

Note: ICU syntax allows omitting the Script property name as well, but JavaScript does not support this, because most of the time Script_Extensions is more useful than Script.


property

A Unicode property name. Must be made of ASCII letters (A–Z, a–z) and underscores (_), and must be one of the non-binary property names.

value

A Unicode property value. Must be made of ASCII letters (A–Z, a–z), underscores (_), and digits (0–9), and must be one of the supported values listed in PropertyValueAliases.txt.

Description\p and \P are only supported in Unicode-aware mode. In Unicode-unaware mode, they are identity escapes for the p or P character.
Every Unicode character has a set of properties that describe it. For example, the character a has the General_Category property with value Lowercase_Letter, and the Script property with value Latn. The \p and \P escape sequences allow you to match a character based on its properties. For example, a can be matched by \p{Lowercase_Letter} (the General_Category property name is optional) as well as \p{Script=Latn}. \P creates a complement class that consists of code points without the specified property.
To compose multiple properties, use the character set intersection syntax enabled with the v flag, or see pattern subtraction and intersection.
In v mode, \p may match a sequence of code points, defined in Unicode as "properties of strings". This is most useful for emojis, which are often composed of multiple code points. However, \P can only complement character properties.

Note: There are plans to port the properties of strings feature to u mode as well.
ExamplesGeneral categoriesGeneral categories are used to classify Unicode characters and subcategories are available to define a more precise categorization. It is possible to use both short or long forms in Unicode property escapes.
They can be used to match letters, numbers, symbols, punctuations, spaces, etc. For a more exhaustive list of general categories, please refer to the Unicode specification.
js// finding all the letters of a text
const story = "It's the Cheshire Cat: now I shall have somebody to talk to.";

// Most explicit form
story.match(/\p{General_Category=Letter}/gu);

// It is not mandatory to use the property name for General categories
story.match(/\p{Letter}/gu);

// This is equivalent (short alias):
story.match(/\p{L}/gu);

// This is also equivalent (conjunction of all the subcategories using short aliases)
story.match(/\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}/gu);
Scripts and script extensionsSome languages use different scripts for their writing system. For instance, English and Spanish are written using the Latin script while Arabic and Russian are written with other scripts (respectively Arabic and Cyrillic). The Script and Script_Extensions Unicode properties allow regular expression to match characters according to the script they are mainly used with (Script) or according to the set of scripts they belong to (Script_Extensions).
For example, A belongs to the Latin script and ε to the Greek script.
jsconst mixedCharacters = "aεЛ";

// Using the canonical "long" name of the script
mixedCharacters.match(/\p{Script=Latin}/u); // a

// Using a short alias (ISO 15924 code) for the script
mixedCharacters.match(/\p{Script=Grek}/u); // ε

// Using the short name sc for the Script property
mixedCharacters.match(/\p{sc=Cyrillic}/u); // Л

For more details, refer to the Unicode specification, the Scripts table in the ECMAScript specification, and the ISO 15924 list of script codes.
If a character is used in a limited set of scripts, the Script property will only match for the "predominant" used script. If we want to match characters based on a "non-predominant" script, we could use the Script_Extensions property (Scx for short).
js// ٢ is the digit 2 in Arabic-Indic notation
// while it is predominantly written within the Arabic script
// it can also be written in the Thaana script

"٢".match(/\p{Script=Thaana}/u);
// null as Thaana is not the predominant script

"٢".match(/\p{Script_Extensions=Thaana}/u);
// ["٢", index: 0, input: "٢", groups: undefined]
Unicode property escapes vs. character classesWith JavaScript regular expressions, it is also possible to use character classes and especially \w or \d to match letters or digits. However, such forms only match characters from the Latin script (in other words, a to z and A to Z for \w and 0 to 9 for \d). As shown in this example, it might be a bit clumsy to work with non Latin texts.
Unicode property escapes categories encompass much more characters and \p{Letter} or \p{Number} will work for any script.
js// Trying to use ranges to avoid \w limitations:

const nonEnglishText = "Приключения Алисы в Стране чудес";
const regexpBMPWord = /([\u0000-\u0019\u0021-\uFFFF])+/gu;
// BMP goes through U+0000 to U+FFFF but space is U+0020

console.table(nonEnglishText.match(regexpBMPWord));

// Using Unicode property escapes instead
const regexpUPE = /\p{L}+/gu;
console.table(nonEnglishText.match(regexpUPE));
Matching pricesThe following example matches prices in a string:
jsfunction getPrices(str) {
  // Sc stands for "currency symbol"
  return [...str.matchAll(/\p{Sc}\s*[\d.,]+/gu)].map((match) => match[0]);
}

const str = `California rolls $6.99
Crunchy rolls $8.49
Shrimp tempura $10.99`;
console.log(getPrices(str)); // ["$6.99", "$8.49", "$10.99"]

const str2 = `US store $19.99
Europe store €18.99
Japan store ¥2000`;
console.log(getPrices(str2)); // ["$19.99", "€18.99", "¥2000"]
Matching stringsWith the v flag, \p{…} can match strings that are potentially longer than one character by using a property of strings:
jsconst flag = "🇺🇳";
console.log(flag.length); // 2
console.log(/\p{RGI_Emoji_Flag_Sequence}/v.exec(flag)); // [ '🇺🇳' ]

However, you can't use \P to match "a string that does not have a property", because it's unclear how many characters should be consumed.
js/\P{RGI_Emoji_Flag_Sequence}/v; // SyntaxError: Invalid regular expression: Invalid property name
SpecificationsSpecificationECMAScript Language Specification # prod-CharacterClassEscapeBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Character classes guide
Regular expressions
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W, \s, \S
Character escape: \n, \u{...}
Disjunction: |
Unicode character property on Wikipedia
ES2018: RegExp Unicode property escapes by Dr. Axel Rauschmayer (2017)
Unicode regular expressions § Properties
Unicode Utilities: UnicodeSet
RegExp v flag with set notation and properties of strings on v8.dev (2022)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Wildcard: .A wildcard matches all characters except line terminators. It also matches line terminators if the s flag is set.Syntaxregex.
Description. matches any character except line terminators. If the s flag is set, . also matches line terminators.
The exact character set matched by . depends on whether the regex is Unicode-aware. If it is Unicode-aware, . matches any Unicode code point; otherwise, it matches any UTF-16 code unit. For example:
js/../.test("😄"); // true; matches two UTF-16 code units as a surrogate pair
/../u.test("😄"); // false; input only has one Unicode character
ExamplesUsage with quantifiersWildcards are often used with quantifiers to match any character sequence, until the next character of interest is found. For example, the following example extracts the title of a Markdown page in the form # Title:
jsfunction parseTitle(entry) {
  // Use multiline mode because the title may not be at the start of
  // the file. Note that the m flag does not make . match line
  // terminators, so the title must be on a single line
  // Return text matched by the first capturing group.
  return /^#[ \t]+(.+)$/m.exec(entry)?.[1];
}

parseTitle("# Hello world"); // "Hello world"
parseTitle("## Subsection"); // undefined
parseTitle(`
---
slug: Web/JavaScript/Reference/Regular_expressions/Wildcard
---

# Wildcard: .

A **wildcard** matches all characters except line terminators.
`); // "Wildcard: ."
Matching code block contentThe following example matches the content of a code block enclosed by three backticks in Markdown. It uses the s flag to make . match line terminators, because the content of a code block may span multiple lines:
jsfunction parseCodeBlock(entry) {
  return /^```.*?^(.+?)\n```/ms.exec(entry)?.[1];
}

parseCodeBlock(`
\`\`\`js
console.log("Hello world");
\`\`\`
`); // "console.log("Hello world");"

parseCodeBlock(`
A \`try...catch\` statement must have the blocks enclosed in curly braces.

\`\`\`js example-bad
try
  doSomething();
catch (e)
  console.log(e);
\`\`\`
`); // "try\n  doSomething();\ncatch (e)\n  console.log(e);"


Warning: These examples are for demonstration only. If you want to parse Markdown, use a dedicated Markdown parser because there are many edge cases to consider.
SpecificationsSpecificationECMAScript Language Specification # prod-AtomBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Character classes guide
Regular expressions
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W, \s, \S
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Word boundary assertion: \b, \BA word boundary assertion checks if the current position in the string is a word boundary. A word boundary is where the next character is a word character and the previous character is not a word character, or vice versa.Syntaxregex\b
\B
Description\b asserts that the current position in the string is a word boundary. \B negates the assertion: it asserts that the current position is not a word boundary. Both are assertions, so unlike other character escapes or character class escapes, \b and \B don't consume any characters.
A word character includes the following:

Letters (A–Z, a–z), numbers (0–9), and underscore (_).
If the regex is Unicode-aware and the i flag is set, other Unicode characters that get canonicalized to one of the characters above through case folding.

Word characters are also matched by the \w character class escape.
Out-of-bounds input positions are considered non-word characters. For example, the following are successful matches:
js/\ba/.exec("abc");
/c\b/.exec("abc");

/\B /.exec(" abc");
/ \B/.exec("abc ");
ExamplesDetecting wordsThe following example detects if a string contains the word "thanks" or "thank you":
jsfunction hasThanks(str) {
  return /\b(thanks|thank you)\b/i.test(str);
}

hasThanks("Thanks! You helped me a lot."); // true
hasThanks("Just want to say thank you for all your work."); // true
hasThanks("Thanksgiving is around the corner."); // false


Warning: Not all languages have clearly defined word boundaries. If you are working with languages like Chinese or Thai, where there are no whitespace separators, use a more advanced library like Intl.Segmenter to search for words instead.
SpecificationsSpecificationECMAScript Language Specification # prod-AssertionBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Assertions guide
Regular expressions
Input boundary assertion: ^, $
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Character escape: \n, \u{...}
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
JavaScript error referenceBelow, you'll find a list of errors which are thrown by JavaScript. These errors can be a helpful debugging aid, but the reported problem isn't always immediately clear. The pages below will provide additional details about these errors. Each error is an object based upon the Error object, and has a name and a message.
Errors displayed in the Web console may include a link to the corresponding page below to help you quickly comprehend the problem in your code.
For a beginner's introductory tutorial on fixing JavaScript errors, see What went wrong? Troubleshooting JavaScript.List of errorsIn this list, each page is listed by name (the type of error) and message (a more detailed human-readable error message). Together, these two properties provide a starting point toward understanding and resolving the error. For more information, follow the links below!Error: Permission denied to access property "x"InternalError: too much recursionRangeError: BigInt division by zeroRangeError: BigInt negative exponentRangeError: argument is not a valid code pointRangeError: invalid array lengthRangeError: invalid dateRangeError: precision is out of rangeRangeError: radix must be an integerRangeError: repeat count must be less than infinityRangeError: repeat count must be non-negativeRangeError: x can't be converted to BigInt because it isn't an integerReferenceError: "x" is not definedReferenceError: assignment to undeclared variable "x"ReferenceError: can't access lexical declaration 'X' before initializationReferenceError: deprecated caller or arguments usageReferenceError: reference to undefined property "x"SyntaxError: "0"-prefixed octal literals and octal escape seq. are deprecatedSyntaxError: "use strict" not allowed in function with non-simple parametersSyntaxError: "x" is a reserved identifierSyntaxError: JSON.parse: bad parsingSyntaxError: Unexpected '#' used outside of class bodySyntaxError: Unexpected tokenSyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# insteadSyntaxError: a declaration in the head of a for-of loop can't have an initializerSyntaxError: applying the 'delete' operator to an unqualified name is deprecatedSyntaxError: await is only valid in async functions, async generators and modulesSyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressionsSyntaxError: continue must be inside loopSyntaxError: for-in loop head declarations may not have initializersSyntaxError: function statement requires a nameSyntaxError: getter and setter for private name #x should either be both static or non-staticSyntaxError: identifier starts immediately after numeric literalSyntaxError: illegal characterSyntaxError: invalid BigInt syntaxSyntaxError: invalid assignment left-hand sideSyntaxError: invalid regular expression flag "x"SyntaxError: label not foundSyntaxError: missing ) after argument listSyntaxError: missing ) after conditionSyntaxError: missing : after property idSyntaxError: missing ; before statementSyntaxError: missing = in const declarationSyntaxError: missing ] after element listSyntaxError: missing formal parameterSyntaxError: missing name after . operatorSyntaxError: missing variable nameSyntaxError: missing } after function bodySyntaxError: missing } after property listSyntaxError: redeclaration of formal parameter "x"SyntaxError: return not in functionSyntaxError: test for equality (==) mistyped as assignment (=)?SyntaxError: unlabeled break must be inside loop or switchSyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**'SyntaxError: unterminated string literalTypeError: "x" has no propertiesTypeError: "x" is (not) "y"TypeError: "x" is not a constructorTypeError: "x" is not a functionTypeError: "x" is not a non-null objectTypeError: "x" is read-onlyTypeError: 'x' is not iterableTypeError: More arguments neededTypeError: Reduce of empty array with no initial valueTypeError: X.prototype.y called on incompatible typeTypeError: can't assign to property "x" on "y": not an objectTypeError: can't convert BigInt to numberTypeError: can't convert x to BigIntTypeError: can't define property "x": "obj" is not extensibleTypeError: can't delete non-configurable array elementTypeError: can't redefine non-configurable property "x"TypeError: cannot use 'in' operator to search for 'x' in 'y'TypeError: cyclic object valueTypeError: invalid 'instanceof' operand 'x'TypeError: invalid Array.prototype.sort argumentTypeError: invalid assignment to const "x"TypeError: property "x" is non-configurable and can't be deletedTypeError: setting getter-only property "x"URIError: malformed URI sequenceWarning: -file- is being assigned a //# sourceMappingURL, but already has oneWarning: unreachable code after return statementFound a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Apr 18, 2023 by MDN contributors.
Error: Permission denied to access property "x"
  The JavaScript exception "Permission denied to access property" occurs when there was
  an attempt to access an object for which you have no permission.
MessageDOMException: Blocked a frame with origin "x" from accessing a cross-origin frame. (Chromium-based)
DOMException: Permission denied to access property "x" on cross-origin object (Firefox)
SecurityError: Blocked a frame with origin "x" from accessing a cross-origin frame. Protocols, domains, and ports must match. (Safari)
Error typeDOMException.What went wrong?
  There was attempt to access an object for which you have no permission. This is likely
  an <iframe> element loaded from a different domain for which you
  violated the same-origin policy.
ExamplesNo permission to access documenthtml<!doctype html>
<html lang="en-US">
  <head>
    <iframe
      id="myframe"
      src="http://www1.w3c-test.org/common/blank.html"></iframe>
    <script>
      onload = function () {
        console.log(frames[0].document);
        // Error: Permission denied to access property "document"
      };
    </script>
  </head>
  <body></body>
</html>
See also
<iframe>
Same-origin policy
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
InternalError: too much recursion
  The JavaScript exception "too much recursion" or "Maximum call stack size exceeded"
  occurs when there are too many function calls, or a function is missing a base case.
MessageRangeError: Maximum call stack size exceeded (Chrome)
InternalError: too much recursion (Firefox)
RangeError: Maximum call stack size exceeded. (Safari)
Error typeInternalError in Firefox; RangeError in Chrome and Safari.What went wrong?
  A function that calls itself is called a recursive function. Once a condition
  is met, the function stops calling itself. This is called a base case.


  In some ways, recursion is analogous to a loop. Both execute the same code multiple
  times, and both require a condition (to avoid an infinite loop, or rather, infinite
  recursion in this case). When there are too many function calls, or a function is
  missing a base case, JavaScript will throw this error.
ExamplesThis recursive function runs 10 times, as per the exit condition.
jsfunction loop(x) {
  if (x >= 10)
    // "x >= 10" is the exit condition
    return;
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

Setting this condition to an extremely high value, won't work:
jsfunction loop(x) {
  if (x >= 1000000000000) return;
  // do stuff
  loop(x + 1);
}
loop(0);

// InternalError: too much recursion


  This recursive function is missing a base case. As there is no exit condition, the
  function will call itself infinitely.

jsfunction loop(x) {
  // The base case is missing
  loop(x + 1); // Recursive call
}

loop(0);

// InternalError: too much recursion
Class error: too much recursionjsclass Person {
  constructor() {}
  set name(name) {
    this.name = name; // Recursive call
  }
}

const tony = new Person();
tony.name = "Tonisha"; // InternalError: too much recursion


  When a value is assigned to the property name (this.name = name;) JavaScript needs to
  set that property. When this happens, the setter function is triggered.

In this example when the setter is triggered, it is told to do the same thing again: to set the same property that it is meant to handle. This causes the function to call itself, again and again, making it infinitely recursive.
This issue also appears if the same variable is used in the getter.
jsclass Person {
  get name() {
    return this.name; // Recursive call
  }
}


  To avoid this problem, make sure that the property being assigned to inside the setter
  function is different from the one that initially triggered the setter. The same goes
  for the getter.

jsclass Person {
  constructor() {}
  set name(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
}
const tony = new Person();
tony.name = "Tonisha";
console.log(tony);
See also
Recursion
Recursive functions
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
RangeError: argument is not a valid code point
  The JavaScript exception "Invalid code point" occurs when NaN values,
  negative Integers (-1), non-Integers (5.4), or values larger than 0x10FFFF (1114111) are
  used with String.fromCodePoint().
MessageRangeError: Invalid code point -1 (V8-based)
RangeError: -1 is not a valid code point (Firefox)
RangeError: Arguments contain a value that is out of range of code points (Safari)
Error typeRangeErrorWhat went wrong?
String.fromCodePoint() throws this error when passed NaN
  values, negative Integers (-1), non-Integers (5.4), or values larger than 0x10FFFF
  (1114111).


  A code point is a value in the
  Unicode codespace; that is, the range of integers from 0 to
  0x10FFFF.
ExamplesInvalid casesjsString.fromCodePoint("_"); // RangeError
String.fromCodePoint(Infinity); // RangeError
String.fromCodePoint(-1); // RangeError
String.fromCodePoint(3.14); // RangeError
String.fromCodePoint(3e-2); // RangeError
String.fromCodePoint(NaN); // RangeError
Valid casesjsString.fromCodePoint(42); // "*"
String.fromCodePoint(65, 90); // "AZ"
String.fromCodePoint(0x404); // 'Є' (U+0404)
String.fromCodePoint(0x2f804); // '你' (U+2F804)
String.fromCodePoint(194564); // '你'
String.fromCodePoint(0x1d306, 0x61, 0x1d307); // '𝌆a𝌇'
See also
String.fromCodePoint()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
RangeError: BigInt division by zeroThe JavaScript exception "BigInt division by zero" occurs when a BigInt is divided by 0n.MessageRangeError: Division by zero (V8-based)
RangeError: BigInt division by zero (Firefox)
RangeError: 0 is an invalid divisor value. (Safari)
Error typeRangeError.What went wrong?The divisor of a division or remainder operator is 0n. In Number arithmetic, this produces Infinity, but there's no "infinity value" in BigInts, so an error is issued. Check if the divisor is 0n before doing the division.ExamplesDivision by 0njsconst a = 1n;
const b = 0n;
const quotient = a / b;
// RangeError: BigInt division by zero

Instead, check if the divisor is 0n first, and either issue an error with a better message, or fallback to a different value, like Infinity or undefined.
jsconst a = 1n;
const b = 0n;
const quotient = b === 0n ? undefined : a / b;
See also
BigInt
Division (/)
Remainder (%)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
RangeError: BigInt negative exponentThe JavaScript exception "BigInt negative exponent" occurs when a BigInt is raised to the power of a negative BigInt value.MessageRangeError: Exponent must be positive (V8-based)
RangeError: BigInt negative exponent (Firefox)
RangeError: Negative exponent is not allowed (Safari)
Error typeRangeError.What went wrong?The exponent of an exponentiation operation must be positive. Since negative exponents would take the reciprocal of the base, the result will be between -1 and 1 in almost all cases, which gets rounded to 0n. To catch mistakes, negative exponents are not allowed. Check if the exponent is non-negative before doing exponentiation.ExamplesUsing a negative BigInt as exponentjsconst a = 1n;
const b = -1n;
const c = a ** b;
// RangeError: BigInt negative exponent

Instead, check if the exponent is negative first, and either issue an error with a better message, or fallback to a different value, like 0n or undefined.
jsconst a = 1n;
const b = -1n;
const quotient = b >= 0n ? a ** b : 0n;
See also
BigInt
Exponentiation (**)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
RangeError: invalid array lengthThe JavaScript exception "Invalid array length" occurs when specifying an array length that is either negative, a floating number or exceeds the maximum supported by the platform (i.e. when creating an Array or ArrayBuffer, or when setting the length property).

  The maximum allowed array length depends on the platform, browser and browser version.
  For Array the maximum length is 232-1.
  For ArrayBuffer the maximum is 231-1 (2GiB-1) on 32-bit systems.
  From Firefox version 89 the maximum value of ArrayBuffer is 233 (8GiB) on 64-bit systems.


Note: Array and ArrayBuffer are independent data structures (the implementation of one does not affect the other).
MessageRangeError: invalid array length (V8-based & Firefox)
RangeError: Array buffer allocation failed (V8-based)
RangeError: Array size is not a small enough positive integer. (Safari)
Error typeRangeErrorWhat went wrong?An invalid array length might appear in these situations:

Creating an Array or ArrayBuffer with a negative length, or setting a negative value for the length property.
Creating an Array or setting the length property greater than 232-1.
Creating an ArrayBuffer that is bigger than 231-1 (2GiB-1) on a 32-bit system, or 233 (8GiB) on a 64-bit system.
Creating an Array or setting the length property to a floating-point number.
Before Firefox 89: Creating an ArrayBuffer that is bigger than 231-1 (2GiB-1).


  If you are creating an Array, using the constructor, you probably want to
  use the literal notation instead, as the first argument is interpreted as the length of
  the Array.


  Otherwise, you might want to clamp the length before setting the length property, or
  using it as argument of the constructor.
ExamplesInvalid casesjsnew Array(Math.pow(2, 40));
new Array(-1);
new ArrayBuffer(Math.pow(2, 32)); // 32-bit system
new ArrayBuffer(-1);

const a = [];
a.length = a.length - 1; // set the length property to -1

const b = new Array(Math.pow(2, 32) - 1);
b.length = b.length + 1; // set the length property to 2^32
b.length = 2.5; // set the length property to a floating-point number

const c = new Array(2.5); // pass a floating-point number
Valid casesjs[Math.pow(2, 40)]; // [ 1099511627776 ]
[-1]; // [ -1 ]
new ArrayBuffer(Math.pow(2, 31) - 1);
new ArrayBuffer(Math.pow(2, 33)); // 64-bit systems after Firefox 89
new ArrayBuffer(0);

const a = [];
a.length = Math.max(0, a.length - 1);

const b = new Array(Math.pow(2, 32) - 1);
b.length = Math.min(0xffffffff, b.length + 1);
// 0xffffffff is the hexadecimal notation for 2^32 - 1
// which can also be written as (-1 >>> 0)

b.length = 3;

const c = new Array(3);
See also
Array
length
ArrayBuffer
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 5, 2023 by MDN contributors.
RangeError: invalid date
  The JavaScript exception "invalid date" occurs when a string leading to an invalid date
  has been provided to Date or Date.parse().
MessageRangeError: Invalid time value (V8-based)
RangeError: invalid date (Firefox)
RangeError: Invalid Date (Safari)
Error typeRangeErrorWhat went wrong?
  A string leading to an invalid date has been provided to Date or
  Date.parse().
ExamplesInvalid cases
  Unrecognizable strings or dates containing illegal element values in ISO formatted
  strings usually return NaN. However, depending on the implementation,
  non–conforming ISO format strings, may also throw RangeError: invalid date,
  like the following cases in Firefox:

jsnew Date("foo-bar 2014");
new Date("2014-25-23").toISOString();
new Date("foo-bar 2014").toString();

This, however, returns NaN in Firefox:
jsDate.parse("foo-bar 2014"); // NaN

For more details, see the Date.parse() documentation.Valid casesjsnew Date("05 October 2011 14:48 UTC");
new Date(1317826080); // Unix Timestamp for 05 October 2011 14:48:00 UTC
See also
Date
Date.prototype.parse()
Date.prototype.toISOString()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
RangeError: precision is out of range
  The JavaScript exception "precision is out of range" occurs when a number that's
  outside of the range of 0 and 20 (or 21) was passed into toFixed or
  toPrecision.
MessageRangeError: toExponential() argument must be between 0 and 100 (V8-based & Safari)
RangeError: toFixed() digits argument must be between 0 and 100 (V8-based & Safari)
RangeError: toPrecision() argument must be between 1 and 100 (V8-based & Safari)
RangeError: precision -1 out of range (Firefox)
Error typeRangeErrorWhat went wrong?There was an out of range precision argument in one of these methods:

Number.prototype.toExponential(), which requires the arguments to be between 0 and 100, inclusive.
Number.prototype.toFixed(), which requires the arguments to be between 0 and 100, inclusive.
Number.prototype.toPrecision(), which requires the arguments to be between 1 and 100, inclusive.
ExamplesInvalid casesjs(77.1234).toExponential(-1); // RangeError
(77.1234).toExponential(101); // RangeError

(2.34).toFixed(-100); // RangeError
(2.34).toFixed(1001); // RangeError

(1234.5).toPrecision(-1); // RangeError
(1234.5).toPrecision(101); // RangeError
Valid casesjs(77.1234).toExponential(4); // 7.7123e+1
(77.1234).toExponential(2); // 7.71e+1

(2.34).toFixed(1); // 2.3
(2.35).toFixed(1); // 2.4 (note that it rounds up in this case)

(5.123456).toPrecision(5); // 5.1235
(5.123456).toPrecision(2); // 5.1
(5.123456).toPrecision(1); // 5
See also
Number.prototype.toExponential()
Number.prototype.toFixed()
Number.prototype.toPrecision()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
RangeError: radix must be an integer
  The JavaScript exception "radix must be an integer at least 2 and no greater than 36"
  occurs when the optional radix parameter of the
  Number.prototype.toString() or
  the BigInt.prototype.toString() method was specified and is not between 2
  and 36.
MessageRangeError: toString() radix argument must be between 2 and 36 (V8-based & Safari)
RangeError: radix must be an integer at least 2 and no greater than 36 (Firefox)
Error typeRangeErrorWhat went wrong?
  The optional radix parameter of the
  Number.prototype.toString() or
  the BigInt.prototype.toString() method was specified. Its value must be an
  integer (a number) between 2 and 36, specifying the base of the number system to be used
  for representing numeric values. For example, the decimal (base 10) number 169 is
  represented in hexadecimal (base 16) as A9.


  Why is this parameter's value limited to 36? A radix that is larger than 10 uses
  alphabetical characters as digits; therefore, the radix can't be larger than 36, since
  the Latin alphabet (used by English and many other languages) only has 26 characters.

The most common radixes:

2 for binary numbers,
8 for octal numbers,
10 for decimal numbers,
16 for hexadecimal numbers.
ExamplesInvalid casesjs(42).toString(0);
(42).toString(1);
(42).toString(37);
(42).toString(150);
// You cannot use a string like this for formatting:
(12071989).toString("MM-dd-yyyy");
Valid casesjs(42).toString(2); // "101010" (binary)
(13).toString(8); // "15" (octal)
(0x42).toString(10); // "66" (decimal)
(100000).toString(16); // "186a0" (hexadecimal)
See also
Number.prototype.toString()
BigInt.prototype.toString()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
RangeError: repeat count must be less than infinity
  The JavaScript exception "repeat count must be less than infinity" occurs when the
  String.prototype.repeat() method is used with a count
  argument that is infinity.
MessageRangeError: Invalid string length (V8-based)
RangeError: Invalid count value: Infinity (V8-based)
RangeError: repeat count must be less than infinity and not overflow maximum string size (Firefox)
RangeError: Out of memory (Safari)
RangeError: String.prototype.repeat argument must be greater than or equal to 0 and not be Infinity (Safari)
Error typeRangeErrorWhat went wrong?
  The String.prototype.repeat() method has been used. It has a
  count parameter indicating the number of times to repeat the string. It
  must be between 0 and less than positive Infinity and cannot be a negative
  number. The range of allowed values can be described like this: [0, +∞).


  The resulting string can also not be larger than the maximum string size, which can
  differ in JavaScript engines. In Firefox (SpiderMonkey) the maximum string size is
  230 - 2 (~2GiB).
ExamplesInvalid casesjs"abc".repeat(Infinity); // RangeError
"a".repeat(2 ** 30); // RangeError
Valid casesjs"abc".repeat(0); // ''
"abc".repeat(1); // 'abc'
"abc".repeat(2); // 'abcabc'
"abc".repeat(3.5); // 'abcabcabc' (count will be converted to integer)
See also
String.prototype.repeat()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
RangeError: repeat count must be non-negative
  The JavaScript exception "repeat count must be non-negative" occurs when the
  String.prototype.repeat() method is used with a count
  argument that is a negative number.
MessageRangeError: Invalid count value: -1 (V8-based)
RangeError: repeat count must be non-negative (Firefox)
RangeError: String.prototype.repeat argument must be greater than or equal to 0 and not be Infinity (Safari)
Error typeRangeErrorWhat went wrong?
  The String.prototype.repeat() method has been used. It has a
  count parameter indicating the number of times to repeat the string. It
  must be between 0 and less than positive Infinity and cannot be a negative
  number. The range of allowed values can be described like this: [0, +∞).
ExamplesInvalid casesjs"abc".repeat(-1); // RangeError
Valid casesjs"abc".repeat(0); // ''
"abc".repeat(1); // 'abc'
"abc".repeat(2); // 'abcabc'
"abc".repeat(3.5); // 'abcabcabc' (count will be converted to integer)
See also
String.prototype.repeat()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
RangeError: x can't be converted to BigInt because it isn't an integerThe JavaScript exception "x can't be converted to BigInt because it isn't an integer" occurs when the BigInt() function is used on a number that isn't an integer.MessageRangeError: The number 1.5 cannot be converted to a BigInt because it is not an integer (V8-based & Firefox)
RangeError: Not an integer (Safari)
Error typeRangeError.What went wrong?When using the BigInt() function to convert a number to a BigInt, the number must be an integer (such that Number.isInteger returns true).ExamplesInvalid casesjsconst a = BigInt(1.5);
// RangeError: The number 1.5 cannot be converted to a BigInt because it is not an integer
const b = BigInt(NaN);
// RangeError: NaN cannot be converted to a BigInt because it is not an integer
Valid casesjsconst a = BigInt(1);
See also
BigInt() constructor
Number.isInteger()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
ReferenceError: "x" is not defined
  The JavaScript exception "variable is not defined" occurs when there is a
  non-existent variable referenced somewhere.
MessageReferenceError: "x" is not defined (V8-based & Firefox)
ReferenceError: Can't find variable: x (Safari)
Error typeReferenceError.What went wrong?
  There is a non-existent variable referenced somewhere. This variable needs to be
  declared, or you need to make sure it is available in your current script or scope.



Note: When loading a library (such as jQuery), make sure it is
    loaded before you access library variables, such as "$". Put the
    <script> element that loads the library before your code that uses
    it.
  
ExamplesVariable not declaredjsfoo.substring(1); // ReferenceError: foo is not defined


  The "foo" variable isn't defined anywhere. It needs to be some string, so that the
  String.prototype.substring() method will work.

jsconst foo = "bar";
foo.substring(1); // "ar"
Wrong scope
  A variable needs to be available in the current context of execution. Variables defined
  inside a function cannot be
  accessed from anywhere outside the function, because the variable is defined only in the
  scope of the function

jsfunction numbers() {
  const num1 = 2;
  const num2 = 3;
  return num1 + num2;
}

console.log(num1); // ReferenceError num1 is not defined.


  However, a function can access all variables and functions defined inside the scope in
  which it is defined. In other words, a function defined in the global scope can access
  all variables defined in the global scope.

jsconst num1 = 2;
const num2 = 3;

function numbers() {
  return num1 + num2;
}

console.log(numbers()); // 5
See also
Scope
Declaring variables in the JavaScript Guide
Function scope in the JavaScript Guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
ReferenceError: assignment to undeclared variable "x"The JavaScript strict mode-only exception "Assignment to undeclared variable" occurs when the value has been assigned to an undeclared variable.MessageReferenceError: x is not defined (V8-based)
ReferenceError: assignment to undeclared variable x (Firefox)
ReferenceError: Can't find variable: x (Safari)
Error typeReferenceError in strict mode only.What went wrong?
  A value has been assigned to an undeclared variable.
  In other words, there was an assignment without the var keyword.
  There are some differences between declared and undeclared variables, which might lead to unexpected results and that's why JavaScript presents an error in strict mode.

Three things to note about declared and undeclared variables:


    Declared variables are constrained in the execution context in which they are declared.
    Undeclared variables are always global.
  

    Declared variables are created before any code is executed.
    Undeclared variables do not exist until the code assigning to them is executed.
  

    Declared variables are a non-configurable property of their execution context (function or global).
    Undeclared variables are configurable (e.g. can be deleted).
  

For more details and examples, see the var reference page.

  Errors about undeclared variable assignments occur in strict mode code only.
  In non-strict code, they are silently ignored.
ExamplesInvalid casesIn this case, the variable "bar" is an undeclared variable.
jsfunction foo() {
  "use strict";
  bar = true;
}
foo(); // ReferenceError: assignment to undeclared variable bar
Valid casesTo make "bar" a declared variable, you can add a let, const, or var keyword in front of it.
jsfunction foo() {
  "use strict";
  const bar = true;
}
foo();
See also
Strict mode
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
ReferenceError: can't access lexical declaration 'X' before initialization
  The JavaScript exception "can't access lexical declaration `variable' before initialization" occurs when a lexical variable was accessed before it was initialized.
  This happens within any block statement, when let or const variables are accessed before the place where they are declared is executed.
MessageReferenceError: Cannot access 'X' before initialization (V8-based)
ReferenceError: can't access lexical declaration 'X' before initialization (Firefox)
ReferenceError: Cannot access uninitialized variable. (Safari)
Error typeReferenceErrorWhat went wrong?
  A lexical variable was accessed before it was initialized.
  This happens within any block statement, when variables declared with let or const are accessed before the place where they are declared has been executed.


  Note that it is the execution order of access and variable declaration that matters, not the order in which the statements appear in the code.
  For more information, see the description of Temporal Dead Zone.

This issue does not occur for variables declared using var, because they are initialized with a default value of undefined when they are hoisted.
This error can also occur in cyclic imports when a module uses a variable that depends on the module itself being evaluated.ExamplesInvalid cases
  In this case, the variable foo is accessed before it is declared.
  At this point foo has not been initialized with a value, so accessing the variable throws a reference error.

jsfunction test() {
  // Accessing the 'const' variable foo before it's declared
  console.log(foo); // ReferenceError: foo is not initialized
  const foo = 33; // 'foo' is declared and initialized here using the 'const' keyword
}

test();

In this example, the imported variable a is accessed but is uninitialized, because the evaluation of a.js is blocked by the evaluation of the current module b.js.
js// -- a.js (entry module) --
import { b } from "./b.js";

export const a = 2;

// -- b.js --
import { a } from "./a.js";

console.log(a); // ReferenceError: Cannot access 'a' before initialization
export const b = 1;
Valid casesIn the following example, we correctly declare a variable using the const keyword before accessing it.
jsfunction test() {
  // Declaring variable foo
  const foo = 33;
  console.log(foo); // 33
}
test();

In this example, the imported variable a is asynchronously accessed, so both modules are evaluated before the access to a occurs.
js// -- a.js (entry module) --
import { b } from "./b.js";

export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);
export const b = 1;
See also
let
const
var
class
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 11, 2024 by MDN contributors.
ReferenceError: deprecated caller or arguments usage
  The JavaScript strict mode-only exception
  "deprecated caller or arguments usage" occurs when the
  deprecated Function.prototype.caller or Function.prototype.arguments properties
  are used.
MessageTypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them (V8-based & Firefox)
TypeError: 'arguments', 'callee', and 'caller' cannot be accessed in this context. (Safari)
Error typeTypeError in strict mode only.What went wrong?
  In strict mode, the
  Function.prototype.caller or Function.prototype.arguments properties are used
  and shouldn't be. They are deprecated, because they leak the function caller, are
  non-standard, hard to optimize and potentially a performance-harmful feature.
ExamplesDeprecated function.caller or arguments.callee
Function.prototype.caller and
  arguments.callee
  are deprecated (see the reference articles for more information).

js"use strict";

function myFunc() {
  if (myFunc.caller === null) {
    return "The function was called from the top!";
  } else {
    return `This function's caller was ${myFunc.caller}`;
  }
}

myFunc();
// TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
Function.prototype.arguments
Function.prototype.arguments is deprecated (see the reference article for more
  information).

js"use strict";

function f(n) {
  g(n - 1);
}

function g(n) {
  console.log(`before: ${g.arguments[0]}`);
  if (n > 0) {
    f(n);
  }
  console.log(`after: ${g.arguments[0]}`);
}

f(2);

console.log(`returned: ${g.arguments}`);
// TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
See also
Deprecated and obsolete features
Strict mode
Function.prototype.arguments
Function.prototype.caller
arguments.callee
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
ReferenceError: reference to undefined property "x"
  The JavaScript warning "reference to undefined property" occurs when a script attempted
  to access an object property which doesn't exist.
MessageReferenceError: reference to undefined property "x" (Firefox)
Error type
  (Firefox only) ReferenceError warning which is reported only if
  javascript.options.strict preference is set to true.
What went wrong?
  The script attempted to access an object property which doesn't exist. There are two
  ways to access properties; see the property accessors reference page to learn more about them.
ExamplesInvalid cases
  In this case, the property bar is an undefined property, so a
  ReferenceError will occur.

jsconst foo = {};
foo.bar; // ReferenceError: reference to undefined property "bar"
Valid cases
  To avoid the error, you need to either add a definition for bar to the
  object or check for the existence of the bar property before trying to
  access it; ways to do that include using the in operator,
  or the Object.hasOwn() method, like this:

jsconst foo = {};

// Define the bar property

foo.bar = "moon";
console.log(foo.bar); // "moon"

// Test to be sure bar exists before accessing it

if (Object.hasOwn(foo, "bar")) {
  console.log(foo.bar);
}
See also
Property accessors
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
SyntaxError: "0"-prefixed octal literals and octal escape seq. are deprecated
  The JavaScript strict mode-only exception "0-prefixed octal literals and octal escape sequences are
  deprecated; for octal literals use the "0o" prefix instead" occurs when deprecated octal
  literals and octal escape sequences are used.
MessageSyntaxError: Octal literals are not allowed in strict mode. (V8-based)
SyntaxError: "0"-prefixed octal literals are deprecated; use the "0o" prefix instead (Firefox)
SyntaxError: Decimal integer literals with a leading zero are forbidden in strict mode (Safari)

SyntaxError: Octal escape sequences are not allowed in strict mode. (V8-based)
SyntaxError: octal escape sequences can't be used in untagged template literals or in strict mode code (Firefox)
SyntaxError: The only valid numeric escape in strict mode is '\0' (Safari)
Error typeSyntaxError in strict mode only.What went wrong?
  Octal literals and octal escape sequences are deprecated and will throw a
  SyntaxError in strict mode. The
  standardized syntax uses a leading zero followed by a lowercase or uppercase Latin
  letter "O" (0o or 0O).
Examples"0"-prefixed octal literalsjs"use strict";

03;

// SyntaxError: "0"-prefixed octal literals are deprecated; use the "0o" prefix instead
Octal escape sequencesjs"use strict";

"\251";

// SyntaxError: octal escape sequences can't be used in untagged template literals or in strict mode code
Valid octal numbersUse a leading zero followed by the letter "o" or "O":
js0o3;

For octal escape sequences, you can use hexadecimal escape sequences instead:
js"\xA9";
See also
Lexical grammar
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: "use strict" not allowed in function with non-simple parameters
  The JavaScript exception ""use strict" not allowed in function" occurs
  when a "use strict" directive is used at the top of a function with
  default parameters,
  rest parameters, or
  destructuring parameters.
MessageSyntaxError: Illegal 'use strict' directive in function with non-simple parameter list (V8-based)
SyntaxError: "use strict" not allowed in function with default parameter (Firefox)
SyntaxError: "use strict" not allowed in function with rest parameter (Firefox)
SyntaxError: "use strict" not allowed in function with destructuring parameter (Firefox)
SyntaxError: 'use strict' directive not allowed inside a function with a non-simple parameter list. (Safari)
Error typeSyntaxError.What went wrong?
  A "use strict" directive is written at the top of a function that has one
  of the following parameters:


Default parameters
Rest parameters
Destructuring parameters


  A "use strict" directive is not allowed at the top of such functions per
  the ECMAScript specification.
ExamplesFunction statement
  In this case, the function sum has default parameters a=1 and
  b=2:

jsfunction sum(a = 1, b = 2) {
  // SyntaxError: "use strict" not allowed in function with default parameter
  "use strict";
  return a + b;
}


  If the function should be in strict mode, and the
  entire script or enclosing function is also okay to be in strict mode, you can move the
  "use strict" directive outside of the function:

js"use strict";
function sum(a = 1, b = 2) {
  return a + b;
}
Function expressionA function expression can use yet another workaround:
jsconst sum = function sum([a, b]) {
  // SyntaxError: "use strict" not allowed in function with destructuring parameter
  "use strict";
  return a + b;
};

This can be converted to the following expression:
jsconst sum = (function () {
  "use strict";
  return function sum([a, b]) {
    return a + b;
  };
})();
Arrow function
  If an arrow function needs to access the this variable, you can use the
  arrow function as the enclosing function:

jsconst callback = (...args) => {
  // SyntaxError: "use strict" not allowed in function with rest parameter
  "use strict";
  return this.run(args);
};

This can be converted to the following expression:
jsconst callback = (() => {
  "use strict";
  return (...args) => {
    return this.run(args);
  };
})();
See also
Strict mode
function statement
function expression
Default parameters
Rest parameters
Destructuring parameters
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: "x" is a reserved identifier
  The JavaScript exception "variable is a reserved identifier" occurs
  when reserved keywords are used as identifiers.
MessageSyntaxError: Unexpected reserved word (V8-based)
SyntaxError: implements is a reserved identifier (Firefox)
SyntaxError: Cannot use the reserved word 'implements' as a variable name. (Safari)
Error typeSyntaxErrorWhat went wrong?
Reserved keywords will throw in
  if they are used as identifiers. These are reserved in
  strict mode and sloppy mode:


enum

The following are only reserved when they are found in strict mode code:

implements
interface
let
package
private
protected
public
static
ExamplesStrict and non-strict reserved keywordsThe enum identifier is generally reserved.
jsconst enum = { RED: 0, GREEN: 1, BLUE: 2 };
// SyntaxError: enum is a reserved identifier

In strict mode code, more identifiers are reserved.
js"use strict";
const package = ["potatoes", "rice", "fries"];
// SyntaxError: package is a reserved identifier

You'll need to rename these variables.
jsconst colorEnum = { RED: 0, GREEN: 1, BLUE: 2 };
const list = ["potatoes", "rice", "fries"];
Update older browsers
  If you are using an older browser that does not yet implement
  let or
  class,
  for example, you should update to a more recent browser version that does support these
  new language features.

js"use strict";
class DocArchiver {}

// SyntaxError: class is a reserved identifier
// (throws in older browsers only, e.g. Firefox 44 and older)
See also
Lexical grammar
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
SyntaxError: a declaration in the head of a for-of loop can't have an initializerThe JavaScript exception "a declaration in the head of a for-of loop can't have an initializer" occurs when the head of a for...of loop contains an initializer expression such as for (const i = 0 of iterable). This is not allowed in for-of loops.MessageSyntaxError: for-of loop variable declaration may not have an initializer. (V8-based)
SyntaxError: a declaration in the head of a for-of loop can't have an initializer (Firefox)
SyntaxError: Cannot assign to the loop variable inside a for-of loop header. (Safari)
Error typeSyntaxErrorWhat went wrong?The head of a for...of loop contains an initializer expression. That is, a variable is declared and assigned a value for (const i = 0 of iterable). This is not allowed in for-of loops. You might want a for loop that does allow an initializer.ExamplesInvalid for-of loopjsconst iterable = [10, 20, 30];

for (const value = 50 of iterable) {
  console.log(value);
}

// SyntaxError: a declaration in the head of a for-of loop can't
// have an initializer
Valid for-of loopYou need to remove the initializer (value = 50) in the head of the for-of loop. Maybe you intended to make 50 an offset value, in that case you could add it to the loop body, for example.
jsconst iterable = [10, 20, 30];

for (let value of iterable) {
  value += 50;
  console.log(value);
}
// 60
// 70
// 80
See also
for...of
for...in
for
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
SyntaxError: applying the 'delete' operator to an unqualified name is deprecatedThe JavaScript strict mode-only exception "applying the 'delete' operator to an unqualified name is deprecated" occurs when variables are attempted to be deleted using the delete operator.MessageSyntaxError: Delete of an unqualified identifier in strict mode. (V8-based)
SyntaxError: applying the 'delete' operator to an unqualified name is deprecated (Firefox)
SyntaxError: Cannot delete unqualified property 'a' in strict mode. (Safari)
Error typeSyntaxError in strict mode only.What went wrong?Normal variables in JavaScript can't be deleted using the delete operator. In strict mode, an attempt to delete a variable will throw an error and is not allowed.
The delete operator can only delete properties on an object. Object properties are "qualified" if they are configurable.
Unlike what common belief suggests, the delete operator has nothing to do with directly freeing memory. Memory management is done indirectly via breaking references, see the memory management page and the delete operator page for more details.
This error only happens in strict mode code. In non-strict code, the operation just returns false.ExamplesFreeing the contents of a variableAttempting to delete a plain variable throws an error in strict mode:
js"use strict";

var x;

// …

delete x;

// SyntaxError: applying the 'delete' operator to an unqualified name
// is deprecated

To free the contents of a variable, you can set it to null:
js"use strict";

var x;

// …

x = null;

// x can be garbage collected
See also
delete
Memory management
TypeError: property "x" is non-configurable and can't be deleted
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: await is only valid in async functions, async generators and modulesThe JavaScript exception "await is only valid in async functions, async generators and modules" occurs when an await expression is used outside of async functions or modules or other async contexts.MessageSyntaxError: await is only valid in async functions and the top level bodies of modules (V8-based)
SyntaxError: await is only valid in async functions, async generators and modules (Firefox)
SyntaxError: Unexpected identifier (Safari)
Error typeSyntaxError.What went wrong?JavaScript execution is never blocking: an await can never block the execution of the program. Instead, it pauses the execution of the surrounding async task, while allowing other tasks to continue running. Therefore, await cannot be used in sync tasks, such as functions, generator functions, or top level of scripts. It is not always apparent whether the current file is a script or a module — see the Modules guide for more information.ExamplesTop-level awaitYou cannot use await at the top level of a script:
html<script>
  await fetch("https://example.com");
  // SyntaxError: await is only valid in async functions, async generators and modules
</script>

Instead, make the script a module:
html<script type="module">
  await fetch("https://example.com");
</script>
Async callbacksYou cannot use await in a sync callback:
jsurls.forEach((url) => {
  await fetch(url);
  // SyntaxError: await is only valid in async functions, async generators and modules
});

Instead, make the callback async. See more explanation in the Using promises guide.
jsPromise.all(
  urls.map(async (url) => {
    await fetch(url);
  }),
);
See also
await
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressionsThe JavaScript exception "cannot use ?? unparenthesized within || and && expressions" occurs when an nullish coalescing operator is used with a logical OR or logical AND in the same expression without parentheses.MessageSyntaxError: Unexpected token '??' (V8-based)
SyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressions (Firefox)
SyntaxError: Unexpected token '??'. Coalescing and logical operators used together in the same expression; parentheses must be used to disambiguate. (Safari)
Error typeSyntaxErrorWhat went wrong?The operator precedence chain looks like this:
|   >   &&   >   ||   >   =
|   >   ??   >   =

However, the precedence between ?? and &&/|| is intentionally undefined, because the short circuiting behavior of logical operators can make the expression's evaluation counter-intuitive. Therefore, the following combinations are all syntax errors, because the language doesn't know how to parenthesize the operands:
jsa ?? b || c;
a || b ?? c;
a ?? b && c;
a && b ?? c;

Instead, make your intent clear by parenthesizing either side explicitly:
js(a ?? b) || c;
a ?? (b && c);
ExamplesWhen migrating legacy code that uses || and && for guarding against null or undefined, you may often convert it partially:
jsfunction getId(user, fallback) {
  // Previously: user && user.id || fallback
  return user && user.id ?? fallback; // SyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressions
}

Instead, consider parenthesizing the &&:
jsfunction getId(user, fallback) {
  return (user && user.id) ?? fallback;
}

Even better, consider using optional chaining instead of &&:
jsfunction getId(user, fallback) {
  return user?.id ?? fallback;
}
See also
Issue about nullish coalescing precedence in the TC39 nullish-coalescing proposal
Nullish coalescing operator (??)
Operator precedence
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxError: continue must be inside loopThe JavaScript exception "continue must be inside loop" occurs when a continue statement is not inside a loop statement.MessageSyntaxError: Illegal continue statement: no surrounding iteration statement (V8-based)
SyntaxError: Illegal continue statement: 'label' does not denote an iteration statement (V8-based)
SyntaxError: continue must be inside loop (Firefox)
SyntaxError: 'continue' is only valid inside a loop statement. (Safari)
SyntaxError: Cannot continue to the label 'label' as it is not targeting a loop. (Safari)
Error typeSyntaxError.What went wrong?continue statements can be used to continue a loop, and using them elsewhere is a syntax error. Alternatively, you can provide a label to the continue statement to continue any loop with that label — however, if the label does not reference a containing statement, another error SyntaxError: label not found will be thrown, and if the label references a statement that is not a loop, a syntax error is still thrown.ExamplesUsing continue in callbacksIf you want to proceed with the next iteration in a forEach() loop, use return instead, or convert it to a for...of loop.
jsarray.forEach((value) => {
  if (value === 5) {
    continue; // SyntaxError: continue must be inside loop
  }
  // do something with value
});

jsarray.forEach((value) => {
  if (value === 5) {
    return;
  }
  // do something with value
});

jsfor (const value of array) {
  if (value === 5) {
    continue;
  }
  // do something with value
}
See also
continue
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: for-in loop head declarations may not have initializers
  The JavaScript strict mode-only exception
  "for-in loop head declarations may not have initializers"
  occurs when the head of a for...in contains
  an initializer expression, such as for (var i = 0 in obj). This is not
  allowed in for-in loops in strict mode. In addition, lexical declarations with initializers like for (const i = 0 in obj) are not allowed outside strict mode either.
MessageSyntaxError: for-in loop variable declaration may not have an initializer. (V8-based)
SyntaxError: for-in loop head declarations may not have initializers (Firefox)
SyntaxError: a lexical declaration in the head of a for-in loop can't have an initializer (Firefox)
SyntaxError: Cannot assign to the loop variable inside a for-in loop header. (Safari)
Error typeSyntaxError.What went wrong?
  The head of a for...in loop contains an initializer expression.
  That is, a variable is declared and assigned a value for (var i = 0 in obj).
  In non-strict mode, this head declaration is silently ignored and behaves like for (var i in obj).
  In strict mode, however, a SyntaxError is thrown. In addition, lexical declarations with initializers like for (const i = 0 in obj) are not allowed outside strict mode either, and will always produce a SyntaxError.
ExamplesThis example throws a SyntaxError:
jsconst obj = { a: 1, b: 2, c: 3 };

for (const i = 0 in obj) {
  console.log(obj[i]);
}

// SyntaxError: for-in loop head declarations may not have initializers
Valid for-in loopYou can remove the initializer (i = 0) in the head of the for-in loop.
jsconst obj = { a: 1, b: 2, c: 3 };

for (const i in obj) {
  console.log(obj[i]);
}
Array iteration
  The for...in loop shouldn't be used for Array iteration.
  Did you intend to use a for loop
  instead of a for-in loop to iterate an Array? The
  for loop allows you to set an initializer then as well:

jsconst arr = ["a", "b", "c"];

for (let i = 2; i < arr.length; i++) {
  console.log(arr[i]);
}

// "c"
See also
for...in
for...of
for
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
SyntaxError: function statement requires a name
  The JavaScript exception "function statement requires a name" occurs
  when there is a function statement
  in the code that requires a name.
MessageSyntaxError: Function statements require a function name (V8-based)
SyntaxError: function statement requires a name (Firefox)
SyntaxError: Function statements must have a name. (Safari)
Error typeSyntaxErrorWhat went wrong?
  There is a function statement in the code that requires a name.
  You'll need to check how functions are defined and if you need to provide a name for it, or if the function in question needs to be a function expression, an IIFE, or if the function code is placed correctly in this context at all.
ExamplesStatements vs. expressions
  A function statement (or function declaration) requires a name.
  This won't work:

jsfunction () {
  return "Hello world";
}
// SyntaxError: function statement requires a name

You can use a function expression (assignment) instead:
jsconst greet = function () {
  return "Hello world";
};

If your function is intended to be an IIFE (Immediately Invoked Function Expression, which is a function that runs as soon as it is defined) you will need to add a few more braces:
js(function () {
  // …
})();
Labeled functionsLabels are an entirely different feature from function names. You can't use a label as a function name.
jsfunction Greeter() {
  german: function () {
    return "Moin";
  }
}
// SyntaxError: function statement requires a name

In addition, labeled function declarations themselves are a deprecated feature. Use regular function declarations instead.
jsfunction Greeter() {
  function german() {
    return "Moin";
  }
}
Object methods
  If you intended to create a method of an object, you will need to create an object.
  The following syntax without a name after the function keyword is valid then.

jsconst greeter = {
  german: function () {
    return "Moin";
  },
};

You can also use the method syntax.
jsconst greeter = {
  german() {
    return "Moin";
  },
};
Callback syntax
  Also, check your syntax when using callbacks.
  Braces and commas can quickly get confusing.

jspromise.then(
  function () {
    console.log("success");
  });
  function () {
    console.log("error");
}
// SyntaxError: function statement requires a name

Correct would be:
jspromise.then(
  function () {
    console.log("success");
  },
  function () {
    console.log("error");
  },
);
See also
Functions guide
function
function expression
IIFE
Labeled statement
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
SyntaxError: getter and setter for private name #x should either be both static or non-staticThe JavaScript exception "mismatched placement" occurs when a private getter and setter are mismatched in whether or not they are static.MessageSyntaxError: Identifier '#x' has already been declared (V8-based)
SyntaxError: getter and setter for private name #x should either be both static or non-static (Firefox)
SyntaxError: Cannot declare a private non-static getter if there is a static private setter with used name. (Safari)
Error typeSyntaxErrorWhat went wrong?Private getters and setters for the same name must either be both static, or both non-static. This limitation does not exist for public methods.ExamplesMismatched placementjsclass Test {
  static set #foo(_) {}
  get #foo() {}
}

// SyntaxError: getter and setter for private name #foo should either be both static or non-static

Since foo is private, the methods must be either both static:
jsclass Test {
  static set #foo(_) {}
  static get #foo() {}
}

or non-static:
jsclass Test {
  set #foo(_) {}
  get #foo() {}
}
See also
get
set
static
Private properties
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
SyntaxError: identifier starts immediately after numeric literal
  The JavaScript exception "identifier starts immediately after numeric literal" occurs
  when an identifier started with a digit. Identifiers can only start with a letter,
  underscore (_), or dollar sign ($).
MessageSyntaxError: Unexpected identifier after numeric literal (Edge)
SyntaxError: identifier starts immediately after numeric literal (Firefox)
SyntaxError: Unexpected number (Chrome)
Error typeSyntaxErrorWhat went wrong?
  The names of variables, called identifiers, conform to certain rules,
  which your code must adhere to!


  A JavaScript identifier must start with a letter, underscore (_), or dollar sign ($).
  They can't start with a digit! Only subsequent characters can be digits (0-9).
ExamplesVariable names starting with numeric literalsVariable names can't start with numbers in JavaScript. The following fails:
jsconst 1life = "foo";
// SyntaxError: identifier starts immediately after numeric literal

const foo = 1life;
// SyntaxError: identifier starts immediately after numeric literal

alert(1.foo);
// SyntaxError: identifier starts immediately after numeric literal

You will need to rename your variable to avoid the leading number.
jsconst life1 = "foo";
const foo = life1;
See also
Lexical grammar
Grammar and types guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
SyntaxError: illegal character
  The JavaScript exception "illegal character" occurs when there is an invalid or
  unexpected token that doesn't belong at this position in the code.
MessageSyntaxError: Invalid character (Edge)
SyntaxError: illegal character (Firefox)
SyntaxError: Invalid or unexpected token (Chrome)
Error typeSyntaxErrorWhat went wrong?
  There is an invalid or unexpected token that doesn't belong at this position in the
  code. Use an editor that supports syntax highlighting and carefully check your code
  against mismatches like a minus sign (-) versus a dash (–)
  or simple quotes (") versus non-standard quotation marks (").
ExamplesMismatched characters
  Some characters look similar, but will cause the parser to fail interpreting your code.
  Famous examples of this are quotes, the minus or semicolon
  (greek question mark (U+37e) looks same).

js“This looks like a string”; // SyntaxError: illegal character
// “ and ” are not " but look like it

42 – 13; // SyntaxError: illegal character
// – (en-dash) is not - but looks like it

const foo = "bar"; // SyntaxError: illegal character
// <37e> is not ; but looks like it

This should work:
js"This is actually a string";
42 - 13;
const foo = "bar";

Some editors and IDEs will notify you or at least use a slightly different highlighting for it, but not all. When something like this happens to your code and you're not able to find the source of the problem, it's often best to just delete the problematic line and retype it.Forgotten charactersIt's easy to forget a character here or there.
jsconst colors = ["#000", #333", "#666"];
// SyntaxError: illegal character

Add the missing quote for "#333".
jsconst colors = ["#000", "#333", "#666"];
Hidden characters
  When copy pasting code from external sources, there might be invalid characters. Watch
  out!

jsconst foo = "bar";​
// SyntaxError: illegal character


  When inspecting this code in an editor like Vim, you can see that there is actually a
  zero-width space (ZWSP) (U+200B) character.

jsconst foo = "bar";<200b>
See also
Lexical grammar
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: invalid assignment left-hand sideThe JavaScript exception "invalid assignment left-hand side" occurs when there was an unexpected assignment somewhere. It may be triggered when a single = sign was used instead of == or ===.MessageSyntaxError: Invalid left-hand side in assignment (V8-based)
SyntaxError: invalid assignment left-hand side (Firefox)
SyntaxError: Left side of assignment is not a reference. (Safari)
Error typeSyntaxError or ReferenceError, depending on the syntax.What went wrong?There was an unexpected assignment somewhere. This might be due to a mismatch of an assignment operator and an equality operator, for example. While a single = sign assigns a value to a variable, the == or === operators compare a value.ExamplesTypical invalid assignmentsjsif (Math.PI + 1 = 3 || Math.PI + 1 = 4) {
  console.log("no way!");
}
// SyntaxError: invalid assignment left-hand side

const str = "Hello, "
+= "is it me "
+= "you're looking for?";
// SyntaxError: invalid assignment left-hand side

In the if statement, you want to use an equality operator (===), and for the string concatenation, the plus (+) operator is needed.
jsif (Math.PI + 1 === 3 || Math.PI + 1 === 4) {
  console.log("no way!");
}

const str = "Hello, "
  + "from the "
  + "other side!";
Assignments producing ReferenceErrorsInvalid assignments don't always produce syntax errors. Sometimes the syntax is almost correct, but at runtime, the left hand side expression evaluates to a value instead of a reference, so the assignment is still invalid. Such errors occur later in execution, when the statement is actually executed.
jsfunction foo() {
  return { a: 1 };
}
foo() = 1; // ReferenceError: invalid assignment left-hand side

Function calls, new calls, super(), and this are all values instead of references. If you want to use them on the left hand side, the assignment target needs to be a property of their produced values instead.
jsfunction foo() {
  return { a: 1 };
}
foo().a = 1;


Note: In Firefox and Safari, the first example produces a ReferenceError in non-strict mode, and a SyntaxError in strict mode. Chrome throws a runtime ReferenceError for both strict and non-strict modes.
Using optional chaining as assignment targetOptional chaining is not a valid target of assignment.
jsobj?.foo = 1; // SyntaxError: invalid assignment left-hand side

Instead, you have to first guard the nullish case.
jsif (obj) {
  obj.foo = 1;
}
See also
Assignment operators
Equality operators
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 1, 2023 by MDN contributors.
SyntaxError: invalid BigInt syntaxThe JavaScript exception "invalid BigInt syntax" occurs when a string value is being coerced to a BigInt but it failed to be parsed as an integer.MessageSyntaxError: Cannot convert x to a BigInt (V8-based)
SyntaxError: invalid BigInt syntax (Firefox)
SyntaxError: Failed to parse String to BigInt (Safari)
Error typeSyntaxError.What went wrong?When using the BigInt() function to convert a string to a BigInt, the string will be parsed in the same way as source code, and the resulting value must be an integer value.ExamplesInvalid casesjsconst a = BigInt("1.5");
const b = BigInt("1n");
const c = BigInt.asIntN(4, "8n");
// SyntaxError: invalid BigInt syntax
Valid casesjsconst a = BigInt("1");
const b = BigInt("  1   ");
const c = BigInt.asIntN(4, "8");
See also
BigInt
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Feb 21, 2023 by MDN contributors.
SyntaxError: invalid regular expression flag "x"The JavaScript exception "invalid regular expression flag" occurs when the flags in a regular expression contain any flag that is not one of: d, g, i, m, s, u, v, or y.
It may also be raised if the expression contains more than one instance of a valid flag.MessageSyntaxError: Invalid regular expression flags (V8-based)
SyntaxError: invalid regular expression flag x (Firefox)
SyntaxError: Invalid regular expression: invalid flags (Safari)
Error typeSyntaxErrorWhat went wrong?The regular expression contains invalid flags, or valid flags have been used more than once in the expression.
The valid (allowed) flags are d, g, i, m, s, u, v, and y. They are introduced in more detail in Regular expressions > Advanced searching with flags.Examples
  In a regular expression literal, which consists of a pattern enclosed between slashes, the flags are defined after the second slash.
  Regular expression flags can be used separately or together in any order.
  This syntax shows how to declare the flags using the regular expression literal:

jsconst re = /pattern/flags;

They can also be defined in the constructor function of the RegExp object (second parameter):
jsconst re = new RegExp("pattern", "flags");

Here is an example showing use of only correct flags.
js/foo/g;
/foo/gims;
/foo/uy;

Below is an example showing the use of some invalid flags b, a and r:
js/foo/bar;

// SyntaxError: invalid regular expression flag "b"

The code below is incorrect, because W, e and b are not valid flags.
jsconst obj = {
  url: /docs/Web,
};

// SyntaxError: invalid regular expression flag "W"


  An expression containing two slashes is interpreted as a regular expression literal.
  Most likely the intent was to create a string literal, using single or double quotes as shown below:

jsconst obj = {
  url: "/docs/Web",
};
See also
Regular expressions guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxError: JSON.parse: bad parsing
  The JavaScript exceptions thrown by JSON.parse() occur when string failed
  to be parsed as JSON.
MessageSyntaxError: JSON.parse: unterminated string literal
SyntaxError: JSON.parse: bad control character in string literal
SyntaxError: JSON.parse: bad character in string literal
SyntaxError: JSON.parse: bad Unicode escape
SyntaxError: JSON.parse: bad escape character
SyntaxError: JSON.parse: unterminated string
SyntaxError: JSON.parse: no number after minus sign
SyntaxError: JSON.parse: unexpected non-digit
SyntaxError: JSON.parse: missing digits after decimal point
SyntaxError: JSON.parse: unterminated fractional number
SyntaxError: JSON.parse: missing digits after exponent indicator
SyntaxError: JSON.parse: missing digits after exponent sign
SyntaxError: JSON.parse: exponent part is missing a number
SyntaxError: JSON.parse: unexpected end of data
SyntaxError: JSON.parse: unexpected keyword
SyntaxError: JSON.parse: unexpected character
SyntaxError: JSON.parse: end of data while reading object contents
SyntaxError: JSON.parse: expected property name or '}'
SyntaxError: JSON.parse: end of data when ',' or ']' was expected
SyntaxError: JSON.parse: expected ',' or ']' after array element
SyntaxError: JSON.parse: end of data when property name was expected
SyntaxError: JSON.parse: expected double-quoted property name
SyntaxError: JSON.parse: end of data after property name when ':' was expected
SyntaxError: JSON.parse: expected ':' after property name in object
SyntaxError: JSON.parse: end of data after property value in object
SyntaxError: JSON.parse: expected ',' or '}' after property value in object
SyntaxError: JSON.parse: expected ',' or '}' after property-value pair in object literal
SyntaxError: JSON.parse: property names must be double-quoted strings
SyntaxError: JSON.parse: expected property name or '}'
SyntaxError: JSON.parse: unexpected character
SyntaxError: JSON.parse: unexpected non-whitespace character after JSON data
Error typeSyntaxErrorWhat went wrong?
JSON.parse() parses a string as JSON. This string has to be valid JSON
  and will throw this error if incorrect syntax was encountered.
ExamplesJSON.parse() does not allow trailing commasBoth lines will throw a SyntaxError:
jsJSON.parse("[1, 2, 3, 4,]");
JSON.parse('{"foo": 1,}');
// SyntaxError JSON.parse: unexpected character
// at line 1 column 14 of the JSON data

Omit the trailing commas to parse the JSON correctly:
jsJSON.parse("[1, 2, 3, 4]");
JSON.parse('{"foo": 1}');
Property names must be double-quoted stringsYou cannot use single-quotes around properties, like 'foo'.
jsJSON.parse("{'foo': 1}");
// SyntaxError: JSON.parse: expected property name or '}'
// at line 1 column 2 of the JSON data

Instead write "foo":
jsJSON.parse('{"foo": 1}');
Leading zeros and decimal points
  You cannot use leading zeros, like 01, and decimal points must be followed by at least
  one digit.

jsJSON.parse('{"foo": 01}');
// SyntaxError: JSON.parse: expected ',' or '}' after property value
// in object at line 1 column 2 of the JSON data

JSON.parse('{"foo": 1.}');
// SyntaxError: JSON.parse: unterminated fractional number
// at line 1 column 2 of the JSON data

Instead write just 1 without a zero and use at least one digit after a decimal point:
jsJSON.parse('{"foo": 1}');
JSON.parse('{"foo": 1.0}');
See also
JSON
JSON.parse()
JSON.stringify()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
SyntaxError: label not foundThe JavaScript exception "label not found" occurs when a break or continue statement references a label that does not exist on any statement that contains the break or continue statement.MessageSyntaxError: Undefined label 'label' (V8-based)
SyntaxError: label not found (Firefox)
SyntaxError: Cannot use the undeclared label 'label'. (Safari)
Error typeSyntaxError.What went wrong?In JavaScript, labels are very limited: you can only use them with break and continue statements, and you can only jump to them from a statement contained within the labeled statement. You cannot jump to this label from anywhere in the program.ExamplesUnsyntactic jumpYou cannot use labels as if they are goto.
jsstart: console.log("Hello, world!");
console.log("Do it again");
break start;

Instead, you can only use labels to enhance the normal semantics of break and continue statements.
jsstart: {
  console.log("Hello, world!");
  if (Math.random() > 0.5) {
    break start;
  }
  console.log("Maybe I'm logged");
}
See also
Labeled statement
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxError: missing ; before statement
  The JavaScript exception "missing ; before statement" occurs when there is a semicolon (;)
  missing somewhere and can't be added
  by automatic semicolon insertion (ASI).
  You need to provide a semicolon, so that JavaScript can parse the source code correctly.
MessageSyntaxError: Expected ';' (Edge)
SyntaxError: missing ; before statement (Firefox)
Error typeSyntaxError.What went wrong?
  There is a semicolon (;) missing somewhere. JavaScript statements must
  be terminated with semicolons. Some of them are affected
  by automatic semicolon insertion (ASI),
  but in this case you need to provide a semicolon,
  so that JavaScript can parse the source code correctly.


  However, oftentimes, this error is only a consequence of another error, like not
  escaping strings properly, or using var wrongly. You might also have too
  many parenthesis somewhere. Carefully check the syntax when this error is thrown.
ExamplesUnescaped strings
  This error can occur easily when not escaping strings properly and the JavaScript
  engine is expecting the end of your string already. For example:

jsconst foo = 'Tom's bar';
// SyntaxError: missing ; before statement

You can use double quotes, or escape the apostrophe:
jsconst foo = "Tom's bar";
// OR
const foo = 'Tom\'s bar';
Declaring properties with keyword
  You cannot declare properties of an object or array with a
  let, const, or var declaration.

jsconst obj = {};
const obj.foo = "hi"; // SyntaxError missing ; before statement

const array = [];
const array[0] = "there"; // SyntaxError missing ; before statement

Instead, omit the keyword:
jsconst obj = {};
obj.foo = "hi";

const array = [];
array[0] = "there";
Bad keywords
  If you come from another programming language, it is also common to use keywords that
  don't mean the same or have no meaning at all in JavaScript:

jsdef print(info) {
  console.log(info);
} // SyntaxError missing ; before statement

Instead, use function instead of def:
jsfunction print(info) {
  console.log(info);
}
See also
Automatic semicolon insertion (ASI)
Statements and declarations
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxError: missing : after property id
  The JavaScript exception "missing : after property id" occurs when objects are created
  using the object initializer syntax.
  A colon (:) separates keys and values for the
  object's properties. Somehow, this colon is missing or misplaced.
MessageSyntaxError: Invalid shorthand property initializer (V8-based)
SyntaxError: missing : after property id (Firefox)
SyntaxError: Unexpected token '='. Expected a ':' following the property name 'x'. (Safari)
SyntaxError: Unexpected token '+'. Expected an identifier as property name. (Safari)
Error typeSyntaxErrorWhat went wrong?
  When creating objects with the object initializer syntax,
  a colon (:) separates keys and values for the object's properties.

jsconst obj = { propertyKey: "value" };
ExamplesColons vs. equal signs
  This code fails, as the equal sign can't be used this way in this object initializer
  syntax.

jsconst obj = { propertyKey = "value" };
// SyntaxError: missing : after property id


  Correct would be to use a colon, or to use square brackets to assign a new property
  after the object has been created already.

jsconst obj = { propertyKey: "value" };

Or alternatively:
jsconst obj = {};
obj.propertyKey = "value";
Computed properties
  If you create a property key from an expression, you need to use square brackets.
  Otherwise the property name can't be computed:

jsconst obj = { "b"+"ar": "foo" };
// SyntaxError: missing : after property id

Put the expression in square brackets []:
jsconst obj = { ["b" + "ar"]: "foo" };
See also
Object initializer
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
SyntaxError: missing ) after argument list
  The JavaScript exception "missing ) after argument list" occurs when there is an error
  with how a function is called. This might be a typo, a missing operator, or an unescaped
  string.
MessageSyntaxError: missing ) after argument list (V8-based & Firefox)
SyntaxError: Unexpected identifier 'x'. Expected ')' to end an argument list. (Safari)
Error typeSyntaxError.What went wrong?
  There is an error with how a function is called. This might be a typo, a missing
  operator, or an unescaped string, for example.
Examples
  Because there is no "+" operator to concatenate the string, JavaScript expects the
  argument for the log function to be just "PI: ". In that case,
  it should be terminated by a closing parenthesis.

jsconsole.log("PI: " Math.PI);
// SyntaxError: missing ) after argument list

You can correct the log call by adding the + operator:
jsconsole.log("PI: " + Math.PI);
// "PI: 3.141592653589793"

Alternatively, you can consider using a template literal, or take advantage of the fact that console.log accepts multiple parameters:
jsconsole.log(`PI: ${Math.PI}`);
console.log("PI:", Math.PI);
Unterminated stringsjsconsole.log('"Java" + "Script" = \"' + "Java" + 'Script\");
// SyntaxError: missing ) after argument list


  Here JavaScript thinks that you meant to have ); inside the string and
  ignores it, and it ends up not knowing that you meant the ); to end the
  function console.log. To fix this, we could put a' after the
  "Script" string:

jsconsole.log('"Java" + "Script" = "' + "Java" + 'Script"');
// '"Java" + "Script" = "JavaScript"'
See also
Functions guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 15, 2023 by MDN contributors.
SyntaxError: missing ) after condition
  The JavaScript exception "missing ) after condition" occurs when there is an error with
  how an
  if
  condition is written. It must appear in parenthesis after the if keyword.
MessageSyntaxError: missing ) after condition (Firefox)
SyntaxError: Unexpected token '{'. Expected ')' to end an 'if' condition. (Safari)
Error typeSyntaxErrorWhat went wrong?
  There is an error with how an
  if
  condition is written. In any programming language, code needs to make decisions and
  carry out actions accordingly depending on different inputs. The if statement executes a
  statement if a specified condition is truthy. In JavaScript, this condition must appear
  in parenthesis after the if keyword, like this:

jsif (condition) {
  // do something if the condition is true
}
ExamplesMissing parenthesisIt might just be an oversight, carefully check all you parenthesis in your code.
jsif (Math.PI < 3 {
  console.log("wait what?");
}

// SyntaxError: missing ) after condition

To fix this code, you would need to add a parenthesis that closes the condition.
jsif (Math.PI < 3) {
  console.log("wait what?");
}
Misused is keyword
  If you are coming from another programming language, it is also easy to add keywords
  that don't mean the same or have no meaning at all in JavaScript.

jsif (done is true) {
 console.log("we are done!");
}

// SyntaxError: missing ) after condition


  Instead you need to use a correct comparison operator.
  For example:

jsif (done === true) {
  console.log("we are done!");
}

Or even better:
jsif (done) {
  console.log("we are done!");
}
See also
if...else
Relational operators
Making decisions in your code — conditionals
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxError: missing ] after element list
  The JavaScript exception "missing ] after element list" occurs when there is an error
  with the array initializer syntax somewhere. Likely there is a closing square bracket
  (]) or a comma (,) missing.
MessageSyntaxError: missing ] after element list (Firefox)
SyntaxError: Unexpected token ';'. Expected either a closing ']' or a ',' following an array element. (Safari)
Error typeSyntaxError.What went wrong?
  There is an error with the array initializer syntax somewhere. Likely there is a
  closing square bracket (]) or a comma (,) missing.
ExamplesIncomplete array initializerjsconst list = [1, 2,

const instruments = [
  "Ukulele",
  "Guitar",
  "Piano",
};

const data = [{ foo: "bar" } { bar: "foo" }];

Correct would be:
jsconst list = [1, 2];

const instruments = ["Ukulele", "Guitar", "Piano"];

const data = [{ foo: "bar" }, { bar: "foo" }];
See also
Array
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
SyntaxError: missing } after function body
  The JavaScript exception "missing } after function body" occurs when there is a syntax
  mistake when creating a function somewhere. Check if any closing curly braces or
  parenthesis are in the correct order.
MessageSyntaxError: missing } after function body (Firefox)
Error typeSyntaxErrorWhat went wrong?
  There is a syntax mistake when creating a function somewhere. Also check if any closing
  curly braces or parenthesis are in the correct order. Indenting or formatting the code
  a bit nicer might also help you to see through the jungle.
ExamplesForgotten closing curly bracketOftentimes, there is a missing curly bracket in your function code:
jsfunction charge() {
  if (sunny) {
    useSolarCells();
  } else {
    promptBikeRide();
}

Correct would be:
jsfunction charge() {
  if (sunny) {
    useSolarCells();
  } else {
    promptBikeRide();
  }
}


  It can be more obscure when using IIFEs or other constructs that use
  a lot of different parenthesis and curly braces, for example.

js(function () {
  if (Math.random() < 0.01) {
    doSomething();
  }
)();


  Oftentimes, indenting differently or double checking indentation helps to spot these
  errors.

js(function () {
  if (Math.random() < 0.01) {
    doSomething();
  }
})();
See also
Functions guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
SyntaxError: missing } after property list
  The JavaScript exception "missing } after property list" occurs when there is a mistake
  in the object initializer syntax somewhere.
  Might be in fact a missing curly bracket, but could also be a missing comma.
MessageSyntaxError: missing } after property list (Firefox)
SyntaxError: Unexpected identifier 'c'. Expected '}' to end an object literal. (Safari)
Error typeSyntaxErrorWhat went wrong?
  There is a mistake in the object initializer
  syntax somewhere. Might be in fact a missing curly bracket, but could
  also be a missing comma, for example. Also check if any closing curly braces or
  parenthesis are in the correct order. Indenting or formatting the code a bit nicer might
  also help you to see through the jungle.
ExamplesForgotten commaOftentimes, there is a missing comma in your object initializer code:
jsconst obj = {
  a: 1,
  b: { myProp: 2 }
  c: 3
};

Correct would be:
jsconst obj = {
  a: 1,
  b: { myProp: 2 },
  c: 3,
};
See also
Object initializer
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
SyntaxError: missing = in const declaration
  The JavaScript exception "missing = in const declaration" occurs when a const
  declaration was not given a value in the same statement (like
  const RED_FLAG;). You need to provide one
  (const RED_FLAG = "#ff0").
MessageSyntaxError: Missing initializer in const declaration (V8-based)
SyntaxError: missing = in const declaration (Firefox)
SyntaxError: Unexpected token ';'. const declared variable 'x' must have an initializer. (Safari)
Error typeSyntaxErrorWhat went wrong?
  A constant is a value that cannot be altered by the program during normal execution. It
  cannot change through re-assignment, and it can't be redeclared. In JavaScript,
  constants are declared using the
  const
  keyword. An initializer for a constant is required; that is, you must specify its value
  in the same statement in which it's declared (which makes sense, given that it can't be
  changed later).
ExamplesMissing const initializer
  Unlike var or let, you must specify a value for a
  const declaration. This throws:

jsconst COLUMNS;
// SyntaxError: missing = in const declaration
Fixing the error
  There are multiple options to fix this error. Check what was intended to be achieved
  with the constant in question.

Adding a constant value
Specify the constant value in the same statement in which it's declared:
jsconst COLUMNS = 80;

const, let or var?

  Do not use const if you weren't meaning to declare a constant. Maybe you
  meant to declare a block-scoped variable with
  let or
  global variable with
  var. Both
  don't require an initial value.

jslet columns;
See also
const
let
var
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: missing formal parameter
  The JavaScript exception "missing formal parameter" occurs when your function
  declaration is missing valid parameters.
MessageSyntaxError: missing formal parameter (Firefox)
SyntaxError: Unexpected number '3'. Expected a parameter pattern or a ')' in parameter list. (Safari)
SyntaxError: Unexpected string literal "x". Expected a parameter pattern or a ')' in parameter list. (Safari)
Error typeSyntaxErrorWhat went wrong?
  "Formal parameter" is a fancy way of saying "function parameter". Your function
  declaration is missing valid parameters. In the declaration of a function, the
  parameters must be identifiers, not any
  value like numbers, strings, or objects. Declaring functions and calling functions are
  two separate steps. Declarations require identifier as parameters, and only when calling
  (invoking) the function, you provide the values the function should use.


  In JavaScript, identifiers can contain
  only alphanumeric characters (or "$" or "_"), and may not start with a digit. An
  identifier differs from a string in that a string is data, while an
  identifier is part of the code.
ExamplesProvide proper function parameters
  Function parameters must be identifiers when setting up a function. All these function
  declarations fail, as they are providing values for their parameters:

jsfunction square(3) {
  return number * number;
}
// SyntaxError: missing formal parameter

function greet("Howdy") {
  return greeting;
}
// SyntaxError: missing formal parameter

function log({ obj: "value"}) {
  console.log(arg)
}
// SyntaxError: missing formal parameter

You will need to use identifiers in function declarations:
jsfunction square(number) {
  return number * number;
}

function greet(greeting) {
  return greeting;
}

function log(arg) {
  console.log(arg);
}

You can then call these functions with the arguments you like:
jssquare(2); // 4

greet("Howdy"); // "Howdy"

log({ obj: "value" }); // { obj: "value" }
See also
SyntaxError: redeclaration of formal parameter "x"
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: missing name after . operator
  The JavaScript exception "missing name after . operator" occurs when there is a problem
  with how the dot operator (.) is used
  for property access.
MessageSyntaxError: missing name after . operator (Firefox)
SyntaxError: Unexpected token '['. Expected a property name after '.'. (Safari)
Error typeSyntaxErrorWhat went wrong?
  The dot operator (.) is used for property access.
  You will have to specify the name of the property that you want to access.
  For computed property access, you might need to change your property access from using a
  dot to using square brackets. These will allow you to compute an expression. Maybe you
  intended to do concatenation instead? A plus operator (+) is needed in that
  case. Please see the examples below.
ExamplesProperty access
Property accessors
  in JavaScript use either the dot (.) or square brackets ([]), but not both.
  Square brackets allow computed property access.

jsconst obj = { foo: { bar: "baz", bar2: "baz2" } };
const i = 2;

obj.[foo].[bar]
// SyntaxError: missing name after . operator

obj.foo."bar"+i;
// SyntaxError: missing name after . operator

To fix this code, you need to access the object like this:
jsobj.foo.bar; // "baz"
// or alternatively
obj["foo"]["bar"]; // "baz"

// computed properties require square brackets
obj.foo["bar" + i]; // "baz2"
// or as template literal
obj.foo[`bar${i}`]; // "baz2"
Property access vs. concatenation
  If you are coming from another programming language (like PHP), it is also easy to mix up the dot operator
  (.) and the concatenation operator (+).

jsconsole.log("Hello" . "world");

// SyntaxError: missing name after . operator

Instead you need to use a plus sign for concatenation:
jsconsole.log("Hello" + "World");
See also
Property accessors
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: missing variable name
  The JavaScript exception "missing variable name" is a common error.
  It is usually caused by omitting a variable name or a typographic error.
MessageSyntaxError: missing variable name (Firefox)
SyntaxError: Unexpected token '='. Expected a parameter pattern or a ')' in parameter list. (Safari)
Error typeSyntaxErrorWhat went wrong?
  A variable is missing a name. The cause is most likely a typo or a forgotten variable name.
  Make sure that you've provided the name of the variable before the = sign.

When declaring multiple variables at the same time, make sure that the previous lines/declaration does not end with a comma instead of a semicolon.ExamplesMissing a variable namejsconst = "foo";

It is easy to forget to assign a name for your variable!
jsconst description = "foo";
Reserved keywords can't be variable names
  There are a few variable names that are reserved keywords.
  You can't use these. Sorry :(

jsconst debugger = "whoop";
// SyntaxError: missing variable name
Declaring multiple variables
  Pay special attention to commas when declaring multiple variables.
  Is there an excess comma, or did you use commas instead of semicolons?
  Did you remember to assign values for all your const variables?

jslet x, y = "foo",
const z, = "foo"

const first = document.getElementById("one"),
const second = document.getElementById("two"),

// SyntaxError: missing variable name

The fixed version:
jslet x,
  y = "foo";
const z = "foo";

const first = document.getElementById("one");
const second = document.getElementById("two");
Arrays
Array literals in JavaScript need square brackets around the values.
  This won't work:

jsconst arr = 1,2,3,4,5;
// SyntaxError: missing variable name

This would be correct:
jsconst arr = [1, 2, 3, 4, 5];
See also
Lexical grammar
var
Grammar and types guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxError: redeclaration of formal parameter "x"
  The JavaScript exception "redeclaration of formal parameter" occurs when the same
  variable name occurs as a function parameter and is then redeclared using a
  let assignment in a function body again.
MessageSyntaxError: Identifier "x" has already been declared (V8-based)
SyntaxError: redeclaration of formal parameter "x" (Firefox)
SyntaxError: Cannot declare a let variable twice: 'x'. (Safari)
Error typeSyntaxErrorWhat went wrong?
  The same variable name occurs as a function parameter and is then redeclared using a
  let assignment in a function body again. Redeclaring the
  same variable within the same function or block scope using let is not
  allowed in JavaScript.
ExamplesRedeclared argumentIn this case, the variable "arg" redeclares the argument.
jsfunction f(arg) {
  let arg = "foo";
}

// SyntaxError: redeclaration of formal parameter "arg"


  If you want to change the value of "arg" in the function body, you can do so, but you
  do not need to declare the same variable again. In other words: you can omit the
  let keyword. If you want to create a new variable, you need to rename it as
  conflicts with the function parameter already.

jsfunction f(arg) {
  arg = "foo";
}

function g(arg) {
  let bar = "foo";
}
See also
let
const
var
Grammar and types guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
SyntaxError: return not in functionThe JavaScript exception "return not in function" occurs when a return statement is called outside of a function.MessageSyntaxError: Illegal return statement (V8-based)
SyntaxError: return not in function (Firefox)
SyntaxError: Return statements are only valid inside functions. (Safari)
Error typeSyntaxError.What went wrong?A return statement is called outside of a function. Maybe there are missing curly braces somewhere? The return statement must be in a function, because it ends function execution and specifies a value to be returned to the function caller.ExamplesMissing curly bracesjsfunction cheer(score) {
  if (score === 147)
    return "Maximum!";
  }
  if (score > 100) {
    return "Century!";
  }
}

// SyntaxError: return not in function

The curly braces look correct at a first glance, but this code snippet is missing a { after the first if statement. Correct would be:
jsfunction cheer(score) {
  if (score === 147) {
    return "Maximum!";
  }
  if (score > 100) {
    return "Century!";
  }
}
See also
return
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
SyntaxError: test for equality (==) mistyped as assignment (=)?
  The JavaScript warning "test for equality (==) mistyped as assignment (=)?" occurs when
  there was an assignment (=) when you would normally expect a test for
  equality (==).
MessageWarning: SyntaxError: test for equality (==) mistyped as assignment (=)?
Error type
  (Firefox only) SyntaxError warning which is reported only if
  javascript.options.strict preference is set to true.
What went wrong?
  There was an assignment (=) when you would normally expect a test for
  equality (==). To help debugging, JavaScript (with strict warnings enabled)
  warns about this pattern.
ExamplesAssignment within conditional expressions
  It is advisable to not use simple assignments in a conditional expression (such as
  if...else),
  because the assignment can be confused with equality when glancing over the code. For
  example, do not use the following code:

jsif (x = y) {
  // do the right thing
}


  If you need to use an assignment in a conditional expression, a common practice is to
  put additional parentheses around the assignment. For example:

jsif ((x = y)) {
  // do the right thing
}


  Otherwise, you probably meant to use a comparison operator (e.g. == or
  ===):

jsif (x === y) {
  // do the right thing
}
See also
if...else
Equality operators
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
SyntaxError: Unexpected '#' used outside of class body
  The JavaScript exception "Unexpected '#' used outside of class body" occurs when a hash
  ("#") is encountered in an unexpected context, most notably
  outside of a class declaration.
  Hashes are valid at the beginning of a file as a hashbang comment,
  or inside of a class as part of a private field. You may encounter this error if you forget
  the quotation marks when trying to access a DOM identifier as well.
MessageSyntaxError: Unexpected '#' used outside of class body.
Error typeSyntaxErrorWhat went wrong?
  We encountered a # somewhere unexpected. This may be due to code moving around and no
  longer being part of a class, a hashbang comment found on a line other than the first
  line of a file, or accidentally forgetting the quotation marks around a DOM identifier.
ExamplesMissing quotation marksFor each case, there might be something slightly wrong. For example
jsdocument.querySelector(#some-element)

This can be fixed via
jsdocument.querySelector("#some-element");
Outside of a classjsclass ClassWithPrivateField {
  #privateField;

  constructor() {}
}

this.#privateField = 42;

This can be fixed by moving the private field back into the class
jsclass ClassWithPrivateField {
  #privateField;

  constructor() {
    this.#privateField = 42;
  }
}
See also
SyntaxError
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
SyntaxError: Unexpected token
  The JavaScript exceptions "unexpected token" occur when a specific language construct
  was expected, but something else was provided. This might be a simple typo.
MessageSyntaxError: expected expression, got "x"
SyntaxError: expected property name, got "x"
SyntaxError: expected target, got "x"
SyntaxError: expected rest argument name, got "x"
SyntaxError: expected closing parenthesis, got "x"
SyntaxError: expected '=>' after argument list, got "x"
Error typeSyntaxErrorWhat went wrong?
  A specific language construct was expected, but something else was provided. This might
  be a simple typo.
ExamplesExpression expectedFor example, when chaining expressions, trailing commas are not allowed.
jsfor (let i = 0; i < 5,; ++i) {
  console.log(i);
}
// Uncaught SyntaxError: expected expression, got ';'

Correct would be omitting the comma or adding another expression:
jsfor (let i = 0; i < 5; ++i) {
  console.log(i);
}
Not enough parenthesesSometimes, you leave out parentheses around if statements:
jsfunction round(n, upperBound, lowerBound) {
  if (n > upperBound) || (n < lowerBound) { // Not enough parenthese here!
    throw new Error(`Number ${n} is more than ${upperBound} or less than ${lowerBound}`);
  } else if (n < (upperBound + lowerBound) / 2) {
    return lowerBound;
  } else {
    return upperBound;
  }
} // SyntaxError: expected expression, got '||'


  The parentheses may look correct at first, but note how the || is outside the
  parentheses. Correct would be putting parentheses around the ||:

jsfunction round(n, upperBound, lowerBound) {
  if ((n > upperBound) || (n < lowerBound)) {
    throw new Error(
      `Number ${n} is more than ${upperBound} or less than ${lowerBound}`,
    );
  } else if (n < (upperBound + lowerBound) / 2) {
    return lowerBound;
  } else {
    return upperBound;
  }
}
See also
SyntaxError
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jan 3, 2024 by MDN contributors.
SyntaxError: unlabeled break must be inside loop or switchThe JavaScript exception "unlabeled break must be inside loop or switch" occurs when a break statement is not inside a loop or a switch statement.MessageSyntaxError: Illegal break statement (V8-based)
SyntaxError: unlabeled break must be inside loop or switch (Firefox)
SyntaxError: 'break' is only valid inside a switch or loop statement. (Safari)
Error typeSyntaxError.What went wrong?break statements can be used to exit a loop or a switch statement, and using them elsewhere is a syntax error. Alternatively, you can provide a label to the break statement to break out of any statement with that label — however, if the label does not reference a containing statement, another error SyntaxError: label not found will be thrown.ExamplesUnsyntactic breakbreak cannot be used outside switch or loops.
jslet score = 0;

function increment() {
  if (score === 100)
    break; // SyntaxError: unlabeled break must be inside loop or switch
  }
  score++;
}

Maybe instead of break, you intend to use return to early-terminate a function.
jslet score = 0;

function increment() {
  if (score === 100) {
    return;
  }
  score++;
}
Using break in callbacksbreak cannot be used in callbacks, even if the callback is called from a loop.
jslet containingIndex = 0;
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

while (containingIndex < matrix.length) {
  matrix[containingIndex].forEach((value) => {
    if (value === 5) {
      break; // SyntaxError: unlabeled break must be inside loop or switch
    }
  });
  containingIndex++;
}

Instead, refactor the code so the break is used outside the callback.
jslet containingIndex = 0;
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

outer: while (containingIndex < matrix.length) {
  for (const value of matrix[containingIndex]) {
    if (value === 5) {
      break outer;
    }
  }
  containingIndex++;
}

jslet containingIndex = 0;
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

while (containingIndex < matrix.length) {
  if (matrix[containingIndex].includes(5)) {
    break;
  }
  containingIndex++;
}

There's no way to early-terminate a forEach() loop. You can use some() instead, or convert it to a for...of loop.
jsarray.forEach((value) => {
  if (value === 5) {
    break; // SyntaxError: unlabeled break must be inside loop or switch
  }
  // do something with value
});

jsarray.some((value) => {
  if (value === 5) {
    return true;
  }
  // do something with value
  return false;
});

jsfor (const value of array) {
  if (value === 5) {
    break;
  }
  // do something with value
}
See also
break
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**'The JavaScript exception "unparenthesized unary expression can't appear on the left-hand side of '**'" occurs when a unary operator (one of typeof, void, delete, await, !, ~, +, -) is used on the left operand of the exponentiation operator without parentheses.MessageSyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence (V8-based)
SyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**' (Firefox)
SyntaxError: Unexpected token '**'. Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression. (Safari)
Error typeSyntaxErrorWhat went wrong?You likely wrote something like this:
js-a ** b

Whether it should be evaluated as (-a) ** b or -(a ** b) is ambiguous. In mathematics, -x2 means -(x ** 2) — and that's how many languages, including Python, Haskell, and PHP, handle it. But making the unary minus operator take precedence over ** breaks symmetry with a ** -b, which is unambiguously a ** (-b). Therefore, the language forbids this syntax and requires you to parenthesize either side to resolve the ambiguity.
js(-a) ** b
-(a ** b)

Other unary operators cannot be the left-hand side of exponentiation either.
jsawait a ** b
!a ** b
+a ** b
~a ** b
ExamplesWhen writing complex math expressions involving exponentiation, you may write something like this:
jsfunction taylorSin(x) {
  return (n) => (-1 ** n * x ** (2 * n + 1)) / factorial(2 * n + 1);
  // SyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**'
}

However, the -1 ** n part is illegal in JavaScript. Instead, parenthesize the left operand:
jsfunction taylorSin(x) {
  return (n) => ((-1) ** n * x ** (2 * n + 1)) / factorial(2 * n + 1);
}

This also makes the code's intent much clearer to other readers.See also
Exponentiation (**)
Operator precedence
Original discussion of exponentiation operator precedence on esdiscuss.org
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
SyntaxError: unterminated string literal
  The JavaScript error "unterminated string literal" occurs when there is an unterminated
  string literal somewhere. String literals must be enclosed by single
  (') or double (") quotes.
MessageSyntaxError: Unterminated string constant (Edge)
SyntaxError: unterminated string literal (Firefox)
Error typeSyntaxErrorWhat went wrong?
  There is an unterminated
  string literal somewhere. String literals must be
  enclosed by single (') or double (") quotes. JavaScript makes
  no distinction between single-quoted strings and double-quoted strings.
  Escape sequences work
  in strings created with either single or double quotes.
  To fix this error, check if:


you have opening and closing quotes (single or double) for your string literal,
you have escaped your string literal correctly,
your string literal isn't split across multiple lines.
ExamplesMultiple linesYou can't split a string across multiple lines like this in JavaScript:
jsconst longString = "This is a very long string which needs
                    to wrap across multiple lines because
                    otherwise my code is unreadable.";
// SyntaxError: unterminated string literal


  Instead, use the + operator,
  a backslash, or template literals.
  The + operator variant looks like this:

jsconst longString =
  "This is a very long string which needs " +
  "to wrap across multiple lines because " +
  "otherwise my code is unreadable.";


  Or you can use the backslash character ("\") at the end of each line to indicate that
  the string will continue on the next line. Make sure there is no space or any other
  character after the backslash (except for a line break), or as an indent; otherwise it
  will not work. That form looks like this:

jsconst longString =
  "This is a very long string which needs \
to wrap across multiple lines because \
otherwise my code is unreadable.";

Another possibility is to use template literals.
jsconst longString = `This is a very long string which needs 
to wrap across multiple lines because 
otherwise my code is unreadable.`;
See also
string literal
Template literals
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
SyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# insteadThe JavaScript warning "Using //@ to indicate sourceURL pragmas is deprecated. Use //# instead" occurs when there is a deprecated source map syntax in a JavaScript source.MessageWarning: SyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# instead

Warning: SyntaxError: Using //@ to indicate sourceMappingURL pragmas is deprecated. Use //# instead
Error typeA warning that a SyntaxError occurred. JavaScript execution won't be halted.What went wrong?There is a deprecated source map syntax in a JavaScript source.
JavaScript sources are often combined and minified to make delivering them from the server more efficient. With source maps, the debugger can map the code being executed to the original source files.
The source map specification changed the syntax due to a conflict with IE whenever it was found in the page after //@cc_on was interpreted to turn on conditional compilation in the IE JScript engine. The conditional compilation comment in IE is a little known feature, but it broke source maps with jQuery and other libraries.ExamplesDeprecated syntaxSyntax with the "@" sign is deprecated.
js//@ sourceMappingURL=http://example.com/path/to/your/sourcemap.map
Standard syntaxUse the "#" sign instead.
js//# sourceMappingURL=http://example.com/path/to/your/sourcemap.map

Or, alternatively, you can set a SourceMap header to your JavaScript file to avoid having a comment at all:
httpSourceMap: /path/to/file.js.map
See also
Use a source map in the Firefox source docs
Introduction to JavaScript source maps on developer.chrome.com (2012)
SourceMap
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
TypeError: 'x' is not iterable
  The JavaScript exception "is not iterable" occurs when the value which is given as the
  right-hand side of for...of,
  as argument of a function such as Promise.all or TypedArray.from,
  or as the right-hand side of an array destructuring assignment,
  is not an iterable object.
MessageTypeError: object is not iterable (cannot read property Symbol(Symbol.iterator)) (V8-based)
TypeError: x is not iterable (Firefox)
TypeError: undefined is not a function (near '...[x]...') (Safari)
Error typeTypeErrorWhat went wrong?
  The value which is given as the right-hand side of for...of,
  or as argument of a function such as Promise.all or TypedArray.from,
  or as the right-hand side of an array destructuring assignment,
  is not an iterable object.
  An iterable can be a built-in iterable type such as
  Array, String or Map, a generator result, or
  an object implementing the iterable protocol.
ExamplesArray destructuring a non-iterablejsconst myobj = { arrayOrObjProp1: {}, arrayOrObjProp2: [42] };

const {
  arrayOrObjProp1: [value1],
  arrayOrObjProp2: [value2],
} = myobj; // TypeError: object is not iterable

console.log(value1, value2);

The non-iterable might turn to be undefined in some runtime environments.Iterating over Object properties
  In JavaScript, Objects are not iterable unless they implement
  the iterable protocol.
  Therefore, you cannot use for...of
  to iterate over the properties of an object.

jsconst obj = { France: "Paris", England: "London" };
for (const p of obj) {
  // …
} // TypeError: obj is not iterable


  Instead you have to use Object.keys or Object.entries, to
  iterate over the properties or entries of an object.

jsconst obj = { France: "Paris", England: "London" };
// Iterate over the property names:
for (const country of Object.keys(obj)) {
  const capital = obj[country];
  console.log(country, capital);
}

for (const [country, capital] of Object.entries(obj)) {
  console.log(country, capital);
}

Another option for this use case might be to use a Map:
jsconst map = new Map();
map.set("France", "Paris");
map.set("England", "London");
// Iterate over the property names:
for (const country of map.keys()) {
  const capital = map.get(country);
  console.log(country, capital);
}

for (const capital of map.values()) {
  console.log(capital);
}

for (const [country, capital] of map.entries()) {
  console.log(country, capital);
}
Iterating over a generator
Generator functions
  are functions you call to produce an iterable object.

jsfunction* generate(a, b) {
  yield a;
  yield b;
}

for (const x of generate) {
  console.log(x);
} // TypeError: generate is not iterable


  When they are not called, the Function object corresponding to the
  generator is callable, but not iterable. Calling a generator produces an iterable
  object which will iterate over the values yielded during the execution of the
  generator.

jsfunction* generate(a, b) {
  yield a;
  yield b;
}

for (const x of generate(1, 2)) {
  console.log(x);
}
Iterating over a custom iterable
  Custom iterables can be created by implementing the
  Symbol.iterator method. You must be certain that your iterator method
  returns an object which is an iterator, which is to say it must have a next method.

jsconst myEmptyIterable = {
  [Symbol.iterator]() {
    return []; // [] is iterable, but it is not an iterator — it has no next method.
  },
};

Array.from(myEmptyIterable); // TypeError: myEmptyIterable is not iterable

Here is a correct implementation:
jsconst myEmptyIterable = {
  [Symbol.iterator]() {
    return [][Symbol.iterator]();
  },
};

Array.from(myEmptyIterable); // []
See also
Iterable protocol
Object.keys
Object.entries
Map
Generator functions
for...of
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: "x" has no properties
  The JavaScript exception "null (or undefined) has no properties" occurs when you
  attempt to access properties of null and undefined. They
  don't have any.
MessageTypeError: Cannot read properties of undefined (reading 'x') (V8-based)
TypeError: null has no properties (Firefox)
TypeError: undefined has no properties (Firefox)
TypeError: undefined is not an object (evaluating 'undefined.x') (Safari)
Error typeTypeError.What went wrong?
  Both null and undefined, have no properties you could
  access.
Examplesnull and undefined have no propertiesjsnull.foo;
// TypeError: null has no properties

undefined.bar;
// TypeError: undefined has no properties
See also
null
undefined
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: "x" is (not) "y"
  The JavaScript exception "x is (not) y" occurs when there was an
  unexpected type. Oftentimes, unexpected undefined or null
  values.
MessageTypeError: Cannot read properties of undefined (reading 'x') (V8-based)
TypeError: "x" is undefined (Firefox)
TypeError: "undefined" is not an object (Firefox)
TypeError: undefined is not an object (evaluating 'obj.x') (Safari)

TypeError: "x" is not a symbol (V8-based & Firefox)
TypeError: Symbol.keyFor requires that the first argument be a symbol (Safari)
Error typeTypeError.What went wrong?
  There was an unexpected type. This occurs oftentimes with undefined or
  null values.


  Also, certain methods, such as Object.create() or
  Symbol.keyFor(), require a specific type, that must be provided.
ExamplesInvalid casesYou cannot invoke a method on an undefined or null variable.
jsconst foo = undefined;
foo.substring(1); // TypeError: foo is undefined

const foo2 = null;
foo2.substring(1); // TypeError: foo is null

Certain methods might require a specific type.
jsconst foo = {};
Symbol.keyFor(foo); // TypeError: foo is not a symbol

const foo2 = "bar";
Object.create(foo2); // TypeError: "foo" is not an object or null
Fixing the issueTo fix null pointer to undefined or null values, you can test if the value is undefined or null first.
jsif (foo !== undefined && foo !== null) {
  // Now we know that foo is defined, we are good to go.
}

Or, if you are confident that foo will not be another falsy value like "" or 0, or if filtering those cases out is not an issue, you can simply test for its truthiness.
jsif (foo) {
  // Now we know that foo is truthy, it will necessarily not be null/undefined.
}
See also
undefined
null
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 12, 2023 by MDN contributors.
TypeError: "x" is not a constructor
  The JavaScript exception "is not a constructor" occurs when there was an attempt to use
  an object or a variable as a constructor, but that object or variable is not a
  constructor.
MessageTypeError: x is not a constructor (V8-based & Firefox & Safari)
Error typeTypeErrorWhat went wrong?
  There was an attempt to use an object or a variable as a constructor, but that object
  or variable is not a constructor. See constructor
  or the new operator
  for more information on what a constructor is.


  There are many global objects, like String or Array, which
  are constructable using new. However, some global objects are not and their
  properties and methods are static. The following JavaScript standard built-in objects
  are not a constructor: Math, JSON, Symbol,
  Reflect, Intl, Atomics.

Generator functions cannot be used as constructors either.ExamplesInvalid casesjsconst Car = 1;
new Car();
// TypeError: Car is not a constructor

new Math();
// TypeError: Math is not a constructor

new Symbol();
// TypeError: Symbol is not a constructor

function* f() {}
const obj = new f();
// TypeError: f is not a constructor
A car constructor
  Suppose you want to create an object type for cars. You want this type of object to be
  called Car, and you want it to have properties for make, model, and year.
  To do this, you would write the following function:

jsfunction Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

Now you can create an object called mycar as follows:
jsconst mycar = new Car("Eagle", "Talon TSi", 1993);
In PromisesWhen returning an immediately-resolved or immediately-rejected Promise, you do not need to create a new Promise(...) and act on it. Instead, use the Promise.resolve() or Promise.reject() static methods.
This is not legal (the Promise constructor is not being called correctly) and will throw a TypeError: this is not a constructor exception:
jsconst fn = () => {
  return new Promise.resolve(true);
};

This is legal, but unnecessarily long:
jsconst fn = () => {
  return new Promise((resolve, reject) => {
    resolve(true);
  });
};

Instead, return the static method:
jsconst resolveAlways = () => {
  return Promise.resolve(true);
};

const rejectAlways = () => {
  return Promise.reject(false);
};
See also
constructor
new
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
TypeError: "x" is not a function
  The JavaScript exception "is not a function" occurs when there was an attempt to call a
  value from a function, but the value is not actually a function.
MessageTypeError: "x" is not a function. (V8-based & Firefox & Safari)
Error typeTypeErrorWhat went wrong?
  It attempted to call a value from a function, but the value is not actually a function.
  Some code expects you to provide a function, but that didn't happen.


  Maybe there is a typo in the function name? Maybe the object you are calling the method
  on does not have this function? For example, JavaScript Objects have no
  map function, but the JavaScript Array object does.


  There are many built-in functions in need of a (callback) function. You will have to
  provide a function in order to have these methods working properly:


When working with Array or TypedArray objects:
    

Array.prototype.every(), Array.prototype.some(),
        Array.prototype.forEach(), Array.prototype.map(),
        Array.prototype.filter(), Array.prototype.reduce(),
        Array.prototype.reduceRight(), Array.prototype.find()



When working with Map and Set objects:
    
Map.prototype.forEach() and Set.prototype.forEach()


ExamplesA typo in the function nameIn this case, which happens way too often, there is a typo in the method name:
jsconst x = document.getElementByID("foo");
// TypeError: document.getElementByID is not a function

The correct function name is getElementById:
jsconst x = document.getElementById("foo");
Function called on the wrong object
  For certain methods, you have to provide a (callback) function and it will work on
  specific objects only. In this example, Array.prototype.map() is used,
  which will work with Array objects only.

jsconst obj = { a: 13, b: 37, c: 42 };

obj.map(function (num) {
  return num * 2;
});

// TypeError: obj.map is not a function

Use an array instead:
jsconst numbers = [1, 4, 9];

numbers.map(function (num) {
  return num * 2;
}); // [2, 8, 18]
Function shares a name with a pre-existing property
  Sometimes when making a class, you may have a property and a function with the same
  name. Upon calling the function, the compiler thinks that the function ceases to exist.

jsfunction Dog() {
  this.age = 11;
  this.color = "black";
  this.name = "Ralph";
  return this;
}

Dog.prototype.name = function (name) {
  this.name = name;
  return this;
};

const myNewDog = new Dog();
myNewDog.name("Cassidy"); //Uncaught TypeError: myNewDog.name is not a function

Use a different property name instead:
jsfunction Dog() {
  this.age = 11;
  this.color = "black";
  this.dogName = "Ralph"; //Using this.dogName instead of .name
  return this;
}

Dog.prototype.name = function (name) {
  this.dogName = name;
  return this;
};

const myNewDog = new Dog();
myNewDog.name("Cassidy"); //Dog { age: 11, color: 'black', dogName: 'Cassidy' }
Using parenthese for multiplicationIn math, you can write 2 × (3 + 5) as 2*(3 + 5) or just 2(3 + 5).
Using the latter will throw an error:
jsconst sixteen = 2(3 + 5);
console.log(`2 x (3 + 5) is ${sixteen}`);
// Uncaught TypeError: 2 is not a function

You can correct the code by adding a * operator:
jsconst sixteen = 2 * (3 + 5);
console.log(`2 x (3 + 5) is ${sixteen}`);
// 2 x (3 + 5) is 16
Import the exported module correctlyEnsure you are importing the module correctly.
An example helpers library (helpers.js)
jsconst helpers = function () {};

helpers.groupBy = function (objectArray, property) {
  return objectArray.reduce((acc, obj) => {
    const key = obj[property];
    acc[key] ??= [];
    acc[key].push(obj);
    return acc;
  }, {});
};

export default helpers;

The correct import usage (App.js):
jsimport helpers from "./helpers";
See also
Functions
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Oct 4, 2023 by MDN contributors.
TypeError: "x" is not a non-null object
  The JavaScript exception "is not a non-null object" occurs when an object is expected
  somewhere and wasn't provided. null is not an object and won't work.
MessageTypeError: Property description must be an object: x (V8-based)
TypeError: Property descriptor must be an object, got "x" (Firefox)
TypeError: Property description must be an object. (Safari)

TypeError: Invalid value used in weak set (V8-based)
TypeError: WeakSet value must be an object, got "x" (Firefox)
TypeError: Attempted to add a non-object value to a WeakSet (Safari)
Error typeTypeErrorWhat went wrong?
  An object is expected somewhere and wasn't provided. null is not an
  object and won't work. You must provide a proper object in the given situation.
ExamplesProperty descriptor expected
  When methods like Object.create() or
  Object.defineProperty() and Object.defineProperties() are
  used, the optional descriptor parameter expects a property descriptor object. Providing
  no object (like just a number), will throw an error:

jsObject.defineProperty({}, "key", 1);
// TypeError: 1 is not a non-null object

Object.defineProperty({}, "key", null);
// TypeError: null is not a non-null object

A valid property descriptor object might look like this:
jsObject.defineProperty({}, "key", { value: "foo", writable: false });
WeakMap and WeakSet objects require object or symbol keys
WeakMap and WeakSet objects store object or symbol keys. You can't
  use other types as keys.

jsconst ws = new WeakSet();
ws.add("foo");
// TypeError: "foo" is not a non-null object

Use objects instead:
jsws.add({ foo: "bar" });
ws.add(window);
See also
Object.create()
Object.defineProperty()
Object.defineProperties()
WeakMap
WeakSet
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
TypeError: "x" is read-only
  The JavaScript strict mode-only exception
  "is read-only" occurs when a global variable or object
  property that was assigned to is a read-only property.
MessageTypeError: Cannot assign to read only property 'x' of #<Object> (V8-based)
TypeError: "x" is read-only (Firefox)
TypeError: Attempted to assign to readonly property. (Safari)
Error typeTypeError in strict mode only.What went wrong?
  The global variable or object property that was assigned to is a read-only property.
  (Technically, it is a non-writable data property.)


  This error happens only in strict mode code. In
  non-strict code, the assignment is silently ignored.
ExamplesInvalid cases
  Read-only properties are not super common, but they can be created using
  Object.defineProperty() or Object.freeze().

js"use strict";
const obj = Object.freeze({ name: "Elsa", score: 157 });
obj.score = 0; // TypeError

("use strict");
Object.defineProperty(this, "LUNG_COUNT", { value: 2, writable: false });
LUNG_COUNT = 3; // TypeError

("use strict");
const frozenArray = Object.freeze([0, 1, 2]);
frozenArray[0]++; // TypeError


  There are also a few read-only properties built into JavaScript. Maybe you tried to
  redefine a mathematical constant.

js"use strict";
Math.PI = 4; // TypeError

Sorry, you can't do that.

  The global variable undefined is also read-only, so you can't silence the
  infamous "undefined is not a function" error by doing this:

js"use strict";
undefined = function () {}; // TypeError: "undefined" is read-only
Valid casesjs"use strict";
let obj = Object.freeze({ name: "Score", points: 157 });
obj = { name: obj.name, points: 0 }; // replacing it with a new object works
See also
Object.defineProperty()
Object.freeze()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: can't assign to property "x" on "y": not an object
  The JavaScript strict mode exception "can't assign to property" occurs when attempting
  to create a property on primitive value
  such as a symbol, a string, a number or a boolean. Primitive values cannot hold any property.
MessageTypeError: Cannot create property 'x' on number '1' (V8-based)
TypeError: can't assign to property "x" on 1: not an object (Firefox)
TypeError: Attempted to assign to readonly property. (Safari)
Error typeTypeError.What went wrong?
  In strict mode, a TypeError is raised when attempting to
  create a property on primitive value such
  as a symbol, a string, a number or a boolean. Primitive values cannot hold any property.


  The problem might be that an unexpected value is flowing at an unexpected place, or
  that an object variant of a String or a Number is expected.
ExamplesInvalid casesjs"use strict";

const foo = "my string";
// The following line does nothing if not in strict mode.
foo.bar = {}; // TypeError: can't assign to property "bar" on "my string": not an object
Fixing the issueEither fix the code to prevent the primitive from being used in such places, or fix the issue by creating the object equivalent Object.
js"use strict";

const foo = new String("my string");
foo.bar = {};
See also
Strict mode
primitive
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: can't convert BigInt to numberThe JavaScript exception "can't convert BigInt to number" occurs when an arithmetic operation involves a mix of BigInt and Number values.MessageTypeError: Cannot mix BigInt and other types, use explicit conversions (V8-based)
TypeError: BigInts have no unsigned right shift, use >> instead (V8-based)
TypeError: can't convert BigInt to number (Firefox)
TypeError: Invalid mix of BigInt and other type in addition/multiplication/…. (Safari)
TypeError: BigInt does not support >>> operator (Safari)
Error typeTypeError.What went wrong?The two sides of an arithmetic operator must both be BigInts or both not. If an operation involves a mix of BigInts and numbers, it's ambiguous whether the result should be a BigInt or number, since there may be loss of precision in both cases.
The error can also happen if the unsigned right shift operator (>>>) is used between two BigInts. In Firefox, the message is the same: "can't convert BigInt to number".ExamplesMixing numbers and BigInts in operationsjsconst sum = 1n + 1;
// TypeError: can't convert BigInt to number

Instead, explicitly coerce one side to a BigInt or number.
jsconst sum = 1n + BigInt(1);
const sum2 = Number(1n) + 1;
Using unsigned right shift on BigIntsjsconst a = 4n >>> 2n;
// TypeError: can't convert BigInt to number

Use normal right shift instead.
jsconst a = 4n >> 2n;
See also
BigInt
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: can't convert x to BigIntThe JavaScript exception "x can't be converted to BigInt" occurs when attempting to convert a Symbol, null, or undefined value to a BigInt, or if an operation expecting a BigInt parameter receives a number.MessageTypeError: Cannot convert null to a BigInt (V8-based)
TypeError: can't convert null to BigInt (Firefox)
TypeError: Invalid argument type in ToBigInt operation (Safari)
Error typeTypeError.What went wrong?When using the BigInt() function to convert a value to a BigInt, the value would first be converted to a primitive. Then, if it's not one of BigInt, string, number, and boolean, the error is thrown.
Some operations, like BigInt.asIntN, require the parameter to be a BigInt. Passing in a number in this case will also throw this error.ExamplesUsing BigInt() on invalid valuesjsconst a = BigInt(null);
// TypeError: can't convert null to BigInt
const b = BigInt(undefined);
// TypeError: can't convert undefined to BigInt
const c = BigInt(Symbol("1"));
// TypeError: can't convert Symbol("1") to BigInt

jsconst a = BigInt(1);
const b = BigInt(true);
const c = BigInt("1");
const d = BigInt(Symbol("1").description);


Note: Simply coercing the value to a string or number using String() or Number() before passing it to BigInt() is usually not sufficient to avoid all errors. If the string is not a valid integer number string, a SyntaxError is thrown; if the number is not an integer (most notably, NaN), a RangeError is thrown. If the range of input is unknown, properly validate it before using BigInt().
Passing a number to a function expecting a BigIntjsconst a = BigInt.asIntN(4, 8);
// TypeError: can't convert 8 to BigInt
const b = new BigInt64Array(3).fill(3);
// TypeError: can't convert 3 to BigInt

jsconst a = BigInt.asIntN(4, 8n);
const b = new BigInt64Array(3).fill(3n);
See also
BigInt() constructor
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
TypeError: can't define property "x": "obj" is not extensible
  The JavaScript exception "can't define property "x": "obj" is not extensible" occurs
  when Object.preventExtensions() marked an object as no longer extensible,
  so that it will never have properties beyond the ones it had at the time it was marked
  as non-extensible.
MessageTypeError: Cannot add property x, object is not extensible (V8-based)
TypeError: Cannot define property x, object is not extensible (V8-based)
TypeError: can't define property "x": Object is not extensible (Firefox)
TypeError: Attempting to define property on object that is not extensible. (Safari)
Error typeTypeErrorWhat went wrong?
  Usually, an object is extensible and new properties can be added to it. However, in
  this case Object.preventExtensions() marked an object as no longer
  extensible, so that it will never have properties beyond the ones it had at the time it
  was marked as non-extensible.
ExamplesAdding new properties to a non-extensible objects
  In strict mode,
  attempting to add new properties to a non-extensible object throws a
  TypeError. In sloppy mode, the addition of the "x" property is silently
  ignored.

js"use strict";

const obj = {};
Object.preventExtensions(obj);

obj.x = "foo";
// TypeError: can't define property "x": Object is not extensible


  In both, strict mode and
  sloppy mode, a call to Object.defineProperty() throws when adding a new
  property to a non-extensible object.

jsconst obj = {};
Object.preventExtensions(obj);

Object.defineProperty(obj, "x", { value: "foo" });
// TypeError: can't define property "x": Object is not extensible


  To fix this error, you will either need to remove the call to
  Object.preventExtensions() entirely, or move it to a position so that the
  property is added earlier and only later the object is marked as non-extensible. Of
  course you can also remove the property that was attempted to be added, if you don't
  need it.

js"use strict";

const obj = {};
obj.x = "foo"; // add property first and only then prevent extensions

Object.preventExtensions(obj);
See also
Object.preventExtensions()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: can't delete non-configurable array element
  The JavaScript exception "can't delete non-configurable array element" occurs when it
  was attempted to shorten the length
  of an array, but one of the array's elements is non-configurable.
MessageTypeError: Cannot delete property '1' of [object Array] (V8-based)
TypeError: can't delete non-configurable array element (Firefox)
TypeError: Unable to delete property. (Safari)
Error typeTypeErrorWhat went wrong?
  It was attempted to shorten the length
  of an array, but one of the array's elements is non-configurable.
  When shortening an array, the elements beyond the new array length will be deleted,
  which failed in this situation.


  The configurable attribute controls whether the property can be deleted
  from the object and whether its attributes (other than writable) can be
  changed.

Usually, properties in an object created by an array initializer are configurable. However, for example, when using Object.defineProperty(), the property isn't configurable by default.ExamplesNon-configurable properties created by Object.defineProperty
  The Object.defineProperty() creates non-configurable properties by
  default if you haven't specified them as configurable.

js"use strict";
const arr = [];
Object.defineProperty(arr, 0, { value: 0 });
Object.defineProperty(arr, 1, { value: "1" });

arr.length = 1;
// TypeError: can't delete non-configurable array element

You will need to set the elements as configurable, if you intend to shorten the array.
js"use strict";
const arr = [];
Object.defineProperty(arr, 0, { value: 0, configurable: true });
Object.defineProperty(arr, 1, { value: "1", configurable: true });

arr.length = 1;
Sealed Arrays
  The Object.seal() function marks all existing elements as
  non-configurable.

js"use strict";
const arr = [1, 2, 3];
Object.seal(arr);

arr.length = 1;
// TypeError: can't delete non-configurable array element


  You either need to remove the Object.seal() call, or make a copy of it.
  In case of a copy, shortening the copy of the array does not modify the original array
  length.

js"use strict";
const arr = [1, 2, 3];
Object.seal(arr);

// Copy the initial array to shorten the copy
const copy = Array.from(arr);
copy.length = 1;
// arr.length === 3
See also
[[Configurable]]
length
Object.defineProperty()
Object.seal()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: can't redefine non-configurable property "x"
  The JavaScript exception "can't redefine non-configurable property" occurs when it was
  attempted to redefine a property, but that property is non-configurable.
MessageTypeError: Cannot redefine property: "x" (V8-based)
TypeError: can't redefine non-configurable property "x" (Firefox)
TypeError: Attempting to change value of a readonly property. (Safari)
Error typeTypeErrorWhat went wrong?
  It was attempted to redefine a property, but that property is non-configurable. The
  configurable attribute controls whether the property can be deleted from
  the object and whether its attributes (other than writable) can be changed.
  Usually, properties in an object created by an
  object initializer are configurable. However, for example, when using
  Object.defineProperty(), the property isn't configurable by default.
ExamplesNon-configurable properties created by Object.defineProperty
  The Object.defineProperty() creates non-configurable properties if you
  haven't specified them as configurable.

jsconst obj = Object.create({});
Object.defineProperty(obj, "foo", { value: "bar" });

Object.defineProperty(obj, "foo", { value: "baz" });
// TypeError: can't redefine non-configurable property "foo"


  You will need to set the "foo" property to configurable, if you intend to redefine it
  later in the code.

jsconst obj = Object.create({});
Object.defineProperty(obj, "foo", { value: "bar", configurable: true });
Object.defineProperty(obj, "foo", { value: "baz", configurable: true });
See also
[[Configurable]]
Object.defineProperty()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: cannot use 'in' operator to search for 'x' in 'y'
  The JavaScript exception "right-hand side of 'in' should be an object" occurs when the
  in operator
  was used to search in strings, or in numbers, or other primitive types. It can only be
  used to check if a property is in an object.
MessageTypeError: Cannot use 'in' operator to search for 'x' in 'y' (V8-based & Firefox)
TypeError: right-hand side of 'in' should be an object, got null (Firefox)
TypeError: "y" is not an Object. (evaluating '"x" in "y"') (Safari)
Error typeTypeErrorWhat went wrong?
  The in operator can only be used
  to check if a property is in an object.
  You can't search in strings, or in numbers, or other primitive types.
ExamplesSearching in strings
  Unlike in other programming languages (e.g. Python), you can't search in strings using
  the in operator.

js"Hello" in "Hello World";
// TypeError: cannot use 'in' operator to search for 'Hello' in 'Hello World'

Instead you will need to use String.prototype.includes(), for example.
js"Hello World".includes("Hello");
// true
The operand can't be null or undefined
  Make sure the object you are inspecting isn't actually null or
  undefined.

jsconst foo = null;
"bar" in foo;
// TypeError: cannot use 'in' operator to search for 'bar' in 'foo' (Chrome)
// TypeError: right-hand side of 'in' should be an object, got null (Firefox)

The in operator always expects an object.
jsconst foo = { baz: "bar" };
"bar" in foo; // false

"PI" in Math; // true
"pi" in Math; // false
Searching in arrays
  Be careful when using the in operator to search in Array
  objects. The in operator checks the index number, not the value at that
  index.

jsconst trees = ["redwood", "bay", "cedar", "oak", "maple"];
3 in trees; // true
"oak" in trees; // false
See also
in
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
TypeError: cyclic object value
  The JavaScript exception "cyclic object value" occurs when object references were found
  in JSON. JSON.stringify() doesn't try
  to solve them and fails accordingly.
MessageTypeError: Converting circular structure to JSON (V8-based)
TypeError: cyclic object value (Firefox)
TypeError: JSON.stringify cannot serialize cyclic structures. (Safari)
Error typeTypeErrorWhat went wrong?
  The JSON format per se doesn't support object
  references (although an IETF draft exists),
  hence JSON.stringify() doesn't try to solve them and fails accordingly.
ExamplesCircular referencesIn a circular structure like the following
jsconst circularReference = { otherData: 123 };
circularReference.myself = circularReference;

JSON.stringify() will fail
jsJSON.stringify(circularReference);
// TypeError: cyclic object value


  To serialize circular references you can use a library that supports them (e.g. cycle.js)
  or implement a solution by yourself, which will require finding and replacing (or
  removing) the cyclic references by serializable values.


  The snippet below illustrates how to find and filter (thus causing data loss) a cyclic
  reference by using the replacer parameter of
  JSON.stringify():

jsfunction getCircularReplacer() {
  const ancestors = [];
  return function (key, value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    // `this` is the object that value is contained in,
    // i.e., its direct parent.
    while (ancestors.length > 0 && ancestors.at(-1) !== this) {
      ancestors.pop();
    }
    if (ancestors.includes(value)) {
      return "[Circular]";
    }
    ancestors.push(value);
    return value;
  };
}

JSON.stringify(circularReference, getCircularReplacer());
// {"otherData":123,"myself":"[Circular]"}

const o = {};
const notCircularReference = [o, o];
JSON.stringify(notCircularReference, getCircularReplacer());
// [{},{}]
See also
JSON.stringify()
cycle.js on GitHub
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
TypeError: invalid 'instanceof' operand 'x'
  The JavaScript exception "invalid 'instanceof' operand" occurs when the right-hand side
  operands of the instanceof operator
  isn't used with a constructor object, i.e. an object which has a prototype property and is callable.
MessageTypeError: Right-hand side of 'instanceof' is not an object (V8-based)
TypeError: Right-hand side of 'instanceof' is not callable (V8-based)
TypeError: invalid 'instanceof' operand "x" (Firefox)
TypeError: ({}) is not a function (Firefox)
TypeError: Right hand side of instanceof is not an object (Safari)
TypeError: {} is not a function. (evaluating '"x" instanceof {}') (Safari)
Error typeTypeErrorWhat went wrong?
  The instanceof operator expects
  the right-hand-side operands to be a constructor object,
  i.e. an object which has a prototype property and is callable. It can also be an object with a Symbol.hasInstance method.
Examplesinstanceof vs. typeofjs"test" instanceof ""; // TypeError: invalid 'instanceof' operand ""
42 instanceof 0; // TypeError: invalid 'instanceof' operand 0

function Foo() {}
const f = Foo(); // Foo() is called and returns undefined
const x = new Foo();

x instanceof f; // TypeError: invalid 'instanceof' operand f
x instanceof x; // TypeError: x is not a function


  To fix these errors, you will either need to replace
  the instanceof operator
  with the typeof operator,
  or to make sure you use the function name, instead of the result of its evaluation.

jstypeof "test" === "string"; // true
typeof 42 === "number"; // true

function Foo() {}
const f = Foo; // Do not call Foo.
const x = new Foo();

x instanceof f; // true
x instanceof Foo; // true
See also
instanceof
typeof
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 15, 2023 by MDN contributors.
TypeError: invalid Array.prototype.sort argumentThe JavaScript exception "invalid Array.prototype.sort argument" occurs when the argument of Array.prototype.sort() isn't either undefined or a function which compares its operands.MessageTypeError: The comparison function must be either a function or undefined (V8-based)
TypeError: invalid Array.prototype.sort argument (Firefox)
TypeError: Array.prototype.sort requires the comparator argument to be a function or undefined (Safari)
Error typeTypeErrorWhat went wrong?The argument of Array.prototype.sort() is expected to be either undefined or a function which compares its operands.ExamplesInvalid casesjs[1, 3, 2].sort(5); // TypeError
Valid casesjs[1, 3, 2].sort(); // [1, 2, 3]
[1, 3, 2].sort((a, b) => a - b); // [1, 2, 3]
See also
Array.prototype.sort()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 25, 2023 by MDN contributors.
TypeError: invalid assignment to const "x"
  The JavaScript exception "invalid assignment to const" occurs when it was attempted to
  alter a constant value. JavaScript
  const
  declarations can't be re-assigned or redeclared.
MessageTypeError: Assignment to constant variable. (V8-based)
TypeError: invalid assignment to const 'x' (Firefox)
TypeError: Attempted to assign to readonly property. (Safari)
Error typeTypeErrorWhat went wrong?
  A constant is a value that cannot be altered by the program during normal execution. It
  cannot change through re-assignment, and it can't be redeclared. In JavaScript,
  constants are declared using the
  const
  keyword.
ExamplesInvalid redeclarationAssigning a value to the same constant name in the same block-scope will throw.
jsconst COLUMNS = 80;

// …

COLUMNS = 120; // TypeError: invalid assignment to const `COLUMNS'
Fixing the error
  There are multiple options to fix this error. Check what was intended to be achieved
  with the constant in question.

Rename

  If you meant to declare another constant, pick another name and re-name. This constant
  name is already taken in this scope.

jsconst COLUMNS = 80;
const WIDE_COLUMNS = 120;

const, let or var?

  Do not use const if you weren't meaning to declare a constant. Maybe you meant to
  declare a block-scoped variable with
  let or
  global variable with
  var.

jslet columns = 80;

// …

columns = 120;

Scoping

  Check if you are in the correct scope. Should this constant appear in this scope or was
  it meant to appear in a function, for example?

jsconst COLUMNS = 80;

function setupBigScreenEnvironment() {
  const COLUMNS = 120;
}
const and immutability
  The const declaration creates a read-only reference to a value. It does
  not mean the value it holds is immutable, just that the variable
  identifier cannot be reassigned. For instance, in case the content is an object, this
  means the object itself can still be altered. This means that you can't mutate the value
  stored in a variable:

jsconst obj = { foo: "bar" };
obj = { foo: "baz" }; // TypeError: invalid assignment to const `obj'

But you can mutate the properties in a variable:
jsobj.foo = "baz";
obj; // { foo: "baz" }
See also
const
let
var
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: More arguments needed
  The JavaScript exception "more arguments needed" occurs when there is an error with how
  a function is called. More arguments need to be provided.
MessageTypeError: Object prototype may only be an Object or null: undefined (V8-based)
TypeError: Object.create requires at least 1 argument, but only 0 were passed (Firefox)
TypeError: Object.setPrototypeOf requires at least 2 arguments, but only 0 were passed (Firefox)
TypeError: Object.defineProperties requires at least 1 argument, but only 0 were passed (Firefox)
TypeError: Object prototype may only be an Object or null. (Safari)
Error typeTypeError.What went wrong?There is an error with how a function is called. More arguments need to be provided.ExamplesRequired arguments not provided
  The Object.create() method requires at least one argument and the
  Object.setPrototypeOf() method requires at least two arguments:

jsconst obj = Object.create();
// TypeError: Object.create requires at least 1 argument, but only 0 were passed

const obj2 = Object.setPrototypeOf({});
// TypeError: Object.setPrototypeOf requires at least 2 arguments, but only 1 were passed

You can fix this by setting null as the prototype, for example:
jsconst obj = Object.create(null);

const obj2 = Object.setPrototypeOf({}, null);
See also
Functions guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
TypeError: property "x" is non-configurable and can't be deleted
  The JavaScript exception "property is non-configurable and can't be deleted" occurs
  when it was attempted to delete a property, but that property is non-configurable.
MessageTypeError: Cannot delete property 'x' of #<Object> (V8-based)
TypeError: property "x" is non-configurable and can't be deleted (Firefox)
TypeError: Unable to delete property. (Safari)
Error typeTypeError in strict mode only.What went wrong?
  It was attempted to delete a property, but that property is non-configurable. The
  configurable attribute controls whether the property can be deleted from
  the object and whether its attributes (other than writable) can be changed.


  This error happens only in strict mode code. In
  non-strict code, the operation returns false.
ExamplesAttempting to delete non-configurable properties
  Non-configurable properties are not super common, but they can be created using
  Object.defineProperty() or Object.freeze().

js"use strict";
const obj = Object.freeze({ name: "Elsa", score: 157 });
delete obj.score; // TypeError

js"use strict";
const obj = {};
Object.defineProperty(obj, "foo", { value: 2, configurable: false });
delete obj.foo; // TypeError

js"use strict";
const frozenArray = Object.freeze([0, 1, 2]);
frozenArray.pop(); // TypeError


  There are also a few non-configurable properties built into JavaScript. Maybe you tried
  to delete a mathematical constant.

js"use strict";
delete Math.PI; // TypeError
See also
delete
Object.defineProperty()
Object.freeze()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 7, 2023 by MDN contributors.
TypeError: Reduce of empty array with no initial value
  The JavaScript exception "reduce of empty array with no initial value" occurs when a
  reduce function is used.
MessageTypeError: Reduce of empty array with no initial value (V8-based & Firefox & Safari)
Error typeTypeErrorWhat went wrong?In JavaScript, there are several reduce functions:


Array.prototype.reduce(), Array.prototype.reduceRight()
    and
  

TypedArray.prototype.reduce(),
    TypedArray.prototype.reduceRight()).
  


  These functions optionally take an initialValue (which will be used as the
  first argument to the first call of the callback). However, if no initial
  value is provided, it will use the first element of the Array or
  TypedArray as the initial value. This error is raised when an empty array
  is provided because no initial value can be returned in that case.
ExamplesInvalid cases
  This problem appears frequently when combined with a filter
  (Array.prototype.filter(), TypedArray.prototype.filter())
  which will remove all elements of the list. Thus leaving none to be used as the initial
  value.

jsconst ints = [0, -1, -2, -3, -4, -5];
ints
  .filter((x) => x > 0) // removes all elements
  .reduce((x, y) => x + y); // no more elements to use for the initial value.


  Similarly, the same issue can happen if there is a typo in a selector, or an unexpected
  number of elements in a list:

jsconst names = document.getElementsByClassName("names");
const name_list = Array.prototype.reduce.call(
  names,
  (acc, name) => acc + ", " + name,
);
Valid casesThese problems can be solved in two different ways.

  One way is to actually provide an initialValue as the neutral element of
  the operator, such as 0 for the addition, 1 for a multiplication, or an empty string for
  a concatenation.

jsconst ints = [0, -1, -2, -3, -4, -5];
ints
  .filter((x) => x > 0) // removes all elements
  .reduce((x, y) => x + y, 0); // the initial value is the neutral element of the addition


  Another way would be to handle the empty case, either before calling
  reduce, or in the callback after adding an unexpected dummy initial value.

jsconst names = document.getElementsByClassName("names");

let nameList1 = "";
if (names.length >= 1) {
  nameList1 = Array.prototype.reduce.call(
    names,
    (acc, name) => `${acc}, ${name}`,
  );
}
// nameList1 === "" when names is empty.

const nameList2 = Array.prototype.reduce.call(
  names,
  (acc, name) => {
    if (acc === "")
      // initial value
      return name;
    return `${acc}, ${name}`;
  },
  "",
);
// nameList2 === "" when names is empty.
See also
Array.prototype.reduce()
Array.prototype.reduceRight()
TypedArray.prototype.reduce()
TypedArray.prototype.reduceRight()
Array
TypedArray
Array.prototype.filter()
TypedArray.prototype.filter()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: setting getter-only property "x"
  The JavaScript strict mode-only exception "setting getter-only property" occurs when there is an attempt
  to set a new value to a property for which only a getter is specified.
MessageTypeError: Cannot set property x of #<Object> which has only a getter (V8-based)
TypeError: setting getter-only property "x" (Firefox)
TypeError: Attempted to assign to readonly property. (Safari)
Error typeTypeError in strict mode only.What went wrong?
  There is an attempt to set a new value to a property for which only a getter is specified.
  While this will be silently ignored in non-strict mode, it will throw a
  TypeError in strict mode.
ExamplesProperty with no setter
  The example below shows how to set a getter for a property.
  It doesn't specify a setter, so a
  TypeError will be thrown upon trying to set the temperature
  property to 30. For more details see also the
  Object.defineProperty() page.

js"use strict";

function Archiver() {
  const temperature = null;
  Object.defineProperty(this, "temperature", {
    get() {
      console.log("get!");
      return temperature;
    },
  });
}

const arc = new Archiver();
arc.temperature; // 'get!'

arc.temperature = 30;
// TypeError: setting getter-only property "temperature"


  To fix this error, you will either need to remove line 16, where there is an attempt to
  set the temperature property, or you will need to implement a setter for it, for
  example like this:

js"use strict";

function Archiver() {
  let temperature = null;
  const archive = [];

  Object.defineProperty(this, "temperature", {
    get() {
      console.log("get!");
      return temperature;
    },
    set(value) {
      temperature = value;
      archive.push({ val: temperature });
    },
  });

  this.getArchive = function () {
    return archive;
  };
}

const arc = new Archiver();
arc.temperature; // 'get!'
arc.temperature = 11;
arc.temperature = 13;
arc.getArchive(); // [{ val: 11 }, { val: 13 }]
See also
Object.defineProperty()
Object.defineProperties()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
TypeError: X.prototype.y called on incompatible type
  The JavaScript exception "called on incompatible target (or object)" occurs when a
  function (on a given object), is called with a this not corresponding to
  the type expected by the function.
MessageTypeError: Method Set.prototype.add called on incompatible receiver undefined (V8-based)
TypeError: Bind must be called on a function (V8-based)
TypeError: Function.prototype.toString called on incompatible object (Firefox)
TypeError: Function.prototype.bind called on incompatible target (Firefox)
TypeError: Type error (Safari)
TypeError: undefined is not an object (Safari)
Error typeTypeErrorWhat went wrong?
  When this error is thrown, a function (on a given object), is called with a
  this not corresponding to the type expected by the function.


  This issue can arise when using the Function.prototype.call() or
  Function.prototype.apply() methods, and providing a this
  argument which does not have the expected type.


  This issue can also happen when providing a function that is stored as a property of an
  object as an argument to another function. In this case, the object that stores the
  function won't be the this target of that function when it is called by the
  other function. To work-around this issue, you will either need to provide a lambda
  which is making the call, or use the Function.prototype.bind() function to
  force the this argument to the expected object.
ExamplesInvalid casesjsconst mySet = new Set();
["bar", "baz"].forEach(mySet.add);
// mySet.add is a function, but "mySet" is not captured as this.

const myFun = function () {
  console.log(this);
};
["bar", "baz"].forEach(myFun.bind);
// myFun.bind is a function, but "myFun" is not captured as this.
Valid casesjsconst mySet = new Set();
["bar", "baz"].forEach(mySet.add.bind(mySet));
// This works due to binding "mySet" as this.

const myFun = function () {
  console.log(this);
};
["bar", "baz"].forEach((x) => myFun.bind(x));
// This works using the "bind" function. It creates a lambda forwarding the argument.
See also
Function.prototype.call()
Function.prototype.apply()
Function.prototype.bind()
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
URIError: malformed URI sequence
  The JavaScript exception "malformed URI sequence" occurs when URI encoding or decoding
  wasn't successful.
MessageURIError: URI malformed (V8-based)
URIError: malformed URI sequence (Firefox)
URIError: String contained an illegal UTF-16 sequence. (Safari)
Error typeURIErrorWhat went wrong?
  URI encoding or decoding wasn't successful. An argument given to either the
  decodeURI, encodeURI, encodeURIComponent, or
  decodeURIComponent function was not valid, so that the function was unable
  encode or decode properly.
ExamplesEncoding
  Encoding replaces each instance of certain characters by one, two, three, or four
  escape sequences representing the UTF-8 encoding of the character. An
  URIError will be thrown if there is an attempt to encode a surrogate which
  is not part of a high-low pair, for example:

jsencodeURI("\uD800");
// "URIError: malformed URI sequence"

encodeURI("\uDFFF");
// "URIError: malformed URI sequence"

A high-low pair is OK. For example:
jsencodeURI("\uD800\uDFFF");
// "%F0%90%8F%BF"
Decoding
  Decoding replaces each escape sequence in the encoded URI component with the character
  that it represents. If there isn't such a character, an error will be thrown:

jsdecodeURIComponent("%E0%A4%A");
// "URIError: malformed URI sequence"

With proper input, this should usually look like something like this:
jsdecodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");
// "JavaScript_шеллы"
See also
URIError
decodeURI
encodeURI
encodeURIComponent
decodeURIComponent
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Jul 24, 2023 by MDN contributors.
Warning: -file- is being assigned a //# sourceMappingURL, but already has oneThe JavaScript warning "-file- is being assigned a //# sourceMappingURL, but already has one." occurs when a source map has been specified more than once for a given JavaScript source.MessageWarning: -file- is being assigned a //# sourceMappingURL, but already has one.
Error typeA warning. JavaScript execution won't be halted.What went wrong?A source map has been specified more than once for a given JavaScript source.
JavaScript sources are often combined and minified to make delivering them from the server more efficient. With source maps, the debugger can map the code being executed to the original source files. There are two ways to assign a source map, either by using a comment or by setting a header to the JavaScript file.ExamplesSetting source mapsSetting a source map by using a comment in the file:
js//# sourceMappingURL=http://example.com/path/to/your/sourcemap.map

Or, alternatively, you can set a header to your JavaScript file:
httpX-SourceMap: /path/to/file.js.map
See also
Use a source map in the Firefox source docs
Introduction to JavaScript source maps on developer.chrome.com (2012)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
Warning: unreachable code after return statement
  The JavaScript warning "unreachable code after return statement" occurs when using an
  expression after a return statement, or when using a
  semicolon-less return statement but including an expression directly after.
MessageWarning: unreachable code after return statement (Firefox)
Error typeWarningWhat went wrong?Unreachable code after a return statement might occur in these situations:


    When using an expression after a return
    statement, or
  

    when using a semicolon-less return statement but including an expression directly
    after.
  


  When an expression exists after a valid return statement, a warning is
  given to indicate that the code after the return statement is unreachable,
  meaning it can never be run.


  Why should I have semicolons after return statements? In the case of
  semicolon-less return statements, it can be unclear whether the developer
  intended to return the statement on the following line, or to stop execution and return.
  The warning indicates that there is ambiguity in the way the return
  statement is written.

Warnings will not be shown for semicolon-less returns if these statements follow it:

throw
break
var
function
ExamplesInvalid casesjsfunction f() {
  let x = 3;
  x += 4;
  return x;   // return exits the function immediately
  x -= 3;     // so this line will never run; it is unreachable
}

function g() {
  return     // this is treated like `return;`
    3 + 4;   // so the function returns, and this line is never reached
}
Valid casesjsfunction f() {
  let x = 3;
  x += 4;
  x -= 3;
  return x; // OK: return after all other statements
}

function g() {
  return 3 + 4 // OK: semicolon-less return with expression on the same line
}
See also
Automatic semicolon insertion
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Aug 25, 2023 by MDN contributors.
JavaScript technologies overviewWhereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.
However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs, including the DOM (Document Object Model).JavaScript, the core language (ECMAScript)The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.
This core language is also used in non-browser environments, for example in Node.js.What falls under the ECMAScript scope?Among other things, ECMAScript defines:

Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)
Error handling mechanisms (throw, try...catch, ability to create user-defined Error types)
Types (boolean, number, string, function, object, ...)
A prototype-based inheritance mechanism
Built-in objects and functions, including JSON, Math, Array methods, parseInt, decodeURI, etc.
Strict mode
A module system
Basic memory model
Standardization processECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization, which hosts proposals, the official specification text, and meeting notes.
Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.
The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page. ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.
New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process, and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.
See Wikipedia ECMAScript entry for more information on ECMAScript history.Internationalization APIThe ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the Intl object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.Related resourcesThere are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

ECMAScript Language Specification repo
ECMAScript Internationalization API Specification repo
ECMAScript proposals repo
ECMAScript conformance test suite repo
TC39 meeting notes
ECMAScript spec discussion; current mailing list
ECMAScript spec discussion; historical mailing-list archives (until March 2021)
DOM APIsWebIDLThe WebIDL specification provides the glue between the DOM technologies and ECMAScript.The Core of the DOMThe Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. The W3C standardizes the Core Document Object Model, which defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. Among the things defined by the DOM, we can find:

The document structure, a tree model, and the DOM Event architecture in DOM core: Node, Element, DocumentFragment, Document, DOMImplementation, Event, EventTarget, …
A less rigorous definition of the DOM Event Architecture, as well as specific events in DOM events.
Other things such as DOM Traversal and DOM Range.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".HTML DOMHTML, the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the className property on HTML elements, or APIs such as document.body.
The HTML specification also defines restrictions on documents; for example, it requires all children of a <ul> element, which represents an unordered list, to be <li> elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.
Looking for the Document object, Window object, and the other DOM elements? Read the DOM documentation.Other notable APIs
The setTimeout and setInterval functions were first specified on the Window interface in HTML Standard.
XMLHttpRequest makes it possible to send asynchronous HTTP requests.
The Fetch API provides a more ergonomic abstraction for network requests.
The CSS Object Model abstract CSS rules as objects.
WebWorkers allows parallel computation.
WebSockets allows low-level bidirectional communication.
Canvas 2D Context is a drawing API for <canvas>.
The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as fetch() and setTimeout().JavaScript implementationsThere are three main JavaScript implementations used in browser environments and beyond:

Mozilla's SpiderMonkey, used in Firefox. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.
Google's V8, used in Google Chrome, Opera, Edge, Node.js, Deno, Electron, and more.
Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in WebKit browsers such as Apple Safari, and Bun.

Besides the above implementations, there are other popular JavaScript engines such as:

Carakan, used in earlier versions of Opera.
Microsoft's Chakra engine, used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used a new JavaScript engine, confusingly also called Chakra.
LibJS, used in the browser implementation of SerenityOS.
Mozilla's Rhino engine, a JavaScript implementation written in Java, created primarily by Norris Boyd (also at Netscape).

There are some engines specifically tailored for non-browser purposes:

Engine262, a JavaScript engine written in JavaScript. It is created for JavaScript developers to explore new language features and find bugs in the specification.
Moddable XS, used in embedded systems such as IoT.
QuickJS, a small and embeddable JavaScript engine.
Meta's Hermes engine, an engine optimized for React Native.
Oracle's GraalJS, a high performance implementation built on the GraalVM by Oracle Labs.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.
Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.ShellsA JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.Standalone JavaScript shellsThe following JavaScript shells are stand-alone environments, like Perl or Python.

Node.js - Node.js is a platform for easily building fast, scalable network applications.
ShellJS - Portable Unix shell commands for Node.js.
Browser-based JavaScript shellsThe following JavaScript shells run code through the browser's JavaScript engine.

Firefox has a built-in JavaScript console, which support multi-line editing.
Babel REPL - A browser-based REPL for experimenting with future JavaScript.
TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.
Tools & resourcesHelpful tools for writing and debugging your JavaScript code.

Firefox Developer Tools

Web Console, JavaScript Profiler, Debugger, and more.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

TogetherJS

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

Stack Overflow

Stack Overflow questions tagged with "JavaScript".

JSFiddle

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

Plunker

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

JSBin

JS Bin is an open-source collaborative web development debugging tool.

Codepen

Codepen is another collaborative web development tool used as a live result playground.

StackBlitz

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

RunJS

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 20, 2023 by MDN contributors.
Lexical grammarThis page describes JavaScript's lexical grammar. JavaScript source text is just a sequence of characters — in order for the interpreter to understand it, the string has to be parsed to a more structured representation. The initial step of parsing is called lexical analysis, in which the text gets scanned from left to right and is converted into a sequence of individual, atomic input elements. Some input elements are insignificant to the interpreter, and will be stripped after this step — they include white space and comments. The others, including identifiers, keywords, literals, and punctuators (mostly operators), will be used for further syntax analysis. Line terminators and multiline comments are also syntactically insignificant, but they guide the process for automatic semicolons insertion to make certain invalid token sequences become valid.Format-control charactersFormat-control characters have no visual representation but are used to control the interpretation of the text.



Code point
Name
Abbreviation
Description




U+200C
Zero width non-joiner
<ZWNJ>
Placed between characters to prevent being connected into ligatures in certain languages (Wikipedia).


U+200D
Zero width joiner
<ZWJ>
Placed between characters that would not normally be connected in order to cause the characters to be rendered using their connected form in certain languages (Wikipedia).


U+FEFF
Byte order mark
<BOM>
Used at the start of the script to mark it as Unicode and the text's byte order (Wikipedia).



In JavaScript source text, <ZWNJ> and <ZWJ> are treated as identifier parts, while <BOM> (also called a zero-width no-break space <ZWNBSP> when not at the start of text) is treated as white space.White spaceWhite space characters improve the readability of source text and separate tokens from each other. These characters are usually unnecessary for the functionality of the code. Minification tools are often used to remove whitespace in order to reduce the amount of data that needs to be transferred.



Code point
Name
Abbreviation
Description
Escape sequence




U+0009
Character tabulation
<TAB>
Horizontal tabulation
\t


U+000B
Line tabulation
<VT>
Vertical tabulation
\v


U+000C
Form feed
<FF>
Page breaking control character (Wikipedia).
\f


U+0020
Space
<SP>
Normal space



U+00A0
No-break space
<NBSP>
Normal space, but no point at which a line may break



U+FEFF
Zero-width no-break space
<ZWNBSP>
When not at the start of a script, the BOM marker is a normal whitespace character.



Others
Other Unicode space characters
<USP>
Characters in the "Space_Separator" general category





Note: Of those characters with the "White_Space" property but are not in the "Space_Separator" general category, U+0009, U+000B, and U+000C are still treated as white space in JavaScript; U+0085 NEXT LINE has no special role; others become the set of line terminators.


Note: Changes to the Unicode standard used by the JavaScript engine may affect programs' behavior. For example, ES2016 upgraded the reference Unicode standard from 5.1 to 8.0.0, which caused U+180E MONGOLIAN VOWEL SEPARATOR to be moved from the "Space_Separator" category to the "Format (Cf)" category, and made it a non-whitespace. Subsequently, the result of "\u180E".trim().length changed from 0 to 1.
Line terminatorsIn addition to white space characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of automatic semicolon insertion.
Outside the context of lexical grammar, white space and line terminators are often conflated. For example, String.prototype.trim() removes all white space and line terminators from the beginning and end of a string. The \s character class escape in regular expressions matches all white space and line terminators.
Only the following Unicode code points are treated as line terminators in ECMAScript, other line breaking characters are treated as white space (for example, Next Line, NEL, U+0085 is considered as white space).



Code point
Name
Abbreviation
Description
Escape sequence




U+000A
Line Feed
<LF>
New line character in UNIX systems.
\n


U+000D
Carriage Return
<CR>
New line character in Commodore and early Mac systems.
\r


U+2028
Line Separator
<LS>
Wikipedia



U+2029
Paragraph Separator
<PS>
Wikipedia



CommentsComments are used to add hints, notes, suggestions, or warnings to JavaScript code. This can make it easier to read and understand. They can also be used to disable code to prevent it from being executed; this can be a valuable debugging tool.
JavaScript has two long-standing ways to add comments to code: line comments and block comments. In addition, there's a special hashbang comment syntax.Line commentsThe first way is the // comment; this makes all text following it on the same line into a comment. For example:
jsfunction comment() {
  // This is a one line JavaScript comment
  console.log("Hello world!");
}
comment();
Block commentsThe second way is the /* */ style, which is much more flexible.
For example, you can use it on a single line:
jsfunction comment() {
  /* This is a one line JavaScript comment */
  console.log("Hello world!");
}
comment();

You can also make multiple-line comments, like this:
jsfunction comment() {
  /* This comment spans multiple lines. Notice
     that we don't need to end the comment until we're done. */
  console.log("Hello world!");
}
comment();

You can also use it in the middle of a line, if you wish, although this can make your code harder to read so it should be used with caution:
jsfunction comment(x) {
  console.log("Hello " + x /* insert the value of x */ + " !");
}
comment("world");

In addition, you can use it to disable code to prevent it from running, by wrapping code in a comment, like this:
jsfunction comment() {
  /* console.log("Hello world!"); */
}
comment();

In this case, the console.log() call is never issued, since it's inside a comment. Any number of lines of code can be disabled this way.
Block comments that contain at least one line terminator behave like line terminators in automatic semicolon insertion.Hashbang commentsThere's a special third comment syntax, the hashbang comment. A hashbang comment behaves exactly like a single line-only (//) comment, except that it begins with #! and is only valid at the absolute start of a script or module. Note also that no whitespace of any kind is permitted before the #!. The comment consists of all the characters after #! up to the end of the first line; only one such comment is permitted.
Hashbang comments in JavaScript resemble shebangs in Unix which provide the path to a specific JavaScript interpreter that you want to use to execute the script. Before the hashbang comment became standardized, it had already been de-facto implemented in non-browser hosts like Node.js, where it was stripped from the source text before being passed to the engine. An example is as follows:
js#!/usr/bin/env node

console.log("Hello world");

The JavaScript interpreter will treat it as a normal comment — it only has semantic meaning to the shell if the script is directly run in a shell.

Warning: If you want scripts to be runnable directly in a shell environment, encode them in UTF-8 without a BOM. Although a BOM will not cause any problems for code running in a browser — because it's stripped during UTF-8 decoding, before the source text is analyzed — a Unix/Linux shell will not recognize the hashbang if it's preceded by a BOM character.

You must only use the #! comment style to specify a JavaScript interpreter. In all other cases just use a // comment (or multiline comment).IdentifiersAn identifier is used to link a value with a name. Identifiers can be used in various places:
jsconst decl = 1; // Variable declaration (may also be `let` or `var`)
function fn() {} // Function declaration
const obj = { key: "value" }; // Object keys
// Class declaration
class C {
  #priv = "value"; // Private property
}
lbl: console.log(1); // Label

In JavaScript, identifiers are commonly made of alphanumeric characters, underscores (_), and dollar signs ($). Identifiers are not allowed to start with numbers. However, JavaScript identifiers are not only limited to ASCII — many Unicode code points are allowed as well. Namely, any character in the ID_Start category can start an identifier, while any character in the ID_Continue category can appear after the first character.

Note: If, for some reason, you need to parse some JavaScript source yourself, do not assume all identifiers follow the pattern /[A-Za-z_$][\w$]*/ (i.e. ASCII-only)! The range of identifiers can be described by the regex /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u (excluding unicode escape sequences).

In addition, JavaScript allows using Unicode escape sequences in the form of \u0000 or \u{000000} in identifiers, which encode the same string value as the actual Unicode characters. For example, 你好 and \u4f60\u597d are the same identifiers:
jsconst 你好 = "Hello";
console.log(\u4f60\u597d); // Hello

Not all places accept the full range of identifiers. Certain syntaxes, such as function declarations, function expressions, and variable declarations require using identifiers names that are not reserved words.
jsfunction import() {} // Illegal: import is a reserved word.

Most notably, private properties and object properties allow reserved words.
jsconst obj = { import: "value" }; // Legal despite `import` being reserved
class C {
  #import = "value";
}
KeywordsKeywords are tokens that look like identifiers but have special meanings in JavaScript. For example, the keyword async before a function declaration indicates that the function is asynchronous.
Some keywords are reserved, meaning that they cannot be used as an identifier for variable declarations, function declarations, etc. They are often called reserved words. A list of these reserved words is provided below. Not all keywords are reserved — for example, async can be used as an identifier anywhere. Some keywords are only contextually reserved — for example, await is only reserved within the body of an async function, and let is only reserved in strict mode code, or const and let declarations.
Identifiers are always compared by string value, so escape sequences are interpreted. For example, this is still a syntax error:
jsconst els\u{65} = 1;
// `els\u{65}` encodes the same identifier as `else`
Reserved wordsThese keywords cannot be used as identifiers for variables, functions, classes, etc. anywhere in JavaScript source.

break
case
catch
class
const
continue
debugger
default
delete
do
else
export
extends
false
finally
for
function
if
import
in
instanceof
new
null
return
super
switch
this
throw
true
try
typeof
var
void
while
with

The following are only reserved when they are found in strict mode code:

let (also reserved in const, let, and class declarations)
static
yield (also reserved in generator function bodies)

The following are only reserved when they are found in module code or async function bodies:

await
Future reserved wordsThe following are reserved as future keywords by the ECMAScript specification. They have no special functionality at present, but they might at some future time, so they cannot be used as identifiers.
These are always reserved:

enum

The following are only reserved when they are found in strict mode code:

implements
interface
package
private
protected
public

Future reserved words in older standards
The following are reserved as future keywords by older ECMAScript specifications (ECMAScript 1 till 3).

abstract
boolean
byte
char
double
final
float
goto
int
long
native
short
synchronized
throws
transient
volatile
Identifiers with special meaningsA few identifiers have a special meaning in some contexts without being reserved words of any kind. They include:

arguments (not a keyword, but cannot be declared as identifier in strict mode)
as (import * as ns from "mod")
async
eval (not a keyword, but cannot be declared as identifier in strict mode)
from (import x from "mod")
get
of
set
Literals
Note: This section discusses literals that are atomic tokens. Object literals and array literals are expressions that consist of a series of tokens.
Null literalSee also null for more information.
jsnull
Boolean literalSee also boolean type for more information.
jstrue
false
Numeric literalsThe Number and BigInt types use numeric literals.
Decimal
js1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal

Exponential
The decimal exponential literal is specified by the following format: beN; where b is a base number (integer or floating), followed by an E or e character (which serves as separator or exponent indicator) and N, which is exponent or power number – a signed integer.
js0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000

Binary
Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). Any character after the 0b that is not 0 or 1 will terminate the literal sequence.
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607

Octal
Octal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "O" (0o or 0O). Any character after the 0o that is outside the range (01234567) will terminate the literal sequence.
js0O755 // 493
0o644 // 420

Hexadecimal
Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). Any character after the 0x that is outside the range (0123456789ABCDEF) will terminate the literal sequence.
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10

BigInt literal
The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision. BigInt literals are created by appending n to the end of an integer.
js123456789123456789n     // 123456789123456789
0o777777777777n         // 68719476735
0x123456789ABCDEFn      // 81985529216486895
0b11101001010101010101n // 955733

BigInt literals cannot start with 0 to avoid confusion with legacy octal literals.
js0755n; // SyntaxError: invalid BigInt syntax

For octal BigInt numbers, always use zero followed by the letter "o" (uppercase or lowercase):
js0o755n;

For more information about BigInt, see also JavaScript data structures.
Numeric separators
To improve readability for numeric literals, underscores (_, U+005F) can be used as separators:
js1_000_000_000_000
1_050.95
0b1010_0001_1000_0101
0o2_2_5_6
0xA0_B0_C0
1_000_000_000_000_000_000_000n

Note these limitations:
js// More than one underscore in a row is not allowed
100__000; // SyntaxError

// Not allowed at the end of numeric literals
100_; // SyntaxError

// Can not be used after leading 0
0_1; // SyntaxError
String literalsA string literal is zero or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for these code points:

U+005C \ (backslash)
U+000D <CR>
U+000A <LF>
The same kind of quote that begins the string literal

Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded.
js'foo'
"bar"

The following subsections describe various escape sequences (\ followed by one or more characters) available in string literals. Any escape sequence not listed below becomes an "identity escape" that becomes the code point itself. For example, \z is the same as z. There's a deprecated octal escape sequence syntax described in the Deprecated and obsolete features page. Many of these escape sequences are also valid in regular expressions — see Character escape.
Escape sequences
Special characters can be encoded using escape sequences:



Escape sequence
Unicode code point




\0
null character (U+0000 NULL)


\'
single quote (U+0027 APOSTROPHE)


\"
double quote (U+0022 QUOTATION MARK)


\\
backslash (U+005C REVERSE SOLIDUS)


\n
newline (U+000A LINE FEED; LF)


\r
carriage return (U+000D CARRIAGE RETURN; CR)


\v
vertical tab (U+000B LINE TABULATION)


\t
tab (U+0009 CHARACTER TABULATION)


\b
backspace (U+0008 BACKSPACE)


\f
form feed (U+000C FORM FEED)


\ followed by a line terminator
empty string



The last escape sequence, \ followed by a line terminator, is useful for splitting a string literal across multiple lines without changing its meaning.
jsconst longString =
  "This is a very long string which needs \
to wrap across multiple lines because \
otherwise my code is unreadable.";

Make sure there is no space or any other character after the backslash (except for a line break), otherwise it will not work. If the next line is indented, the extra spaces will also be present in the string's value.
You can also use the + operator to append multiple strings together, like this:
jsconst longString =
  "This is a very long string which needs " +
  "to wrap across multiple lines because " +
  "otherwise my code is unreadable.";

Both of the above methods result in identical strings.
Hexadecimal escape sequences
Hexadecimal escape sequences consist of \x followed by exactly two hexadecimal digits representing a code unit or code point in the range 0x0000 to 0x00FF.
js"\xA9"; // "©"

Unicode escape sequences
A Unicode escape sequence consists of exactly four hexadecimal digits following \u. It represents a code unit in the UTF-16 encoding. For code points U+0000 to U+FFFF, the code unit is equal to the code point. Code points U+10000 to U+10FFFF require two escape sequences representing the two code units (a surrogate pair) used to encode the character; the surrogate pair is distinct from the code point.
See also String.fromCharCode() and String.prototype.charCodeAt().
js"\u00A9"; // "©" (U+A9)

Unicode code point escapes
A Unicode code point escape consists of \u{, followed by a code point in hexadecimal base, followed by }. The value of the hexadecimal digits must be in the range 0 and 0x10FFFF inclusive. Code points in the range U+10000 to U+10FFFF do not need to be represented as a surrogate pair.
See also String.fromCodePoint() and String.prototype.codePointAt().
js"\u{2F804}"; // CJK COMPATIBILITY IDEOGRAPH-2F804 (U+2F804)

// the same character represented as a surrogate pair
"\uD87E\uDC04";
Regular expression literalsRegular expression literals are enclosed by two forward slashes (/). The lexer consumes all characters up to the next unescaped forward slash or the end of the line, unless the forward slash appears within a character class ([]). Some characters (namely, those that are identifier parts) can appear after the closing slash, denoting flags.
The lexical grammar is very lenient: not all regular expression literals that get identified as one token are valid regular expressions.
See also RegExp for more information.
js/ab+c/g
/[/]/

A regular expression literal cannot start with two forward slashes (//), because that would be a line comment. To specify an empty regular expression, use /(?:)/.Template literalsOne template literal consists of several tokens: `xxx${ (template head), }xxx${ (template middle), and }xxx` (template tail) are individual tokens, while any expression may come between them.
See also template literals for more information.
js`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag`string text ${expression} string text`
Automatic semicolon insertionSome JavaScript statements' syntax definitions require semicolons (;) at the end. They include:

var, let, const
Expression statements
do...while
continue, break, return, throw
debugger
Class field declarations (public or private)
import, export

However, to make the language more approachable and convenient, JavaScript is able to automatically insert semicolons when consuming the token stream, so that some invalid token sequences can be "fixed" to valid syntax. This step happens after the program text has been parsed to tokens according to the lexical grammar. There are three cases when semicolons are automatically inserted:
1. When a token not allowed by the grammar is encountered, and it's separated from the previous token by at least one line terminator (including a block comment that includes at least one line terminator), or the token is "}", then a semicolon is inserted before the token.
js{ 1
2 } 3

// is transformed by ASI into:

{ 1
;2 ;} 3;

// Which is valid grammar encoding three statements,
// each consisting of a number literal

The ending ")" of do...while is taken care of as a special case by this rule as well.
jsdo {
  // ...
} while (condition) /* ; */ // ASI here
const a = 1

However, semicolons are not inserted if the semicolon would then become the separator in the for statement's head.
jsfor (
  let a = 1 // No ASI here
  a < 10 // No ASI here
  a++
) {}

Semicolons are also never inserted as empty statements. For example, in the code below, if a semicolon is inserted after ")", then the code would be valid, with an empty statement as the if body and the const declaration being a separate statement. However, because automatically inserted semicolons cannot become empty statements, this causes a declaration to become the body of the if statement, which is not valid.
jsif (Math.random() > 0.5)
const x = 1 // SyntaxError: Unexpected token 'const'

2. When the end of the input stream of tokens is reached, and the parser is unable to parse the single input stream as a complete program, a semicolon is inserted at the end.
jsconst a = 1 /* ; */ // ASI here

This rule is a complement to the previous rule, specifically for the case where there's no "offending token" but the end of input stream.
3. When the grammar forbids line terminators in some place but a line terminator is found, a semicolon is inserted. These places include:

expr <here> ++, expr <here> --
continue <here> lbl
break <here> lbl
return <here> expr
throw <here> expr
yield <here> expr
yield <here> * expr
(param) <here> => {}
async <here> function, async <here> prop(), async <here> function*, async <here> *prop(), async <here> (param) <here> => {}

Here ++ is not treated as a postfix operator applying to variable b, because a line terminator occurs between b and ++.
jsa = b
++c

// is transformed by ASI into

a = b;
++c;

Here, the return statement returns undefined, and the a + b becomes an unreachable statement.
jsreturn
a + b

// is transformed by ASI into

return;
a + b;

Note that ASI would only be triggered if a line break separates tokens that would otherwise produce invalid syntax. If the next token can be parsed as part of a valid structure, semicolons would not be inserted. For example:
jsconst a = 1
(1).toString()

const b = 1
[1, 2, 3].forEach(console.log)

Because () can be seen as a function call, it would usually not trigger ASI. Similarly, [] may be a member access. The code above is equivalent to:
jsconst a = 1(1).toString();

const b = 1[1, 2, 3].forEach(console.log);

This happens to be valid syntax. 1[1, 2, 3] is a property accessor with a comma-joined expression. Therefore, you would get errors like "1 is not a function" and "Cannot read properties of undefined (reading 'forEach')" when running the code.
Within classes, class fields and generator methods can be a pitfall as well.
jsclass A {
  a = 1
  *gen() {}
}

It is seen as:
jsclass A {
  a = 1 * gen() {}
}

And therefore will be a syntax error around {.
There are the following rules-of-thumb for dealing with ASI, if you want to enforce semicolon-less style:

Write postfix ++ and -- on the same line as their operands.
    jsconst a = b
++
console.log(a) // ReferenceError: Invalid left-hand side expression in prefix operation

jsconst a = b++
console.log(a)


The expressions after return, throw, or yield should be on the same line as the keyword.
    jsfunction foo() {
  return
    1 + 1 // Returns undefined; 1 + 1 is ignored
}

jsfunction foo() {
  return 1 + 1
}

function foo() {
  return (
    1 + 1
  )
}


Similarly, the label identifier after break or continue should be on the same line as the keyword.
    jsouterBlock: {
  innerBlock: {
    break
      outerBlock // SyntaxError: Illegal break statement
  }
}

jsouterBlock: {
  innerBlock: {
    break outerBlock
  }
}


The => of an arrow function should be on the same line as the end of its parameters.
    jsconst foo = (a, b)
  => a + b

jsconst foo = (a, b) =>
  a + b


The async of async functions, methods, etc. cannot be directly followed by a line terminator.
    jsasync
function foo() {}

jsasync function
foo() {}


If a line starts with one of (, [, `, +, -, / (as in regex literals), prefix it with a semicolon, or end the previous line with a semicolon.
    js// The () may be merged with the previous line as a function call
(() => {
  // ...
})()

// The [ may be merged with the previous line as a property access
[1, 2, 3].forEach(console.log)

// The ` may be merged with the previous line as a tagged template literal
`string text ${data}`.match(pattern).forEach(console.log)

// The + may be merged with the previous line as a binary + expression
+a.toString()

// The - may be merged with the previous line as a binary - expression
-a.toString()

// The / may be merged with the previous line as a division expression
/pattern/.exec(str).forEach(console.log)

js;(() => {
  // ...
})()
;[1, 2, 3].forEach(console.log)
;`string text ${data}`.match(pattern).forEach(console.log)
;+a.toString()
;-a.toString()
;/pattern/.exec(str).forEach(console.log)


Class fields should preferably always be ended with semicolons — in addition to the previous rule (which includes a field declaration followed by a computed property, since the latter starts with [), semicolons are also required between a field declaration and a generator method.
    jsclass A {
  a = 1
  [b] = 2
  *gen() {} // Seen as a = 1[b] = 2 * gen() {}
}

jsclass A {
  a = 1;
  [b] = 2;
  *gen() {}
}


SpecificationsSpecificationECMAScript Language Specification Browser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Grammar and types guide
Micro-feature from ES6, now in Firefox Aurora and Nightly: binary and octal numbers by Jeff Walden (2013)
JavaScript character escape sequences by Mathias Bynens (2011)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Nov 8, 2023 by MDN contributors.
Iteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the @@iterator method, meaning that the object (or one of the objects up its prototype chain) must have a property with a @@iterator key which is available via constant Symbol.iterator:

[Symbol.iterator]

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its @@iterator method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance.



Note: It is not possible to know reflectively (i.e. without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [@@iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // ...
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an @@iterator method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its @@iterator method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [@@iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator] to return different iterators that always start from the beginning, like Set.prototype[@@iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterables
String, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an @@iterator method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
  There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.

Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e. the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e. it has [@@asyncIterator]() but no [@@iterator]()) will throw a TypeError: x is not iterable.Non-well-formed iterablesIf an iterable's @@iterator method doesn't return an iterator object, then it's considered a non-well-formed iterable.
Using one is likely to result in runtime errors or buggy behavior:
jsconst nonWellFormedIterable = {};
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Simple iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// ...
Defining an iterable with a generatorjsfunction* makeSimpleGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeSimpleGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// ...
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[@@iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own @@iterator:
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining @@iterator affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
SpecificationsSpecificationECMAScript Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 27, 2023 by MDN contributors.
Strict mode
Note: Sometimes you'll see the default, non-strict mode referred to as sloppy mode. This isn't an official term, but be aware of it, just in case.

JavaScript's strict mode is a way to opt in to a restricted variant of JavaScript, thereby implicitly opting-out of "sloppy mode". Strict mode isn't just a subset: it intentionally has different semantics from normal code. Browsers not supporting strict mode will run strict mode code with different behavior from browsers that do, so don't rely on strict mode without feature-testing for support for the relevant aspects of strict mode. Strict mode code and non-strict mode code can coexist, so scripts can opt into strict mode incrementally.
Strict mode makes several changes to normal JavaScript semantics:

Eliminates some JavaScript silent errors by changing them to throw errors.
Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes be made to run faster than identical code that's not strict mode.
Prohibits some syntax likely to be defined in future versions of ECMAScript.
Invoking strict modeStrict mode applies to entire scripts or to individual functions. It doesn't apply to block statements enclosed in {} braces; attempting to apply it to such contexts does nothing. eval code, Function code, event handler attributes, strings passed to setTimeout(), and related functions are either function bodies or entire scripts, and invoking strict mode in them works as expected.Strict mode for scriptsTo invoke strict mode for an entire script, put the exact statement "use strict"; (or 'use strict';) before any other statements.
js// Whole-script strict mode syntax
"use strict";
const v = "Hi! I'm a strict mode script!";
Strict mode for functionsLikewise, to invoke strict mode for a function, put the exact statement "use strict"; (or 'use strict';) in the function's body before any other statements.
jsfunction myStrictFunction() {
  // Function-level strict mode syntax
  "use strict";
  function nested() {
    return "And so am I!";
  }
  return `Hi! I'm a strict mode function! ${nested()}`;
}
function myNotStrictFunction() {
  return "I'm not strict.";
}

The "use strict" directive can only be applied to the body of functions with simple parameters. Using "use strict" in functions with rest, default, or destructured parameters is a syntax error.
jsfunction sum(a = 1, b = 2) {
  // SyntaxError: "use strict" not allowed in function with default parameter
  "use strict";
  return a + b;
}
Strict mode for modulesThe entire contents of JavaScript modules are automatically in strict mode, with no statement needed to initiate it.
jsfunction myStrictFunction() {
  // because this is a module, I'm strict by default
}
export default myStrictFunction;
Strict mode for classesAll parts of a class's body are strict mode code, including both class declarations and class expressions.
jsclass C1 {
  // All code here is evaluated in strict mode
  test() {
    delete Object.prototype;
  }
}
new C1().test(); // TypeError, because test() is in strict mode

const C2 = class {
  // All code here is evaluated in strict mode
};

// Code here may not be in strict mode
delete Object.prototype; // Will not throw error
Changes in strict modeStrict mode changes both syntax and runtime behavior. Changes generally fall into these categories:

changes converting mistakes into errors (as syntax errors or at runtime)
changes simplifying how variable references are resolved
changes simplifying eval and arguments
changes making it easier to write "secure" JavaScript
changes anticipating future ECMAScript evolution.
Converting mistakes into errorsStrict mode changes some previously-accepted mistakes into errors. JavaScript was designed to be easy for novice developers, and sometimes it gives operations which should be errors non-error semantics. Sometimes this fixes the immediate problem, but sometimes this creates worse problems in the future. Strict mode treats these mistakes as errors so that they're discovered and promptly fixed.
Assigning to undeclared variables
Strict mode makes it impossible to accidentally create global variables. In sloppy mode, mistyping a variable in an assignment creates a new property on the global object and continues to "work". Assignments which would accidentally create global variables throw an error in strict mode:
js"use strict";
let mistypeVariable;

// Assuming no global variable mistypeVarible exists
// this line throws a ReferenceError due to the
// misspelling of "mistypeVariable" (lack of an "a")
mistypeVarible = 17;

Failing to assign to object properties
Strict mode makes assignments which would otherwise silently fail to throw an exception. There are three ways to fail a property assignment:

assignment to a non-writable data property
assignment to a getter-only accessor property
assignment to a new property on a non-extensible object

For example, NaN is a non-writable global variable. In sloppy mode, assigning to NaN does nothing; the developer receives no failure feedback. In strict mode, assigning to NaN throws an exception.
js"use strict";

// Assignment to a non-writable global
undefined = 5; // TypeError
Infinity = 5; // TypeError

// Assignment to a non-writable property
const obj1 = {};
Object.defineProperty(obj1, "x", { value: 42, writable: false });
obj1.x = 9; // TypeError

// Assignment to a getter-only property
const obj2 = {
  get x() {
    return 17;
  },
};
obj2.x = 5; // TypeError

// Assignment to a new property on a non-extensible object
const fixed = {};
Object.preventExtensions(fixed);
fixed.newProp = "ohai"; // TypeError

Failing to delete object properties
Attempts to delete a non-configurable or otherwise undeletable (e.g. it's intercepted by a proxy's deleteProperty handler which returns false) property throw in strict mode (where before the attempt would have no effect):
js"use strict";
delete Object.prototype; // TypeError
delete [].length; // TypeError

Strict mode also forbids deleting plain names. delete name in strict mode is a syntax error:
js"use strict";

var x;
delete x; // syntax error

If the name is a configurable global property, prefix it with globalThis to delete it.
js"use strict";

delete globalThis.x;

Duplicate parameter names
Strict mode requires that function parameter names be unique. In sloppy mode, the last duplicated argument hides previous identically-named arguments. Those previous arguments remain available through arguments, so they're not completely inaccessible. Still, this hiding makes little sense and is probably undesirable (it might hide a typo, for example), so in strict mode, duplicate argument names are a syntax error:
jsfunction sum(a, a, c) {
  // syntax error
  "use strict";
  return a + a + c; // wrong if this code ran
}

Legacy octal literals
Strict mode forbids a 0-prefixed octal literal or octal escape sequence. In sloppy mode, a number beginning with a 0, such as 0644, is interpreted as an octal number (0644 === 420), if all digits are smaller than 8. Novice developers sometimes believe a leading-zero prefix has no semantic meaning, so they might use it as an alignment device — but this changes the number's meaning! A leading-zero syntax for the octal is rarely useful and can be mistakenly used, so strict mode makes it a syntax error:
js"use strict";
const sum =
  015 + // syntax error
  197 +
  142;

The standardized way to denote octal literals is via the 0o prefix. For example:
jsconst sumWithOctal = 0o10 + 8;
console.log(sumWithOctal); // 16

Octal escape sequences, such as "\45", which is equal to "%", can be used to represent characters by extended-ASCII character code numbers in octal. In strict mode, this is a syntax error. More formally, it's disallowed to have \ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07.
Setting properties on primitive values
Strict mode forbids setting properties on primitive values. Accessing a property on a primitive implicitly creates a wrapper object that's unobservable, so in sloppy mode, setting properties is ignored (no-op). In strict mode, a TypeError is thrown.
js"use strict";

false.true = ""; // TypeError
(14).sailing = "home"; // TypeError
"with".you = "far away"; // TypeError

Duplicate property names
Duplicate property names used to be considered a SyntaxError in strict mode. With the introduction of computed property names, making duplication possible at runtime, this restriction was removed in ES2015.
js"use strict";
const o = { p: 1, p: 2 }; // syntax error prior to ECMAScript 2015


Note: Making code that used to error become non-errors is always considered backwards-compatible. This is a good part of the language being strict about throwing errors: it leaves room for future semantic changes.
Simplifying scope managementStrict mode simplifies how variable names map to particular variable definitions in the code. Many compiler optimizations rely on the ability to say that variable X is stored in that location: this is critical to fully optimizing JavaScript code. JavaScript sometimes makes this basic mapping of name to variable definition in the code impossible to perform until runtime. Strict mode removes most cases where this happens, so the compiler can better optimize strict mode code.
Removal of the with statement
Strict mode prohibits with. The problem with with is that any name inside the block might map either to a property of the object passed to it, or to a variable in surrounding (or even global) scope, at runtime; it's impossible to know which beforehand. Strict mode makes with a syntax error, so there's no chance for a name in a with to refer to an unknown location at runtime:
js"use strict";
const x = 17;
with (obj) {
  // Syntax error
  // If this weren't strict mode, would this be const x, or
  // would it instead be obj.x? It's impossible in general
  // to say without running the code, so the name can't be
  // optimized.
  x;
}

The simple alternative of assigning the object to a short name variable, then accessing the corresponding property on that variable, stands ready to replace with.
Non-leaking eval
In strict mode, eval does not introduce new variables into the surrounding scope. In sloppy mode, eval("var x;") introduces a variable x into the surrounding function or the global scope. This means that, in general, in a function containing a call to eval, every name not referring to an argument or local variable must be mapped to a particular definition at runtime (because that eval might have introduced a new variable that would hide the outer variable). In strict mode, eval creates variables only for the code being evaluated, so eval can't affect whether a name refers to an outer variable or some local variable:
jsvar x = 17;
var evalX = eval("'use strict'; var x = 42; x;");
console.assert(x === 17);
console.assert(evalX === 42);

Whether the string passed to eval() is evaluated in strict mode depends on how eval() is invoked (direct eval or indirect eval).
Block-scoped function declarations
The JavaScript language specification, since its start, had not allowed function declarations nested in block statements. However, it was so intuitive that most browsers implemented it as an extension grammar. Unfortunately, the implementations' semantics diverged, and it became impossible for the language specification to reconcile all implementations. Therefore, block-scoped function declarations are only explicitly specified in strict mode (whereas they were once disallowed in strict mode), while sloppy mode behavior remains divergent among browsers.Making eval and arguments simplerStrict mode makes arguments and eval less bizarrely magical. Both involve a considerable amount of magical behavior in sloppy mode: eval to add or remove bindings and to change binding values, and arguments syncing named arguments with its indexed properties. Strict mode makes great strides toward treating eval and arguments as keywords.
Preventing binding or assigning eval and arguments
The names eval and arguments can't be bound or assigned in language syntax. All these attempts to do so are syntax errors:
js"use strict";
eval = 17;
arguments++;
++eval;
const obj = { set p(arguments) {} };
let eval;
try {
} catch (arguments) {}
function x(eval) {}
function arguments() {}
const y = function eval() {};
const f = new Function("arguments", "'use strict'; return 17;");

No syncing between parameters and arguments indices
Strict mode code doesn't sync indices of the arguments object with each parameter binding. In a sloppy mode function whose first argument is arg, setting arg also sets arguments[0], and vice versa (unless no arguments were provided or arguments[0] is deleted). arguments objects for strict mode functions store the original arguments when the function was invoked. arguments[i] does not track the value of the corresponding named argument, nor does a named argument track the value in the corresponding arguments[i].
jsfunction f(a) {
  "use strict";
  a = 42;
  return [a, arguments[0]];
}
const pair = f(17);
console.assert(pair[0] === 42);
console.assert(pair[1] === 17);
"Securing" JavaScriptStrict mode makes it easier to write "secure" JavaScript. Some websites now provide ways for users to write JavaScript which will be run by the website on behalf of other users. JavaScript in browsers can access the user's private information, so such JavaScript must be partially transformed before it is run, to censor access to forbidden functionality. JavaScript's flexibility makes it effectively impossible to do this without many runtime checks. Certain language functions are so pervasive that performing runtime checks has a considerable performance cost. A few strict mode tweaks, plus requiring that user-submitted JavaScript be strict mode code and that it be invoked in a certain manner, substantially reduce the need for those runtime checks.
No this substitution
The value passed as this to a function in strict mode is not forced into being an object (a.k.a. "boxed"). For a sloppy mode function, this is always an object: either the provided object, if called with an object-valued this; or the boxed value of this, if called with a primitive as this; or the global object, if called with undefined or null as this. (Use call, apply, or bind to specify a particular this.) Not only is automatic boxing a performance cost, but exposing the global object in browsers is a security hazard because the global object provides access to functionality that "secure" JavaScript environments must restrict. Thus for a strict mode function, the specified this is not boxed into an object, and if unspecified, this is undefined instead of globalThis:
js"use strict";
function fun() {
  return this;
}
console.assert(fun() === undefined);
console.assert(fun.call(2) === 2);
console.assert(fun.apply(null) === null);
console.assert(fun.call(undefined) === undefined);
console.assert(fun.bind(true)() === true);

Removal of stack-walking properties
In strict mode it's no longer possible to "walk" the JavaScript stack. Many implementations used to implement some extension features that make it possible to detect the upstream caller of a function. When a function fun is in the middle of being called, fun.caller is the function that most recently called fun, and fun.arguments is the arguments for that invocation of fun. Both extensions are problematic for "secure" JavaScript because they allow "secured" code to access "privileged" functions and their (potentially unsecured) arguments. If fun is in strict mode, both fun.caller and fun.arguments are non-deletable properties which throw when set or retrieved:
jsfunction restricted() {
  "use strict";
  restricted.caller; // throws a TypeError
  restricted.arguments; // throws a TypeError
}
function privilegedInvoker() {
  return restricted();
}
privilegedInvoker();

Similarly, arguments.callee is no longer supported. In sloppy mode, arguments.callee refers to the enclosing function. This use case is weak: name the enclosing function! Moreover, arguments.callee substantially hinders optimizations like inlining functions, because it must be made possible to provide a reference to the un-inlined function if arguments.callee is accessed. arguments.callee for strict mode functions is a non-deletable property which throws an error when set or retrieved:
js"use strict";
const f = function () {
  return arguments.callee;
};
f(); // throws a TypeError
Future-proofing JavaScriptExtra reserved words
Reserved words are identifiers that can't be used as variable names. Strict mode reserves some more names than sloppy mode, some of which are already used in the language, and some of which are reserved for the future to make future syntax extensions easier to implement.

implements
interface
let
package
private
protected
public
static
yield
Transitioning to strict modeStrict mode has been designed so that the transition to it can be made gradually. It is possible to change each file individually and even to transition code to strict mode down to the function granularity.
You can migrate a codebase to strict mode by first adding "use strict" to a piece of source code, and then fixing all execution errors, while watching out for semantic differences.Syntax errorsWhen adding 'use strict';, the following cases will throw a SyntaxError before the script is executing:

Octal syntax const n = 023;
with statement
Using delete on a variable name delete myVariable;
Using eval or arguments as variable or function argument name
Using one of the newly reserved keywords (in prevision for future language features): implements, interface, let, package, private, protected, public, static, and yield
Declaring two function parameters with the same name function f(a, b, b) {}
Declaring the same property name twice in an object literal {a: 1, b: 3, a: 7}. This constraint was later removed (bug 1041128).

These errors are good, because they reveal plain errors or bad practices. They occur before the code is running, so they are easily discoverable as long as the code gets parsed by the runtime.New runtime errorsJavaScript used to silently fail in contexts where what was done should be an error. Strict mode throws in such cases. If your code base contains such cases, testing will be necessary to be sure nothing is broken. You can screen for such errors at the function granularity level.

Assigning to an undeclared variable throws a ReferenceError. This used to set a property on the global object, which is rarely the expected effect. If you really want to set a value to the global object, explicitly assign it as a property on globalThis.
Failing to assign to an object's property (e.g. it's read-only) throws a TypeError. In sloppy mode, this would silently fail.
Deleting a non-deletable property throws a TypeError. In sloppy mode, this would silently fail.
Accessing arguments.callee, strictFunction.caller, or strictFunction.arguments throws a TypeError if the function is in strict mode. If you are using arguments.callee to call the function recursively, you can use a named function expression instead.
Semantic differencesThese differences are very subtle differences. It's possible that a test suite doesn't catch this kind of subtle difference. Careful review of your code base will probably be necessary to be sure these differences don't affect the semantics of your code. Fortunately, this careful review can be done gradually down the function granularity.

this

In sloppy mode, function calls like f() would pass the global object as the this value. In strict mode, it is now undefined. When a function was called with call or apply, if the value was a primitive value, this one was boxed into an object (or the global object for undefined and null). In strict mode, the value is passed directly without conversion or replacement.

arguments

In sloppy mode, modifying a value in the arguments object modifies the corresponding named argument. This made optimizations complicated for JavaScript engine and made code harder to read/understand. In strict mode, the arguments object is created and initialized with the same values than the named arguments, but changes to either the arguments object or the named arguments aren't reflected in one another.

eval

In strict mode code, eval doesn't create a new variable in the scope from which it was called. Also, of course, in strict mode, the string is evaluated with strict mode rules. Thorough testing will need to be performed to make sure nothing breaks. Not using eval if you don't really need it may be another pragmatic solution.

Block-scoped function declarations

In sloppy mode, a function declaration inside a block may be visible outside the block and even callable. In strict mode, a function declaration inside a block is only visible inside the block.

SpecificationsSpecificationECMAScript Language Specification See also
JavaScript modules guide
Lexical grammar
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Template literals (Template strings)Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e. escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates should allow the embedding of languages (for example DSLs, or LaTeX), where other escapes sequences are common. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates.
jslatex`\unicode`;
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript Language Specification # sec-template-literalsBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Text formatting guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Dec 3, 2023 by MDN contributors.
Trailing commasTrailing commas (sometimes called "final commas") can be useful when adding new elements, parameters, or properties to JavaScript code. If you want to add a new property, you can add a new line without modifying the previously last line if that line already uses a trailing comma. This makes version-control diffs cleaner and editing code might be less troublesome.
JavaScript has allowed trailing commas in array literals since the beginning. Trailing commas are now also allowed in object literals, function parameters, named imports, named exports, and more.
JSON, however, disallows all trailing commas.DescriptionJavaScript allows trailing commas wherever a comma-separated list of values is accepted and more values may be expected after the last item. This includes:

Array literals
Object literals
Parameter definitions
Function calls
Named imports
Named exports
Array and object destructuring

In all these cases, the trailing comma is entirely optional and doesn't change the program's semantics in any way.
It is particular useful when adding, removing, or reordering items in a list that spans multiple lines, because it reduces the number of lines that need to be changed, which helps with both editing and reviewing the diff.
diff  [
    "foo",
+   "baz",
    "bar",
-   "baz",
  ]
ExamplesTrailing commas in literalsArrays
JavaScript ignores trailing commas in arrays literals:
jsconst arr = [
  1,
  2,
  3,
];

arr; // [1, 2, 3]
arr.length; // 3

If more than one trailing comma is used, an elision (or hole) is produced. An array with holes is called sparse (a dense array has no holes). When iterating arrays for example with Array.prototype.forEach() or Array.prototype.map(), array holes are skipped. Sparse arrays are generally unfavorable, so you should avoid having multiple trailing commas.
jsconst arr = [1, 2, 3, , ,];
arr.length; // 5

Objects
Trailing commas in object literals are legal as well:
jsconst object = {
  foo: "bar",
  baz: "qwerty",
  age: 42,
};
Trailing commas in functionsTrailing commas are also allowed in function parameter lists.
Parameter definitions
The following function definition pairs are legal and equivalent to each other. Trailing commas don't affect the length property of function declarations or their arguments object.
jsfunction f(p) {}
function f(p,) {}

(p) => {};
(p,) => {};

The trailing comma also works with method definitions for classes or objects:
jsclass C {
  one(a,) {}
  two(a, b,) {}
}

const obj = {
  one(a,) {},
  two(a, b,) {},
};

Function calls
The following function invocation pairs are legal and equivalent to each other.
jsf(p);
f(p,);

Math.max(10, 20);
Math.max(10, 20,);

Illegal trailing commas
Function parameter definitions or function invocations only containing a comma will throw a SyntaxError. Furthermore, when using rest parameters, trailing commas are not allowed:
jsfunction f(,) {} // SyntaxError: missing formal parameter
(,) => {};       // SyntaxError: expected expression, got ','
f(,)             // SyntaxError: expected expression, got ','

function f(...p,) {} // SyntaxError: parameter after rest parameter
(...p,) => {}        // SyntaxError: expected closing parenthesis, got ','
Trailing commas in destructuringA trailing comma is also allowed on the left-hand side when using destructuring assignment:
js// array destructuring with trailing comma
[a, b,] = [1, 2];

// object destructuring with trailing comma
const o = {
  p: 42,
  q: true,
};
const { p, q, } = o;

Again, when using a rest element, a SyntaxError will be thrown:
jsconst [a, ...b,] = [1, 2, 3];
// SyntaxError: rest element may not have a trailing comma
Trailing commas in JSONAs JSON is based on a very restricted subset of JavaScript syntax, trailing commas are not allowed in JSON.
Both lines will throw a SyntaxError:
jsJSON.parse("[1, 2, 3, 4, ]");
JSON.parse('{"foo" : 1, }');
// SyntaxError JSON.parse: unexpected character
// at line 1 column 14 of the JSON data

Omit the trailing commas to parse the JSON correctly:
jsJSON.parse("[1, 2, 3, 4 ]");
JSON.parse('{"foo" : 1 }');
Trailing commas in named imports and named exportsTrailing commas are valid in named imports and named exports.
Named imports
jsimport {
  A,
  B,
  C,
} from "D";

import { X, Y, Z, } from "W";

import { A as B, C as D, E as F, } from "Z";

Named exports
jsexport {
  A,
  B,
  C,
};

export { A, B, C, };

export { A as B, C as D, E as F, };
Quantifier prefix
Note: The trailing comma in a quantifier actually changes its semantics from matching "exactly n" to matching "at least n".

js/x{2}/; // Exactly 2 occurrences of "x"; equivalent to /xx/
/x{2,}/; // At least 2 occurrences of "x"; equivalent to /xx+/
/x{2,4}/; // 2 to 4 occurrences of "x"; equivalent to /xxx?x?/
SpecificationsSpecificationECMAScript Language Specification # prod-ElisionECMAScript Language Specification # prod-ObjectLiteralECMAScript Language Specification # prod-ArrayLiteralECMAScript Language Specification # prod-ArgumentsECMAScript Language Specification # prod-FormalParametersECMAScript Language Specification # prod-CoverParenthesizedExpressionAndArrowParameterListECMAScript Language Specification # prod-NamedImportsECMAScript Language Specification # prod-NamedExportsECMAScript Language Specification # prod-QuantifierPrefixECMAScript Language Specification # prod-annexB-InvalidBracedQuantifierBrowser compatibilityBCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.See also
Grammar and types guide
Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.
Deprecated and obsolete featuresThis page lists features of JavaScript that are deprecated (that is, still available but planned for removal) and obsolete (that is, no longer usable).Deprecated featuresThese deprecated features can still be used, but should be used with caution because they are not required to be implemented by every JavaScript engine. You should work to remove their use from your code.
Some of these deprecated features are listed in the Annex B section of the ECMAScript specification. This section is described as normative optional — that is, web browser hosts must implement these features, while non-web hosts may not. These features are likely stable because removing them will cause backward compatibility issues and break legacy websites. (JavaScript has the design goal of "don't break the web".) Still, they are not cross-platform portable and may not be supported by all analysis tools, so you are advised to not use them, as the introduction of Annex B states:

… All of the language features and behaviors specified in this annex have one or more undesirable characteristics and in the absence of legacy usage would be removed from this specification. …
… Programmers should not use or assume the existence of these features and behaviors when writing new ECMAScript code. …

Some others, albeit in the main spec body, are also marked as normative optional and should not be depended on.HTML commentsJavaScript source, if parsed as scripts, allows HTML-like comments, as if the script is part of a <script> tag.
The following is valid JavaScript when running in a web browser (or Node.js, which uses the V8 engine powering Chrome):
js<!-- comment
console.log("a"); <!-- another comment
console.log("b");
--> More comment
// Logs "a" and "b"

<!-- and --> both act like //, i.e. starting line comments. --> is only valid at the start of a line (to avoid ambiguity with a postfix decrement followed by a greater than operator), while <!-- can occur anywhere in the line.RegExpThe following properties are deprecated. This does not affect their use in replacement strings:

$1–$9

Parenthesized substring matches, if any.

input, $_

The string against which a regular expression is matched.

lastMatch, $&

The last matched substring.

lastParen, $+

The last parenthesized substring match, if any.

leftContext, $`

The substring preceding the most recent match.

rightContext, $'

The substring following the most recent match.



Warning: Avoid using these static properties, as they can cause issues when interacting with external code!

The compile() method is deprecated. Construct a new RegExp instance instead.
The following regex syntaxes are deprecated and only available in Unicode-unaware mode. In Unicode-aware mode, they are all syntax errors:

Lookahead assertions can have quantifiers.
Backreferences that do not refer to an existing capturing group become legacy octal escapes.
In character classes, character ranges where one boundary is a character class makes the - become a literal character.
An escape sequence that's not recognized becomes an "identity escape".
Escape sequences within character classes of the form \cX where X is a number or _ are decoded in the same way as those with ASCII letters: \c0 is the same as \cP when taken modulo 32. In addition, if the form \cX is encountered anywhere where X is not one of the recognized characters, then the backslash is treated as a literal character.
The sequence \k within a regex that doesn't have any named capturing groups is treated as an identity escape.
The syntax characters ], {, and } may appear literally without escaping if they cannot be interpreted as the end of a character class or quantifier delimiters.
Function
The caller property of functions and the arguments.callee property are deprecated and unavailable in strict mode.
Instead of accessing arguments as a property of a function, you should use the arguments object inside function closures.
Object
The Object.prototype.__proto__ accessors are deprecated. Use Object.getPrototypeOf and Object.setPrototypeOf instead. This does not apply to the __proto__ literal key in object literals.
The Object.prototype.__defineGetter__, Object.prototype.__defineSetter__, Object.prototype.__lookupGetter__, and Object.prototype.__lookupSetter__ methods are deprecated. Use Object.getOwnPropertyDescriptor and Object.defineProperty instead.
String
HTML wrapper methods like String.prototype.fontsize and String.prototype.big.
String.prototype.substr probably won't be removed anytime soon, but it's defined in Annex B and hence normative optional.
String.prototype.trimLeft and String.prototype.trimRight should be replaced with String.prototype.trimStart and String.prototype.trimEnd.
Date
The getYear() and setYear() methods are affected by the Year-2000-Problem and have been subsumed by getFullYear and setFullYear.
The toGMTString() method is deprecated. Use toUTCString() instead.
Escape sequences
Octal escape sequences (\ followed by one, two, or three octal digits) are deprecated in string and regular expression literals.
The escape() and unescape() functions are deprecated. Use encodeURI(), encodeURIComponent(), decodeURI(), or decodeURIComponent() to encode and decode escape sequences for special characters.
StatementsThe with statement is deprecated and unavailable in strict mode.
Initializers in var declarations of for...in loops headers are deprecated and produce syntax errors in strict mode. They are silently ignored in non-strict mode.
Normally, the catch block of a try...catch statement cannot contain any variable declaration with the same name as the variables bound in the catch(). An extension grammar allows the catch block to contain a var declared variable with the same name as the catch-bound identifier, but only if the catch binding is a simple identifier, not a destructuring pattern. However, this variable's initialization and assignment would only act on the catch-bound identifier, instead of the upper scope variable, and the behavior could be confusing.
jsvar a = 2;
try {
  throw 42;
} catch (a) {
  var a = 1; // This 1 is assigned to the caught `a`, not the outer `a`.
}
console.log(a); // 2

try {
  throw 42;
  // Note: identifier changed to `err` to avoid conflict with
  // the inner declaration of `a`.
} catch (err) {
  var a = 1; // This 1 is assigned to the upper-scope `a`.
}
console.log(a); // 1

This is listed in Annex B of the spec and hence may not be implemented everywhere. Avoid any name conflicts between the catch-bound identifier and variables declared in the catch block.Obsolete featuresThese obsolete features have been entirely removed from JavaScript and can no longer be used as of the indicated version of JavaScript.RegExpThe following are now properties of RegExp instances, no longer of the RegExp constructor:



Property
Description




global
Whether or not to test the regular expression against all possible matches in a string, or only against the first.


ignoreCase
Whether or not to ignore case while attempting a match in a string.


lastIndex
The index at which to start the next match.


multiline (also via RegExp.$*)
Whether or not to search in strings across multiple lines.


source
The text of the pattern.



The valueOf() method is no longer specialized for RegExp. It uses Object.prototype.valueOf(), which returns itself.Function
Functions' arity property is obsolete. Use length instead.
Object


Property
Description
Alternative




__count__
Returns the number of enumerable properties directly on a user-defined object.
Object.keys()


__parent__
Points to an object's context.
No direct replacement


__iterator__
Used with legacy iterators.
Symbol.iterator and the new iteration protocols


__noSuchMethod__
A method called when a non-existent property is called as method.
Proxy


Object.prototype.eval()
Evaluates a string of JavaScript code in the context of the specified object.
No direct replacement


Object.observe()
Asynchronously observing the changes to an object.
Proxy


Object.unobserve()
Remove observers.
Proxy


Object.getNotifier()
Create a notifier object that allows to synthetically trigger a change observable with Object.observe().
No direct replacement


Object.prototype.watch()
Attach a handler callback to a property that gets called when the property is assigned.
Proxy


Object.prototype.unwatch()
Remove watch handlers on a property.
Proxy


String
Non-standard String generic methods like String.slice(myStr, 0, 12), String.replace(myStr, /\./g, "!"), etc. have been introduced in Firefox 1.5 (JavaScript 1.6), deprecated in Firefox 53, and removed in Firefox 68. You can use methods on String.prototype together with Function.call instead.
String.prototype.quote is removed from Firefox 37.
Non-standard flags parameter in String.prototype.search, String.prototype.match, and String.prototype.replace are obsolete.
WeakMap
WeakMap.prototype.clear() was added in Firefox 20 and removed in Firefox 46. It is not possible to traverse all keys in a WeakMap.
Date
Date.prototype.toLocaleFormat(), which used a format string in the same format expected by the strftime() function in C, is obsolete. Use toLocaleString() or Intl.DateTimeFormat instead.
Array
Non-standard Array generic methods like Array.slice(myArr, 0, 12), Array.forEach(myArr, myFn), etc. have been introduced in Firefox 1.5 (JavaScript 1.6), deprecated in Firefox 68, and removed in Firefox 71. You can use methods on Array.prototype together with Function.call instead.




Property
Description
Alternative




Array.observe()
Asynchronously observing changes to Arrays.
Proxy


Array.unobserve()
Remove observers.
Proxy


Number
Number.toInteger() is obsolete. Use Math.floor, Math.round, or other methods instead.
Proxy
Proxy.create and Proxy.createFunction are obsolete. Use the Proxy() constructor instead.
The following traps are obsolete:
    
hasOwn (bug 980565, Firefox 33).
getEnumerablePropertyKeys (bug 783829, Firefox 37)
getOwnPropertyNames (bug 1007334, Firefox 33)
keys (bug 1007334, Firefox 33)


ParallelArray
ParallelArray is obsolete.
Statements
for each...in is obsolete. Use for...of instead.
let blocks and let expressions are obsolete.
Expression closures (function () 1 as a shorthand of function () { return 1; }) are obsolete. Use regular functions or arrow functions instead.
Acquiring source textThe toSource() methods of arrays, numbers, strings, etc. and the uneval() global function are obsolete. Use toString(), or write your own serialization method instead.Legacy generator and iteratorLegacy generator function statements and legacy generator function expressions are removed. The legacy generator function syntax reuses the function keyword, which automatically becomes a generator function when there are one or more yield expressions in the body — this is now a syntax error. Use function* statements and function* expressions instead.
Array comprehensions and generator comprehensions are removed.
js// Legacy array comprehensions
[for (x of iterable) x]
[for (x of iterable) if (condition) x]
[for (x of iterable) for (y of iterable) x + y]

// Legacy generator comprehensions
(for (x of iterable) x)
(for (x of iterable) if (condition) x)
(for (x of iterable) for (y of iterable) x + y)

Firefox, prior to version 26, implemented another iterator protocol that is similar to the standard Iterator protocol. An object is an legacy iterator when it implements a next() method, which produces a value on each call and throws a StopIteration object at the end of iteration. This legacy iterator protocol differs from the standard iterator protocol:

The value was returned directly as the return value of calls to next(), instead of the value property of the IteratorResult object.
Iteration termination was expressed by throwing a StopIteration object, instead of through the done property of the IteratorResult object.

This feature, along with the StopIteration global constructor, was removed in Firefox 58+. For future-facing usages, consider using for...of loops and the iterator protocol.Sharp variablesSharp variables are obsolete. To create circular structures, use temporary variables instead.Found a content problem with this page?Edit the page on GitHub.Report the content issue.View the source on GitHub.Want to get more involved? Learn how to contribute.This page was last modified on Sep 25, 2023 by MDN contributors.
